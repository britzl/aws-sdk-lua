--- GENERATED CODE - DO NOT MODIFY
-- Amazon Simple Systems Manager (SSM) (ssm-2014-11-06)

local M = {}

M.metadata = {
	api_version = "2014-11-06",
	json_version = "1.1",
	protocol = "json",
	checksum_format = "",
	endpoint_prefix = "ssm",
	service_abbreviation = "Amazon SSM",
	service_full_name = "Amazon Simple Systems Manager (SSM)",
	signature_version = "v4",
	target_prefix = "AmazonSSM",
	timestamp_format = "",
	global_endpoint = "",
	uid = "ssm-2014-11-06",
}

local keys = {}
local asserts = {}

keys.UpdateManagedInstanceRoleRequest = { ["InstanceId"] = true, ["IamRole"] = true, nil }

function asserts.AssertUpdateManagedInstanceRoleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateManagedInstanceRoleRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["IamRole"], "Expected key IamRole to exist in table")
	if struct["InstanceId"] then asserts.AssertManagedInstanceId(struct["InstanceId"]) end
	if struct["IamRole"] then asserts.AssertIamRole(struct["IamRole"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateManagedInstanceRoleRequest[k], "UpdateManagedInstanceRoleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateManagedInstanceRoleRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [ManagedInstanceId] <p>The ID of the managed instance where you want to update the role.</p>
-- * IamRole [IamRole] <p>The IAM role you want to assign or change.</p>
-- Required key: InstanceId
-- Required key: IamRole
-- @return UpdateManagedInstanceRoleRequest structure as a key-value pair table
function M.UpdateManagedInstanceRoleRequest(args)
	assert(args, "You must provide an argument table when creating UpdateManagedInstanceRoleRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["IamRole"] = args["IamRole"],
	}
	asserts.AssertUpdateManagedInstanceRoleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTagsForResourceResult = { ["TagList"] = true, nil }

function asserts.AssertListTagsForResourceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTagsForResourceResult to be of type 'table'")
	if struct["TagList"] then asserts.AssertTagList(struct["TagList"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTagsForResourceResult[k], "ListTagsForResourceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTagsForResourceResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TagList [TagList] <p>A list of tags.</p>
-- @return ListTagsForResourceResult structure as a key-value pair table
function M.ListTagsForResourceResult(args)
	assert(args, "You must provide an argument table when creating ListTagsForResourceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TagList"] = args["TagList"],
	}
	asserts.AssertListTagsForResourceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartSessionResponse = { ["SessionId"] = true, ["TokenValue"] = true, ["StreamUrl"] = true, nil }

function asserts.AssertStartSessionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartSessionResponse to be of type 'table'")
	if struct["SessionId"] then asserts.AssertSessionId(struct["SessionId"]) end
	if struct["TokenValue"] then asserts.AssertTokenValue(struct["TokenValue"]) end
	if struct["StreamUrl"] then asserts.AssertStreamUrl(struct["StreamUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartSessionResponse[k], "StartSessionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartSessionResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SessionId [SessionId] <p>The ID of the session.</p>
-- * TokenValue [TokenValue] <p>An encrypted token value containing session and caller information. Used to authenticate the connection to the instance.</p>
-- * StreamUrl [StreamUrl] <p>A URL back to SSM Agent on the instance that the Session Manager client uses to send commands and receive output from the instance. Format: <code>wss://ssm-messages.<b>region</b>.amazonaws.com/v1/data-channel/<b>session-id</b>?stream=(input|output)</code> </p> <p> <b>region</b> represents the Region identifier for an AWS Region supported by AWS Systems Manager, such as <code>us-east-2</code> for the US East (Ohio) Region. For a list of supported <b>region</b> values, see the <b>Region</b> column in the <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#ssm_region">AWS Systems Manager table of regions and endpoints</a> in the <i>AWS General Reference</i>.</p> <p> <b>session-id</b> represents the ID of a Session Manager session, such as <code>1a2b3c4dEXAMPLE</code>.</p>
-- @return StartSessionResponse structure as a key-value pair table
function M.StartSessionResponse(args)
	assert(args, "You must provide an argument table when creating StartSessionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SessionId"] = args["SessionId"],
		["TokenValue"] = args["TokenValue"],
		["StreamUrl"] = args["StreamUrl"],
	}
	asserts.AssertStartSessionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowStepFunctionsParameters = { ["Input"] = true, ["Name"] = true, nil }

function asserts.AssertMaintenanceWindowStepFunctionsParameters(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowStepFunctionsParameters to be of type 'table'")
	if struct["Input"] then asserts.AssertMaintenanceWindowStepFunctionsInput(struct["Input"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowStepFunctionsName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowStepFunctionsParameters[k], "MaintenanceWindowStepFunctionsParameters contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowStepFunctionsParameters
-- <p>The parameters for a STEP_FUNCTION task.</p> <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p>For Step Functions tasks, Systems Manager ignores any values specified for <code>TaskParameters</code> and <code>LoggingInfo</code>.</p> </note>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Input [MaintenanceWindowStepFunctionsInput] <p>The inputs for the STEP_FUNCTION task.</p>
-- * Name [MaintenanceWindowStepFunctionsName] <p>The name of the STEP_FUNCTION task.</p>
-- @return MaintenanceWindowStepFunctionsParameters structure as a key-value pair table
function M.MaintenanceWindowStepFunctionsParameters(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowStepFunctionsParameters")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Input"] = args["Input"],
		["Name"] = args["Name"],
	}
	asserts.AssertMaintenanceWindowStepFunctionsParameters(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDocumentResult = { ["DocumentDescription"] = true, nil }

function asserts.AssertCreateDocumentResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDocumentResult to be of type 'table'")
	if struct["DocumentDescription"] then asserts.AssertDocumentDescription(struct["DocumentDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDocumentResult[k], "CreateDocumentResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDocumentResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DocumentDescription [DocumentDescription] <p>Information about the Systems Manager document.</p>
-- @return CreateDocumentResult structure as a key-value pair table
function M.CreateDocumentResult(args)
	assert(args, "You must provide an argument table when creating CreateDocumentResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DocumentDescription"] = args["DocumentDescription"],
	}
	asserts.AssertCreateDocumentResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertMaintenanceWindowFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowFilter to be of type 'table'")
	if struct["Values"] then asserts.AssertMaintenanceWindowFilterValues(struct["Values"]) end
	if struct["Key"] then asserts.AssertMaintenanceWindowFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowFilter[k], "MaintenanceWindowFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowFilter
-- <p>Filter used in the request. Supported filter keys are Name and Enabled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [MaintenanceWindowFilterValues] <p>The filter values.</p>
-- * Key [MaintenanceWindowFilterKey] <p>The name of the filter.</p>
-- @return MaintenanceWindowFilter structure as a key-value pair table
function M.MaintenanceWindowFilter(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertMaintenanceWindowFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateMaintenanceWindowTargetRequest = { ["Description"] = true, ["OwnerInformation"] = true, ["WindowTargetId"] = true, ["Replace"] = true, ["WindowId"] = true, ["Targets"] = true, ["Name"] = true, nil }

function asserts.AssertUpdateMaintenanceWindowTargetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateMaintenanceWindowTargetRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	assert(struct["WindowTargetId"], "Expected key WindowTargetId to exist in table")
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["OwnerInformation"] then asserts.AssertOwnerInformation(struct["OwnerInformation"]) end
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTargetId(struct["WindowTargetId"]) end
	if struct["Replace"] then asserts.AssertBoolean(struct["Replace"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateMaintenanceWindowTargetRequest[k], "UpdateMaintenanceWindowTargetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateMaintenanceWindowTargetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [MaintenanceWindowDescription] <p>An optional description for the update.</p>
-- * OwnerInformation [OwnerInformation] <p>User-provided value that will be included in any CloudWatch events raised while running tasks for these targets in this Maintenance Window.</p>
-- * WindowTargetId [MaintenanceWindowTargetId] <p>The target ID to modify.</p>
-- * Replace [Boolean] <p>If True, then all fields that are required by the RegisterTargetWithMaintenanceWindow action are also required for this API request. Optional fields that are not specified are set to null.</p>
-- * WindowId [MaintenanceWindowId] <p>The Maintenance Window ID with which to modify the target.</p>
-- * Targets [Targets] <p>The targets to add or replace.</p>
-- * Name [MaintenanceWindowName] <p>A name for the update.</p>
-- Required key: WindowId
-- Required key: WindowTargetId
-- @return UpdateMaintenanceWindowTargetRequest structure as a key-value pair table
function M.UpdateMaintenanceWindowTargetRequest(args)
	assert(args, "You must provide an argument table when creating UpdateMaintenanceWindowTargetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Description"] = args["Description"],
		["OwnerInformation"] = args["OwnerInformation"],
		["WindowTargetId"] = args["WindowTargetId"],
		["Replace"] = args["Replace"],
		["WindowId"] = args["WindowId"],
		["Targets"] = args["Targets"],
		["Name"] = args["Name"],
	}
	asserts.AssertUpdateMaintenanceWindowTargetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StopAutomationExecutionRequest = { ["AutomationExecutionId"] = true, ["Type"] = true, nil }

function asserts.AssertStopAutomationExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopAutomationExecutionRequest to be of type 'table'")
	assert(struct["AutomationExecutionId"], "Expected key AutomationExecutionId to exist in table")
	if struct["AutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["AutomationExecutionId"]) end
	if struct["Type"] then asserts.AssertStopType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopAutomationExecutionRequest[k], "StopAutomationExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopAutomationExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutomationExecutionId [AutomationExecutionId] <p>The execution ID of the Automation to stop.</p>
-- * Type [StopType] <p>The stop request type. Valid types include the following: Cancel and Complete. The default type is Cancel.</p>
-- Required key: AutomationExecutionId
-- @return StopAutomationExecutionRequest structure as a key-value pair table
function M.StopAutomationExecutionRequest(args)
	assert(args, "You must provide an argument table when creating StopAutomationExecutionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutomationExecutionId"] = args["AutomationExecutionId"],
		["Type"] = args["Type"],
	}
	asserts.AssertStopAutomationExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResolvedTargets = { ["ParameterValues"] = true, ["Truncated"] = true, nil }

function asserts.AssertResolvedTargets(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResolvedTargets to be of type 'table'")
	if struct["ParameterValues"] then asserts.AssertTargetParameterList(struct["ParameterValues"]) end
	if struct["Truncated"] then asserts.AssertBoolean(struct["Truncated"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResolvedTargets[k], "ResolvedTargets contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResolvedTargets
-- <p>Information about targets that resolved during the Automation execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ParameterValues [TargetParameterList] <p>A list of parameter values sent to targets that resolved during the Automation execution.</p>
-- * Truncated [Boolean] <p>A boolean value indicating whether the resolved target list is truncated.</p>
-- @return ResolvedTargets structure as a key-value pair table
function M.ResolvedTargets(args)
	assert(args, "You must provide an argument table when creating ResolvedTargets")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ParameterValues"] = args["ParameterValues"],
		["Truncated"] = args["Truncated"],
	}
	asserts.AssertResolvedTargets(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DocumentIdentifier = { ["TargetType"] = true, ["Name"] = true, ["Tags"] = true, ["PlatformTypes"] = true, ["DocumentVersion"] = true, ["DocumentType"] = true, ["Owner"] = true, ["SchemaVersion"] = true, ["DocumentFormat"] = true, nil }

function asserts.AssertDocumentIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DocumentIdentifier to be of type 'table'")
	if struct["TargetType"] then asserts.AssertTargetType(struct["TargetType"]) end
	if struct["Name"] then asserts.AssertDocumentARN(struct["Name"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["PlatformTypes"] then asserts.AssertPlatformTypeList(struct["PlatformTypes"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["DocumentType"] then asserts.AssertDocumentType(struct["DocumentType"]) end
	if struct["Owner"] then asserts.AssertDocumentOwner(struct["Owner"]) end
	if struct["SchemaVersion"] then asserts.AssertDocumentSchemaVersion(struct["SchemaVersion"]) end
	if struct["DocumentFormat"] then asserts.AssertDocumentFormat(struct["DocumentFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.DocumentIdentifier[k], "DocumentIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DocumentIdentifier
-- <p>Describes the name of a Systems Manager document.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetType [TargetType] <p>The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
-- * Name [DocumentARN] <p>The name of the Systems Manager document.</p>
-- * Tags [TagList] <p>The tags, or metadata, that have been applied to the document.</p>
-- * PlatformTypes [PlatformTypeList] <p>The operating system platform. </p>
-- * DocumentVersion [DocumentVersion] <p>The document version.</p>
-- * DocumentType [DocumentType] <p>The document type.</p>
-- * Owner [DocumentOwner] <p>The AWS user account that created the document.</p>
-- * SchemaVersion [DocumentSchemaVersion] <p>The schema version.</p>
-- * DocumentFormat [DocumentFormat] <p>The document format, either JSON or YAML.</p>
-- @return DocumentIdentifier structure as a key-value pair table
function M.DocumentIdentifier(args)
	assert(args, "You must provide an argument table when creating DocumentIdentifier")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TargetType"] = args["TargetType"],
		["Name"] = args["Name"],
		["Tags"] = args["Tags"],
		["PlatformTypes"] = args["PlatformTypes"],
		["DocumentVersion"] = args["DocumentVersion"],
		["DocumentType"] = args["DocumentType"],
		["Owner"] = args["Owner"],
		["SchemaVersion"] = args["SchemaVersion"],
		["DocumentFormat"] = args["DocumentFormat"],
	}
	asserts.AssertDocumentIdentifier(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.OutputSource = { ["OutputSourceType"] = true, ["OutputSourceId"] = true, nil }

function asserts.AssertOutputSource(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected OutputSource to be of type 'table'")
	if struct["OutputSourceType"] then asserts.AssertOutputSourceType(struct["OutputSourceType"]) end
	if struct["OutputSourceId"] then asserts.AssertOutputSourceId(struct["OutputSourceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.OutputSource[k], "OutputSource contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type OutputSource
-- <p>Information about the source where the association execution details are stored.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OutputSourceType [OutputSourceType] <p>The type of source where the association execution details are stored, for example, Amazon S3.</p>
-- * OutputSourceId [OutputSourceId] <p>The ID of the output source, for example the URL of an Amazon S3 bucket.</p>
-- @return OutputSource structure as a key-value pair table
function M.OutputSource(args)
	assert(args, "You must provide an argument table when creating OutputSource")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OutputSourceType"] = args["OutputSourceType"],
		["OutputSourceId"] = args["OutputSourceId"],
	}
	asserts.AssertOutputSource(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterDefaultPatchBaselineResult = { ["BaselineId"] = true, nil }

function asserts.AssertRegisterDefaultPatchBaselineResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterDefaultPatchBaselineResult to be of type 'table'")
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterDefaultPatchBaselineResult[k], "RegisterDefaultPatchBaselineResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterDefaultPatchBaselineResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineId [BaselineId] <p>The ID of the default patch baseline.</p>
-- @return RegisterDefaultPatchBaselineResult structure as a key-value pair table
function M.RegisterDefaultPatchBaselineResult(args)
	assert(args, "You must provide an argument table when creating RegisterDefaultPatchBaselineResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertRegisterDefaultPatchBaselineResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowLambdaParameters = { ["Payload"] = true, ["Qualifier"] = true, ["ClientContext"] = true, nil }

function asserts.AssertMaintenanceWindowLambdaParameters(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowLambdaParameters to be of type 'table'")
	if struct["Payload"] then asserts.AssertMaintenanceWindowLambdaPayload(struct["Payload"]) end
	if struct["Qualifier"] then asserts.AssertMaintenanceWindowLambdaQualifier(struct["Qualifier"]) end
	if struct["ClientContext"] then asserts.AssertMaintenanceWindowLambdaClientContext(struct["ClientContext"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowLambdaParameters[k], "MaintenanceWindowLambdaParameters contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowLambdaParameters
-- <p>The parameters for a LAMBDA task type.</p> <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p>For Lambda tasks, Systems Manager ignores any values specified for TaskParameters and LoggingInfo.</p> </note>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Payload [MaintenanceWindowLambdaPayload] <p>JSON to provide to your Lambda function as input.</p>
-- * Qualifier [MaintenanceWindowLambdaQualifier] <p>(Optional) Specify a Lambda function version or alias name. If you specify a function version, the action uses the qualified function ARN to invoke a specific Lambda function. If you specify an alias name, the action uses the alias ARN to invoke the Lambda function version to which the alias points.</p>
-- * ClientContext [MaintenanceWindowLambdaClientContext] <p>Pass client-specific information to the Lambda function that you are invoking. You can then process the client information in your Lambda function as you choose through the context variable.</p>
-- @return MaintenanceWindowLambdaParameters structure as a key-value pair table
function M.MaintenanceWindowLambdaParameters(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowLambdaParameters")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Payload"] = args["Payload"],
		["Qualifier"] = args["Qualifier"],
		["ClientContext"] = args["ClientContext"],
	}
	asserts.AssertMaintenanceWindowLambdaParameters(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterTaskFromMaintenanceWindowResult = { ["WindowTaskId"] = true, ["WindowId"] = true, nil }

function asserts.AssertDeregisterTaskFromMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterTaskFromMaintenanceWindowResult to be of type 'table'")
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterTaskFromMaintenanceWindowResult[k], "DeregisterTaskFromMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterTaskFromMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The ID of the task removed from the Maintenance Window.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window the task was removed from.</p>
-- @return DeregisterTaskFromMaintenanceWindowResult structure as a key-value pair table
function M.DeregisterTaskFromMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating DeregisterTaskFromMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowTaskId"] = args["WindowTaskId"],
		["WindowId"] = args["WindowId"],
	}
	asserts.AssertDeregisterTaskFromMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInventoryDeletionsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["DeletionId"] = true, nil }

function asserts.AssertDescribeInventoryDeletionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInventoryDeletionsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["DeletionId"] then asserts.AssertInventoryDeletionId(struct["DeletionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInventoryDeletionsRequest[k], "DescribeInventoryDeletionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInventoryDeletionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * DeletionId [InventoryDeletionId] <p>Specify the delete inventory ID for which you want information. This ID was returned by the <code>DeleteInventory</code> action.</p>
-- @return DescribeInventoryDeletionsRequest structure as a key-value pair table
function M.DescribeInventoryDeletionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInventoryDeletionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["DeletionId"] = args["DeletionId"],
	}
	asserts.AssertDescribeInventoryDeletionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParametersRequest = { ["Names"] = true, ["WithDecryption"] = true, nil }

function asserts.AssertGetParametersRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParametersRequest to be of type 'table'")
	assert(struct["Names"], "Expected key Names to exist in table")
	if struct["Names"] then asserts.AssertParameterNameList(struct["Names"]) end
	if struct["WithDecryption"] then asserts.AssertBoolean(struct["WithDecryption"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParametersRequest[k], "GetParametersRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParametersRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Names [ParameterNameList] <p>Names of the parameters for which you want to query information.</p>
-- * WithDecryption [Boolean] <p>Return decrypted secure string value. Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.</p>
-- Required key: Names
-- @return GetParametersRequest structure as a key-value pair table
function M.GetParametersRequest(args)
	assert(args, "You must provide an argument table when creating GetParametersRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Names"] = args["Names"],
		["WithDecryption"] = args["WithDecryption"],
	}
	asserts.AssertGetParametersRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParametersResult = { ["InvalidParameters"] = true, ["Parameters"] = true, nil }

function asserts.AssertGetParametersResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParametersResult to be of type 'table'")
	if struct["InvalidParameters"] then asserts.AssertParameterNameList(struct["InvalidParameters"]) end
	if struct["Parameters"] then asserts.AssertParameterList(struct["Parameters"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParametersResult[k], "GetParametersResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParametersResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InvalidParameters [ParameterNameList] <p>A list of parameters that are not formatted correctly or do not run when executed.</p>
-- * Parameters [ParameterList] <p>A list of details for a parameter.</p>
-- @return GetParametersResult structure as a key-value pair table
function M.GetParametersResult(args)
	assert(args, "You must provide an argument table when creating GetParametersResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InvalidParameters"] = args["InvalidParameters"],
		["Parameters"] = args["Parameters"],
	}
	asserts.AssertGetParametersResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertPatchFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Values"], "Expected key Values to exist in table")
	if struct["Values"] then asserts.AssertPatchFilterValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertPatchFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchFilter[k], "PatchFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchFilter
-- <p>Defines a patch filter.</p> <p>A patch filter consists of key/value pairs, but not all keys are valid for all operating system types. For example, the key <code>PRODUCT</code> is valid for all supported operating system types. The key <code>MSRC_SEVERITY</code>, however, is valid only for Windows operating systems, and the key <code>SECTION</code> is valid only for Ubuntu operating systems.</p> <p>Refer to the following sections for information about which keys may be used with each major operating system, and which values are valid for each key.</p> <p> <b>Windows Operating Systems</b> </p> <p>The supported keys for Windows operating systems are <code>PRODUCT</code>, <code>CLASSIFICATION</code>, and <code>MSRC_SEVERITY</code>. See the following lists for valid values for each of these keys.</p> <p> <i>Supported key:</i> <code>PRODUCT</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Windows7</code> </p> </li> <li> <p> <code>Windows8</code> </p> </li> <li> <p> <code>Windows8.1</code> </p> </li> <li> <p> <code>Windows8Embedded</code> </p> </li> <li> <p> <code>Windows10</code> </p> </li> <li> <p> <code>Windows10LTSB</code> </p> </li> <li> <p> <code>WindowsServer2008</code> </p> </li> <li> <p> <code>WindowsServer2008R2</code> </p> </li> <li> <p> <code>WindowsServer2012</code> </p> </li> <li> <p> <code>WindowsServer2012R2</code> </p> </li> <li> <p> <code>WindowsServer2016</code> </p> </li> <li> <p> <code>*</code> </p> <p> <i>Use a wildcard character (*) to target all supported operating system versions.</i> </p> </li> </ul> <p> <i>Supported key:</i> <code>CLASSIFICATION</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>CriticalUpdates</code> </p> </li> <li> <p> <code>DefinitionUpdates</code> </p> </li> <li> <p> <code>Drivers</code> </p> </li> <li> <p> <code>FeaturePacks</code> </p> </li> <li> <p> <code>SecurityUpdates</code> </p> </li> <li> <p> <code>ServicePacks</code> </p> </li> <li> <p> <code>Tools</code> </p> </li> <li> <p> <code>UpdateRollups</code> </p> </li> <li> <p> <code>Updates</code> </p> </li> <li> <p> <code>Upgrades</code> </p> </li> </ul> <p> <i>Supported key:</i> <code>MSRC_SEVERITY</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Critical</code> </p> </li> <li> <p> <code>Important</code> </p> </li> <li> <p> <code>Moderate</code> </p> </li> <li> <p> <code>Low</code> </p> </li> <li> <p> <code>Unspecified</code> </p> </li> </ul> <p> <b>Ubuntu Operating Systems</b> </p> <p>The supported keys for Ubuntu operating systems are <code>PRODUCT</code>, <code>PRIORITY</code>, and <code>SECTION</code>. See the following lists for valid values for each of these keys.</p> <p> <i>Supported key:</i> <code>PRODUCT</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Ubuntu14.04</code> </p> </li> <li> <p> <code>Ubuntu16.04</code> </p> </li> <li> <p> <code>*</code> </p> <p> <i>Use a wildcard character (*) to target all supported operating system versions.</i> </p> </li> </ul> <p> <i>Supported key:</i> <code>PRIORITY</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Required</code> </p> </li> <li> <p> <code>Important</code> </p> </li> <li> <p> <code>Standard</code> </p> </li> <li> <p> <code>Optional</code> </p> </li> <li> <p> <code>Extra</code> </p> </li> </ul> <p> <i>Supported key:</i> <code>SECTION</code> </p> <p>Only the length of the key value is validated. Minimum length is 1. Maximum length is 64.</p> <p> <b>Amazon Linux Operating Systems</b> </p> <p>The supported keys for Amazon Linux operating systems are <code>PRODUCT</code>, <code>CLASSIFICATION</code>, and <code>SEVERITY</code>. See the following lists for valid values for each of these keys.</p> <p> <i>Supported key:</i> <code>PRODUCT</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>AmazonLinux2012.03</code> </p> </li> <li> <p> <code>AmazonLinux2012.09</code> </p> </li> <li> <p> <code>AmazonLinux2013.03</code> </p> </li> <li> <p> <code>AmazonLinux2013.09</code> </p> </li> <li> <p> <code>AmazonLinux2014.03</code> </p> </li> <li> <p> <code>AmazonLinux2014.09</code> </p> </li> <li> <p> <code>AmazonLinux2015.03</code> </p> </li> <li> <p> <code>AmazonLinux2015.09</code> </p> </li> <li> <p> <code>AmazonLinux2016.03</code> </p> </li> <li> <p> <code>AmazonLinux2016.09</code> </p> </li> <li> <p> <code>AmazonLinux2017.03</code> </p> </li> <li> <p> <code>AmazonLinux2017.09</code> </p> </li> <li> <p> <code>*</code> </p> <p> <i>Use a wildcard character (*) to target all supported operating system versions.</i> </p> </li> </ul> <p> <i>Supported key:</i> <code>CLASSIFICATION</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Security</code> </p> </li> <li> <p> <code>Bugfix</code> </p> </li> <li> <p> <code>Enhancement</code> </p> </li> <li> <p> <code>Recommended</code> </p> </li> <li> <p> <code>Newpackage</code> </p> </li> </ul> <p> <i>Supported key:</i> <code>SEVERITY</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Critical</code> </p> </li> <li> <p> <code>Important</code> </p> </li> <li> <p> <code>Medium</code> </p> </li> <li> <p> <code>Low</code> </p> </li> </ul> <p> <b>Amazon Linux 2 Operating Systems</b> </p> <p>The supported keys for Amazon Linux 2 operating systems are <code>PRODUCT</code>, <code>CLASSIFICATION</code>, and <code>SEVERITY</code>. See the following lists for valid values for each of these keys.</p> <p> <i>Supported key:</i> <code>PRODUCT</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>AmazonLinux2</code> </p> </li> <li> <p> <code>AmazonLinux2.0</code> </p> </li> <li> <p> <code>*</code> </p> <p> <i>Use a wildcard character (*) to target all supported operating system versions.</i> </p> </li> </ul> <p> <i>Supported key:</i> <code>CLASSIFICATION</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Security</code> </p> </li> <li> <p> <code>Bugfix</code> </p> </li> <li> <p> <code>Enhancement</code> </p> </li> <li> <p> <code>Recommended</code> </p> </li> <li> <p> <code>Newpackage</code> </p> </li> </ul> <p> <i>Supported key:</i> <code>SEVERITY</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Critical</code> </p> </li> <li> <p> <code>Important</code> </p> </li> <li> <p> <code>Medium</code> </p> </li> <li> <p> <code>Low</code> </p> </li> </ul> <p> <b>RedHat Enterprise Linux (RHEL) Operating Systems</b> </p> <p>The supported keys for RedHat Enterprise Linux operating systems are <code>PRODUCT</code>, <code>CLASSIFICATION</code>, and <code>SEVERITY</code>. See the following lists for valid values for each of these keys.</p> <p> <i>Supported key:</i> <code>PRODUCT</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>RedhatEnterpriseLinux6.5</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux6.6</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux6.7</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux6.8</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux6.9</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux7.0</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux7.1</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux7.2</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux7.3</code> </p> </li> <li> <p> <code>RedhatEnterpriseLinux7.4</code> </p> </li> <li> <p> <code>*</code> </p> <p> <i>Use a wildcard character (*) to target all supported operating system versions.</i> </p> </li> </ul> <p> <i>Supported key:</i> <code>CLASSIFICATION</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Security</code> </p> </li> <li> <p> <code>Bugfix</code> </p> </li> <li> <p> <code>Enhancement</code> </p> </li> <li> <p> <code>Recommended</code> </p> </li> <li> <p> <code>Newpackage</code> </p> </li> </ul> <p> <i>Supported key:</i> <code>SEVERITY</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Critical</code> </p> </li> <li> <p> <code>Important</code> </p> </li> <li> <p> <code>Medium</code> </p> </li> <li> <p> <code>Low</code> </p> </li> </ul> <p> <b>SUSE Linux Enterprise Server (SLES) Operating Systems</b> </p> <p>The supported keys for SLES operating systems are <code>PRODUCT</code>, <code>CLASSIFICATION</code>, and <code>SEVERITY</code>. See the following lists for valid values for each of these keys.</p> <p> <i>Supported key:</i> <code>PRODUCT</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Suse12.0</code> </p> </li> <li> <p> <code>Suse12.1</code> </p> </li> <li> <p> <code>Suse12.2</code> </p> </li> <li> <p> <code>Suse12.3</code> </p> </li> <li> <p> <code>Suse12.4</code> </p> </li> <li> <p> <code>Suse12.5</code> </p> </li> <li> <p> <code>Suse12.6</code> </p> </li> <li> <p> <code>Suse12.7</code> </p> </li> <li> <p> <code>Suse12.8</code> </p> </li> <li> <p> <code>Suse12.9</code> </p> </li> <li> <p> <code>*</code> </p> <p> <i>Use a wildcard character (*) to target all supported operating system versions.</i> </p> </li> </ul> <p> <i>Supported key:</i> <code>CLASSIFICATION</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Security</code> </p> </li> <li> <p> <code>Recommended</code> </p> </li> <li> <p> <code>Optional</code> </p> </li> <li> <p> <code>Feature</code> </p> </li> <li> <p> <code>Document</code> </p> </li> <li> <p> <code>Yast</code> </p> </li> </ul> <p> <i>Supported key:</i> <code>SEVERITY</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Critical</code> </p> </li> <li> <p> <code>Important</code> </p> </li> <li> <p> <code>Moderate</code> </p> </li> <li> <p> <code>Low</code> </p> </li> </ul> <p> <b>CentOS Operating Systems</b> </p> <p>The supported keys for CentOS operating systems are <code>PRODUCT</code>, <code>CLASSIFICATION</code>, and <code>SEVERITY</code>. See the following lists for valid values for each of these keys.</p> <p> <i>Supported key:</i> <code>PRODUCT</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>CentOS6.5</code> </p> </li> <li> <p> <code>CentOS6.6</code> </p> </li> <li> <p> <code>CentOS6.7</code> </p> </li> <li> <p> <code>CentOS6.8</code> </p> </li> <li> <p> <code>CentOS6.9</code> </p> </li> <li> <p> <code>CentOS7.0</code> </p> </li> <li> <p> <code>CentOS7.1</code> </p> </li> <li> <p> <code>CentOS7.2</code> </p> </li> <li> <p> <code>CentOS7.3</code> </p> </li> <li> <p> <code>CentOS7.4</code> </p> </li> <li> <p> <code>*</code> </p> <p> <i>Use a wildcard character (*) to target all supported operating system versions.</i> </p> </li> </ul> <p> <i>Supported key:</i> <code>CLASSIFICATION</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Security</code> </p> </li> <li> <p> <code>Bugfix</code> </p> </li> <li> <p> <code>Enhancement</code> </p> </li> <li> <p> <code>Recommended</code> </p> </li> <li> <p> <code>Newpackage</code> </p> </li> </ul> <p> <i>Supported key:</i> <code>SEVERITY</code> </p> <p> <i>Supported values:</i> </p> <ul> <li> <p> <code>Critical</code> </p> </li> <li> <p> <code>Important</code> </p> </li> <li> <p> <code>Medium</code> </p> </li> <li> <p> <code>Low</code> </p> </li> </ul>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [PatchFilterValueList] <p>The value for the filter key.</p> <p>See <a>PatchFilter</a> for lists of valid values for each key based on operating system type.</p>
-- * Key [PatchFilterKey] <p>The key for the filter.</p> <p>See <a>PatchFilter</a> for lists of valid keys for each operating system type.</p>
-- Required key: Key
-- Required key: Values
-- @return PatchFilter structure as a key-value pair table
function M.PatchFilter(args)
	assert(args, "You must provide an argument table when creating PatchFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertPatchFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowExecutionTaskInvocationsResult = { ["NextToken"] = true, ["WindowExecutionTaskInvocationIdentities"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowExecutionTaskInvocationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowExecutionTaskInvocationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["WindowExecutionTaskInvocationIdentities"] then asserts.AssertMaintenanceWindowExecutionTaskInvocationIdentityList(struct["WindowExecutionTaskInvocationIdentities"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowExecutionTaskInvocationsResult[k], "DescribeMaintenanceWindowExecutionTaskInvocationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowExecutionTaskInvocationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * WindowExecutionTaskInvocationIdentities [MaintenanceWindowExecutionTaskInvocationIdentityList] <p>Information about the task invocation results per invocation.</p>
-- @return DescribeMaintenanceWindowExecutionTaskInvocationsResult structure as a key-value pair table
function M.DescribeMaintenanceWindowExecutionTaskInvocationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowExecutionTaskInvocationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["WindowExecutionTaskInvocationIdentities"] = args["WindowExecutionTaskInvocationIdentities"],
	}
	asserts.AssertDescribeMaintenanceWindowExecutionTaskInvocationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ComplianceExecutionSummary = { ["ExecutionTime"] = true, ["ExecutionId"] = true, ["ExecutionType"] = true, nil }

function asserts.AssertComplianceExecutionSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ComplianceExecutionSummary to be of type 'table'")
	assert(struct["ExecutionTime"], "Expected key ExecutionTime to exist in table")
	if struct["ExecutionTime"] then asserts.AssertDateTime(struct["ExecutionTime"]) end
	if struct["ExecutionId"] then asserts.AssertComplianceExecutionId(struct["ExecutionId"]) end
	if struct["ExecutionType"] then asserts.AssertComplianceExecutionType(struct["ExecutionType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ComplianceExecutionSummary[k], "ComplianceExecutionSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ComplianceExecutionSummary
-- <p>A summary of the call execution that includes an execution ID, the type of execution (for example, <code>Command</code>), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExecutionTime [DateTime] <p>The time the execution ran as a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
-- * ExecutionId [ComplianceExecutionId] <p>An ID created by the system when <code>PutComplianceItems</code> was called. For example, <code>CommandID</code> is a valid execution ID. You can use this ID in subsequent calls.</p>
-- * ExecutionType [ComplianceExecutionType] <p>The type of execution. For example, <code>Command</code> is a valid execution type.</p>
-- Required key: ExecutionTime
-- @return ComplianceExecutionSummary structure as a key-value pair table
function M.ComplianceExecutionSummary(args)
	assert(args, "You must provide an argument table when creating ComplianceExecutionSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExecutionTime"] = args["ExecutionTime"],
		["ExecutionId"] = args["ExecutionId"],
		["ExecutionType"] = args["ExecutionType"],
	}
	asserts.AssertComplianceExecutionSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AddTagsToResourceRequest = { ["ResourceType"] = true, ["ResourceId"] = true, ["Tags"] = true, nil }

function asserts.AssertAddTagsToResourceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AddTagsToResourceRequest to be of type 'table'")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["ResourceId"], "Expected key ResourceId to exist in table")
	assert(struct["Tags"], "Expected key Tags to exist in table")
	if struct["ResourceType"] then asserts.AssertResourceTypeForTagging(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertResourceId(struct["ResourceId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.AddTagsToResourceRequest[k], "AddTagsToResourceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AddTagsToResourceRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceTypeForTagging] <p>Specifies the type of resource you are tagging.</p> <note> <p>The ManagedInstance type for this API action is for on-premises managed instances. You must specify the the name of the managed instance in the following format: mi-ID_number. For example, mi-1a2b3c4d5e6f.</p> </note>
-- * ResourceId [ResourceId] <p>The resource ID you want to tag.</p> <p>Use the ID of the resource. Here are some examples:</p> <p>ManagedInstance: mi-012345abcde</p> <p>MaintenanceWindow: mw-012345abcde</p> <p>PatchBaseline: pb-012345abcde</p> <p>For the Document and Parameter values, use the name of the resource.</p> <note> <p>The ManagedInstance type for this API action is only for on-premises managed instances. You must specify the the name of the managed instance in the following format: mi-ID_number. For example, mi-1a2b3c4d5e6f.</p> </note>
-- * Tags [TagList] <p> One or more tags. The value parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. </p> <important> <p>Do not enter personally identifiable information in this field.</p> </important>
-- Required key: ResourceType
-- Required key: ResourceId
-- Required key: Tags
-- @return AddTagsToResourceRequest structure as a key-value pair table
function M.AddTagsToResourceRequest(args)
	assert(args, "You must provide an argument table when creating AddTagsToResourceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertAddTagsToResourceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListResourceComplianceSummariesResult = { ["NextToken"] = true, ["ResourceComplianceSummaryItems"] = true, nil }

function asserts.AssertListResourceComplianceSummariesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListResourceComplianceSummariesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["ResourceComplianceSummaryItems"] then asserts.AssertResourceComplianceSummaryItemList(struct["ResourceComplianceSummaryItems"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListResourceComplianceSummariesResult[k], "ListResourceComplianceSummariesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListResourceComplianceSummariesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- * ResourceComplianceSummaryItems [ResourceComplianceSummaryItemList] <p>A summary count for specified or targeted managed instances. Summary count includes information about compliant and non-compliant State Manager associations, patch status, or custom items according to the filter criteria that you specify. </p>
-- @return ListResourceComplianceSummariesResult structure as a key-value pair table
function M.ListResourceComplianceSummariesResult(args)
	assert(args, "You must provide an argument table when creating ListResourceComplianceSummariesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ResourceComplianceSummaryItems"] = args["ResourceComplianceSummaryItems"],
	}
	asserts.AssertListResourceComplianceSummariesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetDocumentResult = { ["Content"] = true, ["DocumentFormat"] = true, ["Name"] = true, ["DocumentVersion"] = true, ["DocumentType"] = true, nil }

function asserts.AssertGetDocumentResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetDocumentResult to be of type 'table'")
	if struct["Content"] then asserts.AssertDocumentContent(struct["Content"]) end
	if struct["DocumentFormat"] then asserts.AssertDocumentFormat(struct["DocumentFormat"]) end
	if struct["Name"] then asserts.AssertDocumentARN(struct["Name"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["DocumentType"] then asserts.AssertDocumentType(struct["DocumentType"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetDocumentResult[k], "GetDocumentResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetDocumentResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Content [DocumentContent] <p>The contents of the Systems Manager document.</p>
-- * DocumentFormat [DocumentFormat] <p>The document format, either JSON or YAML.</p>
-- * Name [DocumentARN] <p>The name of the Systems Manager document.</p>
-- * DocumentVersion [DocumentVersion] <p>The document version.</p>
-- * DocumentType [DocumentType] <p>The document type.</p>
-- @return GetDocumentResult structure as a key-value pair table
function M.GetDocumentResult(args)
	assert(args, "You must provide an argument table when creating GetDocumentResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Content"] = args["Content"],
		["DocumentFormat"] = args["DocumentFormat"],
		["Name"] = args["Name"],
		["DocumentVersion"] = args["DocumentVersion"],
		["DocumentType"] = args["DocumentType"],
	}
	asserts.AssertGetDocumentResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetAutomationExecutionResult = { ["AutomationExecution"] = true, nil }

function asserts.AssertGetAutomationExecutionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetAutomationExecutionResult to be of type 'table'")
	if struct["AutomationExecution"] then asserts.AssertAutomationExecution(struct["AutomationExecution"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetAutomationExecutionResult[k], "GetAutomationExecutionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetAutomationExecutionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutomationExecution [AutomationExecution] <p>Detailed information about the current state of an automation execution.</p>
-- @return GetAutomationExecutionResult structure as a key-value pair table
function M.GetAutomationExecutionResult(args)
	assert(args, "You must provide an argument table when creating GetAutomationExecutionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutomationExecution"] = args["AutomationExecution"],
	}
	asserts.AssertGetAutomationExecutionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryItem = { ["ContentHash"] = true, ["Content"] = true, ["TypeName"] = true, ["Context"] = true, ["SchemaVersion"] = true, ["CaptureTime"] = true, nil }

function asserts.AssertInventoryItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryItem to be of type 'table'")
	assert(struct["TypeName"], "Expected key TypeName to exist in table")
	assert(struct["SchemaVersion"], "Expected key SchemaVersion to exist in table")
	assert(struct["CaptureTime"], "Expected key CaptureTime to exist in table")
	if struct["ContentHash"] then asserts.AssertInventoryItemContentHash(struct["ContentHash"]) end
	if struct["Content"] then asserts.AssertInventoryItemEntryList(struct["Content"]) end
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["Context"] then asserts.AssertInventoryItemContentContext(struct["Context"]) end
	if struct["SchemaVersion"] then asserts.AssertInventoryItemSchemaVersion(struct["SchemaVersion"]) end
	if struct["CaptureTime"] then asserts.AssertInventoryItemCaptureTime(struct["CaptureTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryItem[k], "InventoryItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryItem
-- <p>Information collected from managed instances based on your inventory policy document</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ContentHash [InventoryItemContentHash] <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API does not update the inventory item type contents if the MD5 hash has not changed since last update. </p>
-- * Content [InventoryItemEntryList] <p>The inventory data of the inventory type.</p>
-- * TypeName [InventoryItemTypeName] <p>The name of the inventory type. Default inventory item type names start with AWS. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.</p>
-- * Context [InventoryItemContentContext] <p>A map of associated properties for a specified inventory type. For example, with this attribute, you can specify the <code>ExecutionId</code>, <code>ExecutionType</code>, <code>ComplianceType</code> properties of the <code>AWS:ComplianceItem</code> type.</p>
-- * SchemaVersion [InventoryItemSchemaVersion] <p>The schema version for the inventory item.</p>
-- * CaptureTime [InventoryItemCaptureTime] <p>The time the inventory information was collected.</p>
-- Required key: TypeName
-- Required key: SchemaVersion
-- Required key: CaptureTime
-- @return InventoryItem structure as a key-value pair table
function M.InventoryItem(args)
	assert(args, "You must provide an argument table when creating InventoryItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ContentHash"] = args["ContentHash"],
		["Content"] = args["Content"],
		["TypeName"] = args["TypeName"],
		["Context"] = args["Context"],
		["SchemaVersion"] = args["SchemaVersion"],
		["CaptureTime"] = args["CaptureTime"],
	}
	asserts.AssertInventoryItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowTaskParameterValueExpression = { ["Values"] = true, nil }

function asserts.AssertMaintenanceWindowTaskParameterValueExpression(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowTaskParameterValueExpression to be of type 'table'")
	if struct["Values"] then asserts.AssertMaintenanceWindowTaskParameterValueList(struct["Values"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowTaskParameterValueExpression[k], "MaintenanceWindowTaskParameterValueExpression contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowTaskParameterValueExpression
-- <p>Defines the values for a task parameter.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [MaintenanceWindowTaskParameterValueList] <p>This field contains an array of 0 or more strings, each 1 to 255 characters in length.</p>
-- @return MaintenanceWindowTaskParameterValueExpression structure as a key-value pair table
function M.MaintenanceWindowTaskParameterValueExpression(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowTaskParameterValueExpression")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
	}
	asserts.AssertMaintenanceWindowTaskParameterValueExpression(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowIdentity = { ["Cutoff"] = true, ["EndDate"] = true, ["Name"] = true, ["Schedule"] = true, ["Enabled"] = true, ["ScheduleTimezone"] = true, ["WindowId"] = true, ["NextExecutionTime"] = true, ["Duration"] = true, ["StartDate"] = true, ["Description"] = true, nil }

function asserts.AssertMaintenanceWindowIdentity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowIdentity to be of type 'table'")
	if struct["Cutoff"] then asserts.AssertMaintenanceWindowCutoff(struct["Cutoff"]) end
	if struct["EndDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["EndDate"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	if struct["Schedule"] then asserts.AssertMaintenanceWindowSchedule(struct["Schedule"]) end
	if struct["Enabled"] then asserts.AssertMaintenanceWindowEnabled(struct["Enabled"]) end
	if struct["ScheduleTimezone"] then asserts.AssertMaintenanceWindowTimezone(struct["ScheduleTimezone"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["NextExecutionTime"] then asserts.AssertMaintenanceWindowStringDateTime(struct["NextExecutionTime"]) end
	if struct["Duration"] then asserts.AssertMaintenanceWindowDurationHours(struct["Duration"]) end
	if struct["StartDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["StartDate"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowIdentity[k], "MaintenanceWindowIdentity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowIdentity
-- <p>Information about the Maintenance Window.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cutoff [MaintenanceWindowCutoff] <p>The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution.</p>
-- * EndDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when the Maintenance Window is scheduled to become inactive.</p>
-- * Name [MaintenanceWindowName] <p>The name of the Maintenance Window.</p>
-- * Schedule [MaintenanceWindowSchedule] <p>The schedule of the Maintenance Window in the form of a cron or rate expression.</p>
-- * Enabled [MaintenanceWindowEnabled] <p>Whether the Maintenance Window is enabled.</p>
-- * ScheduleTimezone [MaintenanceWindowTimezone] <p>The time zone that the scheduled Maintenance Window executions are based on, in Internet Assigned Numbers Authority (IANA) format.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window.</p>
-- * NextExecutionTime [MaintenanceWindowStringDateTime] <p>The next time the Maintenance Window will actually run, taking into account any specified times for the Maintenance Window to become active or inactive.</p>
-- * Duration [MaintenanceWindowDurationHours] <p>The duration of the Maintenance Window in hours.</p>
-- * StartDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when the Maintenance Window is scheduled to become active.</p>
-- * Description [MaintenanceWindowDescription] <p>A description of the Maintenance Window.</p>
-- @return MaintenanceWindowIdentity structure as a key-value pair table
function M.MaintenanceWindowIdentity(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowIdentity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Cutoff"] = args["Cutoff"],
		["EndDate"] = args["EndDate"],
		["Name"] = args["Name"],
		["Schedule"] = args["Schedule"],
		["Enabled"] = args["Enabled"],
		["ScheduleTimezone"] = args["ScheduleTimezone"],
		["WindowId"] = args["WindowId"],
		["NextExecutionTime"] = args["NextExecutionTime"],
		["Duration"] = args["Duration"],
		["StartDate"] = args["StartDate"],
		["Description"] = args["Description"],
	}
	asserts.AssertMaintenanceWindowIdentity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowRunCommandParameters = { ["Comment"] = true, ["ServiceRoleArn"] = true, ["TimeoutSeconds"] = true, ["Parameters"] = true, ["DocumentHash"] = true, ["OutputS3BucketName"] = true, ["NotificationConfig"] = true, ["DocumentHashType"] = true, ["OutputS3KeyPrefix"] = true, nil }

function asserts.AssertMaintenanceWindowRunCommandParameters(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowRunCommandParameters to be of type 'table'")
	if struct["Comment"] then asserts.AssertComment(struct["Comment"]) end
	if struct["ServiceRoleArn"] then asserts.AssertServiceRole(struct["ServiceRoleArn"]) end
	if struct["TimeoutSeconds"] then asserts.AssertTimeoutSeconds(struct["TimeoutSeconds"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["DocumentHash"] then asserts.AssertDocumentHash(struct["DocumentHash"]) end
	if struct["OutputS3BucketName"] then asserts.AssertS3BucketName(struct["OutputS3BucketName"]) end
	if struct["NotificationConfig"] then asserts.AssertNotificationConfig(struct["NotificationConfig"]) end
	if struct["DocumentHashType"] then asserts.AssertDocumentHashType(struct["DocumentHashType"]) end
	if struct["OutputS3KeyPrefix"] then asserts.AssertS3KeyPrefix(struct["OutputS3KeyPrefix"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowRunCommandParameters[k], "MaintenanceWindowRunCommandParameters contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowRunCommandParameters
-- <p>The parameters for a RUN_COMMAND task type.</p> <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p>For Run Command tasks, Systems Manager uses specified values for <code>TaskParameters</code> and <code>LoggingInfo</code> only if no values are specified for <code>TaskInvocationParameters</code>. </p> </note>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Comment [Comment] <p>Information about the command(s) to execute.</p>
-- * ServiceRoleArn [ServiceRole] <p>The IAM service role to assume during task execution.</p>
-- * TimeoutSeconds [TimeoutSeconds] <p>If this time is reached and the command has not already started executing, it doesn not execute.</p>
-- * Parameters [Parameters] <p>The parameters for the RUN_COMMAND task execution.</p>
-- * DocumentHash [DocumentHash] <p>The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.</p>
-- * OutputS3BucketName [S3BucketName] <p>The name of the Amazon S3 bucket.</p>
-- * NotificationConfig [NotificationConfig] <p>Configurations for sending notifications about command status changes on a per-instance basis.</p>
-- * DocumentHashType [DocumentHashType] <p>SHA-256 or SHA-1. SHA-1 hashes have been deprecated.</p>
-- * OutputS3KeyPrefix [S3KeyPrefix] <p>The Amazon S3 bucket subfolder.</p>
-- @return MaintenanceWindowRunCommandParameters structure as a key-value pair table
function M.MaintenanceWindowRunCommandParameters(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowRunCommandParameters")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Comment"] = args["Comment"],
		["ServiceRoleArn"] = args["ServiceRoleArn"],
		["TimeoutSeconds"] = args["TimeoutSeconds"],
		["Parameters"] = args["Parameters"],
		["DocumentHash"] = args["DocumentHash"],
		["OutputS3BucketName"] = args["OutputS3BucketName"],
		["NotificationConfig"] = args["NotificationConfig"],
		["DocumentHashType"] = args["DocumentHashType"],
		["OutputS3KeyPrefix"] = args["OutputS3KeyPrefix"],
	}
	asserts.AssertMaintenanceWindowRunCommandParameters(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchStatus = { ["ApprovalDate"] = true, ["DeploymentStatus"] = true, ["ComplianceLevel"] = true, nil }

function asserts.AssertPatchStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchStatus to be of type 'table'")
	if struct["ApprovalDate"] then asserts.AssertDateTime(struct["ApprovalDate"]) end
	if struct["DeploymentStatus"] then asserts.AssertPatchDeploymentStatus(struct["DeploymentStatus"]) end
	if struct["ComplianceLevel"] then asserts.AssertPatchComplianceLevel(struct["ComplianceLevel"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchStatus[k], "PatchStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchStatus
-- <p>Information about the approval status of a patch.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ApprovalDate [DateTime] <p>The date the patch was approved (or will be approved if the status is PENDING_APPROVAL).</p>
-- * DeploymentStatus [PatchDeploymentStatus] <p>The approval status of a patch (APPROVED, PENDING_APPROVAL, EXPLICIT_APPROVED, EXPLICIT_REJECTED).</p>
-- * ComplianceLevel [PatchComplianceLevel] <p>The compliance severity level for a patch.</p>
-- @return PatchStatus structure as a key-value pair table
function M.PatchStatus(args)
	assert(args, "You must provide an argument table when creating PatchStatus")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ApprovalDate"] = args["ApprovalDate"],
		["DeploymentStatus"] = args["DeploymentStatus"],
		["ComplianceLevel"] = args["ComplianceLevel"],
	}
	asserts.AssertPatchStatus(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAssociationExecutionTargetsResult = { ["AssociationExecutionTargets"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeAssociationExecutionTargetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAssociationExecutionTargetsResult to be of type 'table'")
	if struct["AssociationExecutionTargets"] then asserts.AssertAssociationExecutionTargetsList(struct["AssociationExecutionTargets"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAssociationExecutionTargetsResult[k], "DescribeAssociationExecutionTargetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAssociationExecutionTargetsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationExecutionTargets [AssociationExecutionTargetsList] <p>Information about the execution.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- @return DescribeAssociationExecutionTargetsResult structure as a key-value pair table
function M.DescribeAssociationExecutionTargetsResult(args)
	assert(args, "You must provide an argument table when creating DescribeAssociationExecutionTargetsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationExecutionTargets"] = args["AssociationExecutionTargets"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeAssociationExecutionTargetsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterManagedInstanceRequest = { ["InstanceId"] = true, nil }

function asserts.AssertDeregisterManagedInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterManagedInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertManagedInstanceId(struct["InstanceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterManagedInstanceRequest[k], "DeregisterManagedInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterManagedInstanceRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [ManagedInstanceId] <p>The ID assigned to the managed instance when you registered it using the activation process. </p>
-- Required key: InstanceId
-- @return DeregisterManagedInstanceRequest structure as a key-value pair table
function M.DeregisterManagedInstanceRequest(args)
	assert(args, "You must provide an argument table when creating DeregisterManagedInstanceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
	}
	asserts.AssertDeregisterManagedInstanceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Command = { ["MaxErrors"] = true, ["Parameters"] = true, ["DocumentName"] = true, ["OutputS3BucketName"] = true, ["OutputS3KeyPrefix"] = true, ["StatusDetails"] = true, ["RequestedDateTime"] = true, ["Status"] = true, ["TargetCount"] = true, ["NotificationConfig"] = true, ["InstanceIds"] = true, ["ErrorCount"] = true, ["MaxConcurrency"] = true, ["ServiceRole"] = true, ["CloudWatchOutputConfig"] = true, ["DocumentVersion"] = true, ["OutputS3Region"] = true, ["CompletedCount"] = true, ["Comment"] = true, ["ExpiresAfter"] = true, ["DeliveryTimedOutCount"] = true, ["CommandId"] = true, ["Targets"] = true, nil }

function asserts.AssertCommand(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Command to be of type 'table'")
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["DocumentName"] then asserts.AssertDocumentName(struct["DocumentName"]) end
	if struct["OutputS3BucketName"] then asserts.AssertS3BucketName(struct["OutputS3BucketName"]) end
	if struct["OutputS3KeyPrefix"] then asserts.AssertS3KeyPrefix(struct["OutputS3KeyPrefix"]) end
	if struct["StatusDetails"] then asserts.AssertStatusDetails(struct["StatusDetails"]) end
	if struct["RequestedDateTime"] then asserts.AssertDateTime(struct["RequestedDateTime"]) end
	if struct["Status"] then asserts.AssertCommandStatus(struct["Status"]) end
	if struct["TargetCount"] then asserts.AssertTargetCount(struct["TargetCount"]) end
	if struct["NotificationConfig"] then asserts.AssertNotificationConfig(struct["NotificationConfig"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdList(struct["InstanceIds"]) end
	if struct["ErrorCount"] then asserts.AssertErrorCount(struct["ErrorCount"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["ServiceRole"] then asserts.AssertServiceRole(struct["ServiceRole"]) end
	if struct["CloudWatchOutputConfig"] then asserts.AssertCloudWatchOutputConfig(struct["CloudWatchOutputConfig"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["OutputS3Region"] then asserts.AssertS3Region(struct["OutputS3Region"]) end
	if struct["CompletedCount"] then asserts.AssertCompletedCount(struct["CompletedCount"]) end
	if struct["Comment"] then asserts.AssertComment(struct["Comment"]) end
	if struct["ExpiresAfter"] then asserts.AssertDateTime(struct["ExpiresAfter"]) end
	if struct["DeliveryTimedOutCount"] then asserts.AssertDeliveryTimedOutCount(struct["DeliveryTimedOutCount"]) end
	if struct["CommandId"] then asserts.AssertCommandId(struct["CommandId"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	for k,_ in pairs(struct) do
		assert(keys.Command[k], "Command contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Command
-- <p>Describes a command request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxErrors [MaxErrors] <p>The maximum number of errors allowed before the system stops sending the command to additional targets. You can specify a number of errors, such as 10, or a percentage or errors, such as 10%. The default value is 0. For more information about how to use MaxErrors, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Executing Commands Using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * Parameters [Parameters] <p>The parameter values to be inserted in the document when executing the command.</p>
-- * DocumentName [DocumentName] <p>The name of the document requested for execution.</p>
-- * OutputS3BucketName [S3BucketName] <p>The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command.</p>
-- * OutputS3KeyPrefix [S3KeyPrefix] <p>The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command.</p>
-- * StatusDetails [StatusDetails] <p>A detailed status of the command execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding Command Statuses</a> in the <i>AWS Systems Manager User Guide</i>. StatusDetails can be one of the following values:</p> <ul> <li> <p>Pending: The command has not been sent to any instances.</p> </li> <li> <p>In Progress: The command has been sent to at least one instance but has not reached a final state on all instances.</p> </li> <li> <p>Success: The command successfully executed on all invocations. This is a terminal state.</p> </li> <li> <p>Delivery Timed Out: The value of MaxErrors or more command invocations shows a status of Delivery Timed Out. This is a terminal state.</p> </li> <li> <p>Execution Timed Out: The value of MaxErrors or more command invocations shows a status of Execution Timed Out. This is a terminal state.</p> </li> <li> <p>Failed: The value of MaxErrors or more command invocations shows a status of Failed. This is a terminal state.</p> </li> <li> <p>Incomplete: The command was attempted on all instances and one or more invocations does not have a value of Success but not enough invocations failed for the status to be Failed. This is a terminal state.</p> </li> <li> <p>Canceled: The command was terminated before it was completed. This is a terminal state.</p> </li> <li> <p>Rate Exceeded: The number of instances targeted by the command exceeded the account limit for pending invocations. The system has canceled the command before executing it on any instance. This is a terminal state.</p> </li> </ul>
-- * RequestedDateTime [DateTime] <p>The date and time the command was requested.</p>
-- * Status [CommandStatus] <p>The status of the command.</p>
-- * TargetCount [TargetCount] <p>The number of targets for the command.</p>
-- * NotificationConfig [NotificationConfig] <p>Configurations for sending notifications about command status changes. </p>
-- * InstanceIds [InstanceIdList] <p>The instance IDs against which this command was requested.</p>
-- * ErrorCount [ErrorCount] <p>The number of targets for which the status is Failed or Execution Timed Out.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of instances that are allowed to execute the command at the same time. You can specify a number of instances, such as 10, or a percentage of instances, such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/run-command.html">Executing Commands Using Systems Manager Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * ServiceRole [ServiceRole] <p>The IAM service role that Run Command uses to act on your behalf when sending notifications about command status changes. </p>
-- * CloudWatchOutputConfig [CloudWatchOutputConfig] <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
-- * DocumentVersion [DocumentVersion] <p>The SSM document version.</p>
-- * OutputS3Region [S3Region] <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon S3 bucket region.</p>
-- * CompletedCount [CompletedCount] <p>The number of targets for which the command invocation reached a terminal state. Terminal states include the following: Success, Failed, Execution Timed Out, Delivery Timed Out, Canceled, Terminated, or Undeliverable.</p>
-- * Comment [Comment] <p>User-specified information about the command, such as a brief description of what the command should do.</p>
-- * ExpiresAfter [DateTime] <p>If this time is reached and the command has not already started executing, it will not run. Calculated based on the ExpiresAfter user input provided as part of the SendCommand API.</p>
-- * DeliveryTimedOutCount [DeliveryTimedOutCount] <p>The number of targets for which the status is Delivery Timed Out.</p>
-- * CommandId [CommandId] <p>A unique identifier for this command.</p>
-- * Targets [Targets] <p>An array of search criteria that targets instances using a Key,Value combination that you specify. Targets is required if you don't provide one or more instance IDs in the call.</p>
-- @return Command structure as a key-value pair table
function M.Command(args)
	assert(args, "You must provide an argument table when creating Command")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxErrors"] = args["MaxErrors"],
		["Parameters"] = args["Parameters"],
		["DocumentName"] = args["DocumentName"],
		["OutputS3BucketName"] = args["OutputS3BucketName"],
		["OutputS3KeyPrefix"] = args["OutputS3KeyPrefix"],
		["StatusDetails"] = args["StatusDetails"],
		["RequestedDateTime"] = args["RequestedDateTime"],
		["Status"] = args["Status"],
		["TargetCount"] = args["TargetCount"],
		["NotificationConfig"] = args["NotificationConfig"],
		["InstanceIds"] = args["InstanceIds"],
		["ErrorCount"] = args["ErrorCount"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["ServiceRole"] = args["ServiceRole"],
		["CloudWatchOutputConfig"] = args["CloudWatchOutputConfig"],
		["DocumentVersion"] = args["DocumentVersion"],
		["OutputS3Region"] = args["OutputS3Region"],
		["CompletedCount"] = args["CompletedCount"],
		["Comment"] = args["Comment"],
		["ExpiresAfter"] = args["ExpiresAfter"],
		["DeliveryTimedOutCount"] = args["DeliveryTimedOutCount"],
		["CommandId"] = args["CommandId"],
		["Targets"] = args["Targets"],
	}
	asserts.AssertCommand(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PutParameterRequest = { ["KeyId"] = true, ["Name"] = true, ["Value"] = true, ["AllowedPattern"] = true, ["Type"] = true, ["Overwrite"] = true, ["Description"] = true, nil }

function asserts.AssertPutParameterRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PutParameterRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["Value"], "Expected key Value to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["KeyId"] then asserts.AssertParameterKeyId(struct["KeyId"]) end
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	if struct["Value"] then asserts.AssertPSParameterValue(struct["Value"]) end
	if struct["AllowedPattern"] then asserts.AssertAllowedPattern(struct["AllowedPattern"]) end
	if struct["Type"] then asserts.AssertParameterType(struct["Type"]) end
	if struct["Overwrite"] then asserts.AssertBoolean(struct["Overwrite"]) end
	if struct["Description"] then asserts.AssertParameterDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.PutParameterRequest[k], "PutParameterRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PutParameterRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyId [ParameterKeyId] <p>The KMS Key ID that you want to use to encrypt a parameter. Either the default AWS Key Management Service (AWS KMS) key automatically assigned to your AWS account or a custom key. Required for parameters that use the <code>SecureString</code> data type.</p> <p>If you don't specify a key ID, the system uses the default key associated with your AWS account.</p> <ul> <li> <p>To use your default AWS KMS key, choose the <code>SecureString</code> data type, and do <i>not</i> specify the <code>Key ID</code> when you create the parameter. The system automatically populates <code>Key ID</code> with your default KMS key.</p> </li> <li> <p>To use a custom KMS key, choose the <code>SecureString</code> data type with the <code>Key ID</code> parameter.</p> </li> </ul>
-- * Name [PSParameterName] <p>The fully qualified name of the parameter that you want to add to the system. The fully qualified name includes the complete hierarchy of the parameter path and name. For example: <code>/Dev/DBServer/MySQL/db-string13</code> </p> <p>Naming Constraints:</p> <ul> <li> <p>Parameter names are case sensitive.</p> </li> <li> <p>A parameter name must be unique within an AWS Region</p> </li> <li> <p>A parameter name can't be prefixed with "aws" or "ssm" (case-insensitive).</p> </li> <li> <p>Parameter names can include only the following symbols and letters: <code>a-zA-Z0-9_.-/</code> </p> </li> <li> <p>A parameter name can't include spaces.</p> </li> <li> <p>Parameter hierarchies are limited to a maximum depth of fifteen levels.</p> </li> </ul> <p>For additional information about valid values for parameter names, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-parameter-name-constraints.html">Requirements and Constraints for Parameter Names</a> in the <i>AWS Systems Manager User Guide</i>.</p> <note> <p>The maximum length constraint listed below includes capacity for additional system attributes that are not part of the name. The maximum length for the fully qualified parameter name is 1011 characters. </p> </note>
-- * Value [PSParameterValue] <p>The parameter value that you want to add to the system.</p>
-- * AllowedPattern [AllowedPattern] <p>A regular expression used to validate the parameter value. For example, for String types with values restricted to numbers, you can specify the following: AllowedPattern=^\d+$ </p>
-- * Type [ParameterType] <p>The type of parameter that you want to add to the system.</p> <p>Items in a <code>StringList</code> must be separated by a comma (,). You can't use other punctuation or special character to escape items in the list. If you have a parameter value that requires a comma, then use the <code>String</code> data type.</p> <note> <p> <code>SecureString</code> is not currently supported for AWS CloudFormation templates or in the China Regions.</p> </note>
-- * Overwrite [Boolean] <p>Overwrite an existing parameter. If not specified, will default to "false".</p>
-- * Description [ParameterDescription] <p>Information about the parameter that you want to add to the system. Optional but recommended.</p> <important> <p>Do not enter personally identifiable information in this field.</p> </important>
-- Required key: Name
-- Required key: Value
-- Required key: Type
-- @return PutParameterRequest structure as a key-value pair table
function M.PutParameterRequest(args)
	assert(args, "You must provide an argument table when creating PutParameterRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyId"] = args["KeyId"],
		["Name"] = args["Name"],
		["Value"] = args["Value"],
		["AllowedPattern"] = args["AllowedPattern"],
		["Type"] = args["Type"],
		["Overwrite"] = args["Overwrite"],
		["Description"] = args["Description"],
	}
	asserts.AssertPutParameterRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RemoveTagsFromResourceRequest = { ["ResourceType"] = true, ["ResourceId"] = true, ["TagKeys"] = true, nil }

function asserts.AssertRemoveTagsFromResourceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RemoveTagsFromResourceRequest to be of type 'table'")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["ResourceId"], "Expected key ResourceId to exist in table")
	assert(struct["TagKeys"], "Expected key TagKeys to exist in table")
	if struct["ResourceType"] then asserts.AssertResourceTypeForTagging(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertResourceId(struct["ResourceId"]) end
	if struct["TagKeys"] then asserts.AssertKeyList(struct["TagKeys"]) end
	for k,_ in pairs(struct) do
		assert(keys.RemoveTagsFromResourceRequest[k], "RemoveTagsFromResourceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RemoveTagsFromResourceRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceTypeForTagging] <p>The type of resource of which you want to remove a tag.</p> <note> <p>The ManagedInstance type for this API action is only for on-premises managed instances. You must specify the the name of the managed instance in the following format: mi-ID_number. For example, mi-1a2b3c4d5e6f.</p> </note>
-- * ResourceId [ResourceId] <p>The resource ID for which you want to remove tags. Use the ID of the resource. Here are some examples:</p> <p>ManagedInstance: mi-012345abcde</p> <p>MaintenanceWindow: mw-012345abcde</p> <p>PatchBaseline: pb-012345abcde</p> <p>For the Document and Parameter values, use the name of the resource.</p> <note> <p>The ManagedInstance type for this API action is only for on-premises managed instances. You must specify the the name of the managed instance in the following format: mi-ID_number. For example, mi-1a2b3c4d5e6f.</p> </note>
-- * TagKeys [KeyList] <p>Tag keys that you want to remove from the specified resource.</p>
-- Required key: ResourceType
-- Required key: ResourceId
-- Required key: TagKeys
-- @return RemoveTagsFromResourceRequest structure as a key-value pair table
function M.RemoveTagsFromResourceRequest(args)
	assert(args, "You must provide an argument table when creating RemoveTagsFromResourceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["TagKeys"] = args["TagKeys"],
	}
	asserts.AssertRemoveTagsFromResourceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DocumentFilter = { ["value"] = true, ["key"] = true, nil }

function asserts.AssertDocumentFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DocumentFilter to be of type 'table'")
	assert(struct["key"], "Expected key key to exist in table")
	assert(struct["value"], "Expected key value to exist in table")
	if struct["value"] then asserts.AssertDocumentFilterValue(struct["value"]) end
	if struct["key"] then asserts.AssertDocumentFilterKey(struct["key"]) end
	for k,_ in pairs(struct) do
		assert(keys.DocumentFilter[k], "DocumentFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DocumentFilter
-- <p>Describes a filter.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * value [DocumentFilterValue] <p>The value of the filter.</p>
-- * key [DocumentFilterKey] <p>The name of the filter.</p>
-- Required key: key
-- Required key: value
-- @return DocumentFilter structure as a key-value pair table
function M.DocumentFilter(args)
	assert(args, "You must provide an argument table when creating DocumentFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["value"] = args["value"],
		["key"] = args["key"],
	}
	asserts.AssertDocumentFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetDeployablePatchSnapshotForInstanceRequest = { ["InstanceId"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertGetDeployablePatchSnapshotForInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetDeployablePatchSnapshotForInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["SnapshotId"] then asserts.AssertSnapshotId(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetDeployablePatchSnapshotForInstanceRequest[k], "GetDeployablePatchSnapshotForInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetDeployablePatchSnapshotForInstanceRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The ID of the instance for which the appropriate patch snapshot should be retrieved.</p>
-- * SnapshotId [SnapshotId] <p>The user-defined snapshot ID.</p>
-- Required key: InstanceId
-- Required key: SnapshotId
-- @return GetDeployablePatchSnapshotForInstanceRequest structure as a key-value pair table
function M.GetDeployablePatchSnapshotForInstanceRequest(args)
	assert(args, "You must provide an argument table when creating GetDeployablePatchSnapshotForInstanceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertGetDeployablePatchSnapshotForInstanceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowExecutionResult = { ["Status"] = true, ["TaskIds"] = true, ["StartTime"] = true, ["EndTime"] = true, ["WindowExecutionId"] = true, ["StatusDetails"] = true, nil }

function asserts.AssertGetMaintenanceWindowExecutionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowExecutionResult to be of type 'table'")
	if struct["Status"] then asserts.AssertMaintenanceWindowExecutionStatus(struct["Status"]) end
	if struct["TaskIds"] then asserts.AssertMaintenanceWindowExecutionTaskIdList(struct["TaskIds"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["StatusDetails"] then asserts.AssertMaintenanceWindowExecutionStatusDetails(struct["StatusDetails"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowExecutionResult[k], "GetMaintenanceWindowExecutionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowExecutionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [MaintenanceWindowExecutionStatus] <p>The status of the Maintenance Window execution.</p>
-- * TaskIds [MaintenanceWindowExecutionTaskIdList] <p>The ID of the task executions from the Maintenance Window execution.</p>
-- * StartTime [DateTime] <p>The time the Maintenance Window started executing.</p>
-- * EndTime [DateTime] <p>The time the Maintenance Window finished executing.</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution.</p>
-- * StatusDetails [MaintenanceWindowExecutionStatusDetails] <p>The details explaining the Status. Only available for certain status values.</p>
-- @return GetMaintenanceWindowExecutionResult structure as a key-value pair table
function M.GetMaintenanceWindowExecutionResult(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowExecutionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["TaskIds"] = args["TaskIds"],
		["StartTime"] = args["StartTime"],
		["EndTime"] = args["EndTime"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["StatusDetails"] = args["StatusDetails"],
	}
	asserts.AssertGetMaintenanceWindowExecutionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCommandsRequest = { ["InstanceId"] = true, ["Filters"] = true, ["NextToken"] = true, ["CommandId"] = true, ["MaxResults"] = true, nil }

function asserts.AssertListCommandsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCommandsRequest to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["Filters"] then asserts.AssertCommandFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["CommandId"] then asserts.AssertCommandId(struct["CommandId"]) end
	if struct["MaxResults"] then asserts.AssertCommandMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCommandsRequest[k], "ListCommandsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCommandsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>(Optional) Lists commands issued against this instance ID.</p>
-- * Filters [CommandFilterList] <p>(Optional) One or more filters. Use a filter to return a more specific list of results. </p>
-- * NextToken [NextToken] <p>(Optional) The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * CommandId [CommandId] <p>(Optional) If provided, lists only the specified command.</p>
-- * MaxResults [CommandMaxResults] <p>(Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- @return ListCommandsRequest structure as a key-value pair table
function M.ListCommandsRequest(args)
	assert(args, "You must provide an argument table when creating ListCommandsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
		["CommandId"] = args["CommandId"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertListCommandsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetDeployablePatchSnapshotForInstanceResult = { ["InstanceId"] = true, ["SnapshotId"] = true, ["Product"] = true, ["SnapshotDownloadUrl"] = true, nil }

function asserts.AssertGetDeployablePatchSnapshotForInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetDeployablePatchSnapshotForInstanceResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["SnapshotId"] then asserts.AssertSnapshotId(struct["SnapshotId"]) end
	if struct["Product"] then asserts.AssertProduct(struct["Product"]) end
	if struct["SnapshotDownloadUrl"] then asserts.AssertSnapshotDownloadUrl(struct["SnapshotDownloadUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetDeployablePatchSnapshotForInstanceResult[k], "GetDeployablePatchSnapshotForInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetDeployablePatchSnapshotForInstanceResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The ID of the instance.</p>
-- * SnapshotId [SnapshotId] <p>The user-defined snapshot ID.</p>
-- * Product [Product] <p>Returns the specific operating system (for example Windows Server 2012 or Amazon Linux 2015.09) on the instance for the specified patch snapshot.</p>
-- * SnapshotDownloadUrl [SnapshotDownloadUrl] <p>A pre-signed Amazon S3 URL that can be used to download the patch snapshot.</p>
-- @return GetDeployablePatchSnapshotForInstanceResult structure as a key-value pair table
function M.GetDeployablePatchSnapshotForInstanceResult(args)
	assert(args, "You must provide an argument table when creating GetDeployablePatchSnapshotForInstanceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["SnapshotId"] = args["SnapshotId"],
		["Product"] = args["Product"],
		["SnapshotDownloadUrl"] = args["SnapshotDownloadUrl"],
	}
	asserts.AssertGetDeployablePatchSnapshotForInstanceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchRule = { ["PatchFilterGroup"] = true, ["ApproveAfterDays"] = true, ["ComplianceLevel"] = true, ["EnableNonSecurity"] = true, nil }

function asserts.AssertPatchRule(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchRule to be of type 'table'")
	assert(struct["PatchFilterGroup"], "Expected key PatchFilterGroup to exist in table")
	assert(struct["ApproveAfterDays"], "Expected key ApproveAfterDays to exist in table")
	if struct["PatchFilterGroup"] then asserts.AssertPatchFilterGroup(struct["PatchFilterGroup"]) end
	if struct["ApproveAfterDays"] then asserts.AssertApproveAfterDays(struct["ApproveAfterDays"]) end
	if struct["ComplianceLevel"] then asserts.AssertPatchComplianceLevel(struct["ComplianceLevel"]) end
	if struct["EnableNonSecurity"] then asserts.AssertBoolean(struct["EnableNonSecurity"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchRule[k], "PatchRule contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchRule
-- <p>Defines an approval rule for a patch baseline.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchFilterGroup [PatchFilterGroup] <p>The patch filter group that defines the criteria for the rule.</p>
-- * ApproveAfterDays [ApproveAfterDays] <p>The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of <code>7</code> means that patches are approved seven days after they are released. </p>
-- * ComplianceLevel [PatchComplianceLevel] <p>A compliance severity level for all approved patches in a patch baseline. Valid compliance severity levels include the following: Unspecified, Critical, High, Medium, Low, and Informational.</p>
-- * EnableNonSecurity [Boolean] <p>For instances identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is 'false'. Applies to Linux instances only.</p>
-- Required key: PatchFilterGroup
-- Required key: ApproveAfterDays
-- @return PatchRule structure as a key-value pair table
function M.PatchRule(args)
	assert(args, "You must provide an argument table when creating PatchRule")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchFilterGroup"] = args["PatchFilterGroup"],
		["ApproveAfterDays"] = args["ApproveAfterDays"],
		["ComplianceLevel"] = args["ComplianceLevel"],
		["EnableNonSecurity"] = args["EnableNonSecurity"],
	}
	asserts.AssertPatchRule(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListInventoryEntriesRequest = { ["InstanceId"] = true, ["TypeName"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertListInventoryEntriesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListInventoryEntriesRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["TypeName"], "Expected key TypeName to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertInventoryFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListInventoryEntriesRequest[k], "ListInventoryEntriesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListInventoryEntriesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The instance ID for which you want inventory information.</p>
-- * TypeName [InventoryItemTypeName] <p>The type of inventory item for which you want information.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [InventoryFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- Required key: InstanceId
-- Required key: TypeName
-- @return ListInventoryEntriesRequest structure as a key-value pair table
function M.ListInventoryEntriesRequest(args)
	assert(args, "You must provide an argument table when creating ListInventoryEntriesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["TypeName"] = args["TypeName"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertListInventoryEntriesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDocumentPermissionResponse = { ["AccountIds"] = true, nil }

function asserts.AssertDescribeDocumentPermissionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDocumentPermissionResponse to be of type 'table'")
	if struct["AccountIds"] then asserts.AssertAccountIdList(struct["AccountIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDocumentPermissionResponse[k], "DescribeDocumentPermissionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDocumentPermissionResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AccountIds [AccountIdList] <p>The account IDs that have permission to use this document. The ID can be either an AWS account or <i>All</i>.</p>
-- @return DescribeDocumentPermissionResponse structure as a key-value pair table
function M.DescribeDocumentPermissionResponse(args)
	assert(args, "You must provide an argument table when creating DescribeDocumentPermissionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AccountIds"] = args["AccountIds"],
	}
	asserts.AssertDescribeDocumentPermissionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAssociationVersionsResult = { ["AssociationVersions"] = true, ["NextToken"] = true, nil }

function asserts.AssertListAssociationVersionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAssociationVersionsResult to be of type 'table'")
	if struct["AssociationVersions"] then asserts.AssertAssociationVersionList(struct["AssociationVersions"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAssociationVersionsResult[k], "ListAssociationVersionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAssociationVersionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationVersions [AssociationVersionList] <p>Information about all versions of the association for the specified association ID.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- @return ListAssociationVersionsResult structure as a key-value pair table
function M.ListAssociationVersionsResult(args)
	assert(args, "You must provide an argument table when creating ListAssociationVersionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationVersions"] = args["AssociationVersions"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertListAssociationVersionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateAssociationRequest = { ["MaxErrors"] = true, ["ScheduleExpression"] = true, ["OutputLocation"] = true, ["Name"] = true, ["Parameters"] = true, ["InstanceId"] = true, ["DocumentVersion"] = true, ["AssociationName"] = true, ["Targets"] = true, ["ComplianceSeverity"] = true, ["MaxConcurrency"] = true, nil }

function asserts.AssertCreateAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateAssociationRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["ScheduleExpression"] then asserts.AssertScheduleExpression(struct["ScheduleExpression"]) end
	if struct["OutputLocation"] then asserts.AssertInstanceAssociationOutputLocation(struct["OutputLocation"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["AssociationName"] then asserts.AssertAssociationName(struct["AssociationName"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["ComplianceSeverity"] then asserts.AssertAssociationComplianceSeverity(struct["ComplianceSeverity"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateAssociationRequest[k], "CreateAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxErrors [MaxErrors] <p>The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 instances and set MaxError to 10%, then the system stops sending the request when the sixth error is received.</p> <p>Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.</p>
-- * ScheduleExpression [ScheduleExpression] <p>A cron expression when the association will be applied to the target(s).</p>
-- * OutputLocation [InstanceAssociationOutputLocation] <p>An Amazon S3 bucket where you want to store the output details of the request.</p>
-- * Name [DocumentName] <p>The name of the Systems Manager document.</p>
-- * Parameters [Parameters] <p>The parameters for the documents runtime configuration. </p>
-- * InstanceId [InstanceId] <p>The instance ID.</p>
-- * DocumentVersion [DocumentVersion] <p>The document version you want to associate with the target(s). Can be a specific version or the default version.</p>
-- * AssociationName [AssociationName] <p>Specify a descriptive name for the association.</p>
-- * Targets [Targets] <p>The targets (either instances or tags) for the association.</p>
-- * ComplianceSeverity [AssociationComplianceSeverity] <p>The severity level to assign to the association.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time.</p> <p>If a new instance starts and attempts to execute an association while Systems Manager is executing MaxConcurrency associations, the association is allowed to run. During the next association interval, the new instance will process its association within the limit specified for MaxConcurrency.</p>
-- Required key: Name
-- @return CreateAssociationRequest structure as a key-value pair table
function M.CreateAssociationRequest(args)
	assert(args, "You must provide an argument table when creating CreateAssociationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxErrors"] = args["MaxErrors"],
		["ScheduleExpression"] = args["ScheduleExpression"],
		["OutputLocation"] = args["OutputLocation"],
		["Name"] = args["Name"],
		["Parameters"] = args["Parameters"],
		["InstanceId"] = args["InstanceId"],
		["DocumentVersion"] = args["DocumentVersion"],
		["AssociationName"] = args["AssociationName"],
		["Targets"] = args["Targets"],
		["ComplianceSeverity"] = args["ComplianceSeverity"],
		["MaxConcurrency"] = args["MaxConcurrency"],
	}
	asserts.AssertCreateAssociationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowTargetsResult = { ["NextToken"] = true, ["Targets"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowTargetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowTargetsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Targets"] then asserts.AssertMaintenanceWindowTargetList(struct["Targets"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowTargetsResult[k], "DescribeMaintenanceWindowTargetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowTargetsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * Targets [MaintenanceWindowTargetList] <p>Information about the targets in the Maintenance Window.</p>
-- @return DescribeMaintenanceWindowTargetsResult structure as a key-value pair table
function M.DescribeMaintenanceWindowTargetsResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowTargetsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Targets"] = args["Targets"],
	}
	asserts.AssertDescribeMaintenanceWindowTargetsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePatchGroupStateResult = { ["InstancesWithNotApplicablePatches"] = true, ["InstancesWithMissingPatches"] = true, ["InstancesWithFailedPatches"] = true, ["InstancesWithInstalledOtherPatches"] = true, ["Instances"] = true, ["InstancesWithInstalledRejectedPatches"] = true, ["InstancesWithInstalledPatches"] = true, nil }

function asserts.AssertDescribePatchGroupStateResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePatchGroupStateResult to be of type 'table'")
	if struct["InstancesWithNotApplicablePatches"] then asserts.AssertInteger(struct["InstancesWithNotApplicablePatches"]) end
	if struct["InstancesWithMissingPatches"] then asserts.AssertInteger(struct["InstancesWithMissingPatches"]) end
	if struct["InstancesWithFailedPatches"] then asserts.AssertInteger(struct["InstancesWithFailedPatches"]) end
	if struct["InstancesWithInstalledOtherPatches"] then asserts.AssertInteger(struct["InstancesWithInstalledOtherPatches"]) end
	if struct["Instances"] then asserts.AssertInteger(struct["Instances"]) end
	if struct["InstancesWithInstalledRejectedPatches"] then asserts.AssertInstancesCount(struct["InstancesWithInstalledRejectedPatches"]) end
	if struct["InstancesWithInstalledPatches"] then asserts.AssertInteger(struct["InstancesWithInstalledPatches"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePatchGroupStateResult[k], "DescribePatchGroupStateResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePatchGroupStateResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstancesWithNotApplicablePatches [Integer] <p>The number of instances with patches that aren't applicable.</p>
-- * InstancesWithMissingPatches [Integer] <p>The number of instances with missing patches from the patch baseline.</p>
-- * InstancesWithFailedPatches [Integer] <p>The number of instances with patches from the patch baseline that failed to install.</p>
-- * InstancesWithInstalledOtherPatches [Integer] <p>The number of instances with patches installed that aren't defined in the patch baseline.</p>
-- * Instances [Integer] <p>The number of instances in the patch group.</p>
-- * InstancesWithInstalledRejectedPatches [InstancesCount] <p>The number of instances with patches installed that are specified in a RejectedPatches list. Patches with a status of <i>INSTALLED_REJECTED</i> were typically installed before they were added to a RejectedPatches list.</p> <note> <p>If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstancesWithInstalledRejectedPatches will always be 0 (zero).</p> </note>
-- * InstancesWithInstalledPatches [Integer] <p>The number of instances with installed patches.</p>
-- @return DescribePatchGroupStateResult structure as a key-value pair table
function M.DescribePatchGroupStateResult(args)
	assert(args, "You must provide an argument table when creating DescribePatchGroupStateResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstancesWithNotApplicablePatches"] = args["InstancesWithNotApplicablePatches"],
		["InstancesWithMissingPatches"] = args["InstancesWithMissingPatches"],
		["InstancesWithFailedPatches"] = args["InstancesWithFailedPatches"],
		["InstancesWithInstalledOtherPatches"] = args["InstancesWithInstalledOtherPatches"],
		["Instances"] = args["Instances"],
		["InstancesWithInstalledRejectedPatches"] = args["InstancesWithInstalledRejectedPatches"],
		["InstancesWithInstalledPatches"] = args["InstancesWithInstalledPatches"],
	}
	asserts.AssertDescribePatchGroupStateResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationExecutionTargetsFilter = { ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertAssociationExecutionTargetsFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationExecutionTargetsFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Value"], "Expected key Value to exist in table")
	if struct["Value"] then asserts.AssertAssociationExecutionTargetsFilterValue(struct["Value"]) end
	if struct["Key"] then asserts.AssertAssociationExecutionTargetsFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationExecutionTargetsFilter[k], "AssociationExecutionTargetsFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationExecutionTargetsFilter
-- <p>Filters for the association execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [AssociationExecutionTargetsFilterValue] <p>The value specified for the key.</p>
-- * Key [AssociationExecutionTargetsFilterKey] <p>The key value used in the request.</p>
-- Required key: Key
-- Required key: Value
-- @return AssociationExecutionTargetsFilter structure as a key-value pair table
function M.AssociationExecutionTargetsFilter(args)
	assert(args, "You must provide an argument table when creating AssociationExecutionTargetsFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Value"] = args["Value"],
		["Key"] = args["Key"],
	}
	asserts.AssertAssociationExecutionTargetsFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResumeSessionResponse = { ["SessionId"] = true, ["TokenValue"] = true, ["StreamUrl"] = true, nil }

function asserts.AssertResumeSessionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResumeSessionResponse to be of type 'table'")
	if struct["SessionId"] then asserts.AssertSessionId(struct["SessionId"]) end
	if struct["TokenValue"] then asserts.AssertTokenValue(struct["TokenValue"]) end
	if struct["StreamUrl"] then asserts.AssertStreamUrl(struct["StreamUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResumeSessionResponse[k], "ResumeSessionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResumeSessionResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SessionId [SessionId] <p>The ID of the session.</p>
-- * TokenValue [TokenValue] <p>An encrypted token value containing session and caller information. Used to authenticate the connection to the instance.</p>
-- * StreamUrl [StreamUrl] <p>A URL back to SSM Agent on the instance that the Session Manager client uses to send commands and receive output from the instance. Format: <code>wss://ssm-messages.<b>region</b>.amazonaws.com/v1/data-channel/<b>session-id</b>?stream=(input|output)</code>.</p> <p> <b>region</b> represents the Region identifier for an AWS Region supported by AWS Systems Manager, such as <code>us-east-2</code> for the US East (Ohio) Region. For a list of supported <b>region</b> values, see the <b>Region</b> column in the <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html#ssm_region">AWS Systems Manager table of regions and endpoints</a> in the <i>AWS General Reference</i>.</p> <p> <b>session-id</b> represents the ID of a Session Manager session, such as <code>1a2b3c4dEXAMPLE</code>.</p>
-- @return ResumeSessionResponse structure as a key-value pair table
function M.ResumeSessionResponse(args)
	assert(args, "You must provide an argument table when creating ResumeSessionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SessionId"] = args["SessionId"],
		["TokenValue"] = args["TokenValue"],
		["StreamUrl"] = args["StreamUrl"],
	}
	asserts.AssertResumeSessionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteResourceDataSyncRequest = { ["SyncName"] = true, nil }

function asserts.AssertDeleteResourceDataSyncRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteResourceDataSyncRequest to be of type 'table'")
	assert(struct["SyncName"], "Expected key SyncName to exist in table")
	if struct["SyncName"] then asserts.AssertResourceDataSyncName(struct["SyncName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteResourceDataSyncRequest[k], "DeleteResourceDataSyncRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteResourceDataSyncRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SyncName [ResourceDataSyncName] <p>The name of the configuration to delete.</p>
-- Required key: SyncName
-- @return DeleteResourceDataSyncRequest structure as a key-value pair table
function M.DeleteResourceDataSyncRequest(args)
	assert(args, "You must provide an argument table when creating DeleteResourceDataSyncRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SyncName"] = args["SyncName"],
	}
	asserts.AssertDeleteResourceDataSyncRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LabelParameterVersionResult = { ["InvalidLabels"] = true, nil }

function asserts.AssertLabelParameterVersionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LabelParameterVersionResult to be of type 'table'")
	if struct["InvalidLabels"] then asserts.AssertParameterLabelList(struct["InvalidLabels"]) end
	for k,_ in pairs(struct) do
		assert(keys.LabelParameterVersionResult[k], "LabelParameterVersionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LabelParameterVersionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InvalidLabels [ParameterLabelList] <p>The label does not meet the requirements. For information about parameter label requirements, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-paramstore-labels.html">Labeling Parameters</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- @return LabelParameterVersionResult structure as a key-value pair table
function M.LabelParameterVersionResult(args)
	assert(args, "You must provide an argument table when creating LabelParameterVersionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InvalidLabels"] = args["InvalidLabels"],
	}
	asserts.AssertLabelParameterVersionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteParameterRequest = { ["Name"] = true, nil }

function asserts.AssertDeleteParameterRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteParameterRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteParameterRequest[k], "DeleteParameterRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteParameterRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [PSParameterName] <p>The name of the parameter to delete.</p>
-- Required key: Name
-- @return DeleteParameterRequest structure as a key-value pair table
function M.DeleteParameterRequest(args)
	assert(args, "You must provide an argument table when creating DeleteParameterRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
	}
	asserts.AssertDeleteParameterRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ParameterMetadata = { ["KeyId"] = true, ["Name"] = true, ["LastModifiedDate"] = true, ["AllowedPattern"] = true, ["Version"] = true, ["LastModifiedUser"] = true, ["Type"] = true, ["Description"] = true, nil }

function asserts.AssertParameterMetadata(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ParameterMetadata to be of type 'table'")
	if struct["KeyId"] then asserts.AssertParameterKeyId(struct["KeyId"]) end
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	if struct["LastModifiedDate"] then asserts.AssertDateTime(struct["LastModifiedDate"]) end
	if struct["AllowedPattern"] then asserts.AssertAllowedPattern(struct["AllowedPattern"]) end
	if struct["Version"] then asserts.AssertPSParameterVersion(struct["Version"]) end
	if struct["LastModifiedUser"] then asserts.AssertString(struct["LastModifiedUser"]) end
	if struct["Type"] then asserts.AssertParameterType(struct["Type"]) end
	if struct["Description"] then asserts.AssertParameterDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ParameterMetadata[k], "ParameterMetadata contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ParameterMetadata
-- <p>Metada includes information like the ARN of the last user and the date/time the parameter was last used.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyId [ParameterKeyId] <p>The ID of the query key used for this parameter.</p>
-- * Name [PSParameterName] <p>The parameter name.</p>
-- * LastModifiedDate [DateTime] <p>Date the parameter was last changed or updated.</p>
-- * AllowedPattern [AllowedPattern] <p>A parameter name can include only the following letters and symbols.</p> <p>a-zA-Z0-9_.-</p>
-- * Version [PSParameterVersion] <p>The parameter version.</p>
-- * LastModifiedUser [String] <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
-- * Type [ParameterType] <p>The type of parameter. Valid parameter types include the following: String, String list, Secure string.</p>
-- * Description [ParameterDescription] <p>Description of the parameter actions.</p>
-- @return ParameterMetadata structure as a key-value pair table
function M.ParameterMetadata(args)
	assert(args, "You must provide an argument table when creating ParameterMetadata")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyId"] = args["KeyId"],
		["Name"] = args["Name"],
		["LastModifiedDate"] = args["LastModifiedDate"],
		["AllowedPattern"] = args["AllowedPattern"],
		["Version"] = args["Version"],
		["LastModifiedUser"] = args["LastModifiedUser"],
		["Type"] = args["Type"],
		["Description"] = args["Description"],
	}
	asserts.AssertParameterMetadata(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceAssociation = { ["InstanceId"] = true, ["Content"] = true, ["AssociationId"] = true, ["AssociationVersion"] = true, nil }

function asserts.AssertInstanceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAssociation to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["Content"] then asserts.AssertDocumentContent(struct["Content"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAssociation[k], "InstanceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAssociation
-- <p>One or more association documents on the instance. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The instance ID.</p>
-- * Content [DocumentContent] <p>The content of the association document for the instance(s).</p>
-- * AssociationId [AssociationId] <p>The association ID.</p>
-- * AssociationVersion [AssociationVersion] <p>Version information for the association on the instance.</p>
-- @return InstanceAssociation structure as a key-value pair table
function M.InstanceAssociation(args)
	assert(args, "You must provide an argument table when creating InstanceAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Content"] = args["Content"],
		["AssociationId"] = args["AssociationId"],
		["AssociationVersion"] = args["AssociationVersion"],
	}
	asserts.AssertInstanceAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowExecutionTasksResult = { ["WindowExecutionTaskIdentities"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowExecutionTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowExecutionTasksResult to be of type 'table'")
	if struct["WindowExecutionTaskIdentities"] then asserts.AssertMaintenanceWindowExecutionTaskIdentityList(struct["WindowExecutionTaskIdentities"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowExecutionTasksResult[k], "DescribeMaintenanceWindowExecutionTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowExecutionTasksResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowExecutionTaskIdentities [MaintenanceWindowExecutionTaskIdentityList] <p>Information about the task executions.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeMaintenanceWindowExecutionTasksResult structure as a key-value pair table
function M.DescribeMaintenanceWindowExecutionTasksResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowExecutionTasksResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowExecutionTaskIdentities"] = args["WindowExecutionTaskIdentities"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMaintenanceWindowExecutionTasksResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAvailablePatchesResult = { ["NextToken"] = true, ["Patches"] = true, nil }

function asserts.AssertDescribeAvailablePatchesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailablePatchesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Patches"] then asserts.AssertPatchList(struct["Patches"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailablePatchesResult[k], "DescribeAvailablePatchesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailablePatchesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * Patches [PatchList] <p>An array of patches. Each entry in the array is a patch structure.</p>
-- @return DescribeAvailablePatchesResult structure as a key-value pair table
function M.DescribeAvailablePatchesResult(args)
	assert(args, "You must provide an argument table when creating DescribeAvailablePatchesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Patches"] = args["Patches"],
	}
	asserts.AssertDescribeAvailablePatchesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterPatchBaselineForPatchGroupRequest = { ["PatchGroup"] = true, ["BaselineId"] = true, nil }

function asserts.AssertRegisterPatchBaselineForPatchGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterPatchBaselineForPatchGroupRequest to be of type 'table'")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	assert(struct["PatchGroup"], "Expected key PatchGroup to exist in table")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterPatchBaselineForPatchGroupRequest[k], "RegisterPatchBaselineForPatchGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterPatchBaselineForPatchGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group that should be registered with the patch baseline.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline to register the patch group with.</p>
-- Required key: BaselineId
-- Required key: PatchGroup
-- @return RegisterPatchBaselineForPatchGroupRequest structure as a key-value pair table
function M.RegisterPatchBaselineForPatchGroupRequest(args)
	assert(args, "You must provide an argument table when creating RegisterPatchBaselineForPatchGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertRegisterPatchBaselineForPatchGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeletePatchBaselineResult = { ["BaselineId"] = true, nil }

function asserts.AssertDeletePatchBaselineResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePatchBaselineResult to be of type 'table'")
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeletePatchBaselineResult[k], "DeletePatchBaselineResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePatchBaselineResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineId [BaselineId] <p>The ID of the deleted patch baseline.</p>
-- @return DeletePatchBaselineResult structure as a key-value pair table
function M.DeletePatchBaselineResult(args)
	assert(args, "You must provide an argument table when creating DeletePatchBaselineResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertDeletePatchBaselineResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StepExecution = { ["ValidNextSteps"] = true, ["Inputs"] = true, ["TimeoutSeconds"] = true, ["OnFailure"] = true, ["Outputs"] = true, ["IsEnd"] = true, ["StepName"] = true, ["FailureMessage"] = true, ["ExecutionEndTime"] = true, ["StepExecutionId"] = true, ["NextStep"] = true, ["MaxAttempts"] = true, ["FailureDetails"] = true, ["ResponseCode"] = true, ["ExecutionStartTime"] = true, ["Action"] = true, ["IsCritical"] = true, ["OverriddenParameters"] = true, ["Response"] = true, ["StepStatus"] = true, nil }

function asserts.AssertStepExecution(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StepExecution to be of type 'table'")
	if struct["ValidNextSteps"] then asserts.AssertValidNextStepList(struct["ValidNextSteps"]) end
	if struct["Inputs"] then asserts.AssertNormalStringMap(struct["Inputs"]) end
	if struct["TimeoutSeconds"] then asserts.AssertLong(struct["TimeoutSeconds"]) end
	if struct["OnFailure"] then asserts.AssertString(struct["OnFailure"]) end
	if struct["Outputs"] then asserts.AssertAutomationParameterMap(struct["Outputs"]) end
	if struct["IsEnd"] then asserts.AssertBoolean(struct["IsEnd"]) end
	if struct["StepName"] then asserts.AssertString(struct["StepName"]) end
	if struct["FailureMessage"] then asserts.AssertString(struct["FailureMessage"]) end
	if struct["ExecutionEndTime"] then asserts.AssertDateTime(struct["ExecutionEndTime"]) end
	if struct["StepExecutionId"] then asserts.AssertString(struct["StepExecutionId"]) end
	if struct["NextStep"] then asserts.AssertString(struct["NextStep"]) end
	if struct["MaxAttempts"] then asserts.AssertInteger(struct["MaxAttempts"]) end
	if struct["FailureDetails"] then asserts.AssertFailureDetails(struct["FailureDetails"]) end
	if struct["ResponseCode"] then asserts.AssertString(struct["ResponseCode"]) end
	if struct["ExecutionStartTime"] then asserts.AssertDateTime(struct["ExecutionStartTime"]) end
	if struct["Action"] then asserts.AssertAutomationActionName(struct["Action"]) end
	if struct["IsCritical"] then asserts.AssertBoolean(struct["IsCritical"]) end
	if struct["OverriddenParameters"] then asserts.AssertAutomationParameterMap(struct["OverriddenParameters"]) end
	if struct["Response"] then asserts.AssertString(struct["Response"]) end
	if struct["StepStatus"] then asserts.AssertAutomationExecutionStatus(struct["StepStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.StepExecution[k], "StepExecution contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StepExecution
-- <p>Detailed information about an the execution state of an Automation step.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ValidNextSteps [ValidNextStepList] <p>Strategies used when step fails, we support Continue and Abort. Abort will fail the automation when the step fails. Continue will ignore the failure of current step and allow automation to execute the next step. With conditional branching, we add step:stepName to support the automation to go to another specific step.</p>
-- * Inputs [NormalStringMap] <p>Fully-resolved values passed into the step before execution.</p>
-- * TimeoutSeconds [Long] <p>The timeout seconds of the step.</p>
-- * OnFailure [String] <p>The action to take if the step fails. The default value is Abort.</p>
-- * Outputs [AutomationParameterMap] <p>Returned values from the execution of the step.</p>
-- * IsEnd [Boolean] <p>The flag which can be used to end automation no matter whether the step succeeds or fails.</p>
-- * StepName [String] <p>The name of this execution step.</p>
-- * FailureMessage [String] <p>If a step failed, this message explains why the execution failed.</p>
-- * ExecutionEndTime [DateTime] <p>If a step has finished execution, this contains the time the execution ended. If the step has not yet concluded, this field is not populated.</p>
-- * StepExecutionId [String] <p>The unique ID of a step execution.</p>
-- * NextStep [String] <p>The next step after the step succeeds.</p>
-- * MaxAttempts [Integer] <p>The maximum number of tries to run the action of the step. The default value is 1.</p>
-- * FailureDetails [FailureDetails] <p>Information about the Automation failure.</p>
-- * ResponseCode [String] <p>The response code returned by the execution of the step.</p>
-- * ExecutionStartTime [DateTime] <p>If a step has begun execution, this contains the time the step started. If the step is in Pending status, this field is not populated.</p>
-- * Action [AutomationActionName] <p>The action this step performs. The action determines the behavior of the step.</p>
-- * IsCritical [Boolean] <p>The flag which can be used to help decide whether the failure of current step leads to the Automation failure.</p>
-- * OverriddenParameters [AutomationParameterMap] <p>A user-specified list of parameters to override when executing a step.</p>
-- * Response [String] <p>A message associated with the response code for an execution.</p>
-- * StepStatus [AutomationExecutionStatus] <p>The execution status for this step. Valid values include: Pending, InProgress, Success, Cancelled, Failed, and TimedOut.</p>
-- @return StepExecution structure as a key-value pair table
function M.StepExecution(args)
	assert(args, "You must provide an argument table when creating StepExecution")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ValidNextSteps"] = args["ValidNextSteps"],
		["Inputs"] = args["Inputs"],
		["TimeoutSeconds"] = args["TimeoutSeconds"],
		["OnFailure"] = args["OnFailure"],
		["Outputs"] = args["Outputs"],
		["IsEnd"] = args["IsEnd"],
		["StepName"] = args["StepName"],
		["FailureMessage"] = args["FailureMessage"],
		["ExecutionEndTime"] = args["ExecutionEndTime"],
		["StepExecutionId"] = args["StepExecutionId"],
		["NextStep"] = args["NextStep"],
		["MaxAttempts"] = args["MaxAttempts"],
		["FailureDetails"] = args["FailureDetails"],
		["ResponseCode"] = args["ResponseCode"],
		["ExecutionStartTime"] = args["ExecutionStartTime"],
		["Action"] = args["Action"],
		["IsCritical"] = args["IsCritical"],
		["OverriddenParameters"] = args["OverriddenParameters"],
		["Response"] = args["Response"],
		["StepStatus"] = args["StepStatus"],
	}
	asserts.AssertStepExecution(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AutomationExecution = { ["AutomationExecutionStatus"] = true, ["AutomationExecutionId"] = true, ["Parameters"] = true, ["DocumentName"] = true, ["MaxErrors"] = true, ["CurrentAction"] = true, ["TargetMaps"] = true, ["MaxConcurrency"] = true, ["StepExecutionsTruncated"] = true, ["Outputs"] = true, ["ExecutionEndTime"] = true, ["ResolvedTargets"] = true, ["ParentAutomationExecutionId"] = true, ["FailureMessage"] = true, ["DocumentVersion"] = true, ["Mode"] = true, ["Target"] = true, ["ExecutionStartTime"] = true, ["CurrentStepName"] = true, ["StepExecutions"] = true, ["ExecutedBy"] = true, ["Targets"] = true, ["TargetParameterName"] = true, nil }

function asserts.AssertAutomationExecution(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AutomationExecution to be of type 'table'")
	if struct["AutomationExecutionStatus"] then asserts.AssertAutomationExecutionStatus(struct["AutomationExecutionStatus"]) end
	if struct["AutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["AutomationExecutionId"]) end
	if struct["Parameters"] then asserts.AssertAutomationParameterMap(struct["Parameters"]) end
	if struct["DocumentName"] then asserts.AssertDocumentName(struct["DocumentName"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["CurrentAction"] then asserts.AssertString(struct["CurrentAction"]) end
	if struct["TargetMaps"] then asserts.AssertTargetMaps(struct["TargetMaps"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["StepExecutionsTruncated"] then asserts.AssertBoolean(struct["StepExecutionsTruncated"]) end
	if struct["Outputs"] then asserts.AssertAutomationParameterMap(struct["Outputs"]) end
	if struct["ExecutionEndTime"] then asserts.AssertDateTime(struct["ExecutionEndTime"]) end
	if struct["ResolvedTargets"] then asserts.AssertResolvedTargets(struct["ResolvedTargets"]) end
	if struct["ParentAutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["ParentAutomationExecutionId"]) end
	if struct["FailureMessage"] then asserts.AssertString(struct["FailureMessage"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["Mode"] then asserts.AssertExecutionMode(struct["Mode"]) end
	if struct["Target"] then asserts.AssertString(struct["Target"]) end
	if struct["ExecutionStartTime"] then asserts.AssertDateTime(struct["ExecutionStartTime"]) end
	if struct["CurrentStepName"] then asserts.AssertString(struct["CurrentStepName"]) end
	if struct["StepExecutions"] then asserts.AssertStepExecutionList(struct["StepExecutions"]) end
	if struct["ExecutedBy"] then asserts.AssertString(struct["ExecutedBy"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["TargetParameterName"] then asserts.AssertAutomationParameterKey(struct["TargetParameterName"]) end
	for k,_ in pairs(struct) do
		assert(keys.AutomationExecution[k], "AutomationExecution contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AutomationExecution
-- <p>Detailed information about the current state of an individual Automation execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutomationExecutionStatus [AutomationExecutionStatus] <p>The execution status of the Automation.</p>
-- * AutomationExecutionId [AutomationExecutionId] <p>The execution ID.</p>
-- * Parameters [AutomationParameterMap] <p>The key-value map of execution parameters, which were supplied when calling StartAutomationExecution.</p>
-- * DocumentName [DocumentName] <p>The name of the Automation document used during the execution.</p>
-- * MaxErrors [MaxErrors] <p>The MaxErrors value specified by the user when the execution started.</p>
-- * CurrentAction [String] <p>The action of the currently executing step.</p>
-- * TargetMaps [TargetMaps] <p>The specified key-value mapping of document parameters to target resources.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The MaxConcurrency value specified by the user when the execution started.</p>
-- * StepExecutionsTruncated [Boolean] <p>A boolean value that indicates if the response contains the full list of the Automation step executions. If true, use the DescribeAutomationStepExecutions API action to get the full list of step executions.</p>
-- * Outputs [AutomationParameterMap] <p>The list of execution outputs as defined in the automation document.</p>
-- * ExecutionEndTime [DateTime] <p>The time the execution finished.</p>
-- * ResolvedTargets [ResolvedTargets] <p>A list of resolved targets in the rate control execution.</p>
-- * ParentAutomationExecutionId [AutomationExecutionId] <p>The AutomationExecutionId of the parent automation.</p>
-- * FailureMessage [String] <p>A message describing why an execution has failed, if the status is set to Failed.</p>
-- * DocumentVersion [DocumentVersion] <p>The version of the document to use during execution.</p>
-- * Mode [ExecutionMode] <p>The automation execution mode.</p>
-- * Target [String] <p>The target of the execution.</p>
-- * ExecutionStartTime [DateTime] <p>The time the execution started.</p>
-- * CurrentStepName [String] <p>The name of the currently executing step.</p>
-- * StepExecutions [StepExecutionList] <p>A list of details about the current state of all steps that comprise an execution. An Automation document contains a list of steps that are executed in order.</p>
-- * ExecutedBy [String] <p>The Amazon Resource Name (ARN) of the user who executed the automation.</p>
-- * Targets [Targets] <p>The specified targets.</p>
-- * TargetParameterName [AutomationParameterKey] <p>The parameter name.</p>
-- @return AutomationExecution structure as a key-value pair table
function M.AutomationExecution(args)
	assert(args, "You must provide an argument table when creating AutomationExecution")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutomationExecutionStatus"] = args["AutomationExecutionStatus"],
		["AutomationExecutionId"] = args["AutomationExecutionId"],
		["Parameters"] = args["Parameters"],
		["DocumentName"] = args["DocumentName"],
		["MaxErrors"] = args["MaxErrors"],
		["CurrentAction"] = args["CurrentAction"],
		["TargetMaps"] = args["TargetMaps"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["StepExecutionsTruncated"] = args["StepExecutionsTruncated"],
		["Outputs"] = args["Outputs"],
		["ExecutionEndTime"] = args["ExecutionEndTime"],
		["ResolvedTargets"] = args["ResolvedTargets"],
		["ParentAutomationExecutionId"] = args["ParentAutomationExecutionId"],
		["FailureMessage"] = args["FailureMessage"],
		["DocumentVersion"] = args["DocumentVersion"],
		["Mode"] = args["Mode"],
		["Target"] = args["Target"],
		["ExecutionStartTime"] = args["ExecutionStartTime"],
		["CurrentStepName"] = args["CurrentStepName"],
		["StepExecutions"] = args["StepExecutions"],
		["ExecutedBy"] = args["ExecutedBy"],
		["Targets"] = args["Targets"],
		["TargetParameterName"] = args["TargetParameterName"],
	}
	asserts.AssertAutomationExecution(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePatchBaselinesRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribePatchBaselinesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePatchBaselinesRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertPatchBaselineMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertPatchOrchestratorFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePatchBaselinesRequest[k], "DescribePatchBaselinesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePatchBaselinesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [PatchBaselineMaxResults] <p>The maximum number of patch baselines to return (per page).</p>
-- * Filters [PatchOrchestratorFilterList] <p>Each element in the array is a structure containing: </p> <p>Key: (string, "NAME_PREFIX" or "OWNER")</p> <p>Value: (array of strings, exactly 1 entry, between 1 and 255 characters)</p>
-- @return DescribePatchBaselinesRequest structure as a key-value pair table
function M.DescribePatchBaselinesRequest(args)
	assert(args, "You must provide an argument table when creating DescribePatchBaselinesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribePatchBaselinesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationExecutionTarget = { ["Status"] = true, ["DetailedStatus"] = true, ["LastExecutionDate"] = true, ["ResourceType"] = true, ["ResourceId"] = true, ["AssociationId"] = true, ["OutputSource"] = true, ["ExecutionId"] = true, ["AssociationVersion"] = true, nil }

function asserts.AssertAssociationExecutionTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationExecutionTarget to be of type 'table'")
	if struct["Status"] then asserts.AssertStatusName(struct["Status"]) end
	if struct["DetailedStatus"] then asserts.AssertStatusName(struct["DetailedStatus"]) end
	if struct["LastExecutionDate"] then asserts.AssertDateTime(struct["LastExecutionDate"]) end
	if struct["ResourceType"] then asserts.AssertAssociationResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertAssociationResourceId(struct["ResourceId"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["OutputSource"] then asserts.AssertOutputSource(struct["OutputSource"]) end
	if struct["ExecutionId"] then asserts.AssertAssociationExecutionId(struct["ExecutionId"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationExecutionTarget[k], "AssociationExecutionTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationExecutionTarget
-- <p>Includes information about the specified association execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [StatusName] <p>The association execution status.</p>
-- * DetailedStatus [StatusName] <p>Detailed information about the execution status.</p>
-- * LastExecutionDate [DateTime] <p>The date of the last execution.</p>
-- * ResourceType [AssociationResourceType] <p>The resource type, for example, instance.</p>
-- * ResourceId [AssociationResourceId] <p>The resource ID, for example, the instance ID where the association ran.</p>
-- * AssociationId [AssociationId] <p>The association ID.</p>
-- * OutputSource [OutputSource] <p>The location where the association details are saved.</p>
-- * ExecutionId [AssociationExecutionId] <p>The execution ID. If the association does not run at intervals or according to a schedule, then the ExecutionID is the same as the AssociationID.</p>
-- * AssociationVersion [AssociationVersion] <p>The association version.</p>
-- @return AssociationExecutionTarget structure as a key-value pair table
function M.AssociationExecutionTarget(args)
	assert(args, "You must provide an argument table when creating AssociationExecutionTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DetailedStatus"] = args["DetailedStatus"],
		["LastExecutionDate"] = args["LastExecutionDate"],
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["AssociationId"] = args["AssociationId"],
		["OutputSource"] = args["OutputSource"],
		["ExecutionId"] = args["ExecutionId"],
		["AssociationVersion"] = args["AssociationVersion"],
	}
	asserts.AssertAssociationExecutionTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowScheduleResult = { ["ScheduledWindowExecutions"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowScheduleResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowScheduleResult to be of type 'table'")
	if struct["ScheduledWindowExecutions"] then asserts.AssertScheduledWindowExecutionList(struct["ScheduledWindowExecutions"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowScheduleResult[k], "DescribeMaintenanceWindowScheduleResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowScheduleResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduledWindowExecutions [ScheduledWindowExecutionList] <p>Information about Maintenance Window executions scheduled for the specified time range.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You use this token in the next call.)</p>
-- @return DescribeMaintenanceWindowScheduleResult structure as a key-value pair table
function M.DescribeMaintenanceWindowScheduleResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowScheduleResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ScheduledWindowExecutions"] = args["ScheduledWindowExecutions"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMaintenanceWindowScheduleResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeActivationsResult = { ["NextToken"] = true, ["ActivationList"] = true, nil }

function asserts.AssertDescribeActivationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeActivationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["ActivationList"] then asserts.AssertActivationList(struct["ActivationList"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeActivationsResult[k], "DescribeActivationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeActivationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results. </p>
-- * ActivationList [ActivationList] <p>A list of activations for your AWS account.</p>
-- @return DescribeActivationsResult structure as a key-value pair table
function M.DescribeActivationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeActivationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ActivationList"] = args["ActivationList"],
	}
	asserts.AssertDescribeActivationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartAutomationExecutionResult = { ["AutomationExecutionId"] = true, nil }

function asserts.AssertStartAutomationExecutionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartAutomationExecutionResult to be of type 'table'")
	if struct["AutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["AutomationExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartAutomationExecutionResult[k], "StartAutomationExecutionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartAutomationExecutionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutomationExecutionId [AutomationExecutionId] <p>The unique ID of a newly scheduled automation execution.</p>
-- @return StartAutomationExecutionResult structure as a key-value pair table
function M.StartAutomationExecutionResult(args)
	assert(args, "You must provide an argument table when creating StartAutomationExecutionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutomationExecutionId"] = args["AutomationExecutionId"],
	}
	asserts.AssertStartAutomationExecutionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListDocumentVersionsResult = { ["DocumentVersions"] = true, ["NextToken"] = true, nil }

function asserts.AssertListDocumentVersionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListDocumentVersionsResult to be of type 'table'")
	if struct["DocumentVersions"] then asserts.AssertDocumentVersionList(struct["DocumentVersions"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListDocumentVersionsResult[k], "ListDocumentVersionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListDocumentVersionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DocumentVersions [DocumentVersionList] <p>The document versions.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return ListDocumentVersionsResult structure as a key-value pair table
function M.ListDocumentVersionsResult(args)
	assert(args, "You must provide an argument table when creating ListDocumentVersionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DocumentVersions"] = args["DocumentVersions"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertListDocumentVersionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryGroup = { ["Name"] = true, ["Filters"] = true, nil }

function asserts.AssertInventoryGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryGroup to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["Filters"], "Expected key Filters to exist in table")
	if struct["Name"] then asserts.AssertInventoryGroupName(struct["Name"]) end
	if struct["Filters"] then asserts.AssertInventoryFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryGroup[k], "InventoryGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryGroup
-- <p>A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [InventoryGroupName] <p>The name of the group.</p>
-- * Filters [InventoryFilterList] <p>Filters define the criteria for the group. The <code>matchingCount</code> field displays the number of resources that match the criteria. The <code>notMatchingCount</code> field displays the number of resources that don't match the criteria. </p>
-- Required key: Name
-- Required key: Filters
-- @return InventoryGroup structure as a key-value pair table
function M.InventoryGroup(args)
	assert(args, "You must provide an argument table when creating InventoryGroup")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertInventoryGroup(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEffectivePatchesForPatchBaselineRequest = { ["NextToken"] = true, ["BaselineId"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeEffectivePatchesForPatchBaselineRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEffectivePatchesForPatchBaselineRequest to be of type 'table'")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["MaxResults"] then asserts.AssertPatchBaselineMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEffectivePatchesForPatchBaselineRequest[k], "DescribeEffectivePatchesForPatchBaselineRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEffectivePatchesForPatchBaselineRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline to retrieve the effective patches for.</p>
-- * MaxResults [PatchBaselineMaxResults] <p>The maximum number of patches to return (per page).</p>
-- Required key: BaselineId
-- @return DescribeEffectivePatchesForPatchBaselineRequest structure as a key-value pair table
function M.DescribeEffectivePatchesForPatchBaselineRequest(args)
	assert(args, "You must provide an argument table when creating DescribeEffectivePatchesForPatchBaselineRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["BaselineId"] = args["BaselineId"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeEffectivePatchesForPatchBaselineRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Activation = { ["IamRole"] = true, ["RegistrationLimit"] = true, ["Description"] = true, ["ActivationId"] = true, ["RegistrationsCount"] = true, ["CreatedDate"] = true, ["DefaultInstanceName"] = true, ["Expired"] = true, ["ExpirationDate"] = true, nil }

function asserts.AssertActivation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Activation to be of type 'table'")
	if struct["IamRole"] then asserts.AssertIamRole(struct["IamRole"]) end
	if struct["RegistrationLimit"] then asserts.AssertRegistrationLimit(struct["RegistrationLimit"]) end
	if struct["Description"] then asserts.AssertActivationDescription(struct["Description"]) end
	if struct["ActivationId"] then asserts.AssertActivationId(struct["ActivationId"]) end
	if struct["RegistrationsCount"] then asserts.AssertRegistrationsCount(struct["RegistrationsCount"]) end
	if struct["CreatedDate"] then asserts.AssertCreatedDate(struct["CreatedDate"]) end
	if struct["DefaultInstanceName"] then asserts.AssertDefaultInstanceName(struct["DefaultInstanceName"]) end
	if struct["Expired"] then asserts.AssertBoolean(struct["Expired"]) end
	if struct["ExpirationDate"] then asserts.AssertExpirationDate(struct["ExpirationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.Activation[k], "Activation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Activation
-- <p>An activation registers one or more on-premises servers or virtual machines (VMs) with AWS so that you can configure those servers or VMs using Run Command. A server or VM that has been registered with AWS is called a managed instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamRole [IamRole] <p>The Amazon Identity and Access Management (IAM) role to assign to the managed instance.</p>
-- * RegistrationLimit [RegistrationLimit] <p>The maximum number of managed instances that can be registered using this activation.</p>
-- * Description [ActivationDescription] <p>A user defined description of the activation.</p>
-- * ActivationId [ActivationId] <p>The ID created by Systems Manager when you submitted the activation.</p>
-- * RegistrationsCount [RegistrationsCount] <p>The number of managed instances already registered with this activation.</p>
-- * CreatedDate [CreatedDate] <p>The date the activation was created.</p>
-- * DefaultInstanceName [DefaultInstanceName] <p>A name for the managed instance when it is created.</p>
-- * Expired [Boolean] <p>Whether or not the activation is expired.</p>
-- * ExpirationDate [ExpirationDate] <p>The date when this activation can no longer be used to register managed instances.</p>
-- @return Activation structure as a key-value pair table
function M.Activation(args)
	assert(args, "You must provide an argument table when creating Activation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IamRole"] = args["IamRole"],
		["RegistrationLimit"] = args["RegistrationLimit"],
		["Description"] = args["Description"],
		["ActivationId"] = args["ActivationId"],
		["RegistrationsCount"] = args["RegistrationsCount"],
		["CreatedDate"] = args["CreatedDate"],
		["DefaultInstanceName"] = args["DefaultInstanceName"],
		["Expired"] = args["Expired"],
		["ExpirationDate"] = args["ExpirationDate"],
	}
	asserts.AssertActivation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SendCommandResult = { ["Command"] = true, nil }

function asserts.AssertSendCommandResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SendCommandResult to be of type 'table'")
	if struct["Command"] then asserts.AssertCommand(struct["Command"]) end
	for k,_ in pairs(struct) do
		assert(keys.SendCommandResult[k], "SendCommandResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SendCommandResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Command [Command] <p>The request as it was received by Systems Manager. Also provides the command ID which can be used future references to this request.</p>
-- @return SendCommandResult structure as a key-value pair table
function M.SendCommandResult(args)
	assert(args, "You must provide an argument table when creating SendCommandResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Command"] = args["Command"],
	}
	asserts.AssertSendCommandResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DocumentVersionInfo = { ["IsDefaultVersion"] = true, ["DocumentFormat"] = true, ["Name"] = true, ["DocumentVersion"] = true, ["CreatedDate"] = true, nil }

function asserts.AssertDocumentVersionInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DocumentVersionInfo to be of type 'table'")
	if struct["IsDefaultVersion"] then asserts.AssertBoolean(struct["IsDefaultVersion"]) end
	if struct["DocumentFormat"] then asserts.AssertDocumentFormat(struct["DocumentFormat"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["CreatedDate"] then asserts.AssertDateTime(struct["CreatedDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.DocumentVersionInfo[k], "DocumentVersionInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DocumentVersionInfo
-- <p>Version information about the document.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IsDefaultVersion [Boolean] <p>An identifier for the default version of the document.</p>
-- * DocumentFormat [DocumentFormat] <p>The document format, either JSON or YAML.</p>
-- * Name [DocumentName] <p>The document name.</p>
-- * DocumentVersion [DocumentVersion] <p>The document version.</p>
-- * CreatedDate [DateTime] <p>The date the document was created.</p>
-- @return DocumentVersionInfo structure as a key-value pair table
function M.DocumentVersionInfo(args)
	assert(args, "You must provide an argument table when creating DocumentVersionInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IsDefaultVersion"] = args["IsDefaultVersion"],
		["DocumentFormat"] = args["DocumentFormat"],
		["Name"] = args["Name"],
		["DocumentVersion"] = args["DocumentVersion"],
		["CreatedDate"] = args["CreatedDate"],
	}
	asserts.AssertDocumentVersionInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelMaintenanceWindowExecutionResult = { ["WindowExecutionId"] = true, nil }

function asserts.AssertCancelMaintenanceWindowExecutionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelMaintenanceWindowExecutionResult to be of type 'table'")
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelMaintenanceWindowExecutionResult[k], "CancelMaintenanceWindowExecutionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelMaintenanceWindowExecutionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution that has been stopped.</p>
-- @return CancelMaintenanceWindowExecutionResult structure as a key-value pair table
function M.CancelMaintenanceWindowExecutionResult(args)
	assert(args, "You must provide an argument table when creating CancelMaintenanceWindowExecutionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowExecutionId"] = args["WindowExecutionId"],
	}
	asserts.AssertCancelMaintenanceWindowExecutionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSessionsResponse = { ["NextToken"] = true, ["Sessions"] = true, nil }

function asserts.AssertDescribeSessionsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSessionsResponse to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Sessions"] then asserts.AssertSessionList(struct["Sessions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSessionsResponse[k], "DescribeSessionsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSessionsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * Sessions [SessionList] <p>A list of sessions meeting the request parameters.</p>
-- @return DescribeSessionsResponse structure as a key-value pair table
function M.DescribeSessionsResponse(args)
	assert(args, "You must provide an argument table when creating DescribeSessionsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Sessions"] = args["Sessions"],
	}
	asserts.AssertDescribeSessionsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetInventoryRequest = { ["ResultAttributes"] = true, ["Aggregators"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertGetInventoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetInventoryRequest to be of type 'table'")
	if struct["ResultAttributes"] then asserts.AssertResultAttributeList(struct["ResultAttributes"]) end
	if struct["Aggregators"] then asserts.AssertInventoryAggregatorList(struct["Aggregators"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertInventoryFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetInventoryRequest[k], "GetInventoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetInventoryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResultAttributes [ResultAttributeList] <p>The list of inventory item types to return.</p>
-- * Aggregators [InventoryAggregatorList] <p>Returns counts of inventory types based on one or more expressions. For example, if you aggregate by using an expression that uses the <code>AWS:InstanceInformation.PlatformType</code> type, you can see a count of how many Windows and Linux instances exist in your inventoried fleet.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [InventoryFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- @return GetInventoryRequest structure as a key-value pair table
function M.GetInventoryRequest(args)
	assert(args, "You must provide an argument table when creating GetInventoryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResultAttributes"] = args["ResultAttributes"],
		["Aggregators"] = args["Aggregators"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertGetInventoryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StepExecutionFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertStepExecutionFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StepExecutionFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Values"], "Expected key Values to exist in table")
	if struct["Values"] then asserts.AssertStepExecutionFilterValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertStepExecutionFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.StepExecutionFilter[k], "StepExecutionFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StepExecutionFilter
-- <p>A filter to limit the amount of step execution information returned by the call.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [StepExecutionFilterValueList] <p>The values of the filter key.</p>
-- * Key [StepExecutionFilterKey] <p>One or more keys to limit the results. Valid filter keys include the following: StepName, Action, StepExecutionId, StepExecutionStatus, StartTimeBefore, StartTimeAfter.</p>
-- Required key: Key
-- Required key: Values
-- @return StepExecutionFilter structure as a key-value pair table
function M.StepExecutionFilter(args)
	assert(args, "You must provide an argument table when creating StepExecutionFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertStepExecutionFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateAssociationResult = { ["AssociationDescription"] = true, nil }

function asserts.AssertCreateAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateAssociationResult to be of type 'table'")
	if struct["AssociationDescription"] then asserts.AssertAssociationDescription(struct["AssociationDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateAssociationResult[k], "CreateAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationDescription [AssociationDescription] <p>Information about the association.</p>
-- @return CreateAssociationResult structure as a key-value pair table
function M.CreateAssociationResult(args)
	assert(args, "You must provide an argument table when creating CreateAssociationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationDescription"] = args["AssociationDescription"],
	}
	asserts.AssertCreateAssociationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Patch = { ["ContentUrl"] = true, ["ProductFamily"] = true, ["Product"] = true, ["Vendor"] = true, ["Description"] = true, ["Classification"] = true, ["Title"] = true, ["ReleaseDate"] = true, ["Language"] = true, ["MsrcSeverity"] = true, ["KbNumber"] = true, ["MsrcNumber"] = true, ["Id"] = true, nil }

function asserts.AssertPatch(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Patch to be of type 'table'")
	if struct["ContentUrl"] then asserts.AssertPatchContentUrl(struct["ContentUrl"]) end
	if struct["ProductFamily"] then asserts.AssertPatchProductFamily(struct["ProductFamily"]) end
	if struct["Product"] then asserts.AssertPatchProduct(struct["Product"]) end
	if struct["Vendor"] then asserts.AssertPatchVendor(struct["Vendor"]) end
	if struct["Description"] then asserts.AssertPatchDescription(struct["Description"]) end
	if struct["Classification"] then asserts.AssertPatchClassification(struct["Classification"]) end
	if struct["Title"] then asserts.AssertPatchTitle(struct["Title"]) end
	if struct["ReleaseDate"] then asserts.AssertDateTime(struct["ReleaseDate"]) end
	if struct["Language"] then asserts.AssertPatchLanguage(struct["Language"]) end
	if struct["MsrcSeverity"] then asserts.AssertPatchMsrcSeverity(struct["MsrcSeverity"]) end
	if struct["KbNumber"] then asserts.AssertPatchKbNumber(struct["KbNumber"]) end
	if struct["MsrcNumber"] then asserts.AssertPatchMsrcNumber(struct["MsrcNumber"]) end
	if struct["Id"] then asserts.AssertPatchId(struct["Id"]) end
	for k,_ in pairs(struct) do
		assert(keys.Patch[k], "Patch contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Patch
-- <p>Represents metadata about a patch.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ContentUrl [PatchContentUrl] <p>The URL where more information can be obtained about the patch.</p>
-- * ProductFamily [PatchProductFamily] <p>The product family the patch is applicable for (for example, Windows).</p>
-- * Product [PatchProduct] <p>The specific product the patch is applicable for (for example, WindowsServer2016).</p>
-- * Vendor [PatchVendor] <p>The name of the vendor providing the patch.</p>
-- * Description [PatchDescription] <p>The description of the patch.</p>
-- * Classification [PatchClassification] <p>The classification of the patch (for example, SecurityUpdates, Updates, CriticalUpdates).</p>
-- * Title [PatchTitle] <p>The title of the patch.</p>
-- * ReleaseDate [DateTime] <p>The date the patch was released.</p>
-- * Language [PatchLanguage] <p>The language of the patch if it's language-specific.</p>
-- * MsrcSeverity [PatchMsrcSeverity] <p>The severity of the patch (for example Critical, Important, Moderate).</p>
-- * KbNumber [PatchKbNumber] <p>The Microsoft Knowledge Base ID of the patch.</p>
-- * MsrcNumber [PatchMsrcNumber] <p>The ID of the MSRC bulletin the patch is related to.</p>
-- * Id [PatchId] <p>The ID of the patch (this is different than the Microsoft Knowledge Base ID).</p>
-- @return Patch structure as a key-value pair table
function M.Patch(args)
	assert(args, "You must provide an argument table when creating Patch")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ContentUrl"] = args["ContentUrl"],
		["ProductFamily"] = args["ProductFamily"],
		["Product"] = args["Product"],
		["Vendor"] = args["Vendor"],
		["Description"] = args["Description"],
		["Classification"] = args["Classification"],
		["Title"] = args["Title"],
		["ReleaseDate"] = args["ReleaseDate"],
		["Language"] = args["Language"],
		["MsrcSeverity"] = args["MsrcSeverity"],
		["KbNumber"] = args["KbNumber"],
		["MsrcNumber"] = args["MsrcNumber"],
		["Id"] = args["Id"],
	}
	asserts.AssertPatch(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteAssociationResult = { nil }

function asserts.AssertDeleteAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteAssociationResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteAssociationResult[k], "DeleteAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteAssociationResult structure as a key-value pair table
function M.DeleteAssociationResult(args)
	assert(args, "You must provide an argument table when creating DeleteAssociationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteAssociationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePatchBaselinesResult = { ["NextToken"] = true, ["BaselineIdentities"] = true, nil }

function asserts.AssertDescribePatchBaselinesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePatchBaselinesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["BaselineIdentities"] then asserts.AssertPatchBaselineIdentityList(struct["BaselineIdentities"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePatchBaselinesResult[k], "DescribePatchBaselinesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePatchBaselinesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * BaselineIdentities [PatchBaselineIdentityList] <p>An array of PatchBaselineIdentity elements.</p>
-- @return DescribePatchBaselinesResult structure as a key-value pair table
function M.DescribePatchBaselinesResult(args)
	assert(args, "You must provide an argument table when creating DescribePatchBaselinesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["BaselineIdentities"] = args["BaselineIdentities"],
	}
	asserts.AssertDescribePatchBaselinesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowExecutionsResult = { ["WindowExecutions"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowExecutionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowExecutionsResult to be of type 'table'")
	if struct["WindowExecutions"] then asserts.AssertMaintenanceWindowExecutionList(struct["WindowExecutions"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowExecutionsResult[k], "DescribeMaintenanceWindowExecutionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowExecutionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowExecutions [MaintenanceWindowExecutionList] <p>Information about the Maintenance Windows execution.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeMaintenanceWindowExecutionsResult structure as a key-value pair table
function M.DescribeMaintenanceWindowExecutionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowExecutionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowExecutions"] = args["WindowExecutions"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMaintenanceWindowExecutionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreatePatchBaselineResult = { ["BaselineId"] = true, nil }

function asserts.AssertCreatePatchBaselineResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePatchBaselineResult to be of type 'table'")
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePatchBaselineResult[k], "CreatePatchBaselineResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePatchBaselineResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineId [BaselineId] <p>The ID of the created patch baseline.</p>
-- @return CreatePatchBaselineResult structure as a key-value pair table
function M.CreatePatchBaselineResult(args)
	assert(args, "You must provide an argument table when creating CreatePatchBaselineResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertCreatePatchBaselineResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ComplianceSummaryItem = { ["NonCompliantSummary"] = true, ["CompliantSummary"] = true, ["ComplianceType"] = true, nil }

function asserts.AssertComplianceSummaryItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ComplianceSummaryItem to be of type 'table'")
	if struct["NonCompliantSummary"] then asserts.AssertNonCompliantSummary(struct["NonCompliantSummary"]) end
	if struct["CompliantSummary"] then asserts.AssertCompliantSummary(struct["CompliantSummary"]) end
	if struct["ComplianceType"] then asserts.AssertComplianceTypeName(struct["ComplianceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ComplianceSummaryItem[k], "ComplianceSummaryItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ComplianceSummaryItem
-- <p>A summary of compliance information by compliance type.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NonCompliantSummary [NonCompliantSummary] <p>A list of NON_COMPLIANT items for the specified compliance type.</p>
-- * CompliantSummary [CompliantSummary] <p>A list of COMPLIANT items for the specified compliance type.</p>
-- * ComplianceType [ComplianceTypeName] <p>The type of compliance item. For example, the compliance type can be Association, Patch, or Custom:string.</p>
-- @return ComplianceSummaryItem structure as a key-value pair table
function M.ComplianceSummaryItem(args)
	assert(args, "You must provide an argument table when creating ComplianceSummaryItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NonCompliantSummary"] = args["NonCompliantSummary"],
		["CompliantSummary"] = args["CompliantSummary"],
		["ComplianceType"] = args["ComplianceType"],
	}
	asserts.AssertComplianceSummaryItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListResourceDataSyncResult = { ["NextToken"] = true, ["ResourceDataSyncItems"] = true, nil }

function asserts.AssertListResourceDataSyncResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListResourceDataSyncResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["ResourceDataSyncItems"] then asserts.AssertResourceDataSyncItemList(struct["ResourceDataSyncItems"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListResourceDataSyncResult[k], "ListResourceDataSyncResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListResourceDataSyncResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- * ResourceDataSyncItems [ResourceDataSyncItemList] <p>A list of your current Resource Data Sync configurations and their statuses.</p>
-- @return ListResourceDataSyncResult structure as a key-value pair table
function M.ListResourceDataSyncResult(args)
	assert(args, "You must provide an argument table when creating ListResourceDataSyncResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ResourceDataSyncItems"] = args["ResourceDataSyncItems"],
	}
	asserts.AssertListResourceDataSyncResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchGroupPatchBaselineMapping = { ["PatchGroup"] = true, ["BaselineIdentity"] = true, nil }

function asserts.AssertPatchGroupPatchBaselineMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchGroupPatchBaselineMapping to be of type 'table'")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["BaselineIdentity"] then asserts.AssertPatchBaselineIdentity(struct["BaselineIdentity"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchGroupPatchBaselineMapping[k], "PatchGroupPatchBaselineMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchGroupPatchBaselineMapping
-- <p>The mapping between a patch group and the patch baseline the patch group is registered with.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group registered with the patch baseline.</p>
-- * BaselineIdentity [PatchBaselineIdentity] <p>The patch baseline the patch group is registered with.</p>
-- @return PatchGroupPatchBaselineMapping structure as a key-value pair table
function M.PatchGroupPatchBaselineMapping(args)
	assert(args, "You must provide an argument table when creating PatchGroupPatchBaselineMapping")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["BaselineIdentity"] = args["BaselineIdentity"],
	}
	asserts.AssertPatchGroupPatchBaselineMapping(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StopAutomationExecutionResult = { nil }

function asserts.AssertStopAutomationExecutionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopAutomationExecutionResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.StopAutomationExecutionResult[k], "StopAutomationExecutionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopAutomationExecutionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return StopAutomationExecutionResult structure as a key-value pair table
function M.StopAutomationExecutionResult(args)
	assert(args, "You must provide an argument table when creating StopAutomationExecutionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertStopAutomationExecutionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPatchBaselineForPatchGroupResult = { ["PatchGroup"] = true, ["BaselineId"] = true, ["OperatingSystem"] = true, nil }

function asserts.AssertGetPatchBaselineForPatchGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPatchBaselineForPatchGroupResult to be of type 'table'")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPatchBaselineForPatchGroupResult[k], "GetPatchBaselineForPatchGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPatchBaselineForPatchGroupResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline that should be used for the patch group.</p>
-- * OperatingSystem [OperatingSystem] <p>The operating system rule specified for patch groups using the patch baseline.</p>
-- @return GetPatchBaselineForPatchGroupResult structure as a key-value pair table
function M.GetPatchBaselineForPatchGroupResult(args)
	assert(args, "You must provide an argument table when creating GetPatchBaselineForPatchGroupResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["BaselineId"] = args["BaselineId"],
		["OperatingSystem"] = args["OperatingSystem"],
	}
	asserts.AssertGetPatchBaselineForPatchGroupResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SessionFilter = { ["value"] = true, ["key"] = true, nil }

function asserts.AssertSessionFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SessionFilter to be of type 'table'")
	assert(struct["key"], "Expected key key to exist in table")
	assert(struct["value"], "Expected key value to exist in table")
	if struct["value"] then asserts.AssertSessionFilterValue(struct["value"]) end
	if struct["key"] then asserts.AssertSessionFilterKey(struct["key"]) end
	for k,_ in pairs(struct) do
		assert(keys.SessionFilter[k], "SessionFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SessionFilter
-- <p>Describes a filter for Session Manager information.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * value [SessionFilterValue] <p>The filter value. Valid values for each filter key are as follows:</p> <ul> <li> <p>InvokedAfter: Specify a timestamp to limit your results. For example, specify 2018-08-29T00:00:00Z to see sessions that started August 29, 2018, and later.</p> </li> <li> <p>InvokedBefore: Specify a timestamp to limit your results. For example, specify 2018-08-29T00:00:00Z to see sessions that started before August 29, 2018.</p> </li> <li> <p>Target: Specify an instance to which session connections have been made.</p> </li> <li> <p>Owner: Specify an AWS user account to see a list of sessions started by that user.</p> </li> <li> <p>Status: Specify a valid session status to see a list of all sessions with that status. Status values you can specify include:</p> <ul> <li> <p>Connected</p> </li> <li> <p>Connecting</p> </li> <li> <p>Disconnected</p> </li> <li> <p>Terminated</p> </li> <li> <p>Terminating</p> </li> <li> <p>Failed</p> </li> </ul> </li> </ul>
-- * key [SessionFilterKey] <p>The name of the filter.</p>
-- Required key: key
-- Required key: value
-- @return SessionFilter structure as a key-value pair table
function M.SessionFilter(args)
	assert(args, "You must provide an argument table when creating SessionFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["value"] = args["value"],
		["key"] = args["key"],
	}
	asserts.AssertSessionFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ParameterHistory = { ["KeyId"] = true, ["Name"] = true, ["LastModifiedDate"] = true, ["Labels"] = true, ["Value"] = true, ["AllowedPattern"] = true, ["Version"] = true, ["LastModifiedUser"] = true, ["Type"] = true, ["Description"] = true, nil }

function asserts.AssertParameterHistory(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ParameterHistory to be of type 'table'")
	if struct["KeyId"] then asserts.AssertParameterKeyId(struct["KeyId"]) end
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	if struct["LastModifiedDate"] then asserts.AssertDateTime(struct["LastModifiedDate"]) end
	if struct["Labels"] then asserts.AssertParameterLabelList(struct["Labels"]) end
	if struct["Value"] then asserts.AssertPSParameterValue(struct["Value"]) end
	if struct["AllowedPattern"] then asserts.AssertAllowedPattern(struct["AllowedPattern"]) end
	if struct["Version"] then asserts.AssertPSParameterVersion(struct["Version"]) end
	if struct["LastModifiedUser"] then asserts.AssertString(struct["LastModifiedUser"]) end
	if struct["Type"] then asserts.AssertParameterType(struct["Type"]) end
	if struct["Description"] then asserts.AssertParameterDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ParameterHistory[k], "ParameterHistory contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ParameterHistory
-- <p>Information about parameter usage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyId [ParameterKeyId] <p>The ID of the query key used for this parameter.</p>
-- * Name [PSParameterName] <p>The name of the parameter.</p>
-- * LastModifiedDate [DateTime] <p>Date the parameter was last changed or updated.</p>
-- * Labels [ParameterLabelList] <p>Labels assigned to the parameter version.</p>
-- * Value [PSParameterValue] <p>The parameter value.</p>
-- * AllowedPattern [AllowedPattern] <p>Parameter names can include the following letters and symbols.</p> <p>a-zA-Z0-9_.-</p>
-- * Version [PSParameterVersion] <p>The parameter version.</p>
-- * LastModifiedUser [String] <p>Amazon Resource Name (ARN) of the AWS user who last changed the parameter.</p>
-- * Type [ParameterType] <p>The type of parameter used.</p>
-- * Description [ParameterDescription] <p>Information about the parameter.</p>
-- @return ParameterHistory structure as a key-value pair table
function M.ParameterHistory(args)
	assert(args, "You must provide an argument table when creating ParameterHistory")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyId"] = args["KeyId"],
		["Name"] = args["Name"],
		["LastModifiedDate"] = args["LastModifiedDate"],
		["Labels"] = args["Labels"],
		["Value"] = args["Value"],
		["AllowedPattern"] = args["AllowedPattern"],
		["Version"] = args["Version"],
		["LastModifiedUser"] = args["LastModifiedUser"],
		["Type"] = args["Type"],
		["Description"] = args["Description"],
	}
	asserts.AssertParameterHistory(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CommandPlugin = { ["Status"] = true, ["ResponseStartDateTime"] = true, ["StandardErrorUrl"] = true, ["OutputS3BucketName"] = true, ["OutputS3Region"] = true, ["OutputS3KeyPrefix"] = true, ["ResponseCode"] = true, ["Output"] = true, ["ResponseFinishDateTime"] = true, ["StatusDetails"] = true, ["StandardOutputUrl"] = true, ["Name"] = true, nil }

function asserts.AssertCommandPlugin(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CommandPlugin to be of type 'table'")
	if struct["Status"] then asserts.AssertCommandPluginStatus(struct["Status"]) end
	if struct["ResponseStartDateTime"] then asserts.AssertDateTime(struct["ResponseStartDateTime"]) end
	if struct["StandardErrorUrl"] then asserts.AssertUrl(struct["StandardErrorUrl"]) end
	if struct["OutputS3BucketName"] then asserts.AssertS3BucketName(struct["OutputS3BucketName"]) end
	if struct["OutputS3Region"] then asserts.AssertS3Region(struct["OutputS3Region"]) end
	if struct["OutputS3KeyPrefix"] then asserts.AssertS3KeyPrefix(struct["OutputS3KeyPrefix"]) end
	if struct["ResponseCode"] then asserts.AssertResponseCode(struct["ResponseCode"]) end
	if struct["Output"] then asserts.AssertCommandPluginOutput(struct["Output"]) end
	if struct["ResponseFinishDateTime"] then asserts.AssertDateTime(struct["ResponseFinishDateTime"]) end
	if struct["StatusDetails"] then asserts.AssertStatusDetails(struct["StatusDetails"]) end
	if struct["StandardOutputUrl"] then asserts.AssertUrl(struct["StandardOutputUrl"]) end
	if struct["Name"] then asserts.AssertCommandPluginName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.CommandPlugin[k], "CommandPlugin contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CommandPlugin
-- <p>Describes plugin details.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [CommandPluginStatus] <p>The status of this plugin. You can execute a document with multiple plugins.</p>
-- * ResponseStartDateTime [DateTime] <p>The time the plugin started executing. </p>
-- * StandardErrorUrl [Url] <p>The URL for the complete text written by the plugin to stderr. If execution is not yet complete, then this string is empty.</p>
-- * OutputS3BucketName [S3BucketName] <p>The S3 bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response:</p> <p> test_folder/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-1234567876543/awsrunShellScript </p> <p>test_folder is the name of the Amazon S3 bucket;</p> <p> ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p> <p>i-1234567876543 is the instance ID;</p> <p>awsrunShellScript is the name of the plugin.</p>
-- * OutputS3Region [S3Region] <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon S3 bucket region.</p>
-- * OutputS3KeyPrefix [S3KeyPrefix] <p>The S3 directory path inside the bucket where the responses to the command executions should be stored. This was requested when issuing the command. For example, in the following response:</p> <p> test_folder/ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix/i-1234567876543/awsrunShellScript </p> <p>test_folder is the name of the Amazon S3 bucket;</p> <p> ab19cb99-a030-46dd-9dfc-8eSAMPLEPre-Fix is the name of the S3 prefix;</p> <p>i-1234567876543 is the instance ID;</p> <p>awsrunShellScript is the name of the plugin.</p>
-- * ResponseCode [ResponseCode] <p>A numeric response code generated after executing the plugin. </p>
-- * Output [CommandPluginOutput] <p>Output of the plugin execution.</p>
-- * ResponseFinishDateTime [DateTime] <p>The time the plugin stopped executing. Could stop prematurely if, for example, a cancel command was sent. </p>
-- * StatusDetails [StatusDetails] <p>A detailed status of the plugin execution. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding Command Statuses</a> in the <i>AWS Systems Manager User Guide</i>. StatusDetails can be one of the following values:</p> <ul> <li> <p>Pending: The command has not been sent to the instance.</p> </li> <li> <p>In Progress: The command has been sent to the instance but has not reached a terminal state.</p> </li> <li> <p>Success: The execution of the command or plugin was successfully completed. This is a terminal state.</p> </li> <li> <p>Delivery Timed Out: The command was not delivered to the instance before the delivery timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.</p> </li> <li> <p>Execution Timed Out: Command execution started on the instance, but the execution was not complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.</p> </li> <li> <p>Failed: The command was not successful on the instance. For a plugin, this indicates that the result code was not zero. For a command invocation, this indicates that the result code for one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.</p> </li> <li> <p>Canceled: The command was terminated before it was completed. This is a terminal state.</p> </li> <li> <p>Undeliverable: The command can't be delivered to the instance. The instance might not exist, or it might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit, and they don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.</p> </li> <li> <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.</p> </li> </ul>
-- * StandardOutputUrl [Url] <p>The URL for the complete text written by the plugin to stdout in Amazon S3. If the Amazon S3 bucket for the command was not specified, then this string is empty.</p>
-- * Name [CommandPluginName] <p>The name of the plugin. Must be one of the following: aws:updateAgent, aws:domainjoin, aws:applications, aws:runPowerShellScript, aws:psmodule, aws:cloudWatch, aws:runShellScript, or aws:updateSSMAgent. </p>
-- @return CommandPlugin structure as a key-value pair table
function M.CommandPlugin(args)
	assert(args, "You must provide an argument table when creating CommandPlugin")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["ResponseStartDateTime"] = args["ResponseStartDateTime"],
		["StandardErrorUrl"] = args["StandardErrorUrl"],
		["OutputS3BucketName"] = args["OutputS3BucketName"],
		["OutputS3Region"] = args["OutputS3Region"],
		["OutputS3KeyPrefix"] = args["OutputS3KeyPrefix"],
		["ResponseCode"] = args["ResponseCode"],
		["Output"] = args["Output"],
		["ResponseFinishDateTime"] = args["ResponseFinishDateTime"],
		["StatusDetails"] = args["StatusDetails"],
		["StandardOutputUrl"] = args["StandardOutputUrl"],
		["Name"] = args["Name"],
	}
	asserts.AssertCommandPlugin(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEffectiveInstanceAssociationsResult = { ["Associations"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeEffectiveInstanceAssociationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEffectiveInstanceAssociationsResult to be of type 'table'")
	if struct["Associations"] then asserts.AssertInstanceAssociationList(struct["Associations"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEffectiveInstanceAssociationsResult[k], "DescribeEffectiveInstanceAssociationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEffectiveInstanceAssociationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Associations [InstanceAssociationList] <p>The associations for the requested instance.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeEffectiveInstanceAssociationsResult structure as a key-value pair table
function M.DescribeEffectiveInstanceAssociationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeEffectiveInstanceAssociationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Associations"] = args["Associations"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeEffectiveInstanceAssociationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListComplianceSummariesResult = { ["ComplianceSummaryItems"] = true, ["NextToken"] = true, nil }

function asserts.AssertListComplianceSummariesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListComplianceSummariesResult to be of type 'table'")
	if struct["ComplianceSummaryItems"] then asserts.AssertComplianceSummaryItemList(struct["ComplianceSummaryItems"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListComplianceSummariesResult[k], "ListComplianceSummariesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListComplianceSummariesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ComplianceSummaryItems [ComplianceSummaryItemList] <p>A list of compliant and non-compliant summary counts based on compliance types. For example, this call returns State Manager associations, patches, or custom compliance types according to the filter criteria that you specified.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- @return ListComplianceSummariesResult structure as a key-value pair table
function M.ListComplianceSummariesResult(args)
	assert(args, "You must provide an argument table when creating ListComplianceSummariesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ComplianceSummaryItems"] = args["ComplianceSummaryItems"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertListComplianceSummariesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowExecutionTaskInvocationIdentity = { ["Status"] = true, ["Parameters"] = true, ["OwnerInformation"] = true, ["WindowTargetId"] = true, ["ExecutionId"] = true, ["InvocationId"] = true, ["StartTime"] = true, ["TaskType"] = true, ["EndTime"] = true, ["WindowExecutionId"] = true, ["StatusDetails"] = true, ["TaskExecutionId"] = true, nil }

function asserts.AssertMaintenanceWindowExecutionTaskInvocationIdentity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowExecutionTaskInvocationIdentity to be of type 'table'")
	if struct["Status"] then asserts.AssertMaintenanceWindowExecutionStatus(struct["Status"]) end
	if struct["Parameters"] then asserts.AssertMaintenanceWindowExecutionTaskInvocationParameters(struct["Parameters"]) end
	if struct["OwnerInformation"] then asserts.AssertOwnerInformation(struct["OwnerInformation"]) end
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTaskTargetId(struct["WindowTargetId"]) end
	if struct["ExecutionId"] then asserts.AssertMaintenanceWindowExecutionTaskExecutionId(struct["ExecutionId"]) end
	if struct["InvocationId"] then asserts.AssertMaintenanceWindowExecutionTaskInvocationId(struct["InvocationId"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["TaskType"] then asserts.AssertMaintenanceWindowTaskType(struct["TaskType"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["StatusDetails"] then asserts.AssertMaintenanceWindowExecutionStatusDetails(struct["StatusDetails"]) end
	if struct["TaskExecutionId"] then asserts.AssertMaintenanceWindowExecutionTaskId(struct["TaskExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowExecutionTaskInvocationIdentity[k], "MaintenanceWindowExecutionTaskInvocationIdentity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowExecutionTaskInvocationIdentity
-- <p>Describes the information about a task invocation for a particular target as part of a task execution performed as part of a Maintenance Window execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [MaintenanceWindowExecutionStatus] <p>The status of the task invocation.</p>
-- * Parameters [MaintenanceWindowExecutionTaskInvocationParameters] <p>The parameters that were provided for the invocation when it was executed.</p>
-- * OwnerInformation [OwnerInformation] <p>User-provided value that was specified when the target was registered with the Maintenance Window. This was also included in any CloudWatch events raised during the task invocation.</p>
-- * WindowTargetId [MaintenanceWindowTaskTargetId] <p>The ID of the target definition in this Maintenance Window the invocation was performed for.</p>
-- * ExecutionId [MaintenanceWindowExecutionTaskExecutionId] <p>The ID of the action performed in the service that actually handled the task invocation. If the task type is RUN_COMMAND, this value is the command ID.</p>
-- * InvocationId [MaintenanceWindowExecutionTaskInvocationId] <p>The ID of the task invocation.</p>
-- * StartTime [DateTime] <p>The time the invocation started.</p>
-- * TaskType [MaintenanceWindowTaskType] <p>The task type.</p>
-- * EndTime [DateTime] <p>The time the invocation finished.</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution that ran the task.</p>
-- * StatusDetails [MaintenanceWindowExecutionStatusDetails] <p>The details explaining the status of the task invocation. Only available for certain Status values. </p>
-- * TaskExecutionId [MaintenanceWindowExecutionTaskId] <p>The ID of the specific task execution in the Maintenance Window execution.</p>
-- @return MaintenanceWindowExecutionTaskInvocationIdentity structure as a key-value pair table
function M.MaintenanceWindowExecutionTaskInvocationIdentity(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowExecutionTaskInvocationIdentity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Parameters"] = args["Parameters"],
		["OwnerInformation"] = args["OwnerInformation"],
		["WindowTargetId"] = args["WindowTargetId"],
		["ExecutionId"] = args["ExecutionId"],
		["InvocationId"] = args["InvocationId"],
		["StartTime"] = args["StartTime"],
		["TaskType"] = args["TaskType"],
		["EndTime"] = args["EndTime"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["StatusDetails"] = args["StatusDetails"],
		["TaskExecutionId"] = args["TaskExecutionId"],
	}
	asserts.AssertMaintenanceWindowExecutionTaskInvocationIdentity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAssociationStatusRequest = { ["InstanceId"] = true, ["AssociationStatus"] = true, ["Name"] = true, nil }

function asserts.AssertUpdateAssociationStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAssociationStatusRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["AssociationStatus"], "Expected key AssociationStatus to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["AssociationStatus"] then asserts.AssertAssociationStatus(struct["AssociationStatus"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateAssociationStatusRequest[k], "UpdateAssociationStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAssociationStatusRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The ID of the instance.</p>
-- * AssociationStatus [AssociationStatus] <p>The association status.</p>
-- * Name [DocumentName] <p>The name of the Systems Manager document.</p>
-- Required key: Name
-- Required key: InstanceId
-- Required key: AssociationStatus
-- @return UpdateAssociationStatusRequest structure as a key-value pair table
function M.UpdateAssociationStatusRequest(args)
	assert(args, "You must provide an argument table when creating UpdateAssociationStatusRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["AssociationStatus"] = args["AssociationStatus"],
		["Name"] = args["Name"],
	}
	asserts.AssertUpdateAssociationStatusRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdatePatchBaselineResult = { ["ApprovedPatchesEnableNonSecurity"] = true, ["BaselineId"] = true, ["Name"] = true, ["RejectedPatches"] = true, ["GlobalFilters"] = true, ["Sources"] = true, ["ApprovalRules"] = true, ["ModifiedDate"] = true, ["CreatedDate"] = true, ["Description"] = true, ["ApprovedPatchesComplianceLevel"] = true, ["OperatingSystem"] = true, ["ApprovedPatches"] = true, ["RejectedPatchesAction"] = true, nil }

function asserts.AssertUpdatePatchBaselineResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdatePatchBaselineResult to be of type 'table'")
	if struct["ApprovedPatchesEnableNonSecurity"] then asserts.AssertBoolean(struct["ApprovedPatchesEnableNonSecurity"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["Name"] then asserts.AssertBaselineName(struct["Name"]) end
	if struct["RejectedPatches"] then asserts.AssertPatchIdList(struct["RejectedPatches"]) end
	if struct["GlobalFilters"] then asserts.AssertPatchFilterGroup(struct["GlobalFilters"]) end
	if struct["Sources"] then asserts.AssertPatchSourceList(struct["Sources"]) end
	if struct["ApprovalRules"] then asserts.AssertPatchRuleGroup(struct["ApprovalRules"]) end
	if struct["ModifiedDate"] then asserts.AssertDateTime(struct["ModifiedDate"]) end
	if struct["CreatedDate"] then asserts.AssertDateTime(struct["CreatedDate"]) end
	if struct["Description"] then asserts.AssertBaselineDescription(struct["Description"]) end
	if struct["ApprovedPatchesComplianceLevel"] then asserts.AssertPatchComplianceLevel(struct["ApprovedPatchesComplianceLevel"]) end
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	if struct["ApprovedPatches"] then asserts.AssertPatchIdList(struct["ApprovedPatches"]) end
	if struct["RejectedPatchesAction"] then asserts.AssertPatchAction(struct["RejectedPatchesAction"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdatePatchBaselineResult[k], "UpdatePatchBaselineResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdatePatchBaselineResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ApprovedPatchesEnableNonSecurity [Boolean] <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
-- * BaselineId [BaselineId] <p>The ID of the deleted patch baseline.</p>
-- * Name [BaselineName] <p>The name of the patch baseline.</p>
-- * RejectedPatches [PatchIdList] <p>A list of explicitly rejected patches for the baseline.</p>
-- * GlobalFilters [PatchFilterGroup] <p>A set of global filters used to exclude patches from the baseline.</p>
-- * Sources [PatchSourceList] <p>Information about the patches to use to update the instances, including target operating systems and source repositories. Applies to Linux instances only.</p>
-- * ApprovalRules [PatchRuleGroup] <p>A set of rules used to include patches in the baseline.</p>
-- * ModifiedDate [DateTime] <p>The date when the patch baseline was last modified.</p>
-- * CreatedDate [DateTime] <p>The date when the patch baseline was created.</p>
-- * Description [BaselineDescription] <p>A description of the Patch Baseline.</p>
-- * ApprovedPatchesComplianceLevel [PatchComplianceLevel] <p>The compliance severity level assigned to the patch baseline after the update completed.</p>
-- * OperatingSystem [OperatingSystem] <p>The operating system rule used by the updated patch baseline.</p>
-- * ApprovedPatches [PatchIdList] <p>A list of explicitly approved patches for the baseline.</p>
-- * RejectedPatchesAction [PatchAction] <p>The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.</p>
-- @return UpdatePatchBaselineResult structure as a key-value pair table
function M.UpdatePatchBaselineResult(args)
	assert(args, "You must provide an argument table when creating UpdatePatchBaselineResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ApprovedPatchesEnableNonSecurity"] = args["ApprovedPatchesEnableNonSecurity"],
		["BaselineId"] = args["BaselineId"],
		["Name"] = args["Name"],
		["RejectedPatches"] = args["RejectedPatches"],
		["GlobalFilters"] = args["GlobalFilters"],
		["Sources"] = args["Sources"],
		["ApprovalRules"] = args["ApprovalRules"],
		["ModifiedDate"] = args["ModifiedDate"],
		["CreatedDate"] = args["CreatedDate"],
		["Description"] = args["Description"],
		["ApprovedPatchesComplianceLevel"] = args["ApprovedPatchesComplianceLevel"],
		["OperatingSystem"] = args["OperatingSystem"],
		["ApprovedPatches"] = args["ApprovedPatches"],
		["RejectedPatchesAction"] = args["RejectedPatchesAction"],
	}
	asserts.AssertUpdatePatchBaselineResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEffectivePatchesForPatchBaselineResult = { ["NextToken"] = true, ["EffectivePatches"] = true, nil }

function asserts.AssertDescribeEffectivePatchesForPatchBaselineResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEffectivePatchesForPatchBaselineResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["EffectivePatches"] then asserts.AssertEffectivePatchList(struct["EffectivePatches"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEffectivePatchesForPatchBaselineResult[k], "DescribeEffectivePatchesForPatchBaselineResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEffectivePatchesForPatchBaselineResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * EffectivePatches [EffectivePatchList] <p>An array of patches and patch status.</p>
-- @return DescribeEffectivePatchesForPatchBaselineResult structure as a key-value pair table
function M.DescribeEffectivePatchesForPatchBaselineResult(args)
	assert(args, "You must provide an argument table when creating DescribeEffectivePatchesForPatchBaselineResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["EffectivePatches"] = args["EffectivePatches"],
	}
	asserts.AssertDescribeEffectivePatchesForPatchBaselineResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteMaintenanceWindowRequest = { ["WindowId"] = true, nil }

function asserts.AssertDeleteMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteMaintenanceWindowRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteMaintenanceWindowRequest[k], "DeleteMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window to delete.</p>
-- Required key: WindowId
-- @return DeleteMaintenanceWindowRequest structure as a key-value pair table
function M.DeleteMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating DeleteMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
	}
	asserts.AssertDeleteMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAssociationsRequest = { ["AssociationFilterList"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertListAssociationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAssociationsRequest to be of type 'table'")
	if struct["AssociationFilterList"] then asserts.AssertAssociationFilterList(struct["AssociationFilterList"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAssociationsRequest[k], "ListAssociationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAssociationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationFilterList [AssociationFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- @return ListAssociationsRequest structure as a key-value pair table
function M.ListAssociationsRequest(args)
	assert(args, "You must provide an argument table when creating ListAssociationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationFilterList"] = args["AssociationFilterList"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertListAssociationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeParametersRequest = { ["ParameterFilters"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeParametersRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeParametersRequest to be of type 'table'")
	if struct["ParameterFilters"] then asserts.AssertParameterStringFilterList(struct["ParameterFilters"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertParametersFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeParametersRequest[k], "DescribeParametersRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeParametersRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ParameterFilters [ParameterStringFilterList] <p>Filters to limit the request results.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [ParametersFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- @return DescribeParametersRequest structure as a key-value pair table
function M.DescribeParametersRequest(args)
	assert(args, "You must provide an argument table when creating DescribeParametersRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ParameterFilters"] = args["ParameterFilters"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeParametersRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteParametersResult = { ["InvalidParameters"] = true, ["DeletedParameters"] = true, nil }

function asserts.AssertDeleteParametersResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteParametersResult to be of type 'table'")
	if struct["InvalidParameters"] then asserts.AssertParameterNameList(struct["InvalidParameters"]) end
	if struct["DeletedParameters"] then asserts.AssertParameterNameList(struct["DeletedParameters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteParametersResult[k], "DeleteParametersResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteParametersResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InvalidParameters [ParameterNameList] <p>The names of parameters that weren't deleted because the parameters are not valid.</p>
-- * DeletedParameters [ParameterNameList] <p>The names of the deleted parameters.</p>
-- @return DeleteParametersResult structure as a key-value pair table
function M.DeleteParametersResult(args)
	assert(args, "You must provide an argument table when creating DeleteParametersResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InvalidParameters"] = args["InvalidParameters"],
		["DeletedParameters"] = args["DeletedParameters"],
	}
	asserts.AssertDeleteParametersResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationStatus = { ["Date"] = true, ["AdditionalInfo"] = true, ["Message"] = true, ["Name"] = true, nil }

function asserts.AssertAssociationStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationStatus to be of type 'table'")
	assert(struct["Date"], "Expected key Date to exist in table")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Date"] then asserts.AssertDateTime(struct["Date"]) end
	if struct["AdditionalInfo"] then asserts.AssertStatusAdditionalInfo(struct["AdditionalInfo"]) end
	if struct["Message"] then asserts.AssertStatusMessage(struct["Message"]) end
	if struct["Name"] then asserts.AssertAssociationStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationStatus[k], "AssociationStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationStatus
-- <p>Describes an association status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Date [DateTime] <p>The date when the status changed.</p>
-- * AdditionalInfo [StatusAdditionalInfo] <p>A user-defined string.</p>
-- * Message [StatusMessage] <p>The reason for the status.</p>
-- * Name [AssociationStatusName] <p>The status.</p>
-- Required key: Date
-- Required key: Name
-- Required key: Message
-- @return AssociationStatus structure as a key-value pair table
function M.AssociationStatus(args)
	assert(args, "You must provide an argument table when creating AssociationStatus")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Date"] = args["Date"],
		["AdditionalInfo"] = args["AdditionalInfo"],
		["Message"] = args["Message"],
		["Name"] = args["Name"],
	}
	asserts.AssertAssociationStatus(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceInformationFilter = { ["valueSet"] = true, ["key"] = true, nil }

function asserts.AssertInstanceInformationFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceInformationFilter to be of type 'table'")
	assert(struct["key"], "Expected key key to exist in table")
	assert(struct["valueSet"], "Expected key valueSet to exist in table")
	if struct["valueSet"] then asserts.AssertInstanceInformationFilterValueSet(struct["valueSet"]) end
	if struct["key"] then asserts.AssertInstanceInformationFilterKey(struct["key"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceInformationFilter[k], "InstanceInformationFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceInformationFilter
-- <p>Describes a filter for a specific list of instances. You can filter instances information by using tags. You specify tags by using a key-value mapping.</p> <p>Use this action instead of the <a>DescribeInstanceInformationRequest$InstanceInformationFilterList</a> method. The <code>InstanceInformationFilterList</code> method is a legacy method and does not support tags. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * valueSet [InstanceInformationFilterValueSet] <p>The filter values.</p>
-- * key [InstanceInformationFilterKey] <p>The name of the filter. </p>
-- Required key: key
-- Required key: valueSet
-- @return InstanceInformationFilter structure as a key-value pair table
function M.InstanceInformationFilter(args)
	assert(args, "You must provide an argument table when creating InstanceInformationFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["valueSet"] = args["valueSet"],
		["key"] = args["key"],
	}
	asserts.AssertInstanceInformationFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowTargetsRequest = { ["WindowId"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowTargetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowTargetsRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertMaintenanceWindowFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowTargetsRequest[k], "DescribeMaintenanceWindowTargetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowTargetsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window whose targets should be retrieved.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaintenanceWindowMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [MaintenanceWindowFilterList] <p>Optional filters that can be used to narrow down the scope of the returned window targets. The supported filter keys are Type, WindowTargetId and OwnerInformation.</p>
-- Required key: WindowId
-- @return DescribeMaintenanceWindowTargetsRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowTargetsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowTargetsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeMaintenanceWindowTargetsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateAssociationBatchRequestEntry = { ["MaxErrors"] = true, ["ScheduleExpression"] = true, ["OutputLocation"] = true, ["Name"] = true, ["Parameters"] = true, ["InstanceId"] = true, ["DocumentVersion"] = true, ["AssociationName"] = true, ["Targets"] = true, ["ComplianceSeverity"] = true, ["MaxConcurrency"] = true, nil }

function asserts.AssertCreateAssociationBatchRequestEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateAssociationBatchRequestEntry to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["ScheduleExpression"] then asserts.AssertScheduleExpression(struct["ScheduleExpression"]) end
	if struct["OutputLocation"] then asserts.AssertInstanceAssociationOutputLocation(struct["OutputLocation"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["AssociationName"] then asserts.AssertAssociationName(struct["AssociationName"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["ComplianceSeverity"] then asserts.AssertAssociationComplianceSeverity(struct["ComplianceSeverity"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateAssociationBatchRequestEntry[k], "CreateAssociationBatchRequestEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateAssociationBatchRequestEntry
-- <p>Describes the association of a Systems Manager document and an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxErrors [MaxErrors] <p>The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 instances and set MaxError to 10%, then the system stops sending the request when the sixth error is received.</p> <p>Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.</p>
-- * ScheduleExpression [ScheduleExpression] <p>A cron expression that specifies a schedule when the association runs.</p>
-- * OutputLocation [InstanceAssociationOutputLocation] <p>An Amazon S3 bucket where you want to store the results of this request.</p>
-- * Name [DocumentName] <p>The name of the configuration document. </p>
-- * Parameters [Parameters] <p>A description of the parameters for a document. </p>
-- * InstanceId [InstanceId] <p>The ID of the instance. </p>
-- * DocumentVersion [DocumentVersion] <p>The document version.</p>
-- * AssociationName [AssociationName] <p>Specify a descriptive name for the association.</p>
-- * Targets [Targets] <p>The instances targeted by the request.</p>
-- * ComplianceSeverity [AssociationComplianceSeverity] <p>The severity level to assign to the association.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time.</p> <p>If a new instance starts and attempts to execute an association while Systems Manager is executing MaxConcurrency associations, the association is allowed to run. During the next association interval, the new instance will process its association within the limit specified for MaxConcurrency.</p>
-- Required key: Name
-- @return CreateAssociationBatchRequestEntry structure as a key-value pair table
function M.CreateAssociationBatchRequestEntry(args)
	assert(args, "You must provide an argument table when creating CreateAssociationBatchRequestEntry")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxErrors"] = args["MaxErrors"],
		["ScheduleExpression"] = args["ScheduleExpression"],
		["OutputLocation"] = args["OutputLocation"],
		["Name"] = args["Name"],
		["Parameters"] = args["Parameters"],
		["InstanceId"] = args["InstanceId"],
		["DocumentVersion"] = args["DocumentVersion"],
		["AssociationName"] = args["AssociationName"],
		["Targets"] = args["Targets"],
		["ComplianceSeverity"] = args["ComplianceSeverity"],
		["MaxConcurrency"] = args["MaxConcurrency"],
	}
	asserts.AssertCreateAssociationBatchRequestEntry(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PutComplianceItemsResult = { nil }

function asserts.AssertPutComplianceItemsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PutComplianceItemsResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.PutComplianceItemsResult[k], "PutComplianceItemsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PutComplianceItemsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return PutComplianceItemsResult structure as a key-value pair table
function M.PutComplianceItemsResult(args)
	assert(args, "You must provide an argument table when creating PutComplianceItemsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertPutComplianceItemsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Parameter = { ["SourceResult"] = true, ["Name"] = true, ["LastModifiedDate"] = true, ["Value"] = true, ["Selector"] = true, ["Version"] = true, ["Type"] = true, ["ARN"] = true, nil }

function asserts.AssertParameter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Parameter to be of type 'table'")
	if struct["SourceResult"] then asserts.AssertString(struct["SourceResult"]) end
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	if struct["LastModifiedDate"] then asserts.AssertDateTime(struct["LastModifiedDate"]) end
	if struct["Value"] then asserts.AssertPSParameterValue(struct["Value"]) end
	if struct["Selector"] then asserts.AssertPSParameterSelector(struct["Selector"]) end
	if struct["Version"] then asserts.AssertPSParameterVersion(struct["Version"]) end
	if struct["Type"] then asserts.AssertParameterType(struct["Type"]) end
	if struct["ARN"] then asserts.AssertString(struct["ARN"]) end
	for k,_ in pairs(struct) do
		assert(keys.Parameter[k], "Parameter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Parameter
-- <p>An Amazon EC2 Systems Manager parameter in Parameter Store.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceResult [String] <p>Applies to parameters that reference information in other AWS services. SourceResult is the raw result or response from the source.</p>
-- * Name [PSParameterName] <p>The name of the parameter.</p>
-- * LastModifiedDate [DateTime] <p>Date the parameter was last changed or updated and the parameter version was created.</p>
-- * Value [PSParameterValue] <p>The parameter value.</p>
-- * Selector [PSParameterSelector] <p>Either the version number or the label used to retrieve the parameter value. Specify selectors by using one of the following formats:</p> <p>parameter_name:version</p> <p>parameter_name:label</p>
-- * Version [PSParameterVersion] <p>The parameter version.</p>
-- * Type [ParameterType] <p>The type of parameter. Valid values include the following: String, String list, Secure string.</p>
-- * ARN [String] <p>The Amazon Resource Name (ARN) of the parameter.</p>
-- @return Parameter structure as a key-value pair table
function M.Parameter(args)
	assert(args, "You must provide an argument table when creating Parameter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SourceResult"] = args["SourceResult"],
		["Name"] = args["Name"],
		["LastModifiedDate"] = args["LastModifiedDate"],
		["Value"] = args["Value"],
		["Selector"] = args["Selector"],
		["Version"] = args["Version"],
		["Type"] = args["Type"],
		["ARN"] = args["ARN"],
	}
	asserts.AssertParameter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParametersByPathResult = { ["NextToken"] = true, ["Parameters"] = true, nil }

function asserts.AssertGetParametersByPathResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParametersByPathResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Parameters"] then asserts.AssertParameterList(struct["Parameters"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParametersByPathResult[k], "GetParametersByPathResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParametersByPathResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- * Parameters [ParameterList] <p>A list of parameters found in the specified hierarchy.</p>
-- @return GetParametersByPathResult structure as a key-value pair table
function M.GetParametersByPathResult(args)
	assert(args, "You must provide an argument table when creating GetParametersByPathResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Parameters"] = args["Parameters"],
	}
	asserts.AssertGetParametersByPathResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DocumentParameter = { ["DefaultValue"] = true, ["Type"] = true, ["Name"] = true, ["Description"] = true, nil }

function asserts.AssertDocumentParameter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DocumentParameter to be of type 'table'")
	if struct["DefaultValue"] then asserts.AssertDocumentParameterDefaultValue(struct["DefaultValue"]) end
	if struct["Type"] then asserts.AssertDocumentParameterType(struct["Type"]) end
	if struct["Name"] then asserts.AssertDocumentParameterName(struct["Name"]) end
	if struct["Description"] then asserts.AssertDocumentParameterDescrption(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DocumentParameter[k], "DocumentParameter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DocumentParameter
-- <p>Parameters specified in a System Manager document that execute on the server when the command is run. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DefaultValue [DocumentParameterDefaultValue] <p>If specified, the default values for the parameters. Parameters without a default value are required. Parameters with a default value are optional.</p>
-- * Type [DocumentParameterType] <p>The type of parameter. The type can be either String or StringList.</p>
-- * Name [DocumentParameterName] <p>The name of the parameter.</p>
-- * Description [DocumentParameterDescrption] <p>A description of what the parameter does, how to use it, the default value, and whether or not the parameter is optional.</p>
-- @return DocumentParameter structure as a key-value pair table
function M.DocumentParameter(args)
	assert(args, "You must provide an argument table when creating DocumentParameter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DefaultValue"] = args["DefaultValue"],
		["Type"] = args["Type"],
		["Name"] = args["Name"],
		["Description"] = args["Description"],
	}
	asserts.AssertDocumentParameter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateDocumentDefaultVersionResult = { ["Description"] = true, nil }

function asserts.AssertUpdateDocumentDefaultVersionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateDocumentDefaultVersionResult to be of type 'table'")
	if struct["Description"] then asserts.AssertDocumentDefaultVersionDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateDocumentDefaultVersionResult[k], "UpdateDocumentDefaultVersionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateDocumentDefaultVersionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [DocumentDefaultVersionDescription] <p>The description of a custom document that you want to set as the default version.</p>
-- @return UpdateDocumentDefaultVersionResult structure as a key-value pair table
function M.UpdateDocumentDefaultVersionResult(args)
	assert(args, "You must provide an argument table when creating UpdateDocumentDefaultVersionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Description"] = args["Description"],
	}
	asserts.AssertUpdateDocumentDefaultVersionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryAggregator = { ["Aggregators"] = true, ["Expression"] = true, ["Groups"] = true, nil }

function asserts.AssertInventoryAggregator(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryAggregator to be of type 'table'")
	if struct["Aggregators"] then asserts.AssertInventoryAggregatorList(struct["Aggregators"]) end
	if struct["Expression"] then asserts.AssertInventoryAggregatorExpression(struct["Expression"]) end
	if struct["Groups"] then asserts.AssertInventoryGroupList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryAggregator[k], "InventoryAggregator contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryAggregator
-- <p>Specifies the inventory type and attribute for the aggregation execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Aggregators [InventoryAggregatorList] <p>Nested aggregators to further refine aggregation for an inventory type.</p>
-- * Expression [InventoryAggregatorExpression] <p>The inventory type and attribute name for aggregation.</p>
-- * Groups [InventoryGroupList] <p>A user-defined set of one or more filters on which to aggregate inventory data. Groups return a count of resources that match and don't match the specified criteria.</p>
-- @return InventoryAggregator structure as a key-value pair table
function M.InventoryAggregator(args)
	assert(args, "You must provide an argument table when creating InventoryAggregator")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Aggregators"] = args["Aggregators"],
		["Expression"] = args["Expression"],
		["Groups"] = args["Groups"],
	}
	asserts.AssertInventoryAggregator(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParametersByPathRequest = { ["Recursive"] = true, ["ParameterFilters"] = true, ["WithDecryption"] = true, ["MaxResults"] = true, ["Path"] = true, ["NextToken"] = true, nil }

function asserts.AssertGetParametersByPathRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParametersByPathRequest to be of type 'table'")
	assert(struct["Path"], "Expected key Path to exist in table")
	if struct["Recursive"] then asserts.AssertBoolean(struct["Recursive"]) end
	if struct["ParameterFilters"] then asserts.AssertParameterStringFilterList(struct["ParameterFilters"]) end
	if struct["WithDecryption"] then asserts.AssertBoolean(struct["WithDecryption"]) end
	if struct["MaxResults"] then asserts.AssertGetParametersByPathMaxResults(struct["MaxResults"]) end
	if struct["Path"] then asserts.AssertPSParameterName(struct["Path"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParametersByPathRequest[k], "GetParametersByPathRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParametersByPathRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Recursive [Boolean] <p>Retrieve all parameters within a hierarchy.</p> <important> <p>If a user has access to a path, then the user can access all levels of that path. For example, if a user has permission to access path /a, then the user can also access /a/b. Even if a user has explicitly been denied access in IAM for parameter /a, they can still call the GetParametersByPath API action recursively and view /a/b.</p> </important>
-- * ParameterFilters [ParameterStringFilterList] <p>Filters to limit the request results.</p> <note> <p>You can't filter using the parameter name.</p> </note>
-- * WithDecryption [Boolean] <p>Retrieve all parameters in a hierarchy with their value decrypted.</p>
-- * MaxResults [GetParametersByPathMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Path [PSParameterName] <p>The hierarchy for the parameter. Hierarchies start with a forward slash (/) and end with the parameter name. A parameter name hierarchy can have a maximum of 15 levels. Here is an example of a hierarchy: <code>/Finance/Prod/IAD/WinServ2016/license33</code> </p>
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- Required key: Path
-- @return GetParametersByPathRequest structure as a key-value pair table
function M.GetParametersByPathRequest(args)
	assert(args, "You must provide an argument table when creating GetParametersByPathRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Recursive"] = args["Recursive"],
		["ParameterFilters"] = args["ParameterFilters"],
		["WithDecryption"] = args["WithDecryption"],
		["MaxResults"] = args["MaxResults"],
		["Path"] = args["Path"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertGetParametersByPathRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdatePatchBaselineRequest = { ["ApprovedPatchesEnableNonSecurity"] = true, ["BaselineId"] = true, ["Name"] = true, ["RejectedPatches"] = true, ["GlobalFilters"] = true, ["Sources"] = true, ["ApprovalRules"] = true, ["Description"] = true, ["Replace"] = true, ["ApprovedPatchesComplianceLevel"] = true, ["ApprovedPatches"] = true, ["RejectedPatchesAction"] = true, nil }

function asserts.AssertUpdatePatchBaselineRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdatePatchBaselineRequest to be of type 'table'")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	if struct["ApprovedPatchesEnableNonSecurity"] then asserts.AssertBoolean(struct["ApprovedPatchesEnableNonSecurity"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["Name"] then asserts.AssertBaselineName(struct["Name"]) end
	if struct["RejectedPatches"] then asserts.AssertPatchIdList(struct["RejectedPatches"]) end
	if struct["GlobalFilters"] then asserts.AssertPatchFilterGroup(struct["GlobalFilters"]) end
	if struct["Sources"] then asserts.AssertPatchSourceList(struct["Sources"]) end
	if struct["ApprovalRules"] then asserts.AssertPatchRuleGroup(struct["ApprovalRules"]) end
	if struct["Description"] then asserts.AssertBaselineDescription(struct["Description"]) end
	if struct["Replace"] then asserts.AssertBoolean(struct["Replace"]) end
	if struct["ApprovedPatchesComplianceLevel"] then asserts.AssertPatchComplianceLevel(struct["ApprovedPatchesComplianceLevel"]) end
	if struct["ApprovedPatches"] then asserts.AssertPatchIdList(struct["ApprovedPatches"]) end
	if struct["RejectedPatchesAction"] then asserts.AssertPatchAction(struct["RejectedPatchesAction"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdatePatchBaselineRequest[k], "UpdatePatchBaselineRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdatePatchBaselineRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ApprovedPatchesEnableNonSecurity [Boolean] <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline to update.</p>
-- * Name [BaselineName] <p>The name of the patch baseline.</p>
-- * RejectedPatches [PatchIdList] <p>A list of explicitly rejected patches for the baseline.</p> <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package Name Formats for Approved and Rejected Patch Lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * GlobalFilters [PatchFilterGroup] <p>A set of global filters used to exclude patches from the baseline.</p>
-- * Sources [PatchSourceList] <p>Information about the patches to use to update the instances, including target operating systems and source repositories. Applies to Linux instances only.</p>
-- * ApprovalRules [PatchRuleGroup] <p>A set of rules used to include patches in the baseline.</p>
-- * Description [BaselineDescription] <p>A description of the patch baseline.</p>
-- * Replace [Boolean] <p>If True, then all fields that are required by the CreatePatchBaseline action are also required for this API request. Optional fields that are not specified are set to null.</p>
-- * ApprovedPatchesComplianceLevel [PatchComplianceLevel] <p>Assigns a new compliance severity level to an existing patch baseline.</p>
-- * ApprovedPatches [PatchIdList] <p>A list of explicitly approved patches for the baseline.</p> <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package Name Formats for Approved and Rejected Patch Lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * RejectedPatchesAction [PatchAction] <p>The action for Patch Manager to take on patches included in the RejectedPackages list.</p> <ul> <li> <p> <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as <i>InstalledOther</i>. This is the default action if no option is specified.</p> </li> <li> <p> <b>BLOCK</b>: Packages in the RejectedPatches list, and packages that include them as dependencies, are not installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as <i>InstalledRejected</i>.</p> </li> </ul>
-- Required key: BaselineId
-- @return UpdatePatchBaselineRequest structure as a key-value pair table
function M.UpdatePatchBaselineRequest(args)
	assert(args, "You must provide an argument table when creating UpdatePatchBaselineRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ApprovedPatchesEnableNonSecurity"] = args["ApprovedPatchesEnableNonSecurity"],
		["BaselineId"] = args["BaselineId"],
		["Name"] = args["Name"],
		["RejectedPatches"] = args["RejectedPatches"],
		["GlobalFilters"] = args["GlobalFilters"],
		["Sources"] = args["Sources"],
		["ApprovalRules"] = args["ApprovalRules"],
		["Description"] = args["Description"],
		["Replace"] = args["Replace"],
		["ApprovedPatchesComplianceLevel"] = args["ApprovedPatchesComplianceLevel"],
		["ApprovedPatches"] = args["ApprovedPatches"],
		["RejectedPatchesAction"] = args["RejectedPatchesAction"],
	}
	asserts.AssertUpdatePatchBaselineRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Tag = { ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertTag(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Tag to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Value"], "Expected key Value to exist in table")
	if struct["Value"] then asserts.AssertTagValue(struct["Value"]) end
	if struct["Key"] then asserts.AssertTagKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.Tag[k], "Tag contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Tag
-- <p>Metadata that you assign to your AWS resources. Tags enable you to categorize your resources in different ways, for example, by purpose, owner, or environment. In Systems Manager, you can apply tags to documents, managed instances, Maintenance Windows, Parameter Store parameters, and patch baselines.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [TagValue] <p>The value of the tag.</p>
-- * Key [TagKey] <p>The name of the tag.</p>
-- Required key: Key
-- Required key: Value
-- @return Tag structure as a key-value pair table
function M.Tag(args)
	assert(args, "You must provide an argument table when creating Tag")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Value"] = args["Value"],
		["Key"] = args["Key"],
	}
	asserts.AssertTag(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchRuleGroup = { ["PatchRules"] = true, nil }

function asserts.AssertPatchRuleGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchRuleGroup to be of type 'table'")
	assert(struct["PatchRules"], "Expected key PatchRules to exist in table")
	if struct["PatchRules"] then asserts.AssertPatchRuleList(struct["PatchRules"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchRuleGroup[k], "PatchRuleGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchRuleGroup
-- <p>A set of rules defining the approval rules for a patch baseline.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchRules [PatchRuleList] <p>The rules that make up the rule group.</p>
-- Required key: PatchRules
-- @return PatchRuleGroup structure as a key-value pair table
function M.PatchRuleGroup(args)
	assert(args, "You must provide an argument table when creating PatchRuleGroup")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchRules"] = args["PatchRules"],
	}
	asserts.AssertPatchRuleGroup(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateMaintenanceWindowTaskResult = { ["ServiceRoleArn"] = true, ["LoggingInfo"] = true, ["MaxErrors"] = true, ["TaskArn"] = true, ["MaxConcurrency"] = true, ["WindowTaskId"] = true, ["TaskParameters"] = true, ["Priority"] = true, ["TaskInvocationParameters"] = true, ["WindowId"] = true, ["Description"] = true, ["Targets"] = true, ["Name"] = true, nil }

function asserts.AssertUpdateMaintenanceWindowTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateMaintenanceWindowTaskResult to be of type 'table'")
	if struct["ServiceRoleArn"] then asserts.AssertServiceRole(struct["ServiceRoleArn"]) end
	if struct["LoggingInfo"] then asserts.AssertLoggingInfo(struct["LoggingInfo"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["TaskArn"] then asserts.AssertMaintenanceWindowTaskArn(struct["TaskArn"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	if struct["TaskParameters"] then asserts.AssertMaintenanceWindowTaskParameters(struct["TaskParameters"]) end
	if struct["Priority"] then asserts.AssertMaintenanceWindowTaskPriority(struct["Priority"]) end
	if struct["TaskInvocationParameters"] then asserts.AssertMaintenanceWindowTaskInvocationParameters(struct["TaskInvocationParameters"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateMaintenanceWindowTaskResult[k], "UpdateMaintenanceWindowTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateMaintenanceWindowTaskResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceRoleArn [ServiceRole] <p>The updated service role ARN value.</p>
-- * LoggingInfo [LoggingInfo] <p>The updated logging information in Amazon S3.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * MaxErrors [MaxErrors] <p>The updated MaxErrors value.</p>
-- * TaskArn [MaintenanceWindowTaskArn] <p>The updated task ARN value.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The updated MaxConcurrency value.</p>
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The task ID of the Maintenance Window that was updated.</p>
-- * TaskParameters [MaintenanceWindowTaskParameters] <p>The updated parameter values.</p> <note> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * Priority [MaintenanceWindowTaskPriority] <p>The updated priority value.</p>
-- * TaskInvocationParameters [MaintenanceWindowTaskInvocationParameters] <p>The updated parameter values.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window that was updated.</p>
-- * Description [MaintenanceWindowDescription] <p>The updated task description.</p>
-- * Targets [Targets] <p>The updated target values.</p>
-- * Name [MaintenanceWindowName] <p>The updated task name.</p>
-- @return UpdateMaintenanceWindowTaskResult structure as a key-value pair table
function M.UpdateMaintenanceWindowTaskResult(args)
	assert(args, "You must provide an argument table when creating UpdateMaintenanceWindowTaskResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceRoleArn"] = args["ServiceRoleArn"],
		["LoggingInfo"] = args["LoggingInfo"],
		["MaxErrors"] = args["MaxErrors"],
		["TaskArn"] = args["TaskArn"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["WindowTaskId"] = args["WindowTaskId"],
		["TaskParameters"] = args["TaskParameters"],
		["Priority"] = args["Priority"],
		["TaskInvocationParameters"] = args["TaskInvocationParameters"],
		["WindowId"] = args["WindowId"],
		["Description"] = args["Description"],
		["Targets"] = args["Targets"],
		["Name"] = args["Name"],
	}
	asserts.AssertUpdateMaintenanceWindowTaskResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationExecutionFilter = { ["Type"] = true, ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertAssociationExecutionFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationExecutionFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Value"], "Expected key Value to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["Type"] then asserts.AssertAssociationFilterOperatorType(struct["Type"]) end
	if struct["Value"] then asserts.AssertAssociationExecutionFilterValue(struct["Value"]) end
	if struct["Key"] then asserts.AssertAssociationExecutionFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationExecutionFilter[k], "AssociationExecutionFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationExecutionFilter
-- <p>Filters used in the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [AssociationFilterOperatorType] <p>The filter type specified in the request.</p>
-- * Value [AssociationExecutionFilterValue] <p>The value specified for the key.</p>
-- * Key [AssociationExecutionFilterKey] <p>The key value used in the request.</p>
-- Required key: Key
-- Required key: Value
-- Required key: Type
-- @return AssociationExecutionFilter structure as a key-value pair table
function M.AssociationExecutionFilter(args)
	assert(args, "You must provide an argument table when creating AssociationExecutionFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
		["Value"] = args["Value"],
		["Key"] = args["Key"],
	}
	asserts.AssertAssociationExecutionFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListComplianceSummariesRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertListComplianceSummariesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListComplianceSummariesRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertComplianceStringFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListComplianceSummariesRequest[k], "ListComplianceSummariesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListComplianceSummariesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. Currently, you can specify null or 50. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [ComplianceStringFilterList] <p>One or more compliance or inventory filters. Use a filter to return a more specific list of results.</p>
-- @return ListComplianceSummariesRequest structure as a key-value pair table
function M.ListComplianceSummariesRequest(args)
	assert(args, "You must provide an argument table when creating ListComplianceSummariesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertListComplianceSummariesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParameterResult = { ["Parameter"] = true, nil }

function asserts.AssertGetParameterResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParameterResult to be of type 'table'")
	if struct["Parameter"] then asserts.AssertParameter(struct["Parameter"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParameterResult[k], "GetParameterResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParameterResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Parameter [Parameter] <p>Information about a parameter.</p>
-- @return GetParameterResult structure as a key-value pair table
function M.GetParameterResult(args)
	assert(args, "You must provide an argument table when creating GetParameterResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Parameter"] = args["Parameter"],
	}
	asserts.AssertGetParameterResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FailureDetails = { ["FailureStage"] = true, ["FailureType"] = true, ["Details"] = true, nil }

function asserts.AssertFailureDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FailureDetails to be of type 'table'")
	if struct["FailureStage"] then asserts.AssertString(struct["FailureStage"]) end
	if struct["FailureType"] then asserts.AssertString(struct["FailureType"]) end
	if struct["Details"] then asserts.AssertAutomationParameterMap(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(keys.FailureDetails[k], "FailureDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FailureDetails
-- <p>Information about an Automation failure.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FailureStage [String] <p>The stage of the Automation execution when the failure occurred. The stages include the following: InputValidation, PreVerification, Invocation, PostVerification.</p>
-- * FailureType [String] <p>The type of Automation failure. Failure types include the following: Action, Permission, Throttling, Verification, Internal.</p>
-- * Details [AutomationParameterMap] <p>Detailed information about the Automation step failure.</p>
-- @return FailureDetails structure as a key-value pair table
function M.FailureDetails(args)
	assert(args, "You must provide an argument table when creating FailureDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FailureStage"] = args["FailureStage"],
		["FailureType"] = args["FailureType"],
		["Details"] = args["Details"],
	}
	asserts.AssertFailureDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCommandInvocationsResult = { ["NextToken"] = true, ["CommandInvocations"] = true, nil }

function asserts.AssertListCommandInvocationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCommandInvocationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["CommandInvocations"] then asserts.AssertCommandInvocationList(struct["CommandInvocations"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCommandInvocationsResult[k], "ListCommandInvocationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCommandInvocationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>(Optional) The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * CommandInvocations [CommandInvocationList] <p>(Optional) A list of all invocations. </p>
-- @return ListCommandInvocationsResult structure as a key-value pair table
function M.ListCommandInvocationsResult(args)
	assert(args, "You must provide an argument table when creating ListCommandInvocationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["CommandInvocations"] = args["CommandInvocations"],
	}
	asserts.AssertListCommandInvocationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPatchBaselineForPatchGroupRequest = { ["PatchGroup"] = true, ["OperatingSystem"] = true, nil }

function asserts.AssertGetPatchBaselineForPatchGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPatchBaselineForPatchGroupRequest to be of type 'table'")
	assert(struct["PatchGroup"], "Expected key PatchGroup to exist in table")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPatchBaselineForPatchGroupRequest[k], "GetPatchBaselineForPatchGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPatchBaselineForPatchGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group whose patch baseline should be retrieved.</p>
-- * OperatingSystem [OperatingSystem] <p>Returns he operating system rule specified for patch groups using the patch baseline.</p>
-- Required key: PatchGroup
-- @return GetPatchBaselineForPatchGroupRequest structure as a key-value pair table
function M.GetPatchBaselineForPatchGroupRequest(args)
	assert(args, "You must provide an argument table when creating GetPatchBaselineForPatchGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["OperatingSystem"] = args["OperatingSystem"],
	}
	asserts.AssertGetPatchBaselineForPatchGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowsResult = { ["WindowIdentities"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowsResult to be of type 'table'")
	if struct["WindowIdentities"] then asserts.AssertMaintenanceWindowIdentityList(struct["WindowIdentities"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowsResult[k], "DescribeMaintenanceWindowsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowIdentities [MaintenanceWindowIdentityList] <p>Information about the Maintenance Windows.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeMaintenanceWindowsResult structure as a key-value pair table
function M.DescribeMaintenanceWindowsResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowIdentities"] = args["WindowIdentities"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMaintenanceWindowsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeletePatchBaselineRequest = { ["BaselineId"] = true, nil }

function asserts.AssertDeletePatchBaselineRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePatchBaselineRequest to be of type 'table'")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeletePatchBaselineRequest[k], "DeletePatchBaselineRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePatchBaselineRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineId [BaselineId] <p>The ID of the patch baseline to delete.</p>
-- Required key: BaselineId
-- @return DeletePatchBaselineRequest structure as a key-value pair table
function M.DeletePatchBaselineRequest(args)
	assert(args, "You must provide an argument table when creating DeletePatchBaselineRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertDeletePatchBaselineRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ComplianceItem = { ["Status"] = true, ["Severity"] = true, ["Title"] = true, ["ResourceType"] = true, ["ResourceId"] = true, ["ComplianceType"] = true, ["Details"] = true, ["ExecutionSummary"] = true, ["Id"] = true, nil }

function asserts.AssertComplianceItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ComplianceItem to be of type 'table'")
	if struct["Status"] then asserts.AssertComplianceStatus(struct["Status"]) end
	if struct["Severity"] then asserts.AssertComplianceSeverity(struct["Severity"]) end
	if struct["Title"] then asserts.AssertComplianceItemTitle(struct["Title"]) end
	if struct["ResourceType"] then asserts.AssertComplianceResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertComplianceResourceId(struct["ResourceId"]) end
	if struct["ComplianceType"] then asserts.AssertComplianceTypeName(struct["ComplianceType"]) end
	if struct["Details"] then asserts.AssertComplianceItemDetails(struct["Details"]) end
	if struct["ExecutionSummary"] then asserts.AssertComplianceExecutionSummary(struct["ExecutionSummary"]) end
	if struct["Id"] then asserts.AssertComplianceItemId(struct["Id"]) end
	for k,_ in pairs(struct) do
		assert(keys.ComplianceItem[k], "ComplianceItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ComplianceItem
-- <p>Information about the compliance as defined by the resource type. For example, for a patch resource type, <code>Items</code> includes information about the PatchSeverity, Classification, etc.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [ComplianceStatus] <p>The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.</p>
-- * Severity [ComplianceSeverity] <p>The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.</p>
-- * Title [ComplianceItemTitle] <p>A title for the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services.</p>
-- * ResourceType [ComplianceResourceType] <p>The type of resource. <code>ManagedInstance</code> is currently the only supported resource type.</p>
-- * ResourceId [ComplianceResourceId] <p>An ID for the resource. For a managed instance, this is the instance ID.</p>
-- * ComplianceType [ComplianceTypeName] <p>The compliance type. For example, Association (for a State Manager association), Patch, or Custom:<code>string</code> are all valid compliance types.</p>
-- * Details [ComplianceItemDetails] <p>A "Key": "Value" tag combination for the compliance item.</p>
-- * ExecutionSummary [ComplianceExecutionSummary] <p>A summary for the compliance item. The summary includes an execution ID, the execution type (for example, command), and the execution time.</p>
-- * Id [ComplianceItemId] <p>An ID for the compliance item. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article; for example: KB4010320.</p>
-- @return ComplianceItem structure as a key-value pair table
function M.ComplianceItem(args)
	assert(args, "You must provide an argument table when creating ComplianceItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Severity"] = args["Severity"],
		["Title"] = args["Title"],
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["ComplianceType"] = args["ComplianceType"],
		["Details"] = args["Details"],
		["ExecutionSummary"] = args["ExecutionSummary"],
		["Id"] = args["Id"],
	}
	asserts.AssertComplianceItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateAssociationBatchRequest = { ["Entries"] = true, nil }

function asserts.AssertCreateAssociationBatchRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateAssociationBatchRequest to be of type 'table'")
	assert(struct["Entries"], "Expected key Entries to exist in table")
	if struct["Entries"] then asserts.AssertCreateAssociationBatchRequestEntries(struct["Entries"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateAssociationBatchRequest[k], "CreateAssociationBatchRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateAssociationBatchRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Entries [CreateAssociationBatchRequestEntries] <p>One or more associations.</p>
-- Required key: Entries
-- @return CreateAssociationBatchRequest structure as a key-value pair table
function M.CreateAssociationBatchRequest(args)
	assert(args, "You must provide an argument table when creating CreateAssociationBatchRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Entries"] = args["Entries"],
	}
	asserts.AssertCreateAssociationBatchRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowExecutionTasksRequest = { ["NextToken"] = true, ["WindowExecutionId"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowExecutionTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowExecutionTasksRequest to be of type 'table'")
	assert(struct["WindowExecutionId"], "Expected key WindowExecutionId to exist in table")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertMaintenanceWindowFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowExecutionTasksRequest[k], "DescribeMaintenanceWindowExecutionTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowExecutionTasksRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution whose task executions should be retrieved.</p>
-- * MaxResults [MaintenanceWindowMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [MaintenanceWindowFilterList] <p>Optional filters used to scope down the returned tasks. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED. </p>
-- Required key: WindowExecutionId
-- @return DescribeMaintenanceWindowExecutionTasksRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowExecutionTasksRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowExecutionTasksRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeMaintenanceWindowExecutionTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePatchGroupsRequest = { ["NextToken"] = true, ["Filters"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribePatchGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePatchGroupsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Filters"] then asserts.AssertPatchOrchestratorFilterList(struct["Filters"]) end
	if struct["MaxResults"] then asserts.AssertPatchBaselineMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePatchGroupsRequest[k], "DescribePatchGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePatchGroupsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * Filters [PatchOrchestratorFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- * MaxResults [PatchBaselineMaxResults] <p>The maximum number of patch groups to return (per page).</p>
-- @return DescribePatchGroupsRequest structure as a key-value pair table
function M.DescribePatchGroupsRequest(args)
	assert(args, "You must provide an argument table when creating DescribePatchGroupsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Filters"] = args["Filters"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribePatchGroupsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SessionManagerOutputUrl = { ["S3OutputUrl"] = true, ["CloudWatchOutputUrl"] = true, nil }

function asserts.AssertSessionManagerOutputUrl(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SessionManagerOutputUrl to be of type 'table'")
	if struct["S3OutputUrl"] then asserts.AssertSessionManagerS3OutputUrl(struct["S3OutputUrl"]) end
	if struct["CloudWatchOutputUrl"] then asserts.AssertSessionManagerCloudWatchOutputUrl(struct["CloudWatchOutputUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.SessionManagerOutputUrl[k], "SessionManagerOutputUrl contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SessionManagerOutputUrl
-- <p>Reserved for future use.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3OutputUrl [SessionManagerS3OutputUrl] <p>Reserved for future use.</p>
-- * CloudWatchOutputUrl [SessionManagerCloudWatchOutputUrl] <p>Reserved for future use.</p>
-- @return SessionManagerOutputUrl structure as a key-value pair table
function M.SessionManagerOutputUrl(args)
	assert(args, "You must provide an argument table when creating SessionManagerOutputUrl")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3OutputUrl"] = args["S3OutputUrl"],
		["CloudWatchOutputUrl"] = args["CloudWatchOutputUrl"],
	}
	asserts.AssertSessionManagerOutputUrl(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTagsForResourceRequest = { ["ResourceType"] = true, ["ResourceId"] = true, nil }

function asserts.AssertListTagsForResourceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTagsForResourceRequest to be of type 'table'")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["ResourceId"], "Expected key ResourceId to exist in table")
	if struct["ResourceType"] then asserts.AssertResourceTypeForTagging(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertResourceId(struct["ResourceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTagsForResourceRequest[k], "ListTagsForResourceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTagsForResourceRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceTypeForTagging] <p>Returns a list of tags for a specific resource type.</p>
-- * ResourceId [ResourceId] <p>The resource ID for which you want to see a list of tags.</p>
-- Required key: ResourceType
-- Required key: ResourceId
-- @return ListTagsForResourceRequest structure as a key-value pair table
function M.ListTagsForResourceRequest(args)
	assert(args, "You must provide an argument table when creating ListTagsForResourceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
	}
	asserts.AssertListTagsForResourceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAssociationExecutionsRequest = { ["AssociationId"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAssociationExecutionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAssociationExecutionsRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertAssociationExecutionFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAssociationExecutionsRequest[k], "DescribeAssociationExecutionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAssociationExecutionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [AssociationId] <p>The association ID for which you want to view execution history details.</p>
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [AssociationExecutionFilterList] <p>Filters for the request. You can specify the following filters and values.</p> <p>ExecutionId (EQUAL)</p> <p>Status (EQUAL)</p> <p>CreatedTime (EQUAL, GREATER_THAN, LESS_THAN)</p>
-- Required key: AssociationId
-- @return DescribeAssociationExecutionsRequest structure as a key-value pair table
function M.DescribeAssociationExecutionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAssociationExecutionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeAssociationExecutionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowExecutionsRequest = { ["WindowId"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowExecutionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowExecutionsRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertMaintenanceWindowFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowExecutionsRequest[k], "DescribeMaintenanceWindowExecutionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowExecutionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window whose executions should be retrieved.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaintenanceWindowMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [MaintenanceWindowFilterList] <p>Each entry in the array is a structure containing:</p> <p>Key (string, between 1 and 128 characters)</p> <p>Values (array of strings, each string is between 1 and 256 characters)</p> <p>The supported Keys are ExecutedBefore and ExecutedAfter with the value being a date/time string such as 2016-11-04T05:00:00Z.</p>
-- Required key: WindowId
-- @return DescribeMaintenanceWindowExecutionsRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowExecutionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowExecutionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeMaintenanceWindowExecutionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AutomationExecutionMetadata = { ["AutomationExecutionStatus"] = true, ["CurrentStepName"] = true, ["ParentAutomationExecutionId"] = true, ["MaxErrors"] = true, ["Outputs"] = true, ["DocumentName"] = true, ["AutomationExecutionId"] = true, ["FailureMessage"] = true, ["ExecutionEndTime"] = true, ["ResolvedTargets"] = true, ["MaxConcurrency"] = true, ["DocumentVersion"] = true, ["Target"] = true, ["ExecutionStartTime"] = true, ["CurrentAction"] = true, ["ExecutedBy"] = true, ["LogFile"] = true, ["TargetMaps"] = true, ["Targets"] = true, ["TargetParameterName"] = true, ["Mode"] = true, nil }

function asserts.AssertAutomationExecutionMetadata(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AutomationExecutionMetadata to be of type 'table'")
	if struct["AutomationExecutionStatus"] then asserts.AssertAutomationExecutionStatus(struct["AutomationExecutionStatus"]) end
	if struct["CurrentStepName"] then asserts.AssertString(struct["CurrentStepName"]) end
	if struct["ParentAutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["ParentAutomationExecutionId"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["Outputs"] then asserts.AssertAutomationParameterMap(struct["Outputs"]) end
	if struct["DocumentName"] then asserts.AssertDocumentName(struct["DocumentName"]) end
	if struct["AutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["AutomationExecutionId"]) end
	if struct["FailureMessage"] then asserts.AssertString(struct["FailureMessage"]) end
	if struct["ExecutionEndTime"] then asserts.AssertDateTime(struct["ExecutionEndTime"]) end
	if struct["ResolvedTargets"] then asserts.AssertResolvedTargets(struct["ResolvedTargets"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["Target"] then asserts.AssertString(struct["Target"]) end
	if struct["ExecutionStartTime"] then asserts.AssertDateTime(struct["ExecutionStartTime"]) end
	if struct["CurrentAction"] then asserts.AssertString(struct["CurrentAction"]) end
	if struct["ExecutedBy"] then asserts.AssertString(struct["ExecutedBy"]) end
	if struct["LogFile"] then asserts.AssertString(struct["LogFile"]) end
	if struct["TargetMaps"] then asserts.AssertTargetMaps(struct["TargetMaps"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["TargetParameterName"] then asserts.AssertAutomationParameterKey(struct["TargetParameterName"]) end
	if struct["Mode"] then asserts.AssertExecutionMode(struct["Mode"]) end
	for k,_ in pairs(struct) do
		assert(keys.AutomationExecutionMetadata[k], "AutomationExecutionMetadata contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AutomationExecutionMetadata
-- <p>Details about a specific Automation execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutomationExecutionStatus [AutomationExecutionStatus] <p>The status of the execution. Valid values include: Running, Succeeded, Failed, Timed out, or Cancelled.</p>
-- * CurrentStepName [String] <p>The name of the currently executing step.</p>
-- * ParentAutomationExecutionId [AutomationExecutionId] <p>The ExecutionId of the parent Automation.</p>
-- * MaxErrors [MaxErrors] <p>The MaxErrors value specified by the user when starting the Automation.</p>
-- * Outputs [AutomationParameterMap] <p>The list of execution outputs as defined in the Automation document.</p>
-- * DocumentName [DocumentName] <p>The name of the Automation document used during execution.</p>
-- * AutomationExecutionId [AutomationExecutionId] <p>The execution ID.</p>
-- * FailureMessage [String] <p>The list of execution outputs as defined in the Automation document.</p>
-- * ExecutionEndTime [DateTime] <p>The time the execution finished. This is not populated if the execution is still in progress.</p>
-- * ResolvedTargets [ResolvedTargets] <p>A list of targets that resolved during the execution.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The MaxConcurrency value specified by the user when starting the Automation.</p>
-- * DocumentVersion [DocumentVersion] <p>The document version used during the execution.</p>
-- * Target [String] <p>The list of execution outputs as defined in the Automation document.</p>
-- * ExecutionStartTime [DateTime] <p>The time the execution started.&gt;</p>
-- * CurrentAction [String] <p>The action of the currently executing step.</p>
-- * ExecutedBy [String] <p>The IAM role ARN of the user who executed the Automation.</p>
-- * LogFile [String] <p>An Amazon S3 bucket where execution information is stored.</p>
-- * TargetMaps [TargetMaps] <p>The specified key-value mapping of document parameters to target resources.</p>
-- * Targets [Targets] <p>The targets defined by the user when starting the Automation.</p>
-- * TargetParameterName [AutomationParameterKey] <p>The list of execution outputs as defined in the Automation document.</p>
-- * Mode [ExecutionMode] <p>The Automation execution mode.</p>
-- @return AutomationExecutionMetadata structure as a key-value pair table
function M.AutomationExecutionMetadata(args)
	assert(args, "You must provide an argument table when creating AutomationExecutionMetadata")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutomationExecutionStatus"] = args["AutomationExecutionStatus"],
		["CurrentStepName"] = args["CurrentStepName"],
		["ParentAutomationExecutionId"] = args["ParentAutomationExecutionId"],
		["MaxErrors"] = args["MaxErrors"],
		["Outputs"] = args["Outputs"],
		["DocumentName"] = args["DocumentName"],
		["AutomationExecutionId"] = args["AutomationExecutionId"],
		["FailureMessage"] = args["FailureMessage"],
		["ExecutionEndTime"] = args["ExecutionEndTime"],
		["ResolvedTargets"] = args["ResolvedTargets"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["DocumentVersion"] = args["DocumentVersion"],
		["Target"] = args["Target"],
		["ExecutionStartTime"] = args["ExecutionStartTime"],
		["CurrentAction"] = args["CurrentAction"],
		["ExecutedBy"] = args["ExecutedBy"],
		["LogFile"] = args["LogFile"],
		["TargetMaps"] = args["TargetMaps"],
		["Targets"] = args["Targets"],
		["TargetParameterName"] = args["TargetParameterName"],
		["Mode"] = args["Mode"],
	}
	asserts.AssertAutomationExecutionMetadata(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceInformation = { ["IsLatestVersion"] = true, ["IamRole"] = true, ["ComputerName"] = true, ["AssociationOverview"] = true, ["PingStatus"] = true, ["Name"] = true, ["LastSuccessfulAssociationExecutionDate"] = true, ["InstanceId"] = true, ["IPAddress"] = true, ["AssociationStatus"] = true, ["LastAssociationExecutionDate"] = true, ["ResourceType"] = true, ["ActivationId"] = true, ["AgentVersion"] = true, ["PlatformVersion"] = true, ["RegistrationDate"] = true, ["PlatformName"] = true, ["PlatformType"] = true, ["LastPingDateTime"] = true, nil }

function asserts.AssertInstanceInformation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceInformation to be of type 'table'")
	if struct["IsLatestVersion"] then asserts.AssertBoolean(struct["IsLatestVersion"]) end
	if struct["IamRole"] then asserts.AssertIamRole(struct["IamRole"]) end
	if struct["ComputerName"] then asserts.AssertComputerName(struct["ComputerName"]) end
	if struct["AssociationOverview"] then asserts.AssertInstanceAggregatedAssociationOverview(struct["AssociationOverview"]) end
	if struct["PingStatus"] then asserts.AssertPingStatus(struct["PingStatus"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["LastSuccessfulAssociationExecutionDate"] then asserts.AssertDateTime(struct["LastSuccessfulAssociationExecutionDate"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["IPAddress"] then asserts.AssertIPAddress(struct["IPAddress"]) end
	if struct["AssociationStatus"] then asserts.AssertStatusName(struct["AssociationStatus"]) end
	if struct["LastAssociationExecutionDate"] then asserts.AssertDateTime(struct["LastAssociationExecutionDate"]) end
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["ActivationId"] then asserts.AssertActivationId(struct["ActivationId"]) end
	if struct["AgentVersion"] then asserts.AssertVersion(struct["AgentVersion"]) end
	if struct["PlatformVersion"] then asserts.AssertString(struct["PlatformVersion"]) end
	if struct["RegistrationDate"] then asserts.AssertDateTime(struct["RegistrationDate"]) end
	if struct["PlatformName"] then asserts.AssertString(struct["PlatformName"]) end
	if struct["PlatformType"] then asserts.AssertPlatformType(struct["PlatformType"]) end
	if struct["LastPingDateTime"] then asserts.AssertDateTime(struct["LastPingDateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceInformation[k], "InstanceInformation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceInformation
-- <p>Describes a filter for a specific list of instances. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IsLatestVersion [Boolean] <p>Indicates whether latest version of SSM Agent is running on your instance. Some older versions of Windows Server use the EC2Config service to process SSM requests. For this reason, this field does not indicate whether or not the latest version is installed on Windows managed instances.</p>
-- * IamRole [IamRole] <p>The Amazon Identity and Access Management (IAM) role assigned to the on-premises Systems Manager managed instances. This call does not return the IAM role for Amazon EC2 instances. </p>
-- * ComputerName [ComputerName] <p>The fully qualified host name of the managed instance.</p>
-- * AssociationOverview [InstanceAggregatedAssociationOverview] <p>Information about the association.</p>
-- * PingStatus [PingStatus] <p>Connection status of SSM Agent. </p>
-- * Name [String] <p>The name of the managed instance.</p>
-- * LastSuccessfulAssociationExecutionDate [DateTime] <p>The last date the association was successfully run.</p>
-- * InstanceId [InstanceId] <p>The instance ID. </p>
-- * IPAddress [IPAddress] <p>The IP address of the managed instance.</p>
-- * AssociationStatus [StatusName] <p>The status of the association.</p>
-- * LastAssociationExecutionDate [DateTime] <p>The date the association was last executed.</p>
-- * ResourceType [ResourceType] <p>The type of instance. Instances are either EC2 instances or managed instances. </p>
-- * ActivationId [ActivationId] <p>The activation ID created by Systems Manager when the server or VM was registered.</p>
-- * AgentVersion [Version] <p>The version of SSM Agent running on your Linux instance. </p>
-- * PlatformVersion [String] <p>The version of the OS platform running on your instance. </p>
-- * RegistrationDate [DateTime] <p>The date the server or VM was registered with AWS as a managed instance.</p>
-- * PlatformName [String] <p>The name of the operating system platform running on your instance. </p>
-- * PlatformType [PlatformType] <p>The operating system platform type. </p>
-- * LastPingDateTime [DateTime] <p>The date and time when agent last pinged Systems Manager service. </p>
-- @return InstanceInformation structure as a key-value pair table
function M.InstanceInformation(args)
	assert(args, "You must provide an argument table when creating InstanceInformation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IsLatestVersion"] = args["IsLatestVersion"],
		["IamRole"] = args["IamRole"],
		["ComputerName"] = args["ComputerName"],
		["AssociationOverview"] = args["AssociationOverview"],
		["PingStatus"] = args["PingStatus"],
		["Name"] = args["Name"],
		["LastSuccessfulAssociationExecutionDate"] = args["LastSuccessfulAssociationExecutionDate"],
		["InstanceId"] = args["InstanceId"],
		["IPAddress"] = args["IPAddress"],
		["AssociationStatus"] = args["AssociationStatus"],
		["LastAssociationExecutionDate"] = args["LastAssociationExecutionDate"],
		["ResourceType"] = args["ResourceType"],
		["ActivationId"] = args["ActivationId"],
		["AgentVersion"] = args["AgentVersion"],
		["PlatformVersion"] = args["PlatformVersion"],
		["RegistrationDate"] = args["RegistrationDate"],
		["PlatformName"] = args["PlatformName"],
		["PlatformType"] = args["PlatformType"],
		["LastPingDateTime"] = args["LastPingDateTime"],
	}
	asserts.AssertInstanceInformation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Association = { ["ScheduleExpression"] = true, ["Name"] = true, ["LastExecutionDate"] = true, ["InstanceId"] = true, ["Overview"] = true, ["AssociationId"] = true, ["DocumentVersion"] = true, ["AssociationVersion"] = true, ["AssociationName"] = true, ["Targets"] = true, nil }

function asserts.AssertAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Association to be of type 'table'")
	if struct["ScheduleExpression"] then asserts.AssertScheduleExpression(struct["ScheduleExpression"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["LastExecutionDate"] then asserts.AssertDateTime(struct["LastExecutionDate"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["Overview"] then asserts.AssertAssociationOverview(struct["Overview"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	if struct["AssociationName"] then asserts.AssertAssociationName(struct["AssociationName"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	for k,_ in pairs(struct) do
		assert(keys.Association[k], "Association contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Association
-- <p>Describes an association of a Systems Manager document and an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduleExpression [ScheduleExpression] <p>A cron expression that specifies a schedule when the association runs.</p>
-- * Name [DocumentName] <p>The name of the Systems Manager document.</p>
-- * LastExecutionDate [DateTime] <p>The date on which the association was last run.</p>
-- * InstanceId [InstanceId] <p>The ID of the instance.</p>
-- * Overview [AssociationOverview] <p>Information about the association.</p>
-- * AssociationId [AssociationId] <p>The ID created by the system when you create an association. An association is a binding between a document and a set of targets with a schedule.</p>
-- * DocumentVersion [DocumentVersion] <p>The version of the document used in the association.</p>
-- * AssociationVersion [AssociationVersion] <p>The association version.</p>
-- * AssociationName [AssociationName] <p>The association name.</p>
-- * Targets [Targets] <p>The instances targeted by the request to create an association. </p>
-- @return Association structure as a key-value pair table
function M.Association(args)
	assert(args, "You must provide an argument table when creating Association")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ScheduleExpression"] = args["ScheduleExpression"],
		["Name"] = args["Name"],
		["LastExecutionDate"] = args["LastExecutionDate"],
		["InstanceId"] = args["InstanceId"],
		["Overview"] = args["Overview"],
		["AssociationId"] = args["AssociationId"],
		["DocumentVersion"] = args["DocumentVersion"],
		["AssociationVersion"] = args["AssociationVersion"],
		["AssociationName"] = args["AssociationName"],
		["Targets"] = args["Targets"],
	}
	asserts.AssertAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SendAutomationSignalRequest = { ["AutomationExecutionId"] = true, ["Payload"] = true, ["SignalType"] = true, nil }

function asserts.AssertSendAutomationSignalRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SendAutomationSignalRequest to be of type 'table'")
	assert(struct["AutomationExecutionId"], "Expected key AutomationExecutionId to exist in table")
	assert(struct["SignalType"], "Expected key SignalType to exist in table")
	if struct["AutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["AutomationExecutionId"]) end
	if struct["Payload"] then asserts.AssertAutomationParameterMap(struct["Payload"]) end
	if struct["SignalType"] then asserts.AssertSignalType(struct["SignalType"]) end
	for k,_ in pairs(struct) do
		assert(keys.SendAutomationSignalRequest[k], "SendAutomationSignalRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SendAutomationSignalRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutomationExecutionId [AutomationExecutionId] <p>The unique identifier for an existing Automation execution that you want to send the signal to.</p>
-- * Payload [AutomationParameterMap] <p>The data sent with the signal. The data schema depends on the type of signal used in the request. </p>
-- * SignalType [SignalType] <p>The type of signal. Valid signal types include the following: Approve and Reject </p>
-- Required key: AutomationExecutionId
-- Required key: SignalType
-- @return SendAutomationSignalRequest structure as a key-value pair table
function M.SendAutomationSignalRequest(args)
	assert(args, "You must provide an argument table when creating SendAutomationSignalRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutomationExecutionId"] = args["AutomationExecutionId"],
		["Payload"] = args["Payload"],
		["SignalType"] = args["SignalType"],
	}
	asserts.AssertSendAutomationSignalRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteActivationRequest = { ["ActivationId"] = true, nil }

function asserts.AssertDeleteActivationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteActivationRequest to be of type 'table'")
	assert(struct["ActivationId"], "Expected key ActivationId to exist in table")
	if struct["ActivationId"] then asserts.AssertActivationId(struct["ActivationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteActivationRequest[k], "DeleteActivationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteActivationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ActivationId [ActivationId] <p>The ID of the activation that you want to delete.</p>
-- Required key: ActivationId
-- @return DeleteActivationRequest structure as a key-value pair table
function M.DeleteActivationRequest(args)
	assert(args, "You must provide an argument table when creating DeleteActivationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ActivationId"] = args["ActivationId"],
	}
	asserts.AssertDeleteActivationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryItemSchema = { ["TypeName"] = true, ["Version"] = true, ["DisplayName"] = true, ["Attributes"] = true, nil }

function asserts.AssertInventoryItemSchema(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryItemSchema to be of type 'table'")
	assert(struct["TypeName"], "Expected key TypeName to exist in table")
	assert(struct["Attributes"], "Expected key Attributes to exist in table")
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["Version"] then asserts.AssertInventoryItemSchemaVersion(struct["Version"]) end
	if struct["DisplayName"] then asserts.AssertInventoryTypeDisplayName(struct["DisplayName"]) end
	if struct["Attributes"] then asserts.AssertInventoryItemAttributeList(struct["Attributes"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryItemSchema[k], "InventoryItemSchema contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryItemSchema
-- <p>The inventory item schema definition. Users can use this to compose inventory query filters.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TypeName [InventoryItemTypeName] <p>The name of the inventory type. Default inventory item type names start with AWS. Custom inventory type names will start with Custom. Default inventory item types include the following: AWS:AWSComponent, AWS:Application, AWS:InstanceInformation, AWS:Network, and AWS:WindowsUpdate.</p>
-- * Version [InventoryItemSchemaVersion] <p>The schema version for the inventory item.</p>
-- * DisplayName [InventoryTypeDisplayName] <p>The alias name of the inventory type. The alias name is used for display purposes.</p>
-- * Attributes [InventoryItemAttributeList] <p>The schema attributes for inventory. This contains data type and attribute name.</p>
-- Required key: TypeName
-- Required key: Attributes
-- @return InventoryItemSchema structure as a key-value pair table
function M.InventoryItemSchema(args)
	assert(args, "You must provide an argument table when creating InventoryItemSchema")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TypeName"] = args["TypeName"],
		["Version"] = args["Version"],
		["DisplayName"] = args["DisplayName"],
		["Attributes"] = args["Attributes"],
	}
	asserts.AssertInventoryItemSchema(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowIdentityForTarget = { ["WindowId"] = true, ["Name"] = true, nil }

function asserts.AssertMaintenanceWindowIdentityForTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowIdentityForTarget to be of type 'table'")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowIdentityForTarget[k], "MaintenanceWindowIdentityForTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowIdentityForTarget
-- <p>The Maintenance Window to which the specified target belongs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window.</p>
-- * Name [MaintenanceWindowName] <p>The name of the Maintenance Window.</p>
-- @return MaintenanceWindowIdentityForTarget structure as a key-value pair table
function M.MaintenanceWindowIdentityForTarget(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowIdentityForTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
		["Name"] = args["Name"],
	}
	asserts.AssertMaintenanceWindowIdentityForTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteMaintenanceWindowResult = { ["WindowId"] = true, nil }

function asserts.AssertDeleteMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteMaintenanceWindowResult to be of type 'table'")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteMaintenanceWindowResult[k], "DeleteMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the deleted Maintenance Window.</p>
-- @return DeleteMaintenanceWindowResult structure as a key-value pair table
function M.DeleteMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating DeleteMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
	}
	asserts.AssertDeleteMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancePatchStatesResult = { ["InstancePatchStates"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstancePatchStatesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancePatchStatesResult to be of type 'table'")
	if struct["InstancePatchStates"] then asserts.AssertInstancePatchStateList(struct["InstancePatchStates"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancePatchStatesResult[k], "DescribeInstancePatchStatesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancePatchStatesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstancePatchStates [InstancePatchStateList] <p>The high-level patch state for the requested instances.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeInstancePatchStatesResult structure as a key-value pair table
function M.DescribeInstancePatchStatesResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstancePatchStatesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstancePatchStates"] = args["InstancePatchStates"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstancePatchStatesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstancePatchStateFilter = { ["Type"] = true, ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertInstancePatchStateFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstancePatchStateFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Values"], "Expected key Values to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["Type"] then asserts.AssertInstancePatchStateOperatorType(struct["Type"]) end
	if struct["Values"] then asserts.AssertInstancePatchStateFilterValues(struct["Values"]) end
	if struct["Key"] then asserts.AssertInstancePatchStateFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstancePatchStateFilter[k], "InstancePatchStateFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstancePatchStateFilter
-- <p>Defines a filter used in DescribeInstancePatchStatesForPatchGroup used to scope down the information returned by the API.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [InstancePatchStateOperatorType] <p>The type of comparison that should be performed for the value: Equal, NotEqual, LessThan or GreaterThan.</p>
-- * Values [InstancePatchStateFilterValues] <p>The value for the filter, must be an integer greater than or equal to 0.</p>
-- * Key [InstancePatchStateFilterKey] <p>The key for the filter. Supported values are FailedCount, InstalledCount, InstalledOtherCount, MissingCount and NotApplicableCount.</p>
-- Required key: Key
-- Required key: Values
-- Required key: Type
-- @return InstancePatchStateFilter structure as a key-value pair table
function M.InstancePatchStateFilter(args)
	assert(args, "You must provide an argument table when creating InstancePatchStateFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertInstancePatchStateFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParameterHistoryResult = { ["NextToken"] = true, ["Parameters"] = true, nil }

function asserts.AssertGetParameterHistoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParameterHistoryResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Parameters"] then asserts.AssertParameterHistoryList(struct["Parameters"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParameterHistoryResult[k], "GetParameterHistoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParameterHistoryResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * Parameters [ParameterHistoryList] <p>A list of parameters returned by the request.</p>
-- @return GetParameterHistoryResult structure as a key-value pair table
function M.GetParameterHistoryResult(args)
	assert(args, "You must provide an argument table when creating GetParameterHistoryResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Parameters"] = args["Parameters"],
	}
	asserts.AssertGetParameterHistoryResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CompliantSummary = { ["SeveritySummary"] = true, ["CompliantCount"] = true, nil }

function asserts.AssertCompliantSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CompliantSummary to be of type 'table'")
	if struct["SeveritySummary"] then asserts.AssertSeveritySummary(struct["SeveritySummary"]) end
	if struct["CompliantCount"] then asserts.AssertComplianceSummaryCount(struct["CompliantCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.CompliantSummary[k], "CompliantSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CompliantSummary
-- <p>A summary of resources that are compliant. The summary is organized according to the resource count for each compliance type.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SeveritySummary [SeveritySummary] <p>A summary of the compliance severity by compliance type.</p>
-- * CompliantCount [ComplianceSummaryCount] <p>The total number of resources that are compliant.</p>
-- @return CompliantSummary structure as a key-value pair table
function M.CompliantSummary(args)
	assert(args, "You must provide an argument table when creating CompliantSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SeveritySummary"] = args["SeveritySummary"],
		["CompliantCount"] = args["CompliantCount"],
	}
	asserts.AssertCompliantSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAutomationExecutionsResult = { ["NextToken"] = true, ["AutomationExecutionMetadataList"] = true, nil }

function asserts.AssertDescribeAutomationExecutionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAutomationExecutionsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["AutomationExecutionMetadataList"] then asserts.AssertAutomationExecutionMetadataList(struct["AutomationExecutionMetadataList"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAutomationExecutionsResult[k], "DescribeAutomationExecutionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAutomationExecutionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * AutomationExecutionMetadataList [AutomationExecutionMetadataList] <p>The list of details about each automation execution which has occurred which matches the filter specification, if any.</p>
-- @return DescribeAutomationExecutionsResult structure as a key-value pair table
function M.DescribeAutomationExecutionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeAutomationExecutionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["AutomationExecutionMetadataList"] = args["AutomationExecutionMetadataList"],
	}
	asserts.AssertDescribeAutomationExecutionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteInventoryRequest = { ["TypeName"] = true, ["ClientToken"] = true, ["DryRun"] = true, ["SchemaDeleteOption"] = true, nil }

function asserts.AssertDeleteInventoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteInventoryRequest to be of type 'table'")
	assert(struct["TypeName"], "Expected key TypeName to exist in table")
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["ClientToken"] then asserts.AssertClientToken(struct["ClientToken"]) end
	if struct["DryRun"] then asserts.AssertDryRun(struct["DryRun"]) end
	if struct["SchemaDeleteOption"] then asserts.AssertInventorySchemaDeleteOption(struct["SchemaDeleteOption"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteInventoryRequest[k], "DeleteInventoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteInventoryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TypeName [InventoryItemTypeName] <p>The name of the custom inventory type for which you want to delete either all previously collected data, or the inventory type itself. </p>
-- * ClientToken [ClientToken] <p>User-provided idempotency token.</p>
-- * DryRun [DryRun] <p>Use this option to view a summary of the deletion request without deleting any data or the data type. This option is useful when you only want to understand what will be deleted. Once you validate that the data to be deleted is what you intend to delete, you can run the same command without specifying the <code>DryRun</code> option.</p>
-- * SchemaDeleteOption [InventorySchemaDeleteOption] <p>Use the <code>SchemaDeleteOption</code> to delete a custom inventory type (schema). If you don't choose this option, the system only deletes existing inventory data associated with the custom inventory type. Choose one of the following options:</p> <p>DisableSchema: If you choose this option, the system ignores all inventory data for the specified version, and any earlier versions. To enable this schema again, you must call the <code>PutInventory</code> action for a version greater than the disbled version.</p> <p>DeleteSchema: This option deletes the specified custom type from the Inventory service. You can recreate the schema later, if you want.</p>
-- Required key: TypeName
-- @return DeleteInventoryRequest structure as a key-value pair table
function M.DeleteInventoryRequest(args)
	assert(args, "You must provide an argument table when creating DeleteInventoryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TypeName"] = args["TypeName"],
		["ClientToken"] = args["ClientToken"],
		["DryRun"] = args["DryRun"],
		["SchemaDeleteOption"] = args["SchemaDeleteOption"],
	}
	asserts.AssertDeleteInventoryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterManagedInstanceResult = { nil }

function asserts.AssertDeregisterManagedInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterManagedInstanceResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeregisterManagedInstanceResult[k], "DeregisterManagedInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterManagedInstanceResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeregisterManagedInstanceResult structure as a key-value pair table
function M.DeregisterManagedInstanceResult(args)
	assert(args, "You must provide an argument table when creating DeregisterManagedInstanceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeregisterManagedInstanceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterTaskFromMaintenanceWindowRequest = { ["WindowTaskId"] = true, ["WindowId"] = true, nil }

function asserts.AssertDeregisterTaskFromMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterTaskFromMaintenanceWindowRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	assert(struct["WindowTaskId"], "Expected key WindowTaskId to exist in table")
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterTaskFromMaintenanceWindowRequest[k], "DeregisterTaskFromMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterTaskFromMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The ID of the task to remove from the Maintenance Window.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window the task should be removed from.</p>
-- Required key: WindowId
-- Required key: WindowTaskId
-- @return DeregisterTaskFromMaintenanceWindowRequest structure as a key-value pair table
function M.DeregisterTaskFromMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating DeregisterTaskFromMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowTaskId"] = args["WindowTaskId"],
		["WindowId"] = args["WindowId"],
	}
	asserts.AssertDeregisterTaskFromMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryDeletionSummaryItem = { ["Count"] = true, ["Version"] = true, ["RemainingCount"] = true, nil }

function asserts.AssertInventoryDeletionSummaryItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryDeletionSummaryItem to be of type 'table'")
	if struct["Count"] then asserts.AssertResourceCount(struct["Count"]) end
	if struct["Version"] then asserts.AssertInventoryItemSchemaVersion(struct["Version"]) end
	if struct["RemainingCount"] then asserts.AssertRemainingCount(struct["RemainingCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryDeletionSummaryItem[k], "InventoryDeletionSummaryItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryDeletionSummaryItem
-- <p>Either a count, remaining count, or a version number in a delete inventory summary.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Count [ResourceCount] <p>A count of the number of deleted items.</p>
-- * Version [InventoryItemSchemaVersion] <p>The inventory type version.</p>
-- * RemainingCount [RemainingCount] <p>The remaining number of items to delete.</p>
-- @return InventoryDeletionSummaryItem structure as a key-value pair table
function M.InventoryDeletionSummaryItem(args)
	assert(args, "You must provide an argument table when creating InventoryDeletionSummaryItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Count"] = args["Count"],
		["Version"] = args["Version"],
		["RemainingCount"] = args["RemainingCount"],
	}
	asserts.AssertInventoryDeletionSummaryItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelCommandRequest = { ["CommandId"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertCancelCommandRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelCommandRequest to be of type 'table'")
	assert(struct["CommandId"], "Expected key CommandId to exist in table")
	if struct["CommandId"] then asserts.AssertCommandId(struct["CommandId"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelCommandRequest[k], "CancelCommandRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelCommandRequest
-- <p/>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CommandId [CommandId] <p>The ID of the command you want to cancel.</p>
-- * InstanceIds [InstanceIdList] <p>(Optional) A list of instance IDs on which you want to cancel the command. If not provided, the command is canceled on every instance on which it was requested.</p>
-- Required key: CommandId
-- @return CancelCommandRequest structure as a key-value pair table
function M.CancelCommandRequest(args)
	assert(args, "You must provide an argument table when creating CancelCommandRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CommandId"] = args["CommandId"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertCancelCommandRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResourceDataSyncItem = { ["SyncName"] = true, ["LastSyncTime"] = true, ["SyncCreatedTime"] = true, ["LastStatus"] = true, ["LastSyncStatusMessage"] = true, ["LastSuccessfulSyncTime"] = true, ["S3Destination"] = true, nil }

function asserts.AssertResourceDataSyncItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResourceDataSyncItem to be of type 'table'")
	if struct["SyncName"] then asserts.AssertResourceDataSyncName(struct["SyncName"]) end
	if struct["LastSyncTime"] then asserts.AssertLastResourceDataSyncTime(struct["LastSyncTime"]) end
	if struct["SyncCreatedTime"] then asserts.AssertResourceDataSyncCreatedTime(struct["SyncCreatedTime"]) end
	if struct["LastStatus"] then asserts.AssertLastResourceDataSyncStatus(struct["LastStatus"]) end
	if struct["LastSyncStatusMessage"] then asserts.AssertLastResourceDataSyncMessage(struct["LastSyncStatusMessage"]) end
	if struct["LastSuccessfulSyncTime"] then asserts.AssertLastSuccessfulResourceDataSyncTime(struct["LastSuccessfulSyncTime"]) end
	if struct["S3Destination"] then asserts.AssertResourceDataSyncS3Destination(struct["S3Destination"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResourceDataSyncItem[k], "ResourceDataSyncItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResourceDataSyncItem
-- <p>Information about a Resource Data Sync configuration, including its current status and last successful sync.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SyncName [ResourceDataSyncName] <p>The name of the Resource Data Sync.</p>
-- * LastSyncTime [LastResourceDataSyncTime] <p>The last time the configuration attempted to sync (UTC).</p>
-- * SyncCreatedTime [ResourceDataSyncCreatedTime] <p>The date and time the configuration was created (UTC).</p>
-- * LastStatus [LastResourceDataSyncStatus] <p>The status reported by the last sync.</p>
-- * LastSyncStatusMessage [LastResourceDataSyncMessage] <p>The status message details reported by the last sync.</p>
-- * LastSuccessfulSyncTime [LastSuccessfulResourceDataSyncTime] <p>The last time the sync operations returned a status of <code>SUCCESSFUL</code> (UTC).</p>
-- * S3Destination [ResourceDataSyncS3Destination] <p>Configuration information for the target Amazon S3 bucket.</p>
-- @return ResourceDataSyncItem structure as a key-value pair table
function M.ResourceDataSyncItem(args)
	assert(args, "You must provide an argument table when creating ResourceDataSyncItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SyncName"] = args["SyncName"],
		["LastSyncTime"] = args["LastSyncTime"],
		["SyncCreatedTime"] = args["SyncCreatedTime"],
		["LastStatus"] = args["LastStatus"],
		["LastSyncStatusMessage"] = args["LastSyncStatusMessage"],
		["LastSuccessfulSyncTime"] = args["LastSuccessfulSyncTime"],
		["S3Destination"] = args["S3Destination"],
	}
	asserts.AssertResourceDataSyncItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelMaintenanceWindowExecutionRequest = { ["WindowExecutionId"] = true, nil }

function asserts.AssertCancelMaintenanceWindowExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelMaintenanceWindowExecutionRequest to be of type 'table'")
	assert(struct["WindowExecutionId"], "Expected key WindowExecutionId to exist in table")
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelMaintenanceWindowExecutionRequest[k], "CancelMaintenanceWindowExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelMaintenanceWindowExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution to stop.</p>
-- Required key: WindowExecutionId
-- @return CancelMaintenanceWindowExecutionRequest structure as a key-value pair table
function M.CancelMaintenanceWindowExecutionRequest(args)
	assert(args, "You must provide an argument table when creating CancelMaintenanceWindowExecutionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowExecutionId"] = args["WindowExecutionId"],
	}
	asserts.AssertCancelMaintenanceWindowExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAutomationStepExecutionsResult = { ["NextToken"] = true, ["StepExecutions"] = true, nil }

function asserts.AssertDescribeAutomationStepExecutionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAutomationStepExecutionsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["StepExecutions"] then asserts.AssertStepExecutionList(struct["StepExecutions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAutomationStepExecutionsResult[k], "DescribeAutomationStepExecutionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAutomationStepExecutionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * StepExecutions [StepExecutionList] <p>A list of details about the current state of all steps that make up an execution.</p>
-- @return DescribeAutomationStepExecutionsResult structure as a key-value pair table
function M.DescribeAutomationStepExecutionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeAutomationStepExecutionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["StepExecutions"] = args["StepExecutions"],
	}
	asserts.AssertDescribeAutomationStepExecutionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateMaintenanceWindowResult = { ["WindowId"] = true, nil }

function asserts.AssertCreateMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateMaintenanceWindowResult to be of type 'table'")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateMaintenanceWindowResult[k], "CreateMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the created Maintenance Window.</p>
-- @return CreateMaintenanceWindowResult structure as a key-value pair table
function M.CreateMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating CreateMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
	}
	asserts.AssertCreateMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelCommandResult = { nil }

function asserts.AssertCancelCommandResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelCommandResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.CancelCommandResult[k], "CancelCommandResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelCommandResult
-- <p>Whether or not the command was successfully canceled. There is no guarantee that a request can be canceled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return CancelCommandResult structure as a key-value pair table
function M.CancelCommandResult(args)
	assert(args, "You must provide an argument table when creating CancelCommandResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertCancelCommandResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetAutomationExecutionRequest = { ["AutomationExecutionId"] = true, nil }

function asserts.AssertGetAutomationExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetAutomationExecutionRequest to be of type 'table'")
	assert(struct["AutomationExecutionId"], "Expected key AutomationExecutionId to exist in table")
	if struct["AutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["AutomationExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetAutomationExecutionRequest[k], "GetAutomationExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetAutomationExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutomationExecutionId [AutomationExecutionId] <p>The unique identifier for an existing automation execution to examine. The execution ID is returned by StartAutomationExecution when the execution of an Automation document is initiated.</p>
-- Required key: AutomationExecutionId
-- @return GetAutomationExecutionRequest structure as a key-value pair table
function M.GetAutomationExecutionRequest(args)
	assert(args, "You must provide an argument table when creating GetAutomationExecutionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutomationExecutionId"] = args["AutomationExecutionId"],
	}
	asserts.AssertGetAutomationExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterTaskWithMaintenanceWindowResult = { ["WindowTaskId"] = true, nil }

function asserts.AssertRegisterTaskWithMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterTaskWithMaintenanceWindowResult to be of type 'table'")
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterTaskWithMaintenanceWindowResult[k], "RegisterTaskWithMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterTaskWithMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The ID of the task in the Maintenance Window.</p>
-- @return RegisterTaskWithMaintenanceWindowResult structure as a key-value pair table
function M.RegisterTaskWithMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating RegisterTaskWithMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowTaskId"] = args["WindowTaskId"],
	}
	asserts.AssertRegisterTaskWithMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListInventoryEntriesResult = { ["InstanceId"] = true, ["TypeName"] = true, ["Entries"] = true, ["SchemaVersion"] = true, ["NextToken"] = true, ["CaptureTime"] = true, nil }

function asserts.AssertListInventoryEntriesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListInventoryEntriesResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["Entries"] then asserts.AssertInventoryItemEntryList(struct["Entries"]) end
	if struct["SchemaVersion"] then asserts.AssertInventoryItemSchemaVersion(struct["SchemaVersion"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["CaptureTime"] then asserts.AssertInventoryItemCaptureTime(struct["CaptureTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListInventoryEntriesResult[k], "ListInventoryEntriesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListInventoryEntriesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The instance ID targeted by the request to query inventory information.</p>
-- * TypeName [InventoryItemTypeName] <p>The type of inventory item returned by the request.</p>
-- * Entries [InventoryItemEntryList] <p>A list of inventory items on the instance(s).</p>
-- * SchemaVersion [InventoryItemSchemaVersion] <p>The inventory schema version used by the instance(s).</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * CaptureTime [InventoryItemCaptureTime] <p>The time that inventory information was collected for the instance(s).</p>
-- @return ListInventoryEntriesResult structure as a key-value pair table
function M.ListInventoryEntriesResult(args)
	assert(args, "You must provide an argument table when creating ListInventoryEntriesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["TypeName"] = args["TypeName"],
		["Entries"] = args["Entries"],
		["SchemaVersion"] = args["SchemaVersion"],
		["NextToken"] = args["NextToken"],
		["CaptureTime"] = args["CaptureTime"],
	}
	asserts.AssertListInventoryEntriesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowExecutionRequest = { ["WindowExecutionId"] = true, nil }

function asserts.AssertGetMaintenanceWindowExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowExecutionRequest to be of type 'table'")
	assert(struct["WindowExecutionId"], "Expected key WindowExecutionId to exist in table")
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowExecutionRequest[k], "GetMaintenanceWindowExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution that includes the task.</p>
-- Required key: WindowExecutionId
-- @return GetMaintenanceWindowExecutionRequest structure as a key-value pair table
function M.GetMaintenanceWindowExecutionRequest(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowExecutionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowExecutionId"] = args["WindowExecutionId"],
	}
	asserts.AssertGetMaintenanceWindowExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowExecutionTaskInvocationsRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["WindowExecutionId"] = true, ["Filters"] = true, ["TaskId"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowExecutionTaskInvocationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowExecutionTaskInvocationsRequest to be of type 'table'")
	assert(struct["WindowExecutionId"], "Expected key WindowExecutionId to exist in table")
	assert(struct["TaskId"], "Expected key TaskId to exist in table")
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowMaxResults(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["Filters"] then asserts.AssertMaintenanceWindowFilterList(struct["Filters"]) end
	if struct["TaskId"] then asserts.AssertMaintenanceWindowExecutionTaskId(struct["TaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowExecutionTaskInvocationsRequest[k], "DescribeMaintenanceWindowExecutionTaskInvocationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowExecutionTaskInvocationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [MaintenanceWindowMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution the task is part of.</p>
-- * Filters [MaintenanceWindowFilterList] <p>Optional filters used to scope down the returned task invocations. The supported filter key is STATUS with the corresponding values PENDING, IN_PROGRESS, SUCCESS, FAILED, TIMED_OUT, CANCELLING, and CANCELLED.</p>
-- * TaskId [MaintenanceWindowExecutionTaskId] <p>The ID of the specific task in the Maintenance Window task that should be retrieved.</p>
-- Required key: WindowExecutionId
-- Required key: TaskId
-- @return DescribeMaintenanceWindowExecutionTaskInvocationsRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowExecutionTaskInvocationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowExecutionTaskInvocationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["Filters"] = args["Filters"],
		["TaskId"] = args["TaskId"],
	}
	asserts.AssertDescribeMaintenanceWindowExecutionTaskInvocationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetInventorySchemaRequest = { ["TypeName"] = true, ["SubType"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Aggregator"] = true, nil }

function asserts.AssertGetInventorySchemaRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetInventorySchemaRequest to be of type 'table'")
	if struct["TypeName"] then asserts.AssertInventoryItemTypeNameFilter(struct["TypeName"]) end
	if struct["SubType"] then asserts.AssertIsSubTypeSchema(struct["SubType"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertGetInventorySchemaMaxResults(struct["MaxResults"]) end
	if struct["Aggregator"] then asserts.AssertAggregatorSchemaOnly(struct["Aggregator"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetInventorySchemaRequest[k], "GetInventorySchemaRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetInventorySchemaRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TypeName [InventoryItemTypeNameFilter] <p>The type of inventory item to return.</p>
-- * SubType [IsSubTypeSchema] <p>Returns the sub-type schema for a specified inventory type.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [GetInventorySchemaMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Aggregator [AggregatorSchemaOnly] <p>Returns inventory schemas that support aggregation. For example, this call returns the <code>AWS:InstanceInformation</code> type, because it supports aggregation based on the <code>PlatformName</code>, <code>PlatformType</code>, and <code>PlatformVersion</code> attributes.</p>
-- @return GetInventorySchemaRequest structure as a key-value pair table
function M.GetInventorySchemaRequest(args)
	assert(args, "You must provide an argument table when creating GetInventorySchemaRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TypeName"] = args["TypeName"],
		["SubType"] = args["SubType"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Aggregator"] = args["Aggregator"],
	}
	asserts.AssertGetInventorySchemaRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchSource = { ["Configuration"] = true, ["Products"] = true, ["Name"] = true, nil }

function asserts.AssertPatchSource(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchSource to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["Products"], "Expected key Products to exist in table")
	assert(struct["Configuration"], "Expected key Configuration to exist in table")
	if struct["Configuration"] then asserts.AssertPatchSourceConfiguration(struct["Configuration"]) end
	if struct["Products"] then asserts.AssertPatchSourceProductList(struct["Products"]) end
	if struct["Name"] then asserts.AssertPatchSourceName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchSource[k], "PatchSource contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchSource
-- <p>Information about the patches to use to update the instances, including target operating systems and source repository. Applies to Linux instances only.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Configuration [PatchSourceConfiguration] <p>The value of the yum repo configuration. For example:</p> <p> <code>cachedir=/var/cache/yum/$basesearch</code> </p> <p> <code>$releasever</code> </p> <p> <code>keepcache=0</code> </p> <p> <code>debuglevel=2</code> </p>
-- * Products [PatchSourceProductList] <p>The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see <a>PatchFilter</a>.</p>
-- * Name [PatchSourceName] <p>The name specified to identify the patch source.</p>
-- Required key: Name
-- Required key: Products
-- Required key: Configuration
-- @return PatchSource structure as a key-value pair table
function M.PatchSource(args)
	assert(args, "You must provide an argument table when creating PatchSource")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Configuration"] = args["Configuration"],
		["Products"] = args["Products"],
		["Name"] = args["Name"],
	}
	asserts.AssertPatchSource(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancePatchStatesRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertDescribeInstancePatchStatesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancePatchStatesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertPatchComplianceMaxResults(struct["MaxResults"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancePatchStatesRequest[k], "DescribeInstancePatchStatesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancePatchStatesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [PatchComplianceMaxResults] <p>The maximum number of instances to return (per page).</p>
-- * InstanceIds [InstanceIdList] <p>The ID of the instance whose patch state information should be retrieved.</p>
-- Required key: InstanceIds
-- @return DescribeInstancePatchStatesRequest structure as a key-value pair table
function M.DescribeInstancePatchStatesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstancePatchStatesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertDescribeInstancePatchStatesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryDeletionSummary = { ["SummaryItems"] = true, ["TotalCount"] = true, ["RemainingCount"] = true, nil }

function asserts.AssertInventoryDeletionSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryDeletionSummary to be of type 'table'")
	if struct["SummaryItems"] then asserts.AssertInventoryDeletionSummaryItems(struct["SummaryItems"]) end
	if struct["TotalCount"] then asserts.AssertTotalCount(struct["TotalCount"]) end
	if struct["RemainingCount"] then asserts.AssertRemainingCount(struct["RemainingCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryDeletionSummary[k], "InventoryDeletionSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryDeletionSummary
-- <p>Information about the delete operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SummaryItems [InventoryDeletionSummaryItems] <p>A list of counts and versions for deleted items.</p>
-- * TotalCount [TotalCount] <p>The total number of items to delete. This count does not change during the delete operation.</p>
-- * RemainingCount [RemainingCount] <p>Remaining number of items to delete.</p>
-- @return InventoryDeletionSummary structure as a key-value pair table
function M.InventoryDeletionSummary(args)
	assert(args, "You must provide an argument table when creating InventoryDeletionSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SummaryItems"] = args["SummaryItems"],
		["TotalCount"] = args["TotalCount"],
		["RemainingCount"] = args["RemainingCount"],
	}
	asserts.AssertInventoryDeletionSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowExecutionTaskInvocationRequest = { ["WindowExecutionId"] = true, ["InvocationId"] = true, ["TaskId"] = true, nil }

function asserts.AssertGetMaintenanceWindowExecutionTaskInvocationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowExecutionTaskInvocationRequest to be of type 'table'")
	assert(struct["WindowExecutionId"], "Expected key WindowExecutionId to exist in table")
	assert(struct["TaskId"], "Expected key TaskId to exist in table")
	assert(struct["InvocationId"], "Expected key InvocationId to exist in table")
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["InvocationId"] then asserts.AssertMaintenanceWindowExecutionTaskInvocationId(struct["InvocationId"]) end
	if struct["TaskId"] then asserts.AssertMaintenanceWindowExecutionTaskId(struct["TaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowExecutionTaskInvocationRequest[k], "GetMaintenanceWindowExecutionTaskInvocationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowExecutionTaskInvocationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution for which the task is a part.</p>
-- * InvocationId [MaintenanceWindowExecutionTaskInvocationId] <p>The invocation ID to retrieve.</p>
-- * TaskId [MaintenanceWindowExecutionTaskId] <p>The ID of the specific task in the Maintenance Window task that should be retrieved. </p>
-- Required key: WindowExecutionId
-- Required key: TaskId
-- Required key: InvocationId
-- @return GetMaintenanceWindowExecutionTaskInvocationRequest structure as a key-value pair table
function M.GetMaintenanceWindowExecutionTaskInvocationRequest(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowExecutionTaskInvocationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowExecutionId"] = args["WindowExecutionId"],
		["InvocationId"] = args["InvocationId"],
		["TaskId"] = args["TaskId"],
	}
	asserts.AssertGetMaintenanceWindowExecutionTaskInvocationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RemoveTagsFromResourceResult = { nil }

function asserts.AssertRemoveTagsFromResourceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RemoveTagsFromResourceResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.RemoveTagsFromResourceResult[k], "RemoveTagsFromResourceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RemoveTagsFromResourceResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return RemoveTagsFromResourceResult structure as a key-value pair table
function M.RemoveTagsFromResourceResult(args)
	assert(args, "You must provide an argument table when creating RemoveTagsFromResourceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertRemoveTagsFromResourceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAutomationStepExecutionsRequest = { ["ReverseOrder"] = true, ["AutomationExecutionId"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAutomationStepExecutionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAutomationStepExecutionsRequest to be of type 'table'")
	assert(struct["AutomationExecutionId"], "Expected key AutomationExecutionId to exist in table")
	if struct["ReverseOrder"] then asserts.AssertBoolean(struct["ReverseOrder"]) end
	if struct["AutomationExecutionId"] then asserts.AssertAutomationExecutionId(struct["AutomationExecutionId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertStepExecutionFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAutomationStepExecutionsRequest[k], "DescribeAutomationStepExecutionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAutomationStepExecutionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReverseOrder [Boolean] <p>A boolean that indicates whether to list step executions in reverse order by start time. The default value is false.</p>
-- * AutomationExecutionId [AutomationExecutionId] <p>The Automation execution ID for which you want step execution descriptions.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [StepExecutionFilterList] <p>One or more filters to limit the number of step executions returned by the request.</p>
-- Required key: AutomationExecutionId
-- @return DescribeAutomationStepExecutionsRequest structure as a key-value pair table
function M.DescribeAutomationStepExecutionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAutomationStepExecutionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReverseOrder"] = args["ReverseOrder"],
		["AutomationExecutionId"] = args["AutomationExecutionId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeAutomationStepExecutionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyDocumentPermissionResponse = { nil }

function asserts.AssertModifyDocumentPermissionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyDocumentPermissionResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.ModifyDocumentPermissionResponse[k], "ModifyDocumentPermissionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyDocumentPermissionResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return ModifyDocumentPermissionResponse structure as a key-value pair table
function M.ModifyDocumentPermissionResponse(args)
	assert(args, "You must provide an argument table when creating ModifyDocumentPermissionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertModifyDocumentPermissionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ParameterStringFilter = { ["Values"] = true, ["Option"] = true, ["Key"] = true, nil }

function asserts.AssertParameterStringFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ParameterStringFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	if struct["Values"] then asserts.AssertParameterStringFilterValueList(struct["Values"]) end
	if struct["Option"] then asserts.AssertParameterStringQueryOption(struct["Option"]) end
	if struct["Key"] then asserts.AssertParameterStringFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.ParameterStringFilter[k], "ParameterStringFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ParameterStringFilter
-- <p>One or more filters. Use a filter to return a more specific list of results.</p> <note> <p>The <code>Name</code> field can't be used with the <a>GetParametersByPath</a> API action.</p> </note>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [ParameterStringFilterValueList] <p>The value you want to search for.</p>
-- * Option [ParameterStringQueryOption] <p>Valid options are Equals and BeginsWith. For Path filter, valid options are Recursive and OneLevel.</p>
-- * Key [ParameterStringFilterKey] <p>The name of the filter.</p>
-- Required key: Key
-- @return ParameterStringFilter structure as a key-value pair table
function M.ParameterStringFilter(args)
	assert(args, "You must provide an argument table when creating ParameterStringFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Option"] = args["Option"],
		["Key"] = args["Key"],
	}
	asserts.AssertParameterStringFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NonCompliantSummary = { ["SeveritySummary"] = true, ["NonCompliantCount"] = true, nil }

function asserts.AssertNonCompliantSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NonCompliantSummary to be of type 'table'")
	if struct["SeveritySummary"] then asserts.AssertSeveritySummary(struct["SeveritySummary"]) end
	if struct["NonCompliantCount"] then asserts.AssertComplianceSummaryCount(struct["NonCompliantCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.NonCompliantSummary[k], "NonCompliantSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NonCompliantSummary
-- <p>A summary of resources that are not compliant. The summary is organized according to resource type.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SeveritySummary [SeveritySummary] <p>A summary of the non-compliance severity by compliance type</p>
-- * NonCompliantCount [ComplianceSummaryCount] <p>The total number of compliance items that are not compliant.</p>
-- @return NonCompliantSummary structure as a key-value pair table
function M.NonCompliantSummary(args)
	assert(args, "You must provide an argument table when creating NonCompliantSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SeveritySummary"] = args["SeveritySummary"],
		["NonCompliantCount"] = args["NonCompliantCount"],
	}
	asserts.AssertNonCompliantSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAutomationExecutionsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAutomationExecutionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAutomationExecutionsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertAutomationExecutionFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAutomationExecutionsRequest[k], "DescribeAutomationExecutionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAutomationExecutionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [AutomationExecutionFilterList] <p>Filters used to limit the scope of executions that are requested.</p>
-- @return DescribeAutomationExecutionsRequest structure as a key-value pair table
function M.DescribeAutomationExecutionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAutomationExecutionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeAutomationExecutionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowTasksResult = { ["Tasks"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowTasksResult to be of type 'table'")
	if struct["Tasks"] then asserts.AssertMaintenanceWindowTaskList(struct["Tasks"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowTasksResult[k], "DescribeMaintenanceWindowTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowTasksResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tasks [MaintenanceWindowTaskList] <p>Information about the tasks in the Maintenance Window.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeMaintenanceWindowTasksResult structure as a key-value pair table
function M.DescribeMaintenanceWindowTasksResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowTasksResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Tasks"] = args["Tasks"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMaintenanceWindowTasksResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteAssociationRequest = { ["InstanceId"] = true, ["AssociationId"] = true, ["Name"] = true, nil }

function asserts.AssertDeleteAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteAssociationRequest to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteAssociationRequest[k], "DeleteAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The ID of the instance.</p>
-- * AssociationId [AssociationId] <p>The association ID that you want to delete.</p>
-- * Name [DocumentName] <p>The name of the Systems Manager document.</p>
-- @return DeleteAssociationRequest structure as a key-value pair table
function M.DeleteAssociationRequest(args)
	assert(args, "You must provide an argument table when creating DeleteAssociationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["AssociationId"] = args["AssociationId"],
		["Name"] = args["Name"],
	}
	asserts.AssertDeleteAssociationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeActivationsFilter = { ["FilterKey"] = true, ["FilterValues"] = true, nil }

function asserts.AssertDescribeActivationsFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeActivationsFilter to be of type 'table'")
	if struct["FilterKey"] then asserts.AssertDescribeActivationsFilterKeys(struct["FilterKey"]) end
	if struct["FilterValues"] then asserts.AssertStringList(struct["FilterValues"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeActivationsFilter[k], "DescribeActivationsFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeActivationsFilter
-- <p>Filter for the DescribeActivation API.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FilterKey [DescribeActivationsFilterKeys] <p>The name of the filter.</p>
-- * FilterValues [StringList] <p>The filter values.</p>
-- @return DescribeActivationsFilter structure as a key-value pair table
function M.DescribeActivationsFilter(args)
	assert(args, "You must provide an argument table when creating DescribeActivationsFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FilterKey"] = args["FilterKey"],
		["FilterValues"] = args["FilterValues"],
	}
	asserts.AssertDescribeActivationsFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterPatchBaselineForPatchGroupRequest = { ["PatchGroup"] = true, ["BaselineId"] = true, nil }

function asserts.AssertDeregisterPatchBaselineForPatchGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterPatchBaselineForPatchGroupRequest to be of type 'table'")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	assert(struct["PatchGroup"], "Expected key PatchGroup to exist in table")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterPatchBaselineForPatchGroupRequest[k], "DeregisterPatchBaselineForPatchGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterPatchBaselineForPatchGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group that should be deregistered from the patch baseline.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline to deregister the patch group from.</p>
-- Required key: BaselineId
-- Required key: PatchGroup
-- @return DeregisterPatchBaselineForPatchGroupRequest structure as a key-value pair table
function M.DeregisterPatchBaselineForPatchGroupRequest(args)
	assert(args, "You must provide an argument table when creating DeregisterPatchBaselineForPatchGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertDeregisterPatchBaselineForPatchGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResourceDataSyncS3Destination = { ["AWSKMSKeyARN"] = true, ["Prefix"] = true, ["Region"] = true, ["BucketName"] = true, ["SyncFormat"] = true, nil }

function asserts.AssertResourceDataSyncS3Destination(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResourceDataSyncS3Destination to be of type 'table'")
	assert(struct["BucketName"], "Expected key BucketName to exist in table")
	assert(struct["SyncFormat"], "Expected key SyncFormat to exist in table")
	assert(struct["Region"], "Expected key Region to exist in table")
	if struct["AWSKMSKeyARN"] then asserts.AssertResourceDataSyncAWSKMSKeyARN(struct["AWSKMSKeyARN"]) end
	if struct["Prefix"] then asserts.AssertResourceDataSyncS3Prefix(struct["Prefix"]) end
	if struct["Region"] then asserts.AssertResourceDataSyncS3Region(struct["Region"]) end
	if struct["BucketName"] then asserts.AssertResourceDataSyncS3BucketName(struct["BucketName"]) end
	if struct["SyncFormat"] then asserts.AssertResourceDataSyncS3Format(struct["SyncFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResourceDataSyncS3Destination[k], "ResourceDataSyncS3Destination contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResourceDataSyncS3Destination
-- <p>Information about the target Amazon S3 bucket for the Resource Data Sync.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AWSKMSKeyARN [ResourceDataSyncAWSKMSKeyARN] <p>The ARN of an encryption key for a destination in Amazon S3. Must belong to the same region as the destination Amazon S3 bucket.</p>
-- * Prefix [ResourceDataSyncS3Prefix] <p>An Amazon S3 prefix for the bucket.</p>
-- * Region [ResourceDataSyncS3Region] <p>The AWS Region with the Amazon S3 bucket targeted by the Resource Data Sync.</p>
-- * BucketName [ResourceDataSyncS3BucketName] <p>The name of the Amazon S3 bucket where the aggregated data is stored.</p>
-- * SyncFormat [ResourceDataSyncS3Format] <p>A supported sync format. The following format is currently supported: JsonSerDe</p>
-- Required key: BucketName
-- Required key: SyncFormat
-- Required key: Region
-- @return ResourceDataSyncS3Destination structure as a key-value pair table
function M.ResourceDataSyncS3Destination(args)
	assert(args, "You must provide an argument table when creating ResourceDataSyncS3Destination")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AWSKMSKeyARN"] = args["AWSKMSKeyARN"],
		["Prefix"] = args["Prefix"],
		["Region"] = args["Region"],
		["BucketName"] = args["BucketName"],
		["SyncFormat"] = args["SyncFormat"],
	}
	asserts.AssertResourceDataSyncS3Destination(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchFilterGroup = { ["PatchFilters"] = true, nil }

function asserts.AssertPatchFilterGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchFilterGroup to be of type 'table'")
	assert(struct["PatchFilters"], "Expected key PatchFilters to exist in table")
	if struct["PatchFilters"] then asserts.AssertPatchFilterList(struct["PatchFilters"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchFilterGroup[k], "PatchFilterGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchFilterGroup
-- <p>A set of patch filters, typically used for approval rules.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchFilters [PatchFilterList] <p>The set of patch filters that make up the group.</p>
-- Required key: PatchFilters
-- @return PatchFilterGroup structure as a key-value pair table
function M.PatchFilterGroup(args)
	assert(args, "You must provide an argument table when creating PatchFilterGroup")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchFilters"] = args["PatchFilters"],
	}
	asserts.AssertPatchFilterGroup(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.S3OutputUrl = { ["OutputUrl"] = true, nil }

function asserts.AssertS3OutputUrl(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3OutputUrl to be of type 'table'")
	if struct["OutputUrl"] then asserts.AssertUrl(struct["OutputUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3OutputUrl[k], "S3OutputUrl contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3OutputUrl
-- <p>A URL for the Amazon S3 bucket where you want to store the results of this request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OutputUrl [Url] <p>A URL for an Amazon S3 bucket where you want to store the results of this request.</p>
-- @return S3OutputUrl structure as a key-value pair table
function M.S3OutputUrl(args)
	assert(args, "You must provide an argument table when creating S3OutputUrl")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OutputUrl"] = args["OutputUrl"],
	}
	asserts.AssertS3OutputUrl(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowTasksRequest = { ["WindowId"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowTasksRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertMaintenanceWindowFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowTasksRequest[k], "DescribeMaintenanceWindowTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowTasksRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window whose tasks should be retrieved.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaintenanceWindowMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [MaintenanceWindowFilterList] <p>Optional filters used to narrow down the scope of the returned tasks. The supported filter keys are WindowTaskId, TaskArn, Priority, and TaskType.</p>
-- Required key: WindowId
-- @return DescribeMaintenanceWindowTasksRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowTasksRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowTasksRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeMaintenanceWindowTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowAutomationParameters = { ["Parameters"] = true, ["DocumentVersion"] = true, nil }

function asserts.AssertMaintenanceWindowAutomationParameters(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowAutomationParameters to be of type 'table'")
	if struct["Parameters"] then asserts.AssertAutomationParameterMap(struct["Parameters"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowAutomationParameters[k], "MaintenanceWindowAutomationParameters contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowAutomationParameters
-- <p>The parameters for an AUTOMATION task type.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Parameters [AutomationParameterMap] <p>The parameters for the AUTOMATION task.</p> <p>For information about specifying and updating task parameters, see <a>RegisterTaskWithMaintenanceWindow</a> and <a>UpdateMaintenanceWindowTask</a>.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> <p>For AUTOMATION task types, Systems Manager ignores any values specified for these parameters.</p> </note>
-- * DocumentVersion [DocumentVersion] <p>The version of an Automation document to use during task execution.</p>
-- @return MaintenanceWindowAutomationParameters structure as a key-value pair table
function M.MaintenanceWindowAutomationParameters(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowAutomationParameters")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Parameters"] = args["Parameters"],
		["DocumentVersion"] = args["DocumentVersion"],
	}
	asserts.AssertMaintenanceWindowAutomationParameters(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CommandInvocation = { ["Comment"] = true, ["Status"] = true, ["CommandPlugins"] = true, ["ServiceRole"] = true, ["CloudWatchOutputConfig"] = true, ["InstanceId"] = true, ["DocumentName"] = true, ["NotificationConfig"] = true, ["DocumentVersion"] = true, ["StatusDetails"] = true, ["StandardOutputUrl"] = true, ["StandardErrorUrl"] = true, ["TraceOutput"] = true, ["InstanceName"] = true, ["CommandId"] = true, ["RequestedDateTime"] = true, nil }

function asserts.AssertCommandInvocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CommandInvocation to be of type 'table'")
	if struct["Comment"] then asserts.AssertComment(struct["Comment"]) end
	if struct["Status"] then asserts.AssertCommandInvocationStatus(struct["Status"]) end
	if struct["CommandPlugins"] then asserts.AssertCommandPluginList(struct["CommandPlugins"]) end
	if struct["ServiceRole"] then asserts.AssertServiceRole(struct["ServiceRole"]) end
	if struct["CloudWatchOutputConfig"] then asserts.AssertCloudWatchOutputConfig(struct["CloudWatchOutputConfig"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["DocumentName"] then asserts.AssertDocumentName(struct["DocumentName"]) end
	if struct["NotificationConfig"] then asserts.AssertNotificationConfig(struct["NotificationConfig"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["StatusDetails"] then asserts.AssertStatusDetails(struct["StatusDetails"]) end
	if struct["StandardOutputUrl"] then asserts.AssertUrl(struct["StandardOutputUrl"]) end
	if struct["StandardErrorUrl"] then asserts.AssertUrl(struct["StandardErrorUrl"]) end
	if struct["TraceOutput"] then asserts.AssertInvocationTraceOutput(struct["TraceOutput"]) end
	if struct["InstanceName"] then asserts.AssertInstanceTagName(struct["InstanceName"]) end
	if struct["CommandId"] then asserts.AssertCommandId(struct["CommandId"]) end
	if struct["RequestedDateTime"] then asserts.AssertDateTime(struct["RequestedDateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.CommandInvocation[k], "CommandInvocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CommandInvocation
-- <p>An invocation is copy of a command sent to a specific instance. A command can apply to one or more instances. A command invocation applies to one instance. For example, if a user executes SendCommand against three instances, then a command invocation is created for each requested instance ID. A command invocation returns status and detail information about a command you executed. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Comment [Comment] <p>User-specified information about the command, such as a brief description of what the command should do.</p>
-- * Status [CommandInvocationStatus] <p>Whether or not the invocation succeeded, failed, or is pending.</p>
-- * CommandPlugins [CommandPluginList] 
-- * ServiceRole [ServiceRole] <p>The IAM service role that Run Command uses to act on your behalf when sending notifications about command status changes on a per instance basis.</p>
-- * CloudWatchOutputConfig [CloudWatchOutputConfig] <p>CloudWatch Logs information where you want Systems Manager to send the command output.</p>
-- * InstanceId [InstanceId] <p>The instance ID in which this invocation was requested.</p>
-- * DocumentName [DocumentName] <p>The document name that was requested for execution.</p>
-- * NotificationConfig [NotificationConfig] <p>Configurations for sending notifications about command status changes on a per instance basis.</p>
-- * DocumentVersion [DocumentVersion] <p>The SSM document version.</p>
-- * StatusDetails [StatusDetails] <p>A detailed status of the command execution for each invocation (each instance targeted by the command). StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding Command Statuses</a> in the <i>AWS Systems Manager User Guide</i>. StatusDetails can be one of the following values:</p> <ul> <li> <p>Pending: The command has not been sent to the instance.</p> </li> <li> <p>In Progress: The command has been sent to the instance but has not reached a terminal state.</p> </li> <li> <p>Success: The execution of the command or plugin was successfully completed. This is a terminal state.</p> </li> <li> <p>Delivery Timed Out: The command was not delivered to the instance before the delivery timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.</p> </li> <li> <p>Execution Timed Out: Command execution started on the instance, but the execution was not complete before the execution timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.</p> </li> <li> <p>Failed: The command was not successful on the instance. For a plugin, this indicates that the result code was not zero. For a command invocation, this indicates that the result code for one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.</p> </li> <li> <p>Canceled: The command was terminated before it was completed. This is a terminal state.</p> </li> <li> <p>Undeliverable: The command can't be delivered to the instance. The instance might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.</p> </li> <li> <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.</p> </li> </ul>
-- * StandardOutputUrl [Url] <p>The URL to the plugin's StdOut file in Amazon S3, if the Amazon S3 bucket was defined for the parent command. For an invocation, StandardOutputUrl is populated if there is just one plugin defined for the command, and the Amazon S3 bucket was defined for the command.</p>
-- * StandardErrorUrl [Url] <p>The URL to the plugin's StdErr file in Amazon S3, if the Amazon S3 bucket was defined for the parent command. For an invocation, StandardErrorUrl is populated if there is just one plugin defined for the command, and the Amazon S3 bucket was defined for the command.</p>
-- * TraceOutput [InvocationTraceOutput] <p> Gets the trace output sent by the agent. </p>
-- * InstanceName [InstanceTagName] <p>The name of the invocation target. For Amazon EC2 instances this is the value for the aws:Name tag. For on-premises instances, this is the name of the instance.</p>
-- * CommandId [CommandId] <p>The command against which this invocation was requested.</p>
-- * RequestedDateTime [DateTime] <p>The time and date the request was sent to this instance.</p>
-- @return CommandInvocation structure as a key-value pair table
function M.CommandInvocation(args)
	assert(args, "You must provide an argument table when creating CommandInvocation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Comment"] = args["Comment"],
		["Status"] = args["Status"],
		["CommandPlugins"] = args["CommandPlugins"],
		["ServiceRole"] = args["ServiceRole"],
		["CloudWatchOutputConfig"] = args["CloudWatchOutputConfig"],
		["InstanceId"] = args["InstanceId"],
		["DocumentName"] = args["DocumentName"],
		["NotificationConfig"] = args["NotificationConfig"],
		["DocumentVersion"] = args["DocumentVersion"],
		["StatusDetails"] = args["StatusDetails"],
		["StandardOutputUrl"] = args["StandardOutputUrl"],
		["StandardErrorUrl"] = args["StandardErrorUrl"],
		["TraceOutput"] = args["TraceOutput"],
		["InstanceName"] = args["InstanceName"],
		["CommandId"] = args["CommandId"],
		["RequestedDateTime"] = args["RequestedDateTime"],
	}
	asserts.AssertCommandInvocation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryFilter = { ["Type"] = true, ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertInventoryFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Values"], "Expected key Values to exist in table")
	if struct["Type"] then asserts.AssertInventoryQueryOperatorType(struct["Type"]) end
	if struct["Values"] then asserts.AssertInventoryFilterValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertInventoryFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryFilter[k], "InventoryFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryFilter
-- <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [InventoryQueryOperatorType] <p>The type of filter. Valid values include the following: "Equal"|"NotEqual"|"BeginWith"|"LessThan"|"GreaterThan"</p>
-- * Values [InventoryFilterValueList] <p>Inventory filter values. Example: inventory filter where instance IDs are specified as values Key=AWS:InstanceInformation.InstanceId,Values= i-a12b3c4d5e6g, i-1a2b3c4d5e6,Type=Equal </p>
-- * Key [InventoryFilterKey] <p>The name of the filter key.</p>
-- Required key: Key
-- Required key: Values
-- @return InventoryFilter structure as a key-value pair table
function M.InventoryFilter(args)
	assert(args, "You must provide an argument table when creating InventoryFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertInventoryFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResultAttribute = { ["TypeName"] = true, nil }

function asserts.AssertResultAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResultAttribute to be of type 'table'")
	assert(struct["TypeName"], "Expected key TypeName to exist in table")
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResultAttribute[k], "ResultAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResultAttribute
-- <p>The inventory item result attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TypeName [InventoryItemTypeName] <p>Name of the inventory item type. Valid value: AWS:InstanceInformation. Default Value: AWS:InstanceInformation.</p>
-- Required key: TypeName
-- @return ResultAttribute structure as a key-value pair table
function M.ResultAttribute(args)
	assert(args, "You must provide an argument table when creating ResultAttribute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TypeName"] = args["TypeName"],
	}
	asserts.AssertResultAttribute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceAssociationsStatusResult = { ["InstanceAssociationStatusInfos"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstanceAssociationsStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceAssociationsStatusResult to be of type 'table'")
	if struct["InstanceAssociationStatusInfos"] then asserts.AssertInstanceAssociationStatusInfos(struct["InstanceAssociationStatusInfos"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceAssociationsStatusResult[k], "DescribeInstanceAssociationsStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceAssociationsStatusResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceAssociationStatusInfos [InstanceAssociationStatusInfos] <p>Status information about the association.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeInstanceAssociationsStatusResult structure as a key-value pair table
function M.DescribeInstanceAssociationsStatusResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceAssociationsStatusResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceAssociationStatusInfos"] = args["InstanceAssociationStatusInfos"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstanceAssociationsStatusResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowExecutionTaskRequest = { ["WindowExecutionId"] = true, ["TaskId"] = true, nil }

function asserts.AssertGetMaintenanceWindowExecutionTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowExecutionTaskRequest to be of type 'table'")
	assert(struct["WindowExecutionId"], "Expected key WindowExecutionId to exist in table")
	assert(struct["TaskId"], "Expected key TaskId to exist in table")
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["TaskId"] then asserts.AssertMaintenanceWindowExecutionTaskId(struct["TaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowExecutionTaskRequest[k], "GetMaintenanceWindowExecutionTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowExecutionTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution that includes the task.</p>
-- * TaskId [MaintenanceWindowExecutionTaskId] <p>The ID of the specific task execution in the Maintenance Window task that should be retrieved.</p>
-- Required key: WindowExecutionId
-- Required key: TaskId
-- @return GetMaintenanceWindowExecutionTaskRequest structure as a key-value pair table
function M.GetMaintenanceWindowExecutionTaskRequest(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowExecutionTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowExecutionId"] = args["WindowExecutionId"],
		["TaskId"] = args["TaskId"],
	}
	asserts.AssertGetMaintenanceWindowExecutionTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateDocumentResult = { ["DocumentDescription"] = true, nil }

function asserts.AssertUpdateDocumentResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateDocumentResult to be of type 'table'")
	if struct["DocumentDescription"] then asserts.AssertDocumentDescription(struct["DocumentDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateDocumentResult[k], "UpdateDocumentResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateDocumentResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DocumentDescription [DocumentDescription] <p>A description of the document that was updated.</p>
-- @return UpdateDocumentResult structure as a key-value pair table
function M.UpdateDocumentResult(args)
	assert(args, "You must provide an argument table when creating UpdateDocumentResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DocumentDescription"] = args["DocumentDescription"],
	}
	asserts.AssertUpdateDocumentResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EffectivePatch = { ["PatchStatus"] = true, ["Patch"] = true, nil }

function asserts.AssertEffectivePatch(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EffectivePatch to be of type 'table'")
	if struct["PatchStatus"] then asserts.AssertPatchStatus(struct["PatchStatus"]) end
	if struct["Patch"] then asserts.AssertPatch(struct["Patch"]) end
	for k,_ in pairs(struct) do
		assert(keys.EffectivePatch[k], "EffectivePatch contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EffectivePatch
-- <p>The EffectivePatch structure defines metadata about a patch along with the approval state of the patch in a particular patch baseline. The approval state includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchStatus [PatchStatus] <p>The status of the patch in a patch baseline. This includes information about whether the patch is currently approved, due to be approved by a rule, explicitly approved, or explicitly rejected and the date the patch was or will be approved.</p>
-- * Patch [Patch] <p>Provides metadata for a patch, including information such as the KB ID, severity, classification and a URL for where more information can be obtained about the patch.</p>
-- @return EffectivePatch structure as a key-value pair table
function M.EffectivePatch(args)
	assert(args, "You must provide an argument table when creating EffectivePatch")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchStatus"] = args["PatchStatus"],
		["Patch"] = args["Patch"],
	}
	asserts.AssertEffectivePatch(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PutInventoryRequest = { ["InstanceId"] = true, ["Items"] = true, nil }

function asserts.AssertPutInventoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PutInventoryRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Items"], "Expected key Items to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["Items"] then asserts.AssertInventoryItemList(struct["Items"]) end
	for k,_ in pairs(struct) do
		assert(keys.PutInventoryRequest[k], "PutInventoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PutInventoryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>One or more instance IDs where you want to add or update inventory items.</p>
-- * Items [InventoryItemList] <p>The inventory items that you want to add or update on instances.</p>
-- Required key: InstanceId
-- Required key: Items
-- @return PutInventoryRequest structure as a key-value pair table
function M.PutInventoryRequest(args)
	assert(args, "You must provide an argument table when creating PutInventoryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Items"] = args["Items"],
	}
	asserts.AssertPutInventoryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TerminateSessionResponse = { ["SessionId"] = true, nil }

function asserts.AssertTerminateSessionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateSessionResponse to be of type 'table'")
	if struct["SessionId"] then asserts.AssertSessionId(struct["SessionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateSessionResponse[k], "TerminateSessionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateSessionResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SessionId [SessionId] <p>The ID of the session that has been terminated.</p>
-- @return TerminateSessionResponse structure as a key-value pair table
function M.TerminateSessionResponse(args)
	assert(args, "You must provide an argument table when creating TerminateSessionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SessionId"] = args["SessionId"],
	}
	asserts.AssertTerminateSessionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryDeletionStatusItem = { ["LastStatusMessage"] = true, ["LastStatus"] = true, ["DeletionSummary"] = true, ["DeletionStartTime"] = true, ["TypeName"] = true, ["DeletionId"] = true, ["LastStatusUpdateTime"] = true, nil }

function asserts.AssertInventoryDeletionStatusItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryDeletionStatusItem to be of type 'table'")
	if struct["LastStatusMessage"] then asserts.AssertInventoryDeletionLastStatusMessage(struct["LastStatusMessage"]) end
	if struct["LastStatus"] then asserts.AssertInventoryDeletionStatus(struct["LastStatus"]) end
	if struct["DeletionSummary"] then asserts.AssertInventoryDeletionSummary(struct["DeletionSummary"]) end
	if struct["DeletionStartTime"] then asserts.AssertInventoryDeletionStartTime(struct["DeletionStartTime"]) end
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["DeletionId"] then asserts.AssertInventoryDeletionId(struct["DeletionId"]) end
	if struct["LastStatusUpdateTime"] then asserts.AssertInventoryDeletionLastStatusUpdateTime(struct["LastStatusUpdateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryDeletionStatusItem[k], "InventoryDeletionStatusItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryDeletionStatusItem
-- <p>Status information returned by the <code>DeleteInventory</code> action.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LastStatusMessage [InventoryDeletionLastStatusMessage] <p>Information about the status.</p>
-- * LastStatus [InventoryDeletionStatus] <p>The status of the operation. Possible values are InProgress and Complete.</p>
-- * DeletionSummary [InventoryDeletionSummary] <p>Information about the delete operation. For more information about this summary, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-delete.html#sysman-inventory-delete-summary">Understanding the Delete Inventory Summary</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * DeletionStartTime [InventoryDeletionStartTime] <p>The UTC timestamp when the delete operation started.</p>
-- * TypeName [InventoryItemTypeName] <p>The name of the inventory data type.</p>
-- * DeletionId [InventoryDeletionId] <p>The deletion ID returned by the <code>DeleteInventory</code> action.</p>
-- * LastStatusUpdateTime [InventoryDeletionLastStatusUpdateTime] <p>The UTC timestamp of when the last status report.</p>
-- @return InventoryDeletionStatusItem structure as a key-value pair table
function M.InventoryDeletionStatusItem(args)
	assert(args, "You must provide an argument table when creating InventoryDeletionStatusItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LastStatusMessage"] = args["LastStatusMessage"],
		["LastStatus"] = args["LastStatus"],
		["DeletionSummary"] = args["DeletionSummary"],
		["DeletionStartTime"] = args["DeletionStartTime"],
		["TypeName"] = args["TypeName"],
		["DeletionId"] = args["DeletionId"],
		["LastStatusUpdateTime"] = args["LastStatusUpdateTime"],
	}
	asserts.AssertInventoryDeletionStatusItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowTaskInvocationParameters = { ["StepFunctions"] = true, ["Lambda"] = true, ["RunCommand"] = true, ["Automation"] = true, nil }

function asserts.AssertMaintenanceWindowTaskInvocationParameters(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowTaskInvocationParameters to be of type 'table'")
	if struct["StepFunctions"] then asserts.AssertMaintenanceWindowStepFunctionsParameters(struct["StepFunctions"]) end
	if struct["Lambda"] then asserts.AssertMaintenanceWindowLambdaParameters(struct["Lambda"]) end
	if struct["RunCommand"] then asserts.AssertMaintenanceWindowRunCommandParameters(struct["RunCommand"]) end
	if struct["Automation"] then asserts.AssertMaintenanceWindowAutomationParameters(struct["Automation"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowTaskInvocationParameters[k], "MaintenanceWindowTaskInvocationParameters contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowTaskInvocationParameters
-- <p>The parameters for task execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StepFunctions [MaintenanceWindowStepFunctionsParameters] <p>The parameters for a STEP_FUNCTION task type.</p>
-- * Lambda [MaintenanceWindowLambdaParameters] <p>The parameters for a LAMBDA task type.</p>
-- * RunCommand [MaintenanceWindowRunCommandParameters] <p>The parameters for a RUN_COMMAND task type.</p>
-- * Automation [MaintenanceWindowAutomationParameters] <p>The parameters for an AUTOMATION task type.</p>
-- @return MaintenanceWindowTaskInvocationParameters structure as a key-value pair table
function M.MaintenanceWindowTaskInvocationParameters(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowTaskInvocationParameters")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StepFunctions"] = args["StepFunctions"],
		["Lambda"] = args["Lambda"],
		["RunCommand"] = args["RunCommand"],
		["Automation"] = args["Automation"],
	}
	asserts.AssertMaintenanceWindowTaskInvocationParameters(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Target = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Target to be of type 'table'")
	if struct["Values"] then asserts.AssertTargetValues(struct["Values"]) end
	if struct["Key"] then asserts.AssertTargetKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.Target[k], "Target contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Target
-- <p>An array of search criteria that targets instances using a Key,Value combination that you specify. <code>Targets</code> is required if you don't provide one or more instance IDs in the call.</p> <p/>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [TargetValues] <p>User-defined criteria that maps to Key. For example, if you specified tag:ServerRole, you could specify value:WebServer to execute a command on instances that include Amazon EC2 tags of ServerRole,WebServer. For more information about how to send commands that target instances using Key,Value parameters, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Sending Commands to a Fleet</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * Key [TargetKey] <p>User-defined criteria for sending commands that target instances that meet the criteria. Key can be tag:&lt;Amazon EC2 tag&gt; or InstanceIds. For more information about how to send commands that target instances using Key,Value parameters, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-targeting">Targeting Multiple Instances</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- @return Target structure as a key-value pair table
function M.Target(args)
	assert(args, "You must provide an argument table when creating Target")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResumeSessionRequest = { ["SessionId"] = true, nil }

function asserts.AssertResumeSessionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResumeSessionRequest to be of type 'table'")
	assert(struct["SessionId"], "Expected key SessionId to exist in table")
	if struct["SessionId"] then asserts.AssertSessionId(struct["SessionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResumeSessionRequest[k], "ResumeSessionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResumeSessionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SessionId [SessionId] <p>The ID of the disconnected session to resume.</p>
-- Required key: SessionId
-- @return ResumeSessionRequest structure as a key-value pair table
function M.ResumeSessionRequest(args)
	assert(args, "You must provide an argument table when creating ResumeSessionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SessionId"] = args["SessionId"],
	}
	asserts.AssertResumeSessionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowExecution = { ["Status"] = true, ["WindowId"] = true, ["StartTime"] = true, ["EndTime"] = true, ["WindowExecutionId"] = true, ["StatusDetails"] = true, nil }

function asserts.AssertMaintenanceWindowExecution(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowExecution to be of type 'table'")
	if struct["Status"] then asserts.AssertMaintenanceWindowExecutionStatus(struct["Status"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["StatusDetails"] then asserts.AssertMaintenanceWindowExecutionStatusDetails(struct["StatusDetails"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowExecution[k], "MaintenanceWindowExecution contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowExecution
-- <p>Describes the information about an execution of a Maintenance Window. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [MaintenanceWindowExecutionStatus] <p>The status of the execution.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window.</p>
-- * StartTime [DateTime] <p>The time the execution started.</p>
-- * EndTime [DateTime] <p>The time the execution finished.</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution.</p>
-- * StatusDetails [MaintenanceWindowExecutionStatusDetails] <p>The details explaining the Status. Only available for certain status values.</p>
-- @return MaintenanceWindowExecution structure as a key-value pair table
function M.MaintenanceWindowExecution(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowExecution")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["WindowId"] = args["WindowId"],
		["StartTime"] = args["StartTime"],
		["EndTime"] = args["EndTime"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["StatusDetails"] = args["StatusDetails"],
	}
	asserts.AssertMaintenanceWindowExecution(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterPatchBaselineForPatchGroupResult = { ["PatchGroup"] = true, ["BaselineId"] = true, nil }

function asserts.AssertDeregisterPatchBaselineForPatchGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterPatchBaselineForPatchGroupResult to be of type 'table'")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterPatchBaselineForPatchGroupResult[k], "DeregisterPatchBaselineForPatchGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterPatchBaselineForPatchGroupResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group deregistered from the patch baseline.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline the patch group was deregistered from.</p>
-- @return DeregisterPatchBaselineForPatchGroupResult structure as a key-value pair table
function M.DeregisterPatchBaselineForPatchGroupResult(args)
	assert(args, "You must provide an argument table when creating DeregisterPatchBaselineForPatchGroupResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertDeregisterPatchBaselineForPatchGroupResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryResultItem = { ["ContentHash"] = true, ["TypeName"] = true, ["SchemaVersion"] = true, ["CaptureTime"] = true, ["Content"] = true, nil }

function asserts.AssertInventoryResultItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryResultItem to be of type 'table'")
	assert(struct["TypeName"], "Expected key TypeName to exist in table")
	assert(struct["SchemaVersion"], "Expected key SchemaVersion to exist in table")
	assert(struct["Content"], "Expected key Content to exist in table")
	if struct["ContentHash"] then asserts.AssertInventoryItemContentHash(struct["ContentHash"]) end
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["SchemaVersion"] then asserts.AssertInventoryItemSchemaVersion(struct["SchemaVersion"]) end
	if struct["CaptureTime"] then asserts.AssertInventoryItemCaptureTime(struct["CaptureTime"]) end
	if struct["Content"] then asserts.AssertInventoryItemEntryList(struct["Content"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryResultItem[k], "InventoryResultItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryResultItem
-- <p>The inventory result item.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ContentHash [InventoryItemContentHash] <p>MD5 hash of the inventory item type contents. The content hash is used to determine whether to update inventory information. The PutInventory API does not update the inventory item type contents if the MD5 hash has not changed since last update. </p>
-- * TypeName [InventoryItemTypeName] <p>The name of the inventory result item type.</p>
-- * SchemaVersion [InventoryItemSchemaVersion] <p>The schema version for the inventory result item/</p>
-- * CaptureTime [InventoryItemCaptureTime] <p>The time inventory item data was captured.</p>
-- * Content [InventoryItemEntryList] <p>Contains all the inventory data of the item type. Results include attribute names and values. </p>
-- Required key: TypeName
-- Required key: SchemaVersion
-- Required key: Content
-- @return InventoryResultItem structure as a key-value pair table
function M.InventoryResultItem(args)
	assert(args, "You must provide an argument table when creating InventoryResultItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ContentHash"] = args["ContentHash"],
		["TypeName"] = args["TypeName"],
		["SchemaVersion"] = args["SchemaVersion"],
		["CaptureTime"] = args["CaptureTime"],
		["Content"] = args["Content"],
	}
	asserts.AssertInventoryResultItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowTask = { ["LoggingInfo"] = true, ["ServiceRoleArn"] = true, ["MaxErrors"] = true, ["TaskArn"] = true, ["MaxConcurrency"] = true, ["WindowTaskId"] = true, ["TaskParameters"] = true, ["Priority"] = true, ["WindowId"] = true, ["Description"] = true, ["Type"] = true, ["Targets"] = true, ["Name"] = true, nil }

function asserts.AssertMaintenanceWindowTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowTask to be of type 'table'")
	if struct["LoggingInfo"] then asserts.AssertLoggingInfo(struct["LoggingInfo"]) end
	if struct["ServiceRoleArn"] then asserts.AssertServiceRole(struct["ServiceRoleArn"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["TaskArn"] then asserts.AssertMaintenanceWindowTaskArn(struct["TaskArn"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	if struct["TaskParameters"] then asserts.AssertMaintenanceWindowTaskParameters(struct["TaskParameters"]) end
	if struct["Priority"] then asserts.AssertMaintenanceWindowTaskPriority(struct["Priority"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["Type"] then asserts.AssertMaintenanceWindowTaskType(struct["Type"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowTask[k], "MaintenanceWindowTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowTask
-- <p>Information about a task defined for a Maintenance Window.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LoggingInfo [LoggingInfo] <p>Information about an Amazon S3 bucket to write task-level logs to.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * ServiceRoleArn [ServiceRole] <p>The role that should be assumed when executing the task</p>
-- * MaxErrors [MaxErrors] <p>The maximum number of errors allowed before this task stops being scheduled.</p>
-- * TaskArn [MaintenanceWindowTaskArn] <p>The resource that the task uses during execution. For RUN_COMMAND and AUTOMATION task types, <code>TaskArn</code> is the Systems Manager document name or ARN. For LAMBDA tasks, it's the function name or ARN. For STEP_FUNCTION tasks, it's the state machine ARN.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets this task can be run for in parallel.</p>
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The task ID.</p>
-- * TaskParameters [MaintenanceWindowTaskParameters] <p>The parameters that should be passed to the task when it is executed.</p> <note> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * Priority [MaintenanceWindowTaskPriority] <p>The priority of the task in the Maintenance Window. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
-- * WindowId [MaintenanceWindowId] <p>The Maintenance Window ID where the task is registered.</p>
-- * Description [MaintenanceWindowDescription] <p>A description of the task.</p>
-- * Type [MaintenanceWindowTaskType] <p>The type of task. The type can be one of the following: RUN_COMMAND, AUTOMATION, LAMBDA, or STEP_FUNCTION.</p>
-- * Targets [Targets] <p>The targets (either instances or tags). Instances are specified using Key=instanceids,Values=&lt;instanceid1&gt;,&lt;instanceid2&gt;. Tags are specified using Key=&lt;tag name&gt;,Values=&lt;tag value&gt;.</p>
-- * Name [MaintenanceWindowName] <p>The task name.</p>
-- @return MaintenanceWindowTask structure as a key-value pair table
function M.MaintenanceWindowTask(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowTask")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LoggingInfo"] = args["LoggingInfo"],
		["ServiceRoleArn"] = args["ServiceRoleArn"],
		["MaxErrors"] = args["MaxErrors"],
		["TaskArn"] = args["TaskArn"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["WindowTaskId"] = args["WindowTaskId"],
		["TaskParameters"] = args["TaskParameters"],
		["Priority"] = args["Priority"],
		["WindowId"] = args["WindowId"],
		["Description"] = args["Description"],
		["Type"] = args["Type"],
		["Targets"] = args["Targets"],
		["Name"] = args["Name"],
	}
	asserts.AssertMaintenanceWindowTask(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetInventorySchemaResult = { ["NextToken"] = true, ["Schemas"] = true, nil }

function asserts.AssertGetInventorySchemaResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetInventorySchemaResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Schemas"] then asserts.AssertInventoryItemSchemaResultList(struct["Schemas"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetInventorySchemaResult[k], "GetInventorySchemaResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetInventorySchemaResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * Schemas [InventoryItemSchemaResultList] <p>Inventory schemas returned by the request.</p>
-- @return GetInventorySchemaResult structure as a key-value pair table
function M.GetInventorySchemaResult(args)
	assert(args, "You must provide an argument table when creating GetInventorySchemaResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Schemas"] = args["Schemas"],
	}
	asserts.AssertGetInventorySchemaResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListDocumentVersionsRequest = { ["NextToken"] = true, ["Name"] = true, ["MaxResults"] = true, nil }

function asserts.AssertListDocumentVersionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListDocumentVersionsRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListDocumentVersionsRequest[k], "ListDocumentVersionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListDocumentVersionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * Name [DocumentName] <p>The name of the document about which you want version information.</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: Name
-- @return ListDocumentVersionsRequest structure as a key-value pair table
function M.ListDocumentVersionsRequest(args)
	assert(args, "You must provide an argument table when creating ListDocumentVersionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Name"] = args["Name"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertListDocumentVersionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAssociationExecutionsResult = { ["AssociationExecutions"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeAssociationExecutionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAssociationExecutionsResult to be of type 'table'")
	if struct["AssociationExecutions"] then asserts.AssertAssociationExecutionsList(struct["AssociationExecutions"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAssociationExecutionsResult[k], "DescribeAssociationExecutionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAssociationExecutionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationExecutions [AssociationExecutionsList] <p>A list of the executions for the specified association ID.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- @return DescribeAssociationExecutionsResult structure as a key-value pair table
function M.DescribeAssociationExecutionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeAssociationExecutionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationExecutions"] = args["AssociationExecutions"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeAssociationExecutionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceAssociationOutputLocation = { ["S3Location"] = true, nil }

function asserts.AssertInstanceAssociationOutputLocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAssociationOutputLocation to be of type 'table'")
	if struct["S3Location"] then asserts.AssertS3OutputLocation(struct["S3Location"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAssociationOutputLocation[k], "InstanceAssociationOutputLocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAssociationOutputLocation
-- <p>An Amazon S3 bucket where you want to store the results of this request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Location [S3OutputLocation] <p>An Amazon S3 bucket where you want to store the results of this request.</p>
-- @return InstanceAssociationOutputLocation structure as a key-value pair table
function M.InstanceAssociationOutputLocation(args)
	assert(args, "You must provide an argument table when creating InstanceAssociationOutputLocation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3Location"] = args["S3Location"],
	}
	asserts.AssertInstanceAssociationOutputLocation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListDocumentsRequest = { ["DocumentFilterList"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertListDocumentsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListDocumentsRequest to be of type 'table'")
	if struct["DocumentFilterList"] then asserts.AssertDocumentFilterList(struct["DocumentFilterList"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertDocumentKeyValuesFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListDocumentsRequest[k], "ListDocumentsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListDocumentsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DocumentFilterList [DocumentFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [DocumentKeyValuesFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- @return ListDocumentsRequest structure as a key-value pair table
function M.ListDocumentsRequest(args)
	assert(args, "You must provide an argument table when creating ListDocumentsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DocumentFilterList"] = args["DocumentFilterList"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertListDocumentsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateAssociationBatchResult = { ["Successful"] = true, ["Failed"] = true, nil }

function asserts.AssertCreateAssociationBatchResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateAssociationBatchResult to be of type 'table'")
	if struct["Successful"] then asserts.AssertAssociationDescriptionList(struct["Successful"]) end
	if struct["Failed"] then asserts.AssertFailedCreateAssociationList(struct["Failed"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateAssociationBatchResult[k], "CreateAssociationBatchResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateAssociationBatchResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Successful [AssociationDescriptionList] <p>Information about the associations that succeeded.</p>
-- * Failed [FailedCreateAssociationList] <p>Information about the associations that failed.</p>
-- @return CreateAssociationBatchResult structure as a key-value pair table
function M.CreateAssociationBatchResult(args)
	assert(args, "You must provide an argument table when creating CreateAssociationBatchResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Successful"] = args["Successful"],
		["Failed"] = args["Failed"],
	}
	asserts.AssertCreateAssociationBatchResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAvailablePatchesRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAvailablePatchesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailablePatchesRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertPatchBaselineMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertPatchOrchestratorFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailablePatchesRequest[k], "DescribeAvailablePatchesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailablePatchesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [PatchBaselineMaxResults] <p>The maximum number of patches to return (per page).</p>
-- * Filters [PatchOrchestratorFilterList] <p>Filters used to scope down the returned patches.</p>
-- @return DescribeAvailablePatchesRequest structure as a key-value pair table
function M.DescribeAvailablePatchesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAvailablePatchesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeAvailablePatchesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDocumentRequest = { ["Name"] = true, ["DocumentVersion"] = true, nil }

function asserts.AssertDescribeDocumentRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDocumentRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["Name"] then asserts.AssertDocumentARN(struct["Name"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDocumentRequest[k], "DescribeDocumentRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDocumentRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [DocumentARN] <p>The name of the Systems Manager document.</p>
-- * DocumentVersion [DocumentVersion] <p>The document version for which you want information. Can be a specific version or the default version.</p>
-- Required key: Name
-- @return DescribeDocumentRequest structure as a key-value pair table
function M.DescribeDocumentRequest(args)
	assert(args, "You must provide an argument table when creating DescribeDocumentRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["DocumentVersion"] = args["DocumentVersion"],
	}
	asserts.AssertDescribeDocumentRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowsForTargetRequest = { ["ResourceType"] = true, ["NextToken"] = true, ["Targets"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowsForTargetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowsForTargetRequest to be of type 'table'")
	assert(struct["Targets"], "Expected key Targets to exist in table")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	if struct["ResourceType"] then asserts.AssertMaintenanceWindowResourceType(struct["ResourceType"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowSearchMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowsForTargetRequest[k], "DescribeMaintenanceWindowsForTargetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowsForTargetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [MaintenanceWindowResourceType] <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * Targets [Targets] <p>The instance ID or key/value pair to retrieve information about.</p>
-- * MaxResults [MaintenanceWindowSearchMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: Targets
-- Required key: ResourceType
-- @return DescribeMaintenanceWindowsForTargetRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowsForTargetRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowsForTargetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["NextToken"] = args["NextToken"],
		["Targets"] = args["Targets"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeMaintenanceWindowsForTargetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowsForTargetResult = { ["WindowIdentities"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowsForTargetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowsForTargetResult to be of type 'table'")
	if struct["WindowIdentities"] then asserts.AssertMaintenanceWindowsForTargetList(struct["WindowIdentities"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowsForTargetResult[k], "DescribeMaintenanceWindowsForTargetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowsForTargetResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowIdentities [MaintenanceWindowsForTargetList] <p>Information about the Maintenance Window targets and tasks an instance is associated with.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You use this token in the next call.)</p>
-- @return DescribeMaintenanceWindowsForTargetResult structure as a key-value pair table
function M.DescribeMaintenanceWindowsForTargetResult(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowsForTargetResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowIdentities"] = args["WindowIdentities"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMaintenanceWindowsForTargetResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationDescription = { ["Status"] = true, ["MaxErrors"] = true, ["ScheduleExpression"] = true, ["OutputLocation"] = true, ["Name"] = true, ["Parameters"] = true, ["LastExecutionDate"] = true, ["InstanceId"] = true, ["Overview"] = true, ["AssociationId"] = true, ["DocumentVersion"] = true, ["LastSuccessfulExecutionDate"] = true, ["LastUpdateAssociationDate"] = true, ["Date"] = true, ["AssociationVersion"] = true, ["AssociationName"] = true, ["Targets"] = true, ["ComplianceSeverity"] = true, ["MaxConcurrency"] = true, nil }

function asserts.AssertAssociationDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationDescription to be of type 'table'")
	if struct["Status"] then asserts.AssertAssociationStatus(struct["Status"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["ScheduleExpression"] then asserts.AssertScheduleExpression(struct["ScheduleExpression"]) end
	if struct["OutputLocation"] then asserts.AssertInstanceAssociationOutputLocation(struct["OutputLocation"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["LastExecutionDate"] then asserts.AssertDateTime(struct["LastExecutionDate"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["Overview"] then asserts.AssertAssociationOverview(struct["Overview"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["LastSuccessfulExecutionDate"] then asserts.AssertDateTime(struct["LastSuccessfulExecutionDate"]) end
	if struct["LastUpdateAssociationDate"] then asserts.AssertDateTime(struct["LastUpdateAssociationDate"]) end
	if struct["Date"] then asserts.AssertDateTime(struct["Date"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	if struct["AssociationName"] then asserts.AssertAssociationName(struct["AssociationName"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["ComplianceSeverity"] then asserts.AssertAssociationComplianceSeverity(struct["ComplianceSeverity"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationDescription[k], "AssociationDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationDescription
-- <p>Describes the parameters for a document.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [AssociationStatus] <p>The association status.</p>
-- * MaxErrors [MaxErrors] <p>The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 instances and set MaxError to 10%, then the system stops sending the request when the sixth error is received.</p> <p>Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.</p>
-- * ScheduleExpression [ScheduleExpression] <p>A cron expression that specifies a schedule when the association runs.</p>
-- * OutputLocation [InstanceAssociationOutputLocation] <p>An Amazon S3 bucket where you want to store the output details of the request.</p>
-- * Name [DocumentName] <p>The name of the Systems Manager document.</p>
-- * Parameters [Parameters] <p>A description of the parameters for a document. </p>
-- * LastExecutionDate [DateTime] <p>The date on which the association was last run.</p>
-- * InstanceId [InstanceId] <p>The ID of the instance.</p>
-- * Overview [AssociationOverview] <p>Information about the association.</p>
-- * AssociationId [AssociationId] <p>The association ID.</p>
-- * DocumentVersion [DocumentVersion] <p>The document version.</p>
-- * LastSuccessfulExecutionDate [DateTime] <p>The last date on which the association was successfully run.</p>
-- * LastUpdateAssociationDate [DateTime] <p>The date when the association was last updated.</p>
-- * Date [DateTime] <p>The date when the association was made.</p>
-- * AssociationVersion [AssociationVersion] <p>The association version.</p>
-- * AssociationName [AssociationName] <p>The association name.</p>
-- * Targets [Targets] <p>The instances targeted by the request. </p>
-- * ComplianceSeverity [AssociationComplianceSeverity] <p>The severity level that is assigned to the association.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time.</p> <p>If a new instance starts and attempts to execute an association while Systems Manager is executing MaxConcurrency associations, the association is allowed to run. During the next association interval, the new instance will process its association within the limit specified for MaxConcurrency.</p>
-- @return AssociationDescription structure as a key-value pair table
function M.AssociationDescription(args)
	assert(args, "You must provide an argument table when creating AssociationDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["MaxErrors"] = args["MaxErrors"],
		["ScheduleExpression"] = args["ScheduleExpression"],
		["OutputLocation"] = args["OutputLocation"],
		["Name"] = args["Name"],
		["Parameters"] = args["Parameters"],
		["LastExecutionDate"] = args["LastExecutionDate"],
		["InstanceId"] = args["InstanceId"],
		["Overview"] = args["Overview"],
		["AssociationId"] = args["AssociationId"],
		["DocumentVersion"] = args["DocumentVersion"],
		["LastSuccessfulExecutionDate"] = args["LastSuccessfulExecutionDate"],
		["LastUpdateAssociationDate"] = args["LastUpdateAssociationDate"],
		["Date"] = args["Date"],
		["AssociationVersion"] = args["AssociationVersion"],
		["AssociationName"] = args["AssociationName"],
		["Targets"] = args["Targets"],
		["ComplianceSeverity"] = args["ComplianceSeverity"],
		["MaxConcurrency"] = args["MaxConcurrency"],
	}
	asserts.AssertAssociationDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowExecutionTaskIdentity = { ["Status"] = true, ["TaskArn"] = true, ["StartTime"] = true, ["TaskType"] = true, ["EndTime"] = true, ["WindowExecutionId"] = true, ["StatusDetails"] = true, ["TaskExecutionId"] = true, nil }

function asserts.AssertMaintenanceWindowExecutionTaskIdentity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowExecutionTaskIdentity to be of type 'table'")
	if struct["Status"] then asserts.AssertMaintenanceWindowExecutionStatus(struct["Status"]) end
	if struct["TaskArn"] then asserts.AssertMaintenanceWindowTaskArn(struct["TaskArn"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["TaskType"] then asserts.AssertMaintenanceWindowTaskType(struct["TaskType"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["StatusDetails"] then asserts.AssertMaintenanceWindowExecutionStatusDetails(struct["StatusDetails"]) end
	if struct["TaskExecutionId"] then asserts.AssertMaintenanceWindowExecutionTaskId(struct["TaskExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowExecutionTaskIdentity[k], "MaintenanceWindowExecutionTaskIdentity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowExecutionTaskIdentity
-- <p>Information about a task execution performed as part of a Maintenance Window execution.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [MaintenanceWindowExecutionStatus] <p>The status of the task execution.</p>
-- * TaskArn [MaintenanceWindowTaskArn] <p>The ARN of the executed task.</p>
-- * StartTime [DateTime] <p>The time the task execution started.</p>
-- * TaskType [MaintenanceWindowTaskType] <p>The type of executed task.</p>
-- * EndTime [DateTime] <p>The time the task execution finished.</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution that ran the task.</p>
-- * StatusDetails [MaintenanceWindowExecutionStatusDetails] <p>The details explaining the status of the task execution. Only available for certain status values.</p>
-- * TaskExecutionId [MaintenanceWindowExecutionTaskId] <p>The ID of the specific task execution in the Maintenance Window execution.</p>
-- @return MaintenanceWindowExecutionTaskIdentity structure as a key-value pair table
function M.MaintenanceWindowExecutionTaskIdentity(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowExecutionTaskIdentity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["TaskArn"] = args["TaskArn"],
		["StartTime"] = args["StartTime"],
		["TaskType"] = args["TaskType"],
		["EndTime"] = args["EndTime"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["StatusDetails"] = args["StatusDetails"],
		["TaskExecutionId"] = args["TaskExecutionId"],
	}
	asserts.AssertMaintenanceWindowExecutionTaskIdentity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ComplianceItemEntry = { ["Status"] = true, ["Details"] = true, ["Severity"] = true, ["Id"] = true, ["Title"] = true, nil }

function asserts.AssertComplianceItemEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ComplianceItemEntry to be of type 'table'")
	assert(struct["Severity"], "Expected key Severity to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	if struct["Status"] then asserts.AssertComplianceStatus(struct["Status"]) end
	if struct["Details"] then asserts.AssertComplianceItemDetails(struct["Details"]) end
	if struct["Severity"] then asserts.AssertComplianceSeverity(struct["Severity"]) end
	if struct["Id"] then asserts.AssertComplianceItemId(struct["Id"]) end
	if struct["Title"] then asserts.AssertComplianceItemTitle(struct["Title"]) end
	for k,_ in pairs(struct) do
		assert(keys.ComplianceItemEntry[k], "ComplianceItemEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ComplianceItemEntry
-- <p>Information about a compliance item.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [ComplianceStatus] <p>The status of the compliance item. An item is either COMPLIANT or NON_COMPLIANT.</p>
-- * Details [ComplianceItemDetails] <p>A "Key": "Value" tag combination for the compliance item.</p>
-- * Severity [ComplianceSeverity] <p>The severity of the compliance status. Severity can be one of the following: Critical, High, Medium, Low, Informational, Unspecified.</p>
-- * Id [ComplianceItemId] <p>The compliance item ID. For example, if the compliance item is a Windows patch, the ID could be the number of the KB article.</p>
-- * Title [ComplianceItemTitle] <p>The title of the compliance item. For example, if the compliance item is a Windows patch, the title could be the title of the KB article for the patch; for example: Security Update for Active Directory Federation Services. </p>
-- Required key: Severity
-- Required key: Status
-- @return ComplianceItemEntry structure as a key-value pair table
function M.ComplianceItemEntry(args)
	assert(args, "You must provide an argument table when creating ComplianceItemEntry")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Details"] = args["Details"],
		["Severity"] = args["Severity"],
		["Id"] = args["Id"],
		["Title"] = args["Title"],
	}
	asserts.AssertComplianceItemEntry(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SendCommandRequest = { ["Comment"] = true, ["ServiceRoleArn"] = true, ["MaxErrors"] = true, ["Parameters"] = true, ["TimeoutSeconds"] = true, ["CloudWatchOutputConfig"] = true, ["DocumentName"] = true, ["DocumentHash"] = true, ["OutputS3BucketName"] = true, ["NotificationConfig"] = true, ["DocumentVersion"] = true, ["DocumentHashType"] = true, ["OutputS3KeyPrefix"] = true, ["OutputS3Region"] = true, ["Targets"] = true, ["InstanceIds"] = true, ["MaxConcurrency"] = true, nil }

function asserts.AssertSendCommandRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SendCommandRequest to be of type 'table'")
	assert(struct["DocumentName"], "Expected key DocumentName to exist in table")
	if struct["Comment"] then asserts.AssertComment(struct["Comment"]) end
	if struct["ServiceRoleArn"] then asserts.AssertServiceRole(struct["ServiceRoleArn"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["TimeoutSeconds"] then asserts.AssertTimeoutSeconds(struct["TimeoutSeconds"]) end
	if struct["CloudWatchOutputConfig"] then asserts.AssertCloudWatchOutputConfig(struct["CloudWatchOutputConfig"]) end
	if struct["DocumentName"] then asserts.AssertDocumentARN(struct["DocumentName"]) end
	if struct["DocumentHash"] then asserts.AssertDocumentHash(struct["DocumentHash"]) end
	if struct["OutputS3BucketName"] then asserts.AssertS3BucketName(struct["OutputS3BucketName"]) end
	if struct["NotificationConfig"] then asserts.AssertNotificationConfig(struct["NotificationConfig"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["DocumentHashType"] then asserts.AssertDocumentHashType(struct["DocumentHashType"]) end
	if struct["OutputS3KeyPrefix"] then asserts.AssertS3KeyPrefix(struct["OutputS3KeyPrefix"]) end
	if struct["OutputS3Region"] then asserts.AssertS3Region(struct["OutputS3Region"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdList(struct["InstanceIds"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	for k,_ in pairs(struct) do
		assert(keys.SendCommandRequest[k], "SendCommandRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SendCommandRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Comment [Comment] <p>User-specified information about the command, such as a brief description of what the command should do.</p>
-- * ServiceRoleArn [ServiceRole] <p>The IAM role that Systems Manager uses to send notifications. </p>
-- * MaxErrors [MaxErrors] <p>The maximum number of errors allowed without the command failing. When the command fails one more time beyond the value of MaxErrors, the systems stops sending the command to additional targets. You can specify a number like 10 or a percentage like 10%. The default value is 0. For more information about how to use MaxErrors, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-maxerrors">Using Error Controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * Parameters [Parameters] <p>The required and optional parameters specified in the document being executed.</p>
-- * TimeoutSeconds [TimeoutSeconds] <p>If this time is reached and the command has not already started executing, it will not run.</p>
-- * CloudWatchOutputConfig [CloudWatchOutputConfig] <p>Enables Systems Manager to send Run Command output to Amazon CloudWatch Logs. </p>
-- * DocumentName [DocumentARN] <p>Required. The name of the Systems Manager document to execute. This can be a public document or a custom document.</p>
-- * DocumentHash [DocumentHash] <p>The Sha256 or Sha1 hash created by the system when the document was created. </p> <note> <p>Sha1 hashes have been deprecated.</p> </note>
-- * OutputS3BucketName [S3BucketName] <p>The name of the S3 bucket where command execution responses should be stored.</p>
-- * NotificationConfig [NotificationConfig] <p>Configurations for sending notifications.</p>
-- * DocumentVersion [DocumentVersion] <p>The SSM document version to use in the request. You can specify $DEFAULT, $LATEST, or a specific version number. If you execute commands by using the AWS CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example:</p> <p>--document-version "\$DEFAULT"</p> <p>--document-version "\$LATEST"</p> <p>--document-version "3"</p>
-- * DocumentHashType [DocumentHashType] <p>Sha256 or Sha1.</p> <note> <p>Sha1 hashes have been deprecated.</p> </note>
-- * OutputS3KeyPrefix [S3KeyPrefix] <p>The directory structure within the S3 bucket where the responses should be stored.</p>
-- * OutputS3Region [S3Region] <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon S3 bucket region.</p>
-- * Targets [Targets] <p>(Optional) An array of search criteria that targets instances using a Key,Value combination that you specify. Targets is required if you don't provide one or more instance IDs in the call. For more information about how to use targets, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Sending Commands to a Fleet</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * InstanceIds [InstanceIdList] <p>The instance IDs where the command should execute. You can specify a maximum of 50 IDs. If you prefer not to list individual instance IDs, you can instead send commands to a fleet of instances using the Targets parameter, which accepts EC2 tags. For more information about how to use targets, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html">Sending Commands to a Fleet</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * MaxConcurrency [MaxConcurrency] <p>(Optional) The maximum number of instances that are allowed to execute the command at the same time. You can specify a number such as 10 or a percentage such as 10%. The default value is 50. For more information about how to use MaxConcurrency, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/send-commands-multiple.html#send-commands-velocity">Using Concurrency Controls</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- Required key: DocumentName
-- @return SendCommandRequest structure as a key-value pair table
function M.SendCommandRequest(args)
	assert(args, "You must provide an argument table when creating SendCommandRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Comment"] = args["Comment"],
		["ServiceRoleArn"] = args["ServiceRoleArn"],
		["MaxErrors"] = args["MaxErrors"],
		["Parameters"] = args["Parameters"],
		["TimeoutSeconds"] = args["TimeoutSeconds"],
		["CloudWatchOutputConfig"] = args["CloudWatchOutputConfig"],
		["DocumentName"] = args["DocumentName"],
		["DocumentHash"] = args["DocumentHash"],
		["OutputS3BucketName"] = args["OutputS3BucketName"],
		["NotificationConfig"] = args["NotificationConfig"],
		["DocumentVersion"] = args["DocumentVersion"],
		["DocumentHashType"] = args["DocumentHashType"],
		["OutputS3KeyPrefix"] = args["OutputS3KeyPrefix"],
		["OutputS3Region"] = args["OutputS3Region"],
		["Targets"] = args["Targets"],
		["InstanceIds"] = args["InstanceIds"],
		["MaxConcurrency"] = args["MaxConcurrency"],
	}
	asserts.AssertSendCommandRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateDocumentDefaultVersionRequest = { ["Name"] = true, ["DocumentVersion"] = true, nil }

function asserts.AssertUpdateDocumentDefaultVersionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateDocumentDefaultVersionRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["DocumentVersion"], "Expected key DocumentVersion to exist in table")
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersionNumber(struct["DocumentVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateDocumentDefaultVersionRequest[k], "UpdateDocumentDefaultVersionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateDocumentDefaultVersionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [DocumentName] <p>The name of a custom document that you want to set as the default version.</p>
-- * DocumentVersion [DocumentVersionNumber] <p>The version of a custom document that you want to set as the default version.</p>
-- Required key: Name
-- Required key: DocumentVersion
-- @return UpdateDocumentDefaultVersionRequest structure as a key-value pair table
function M.UpdateDocumentDefaultVersionRequest(args)
	assert(args, "You must provide an argument table when creating UpdateDocumentDefaultVersionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["DocumentVersion"] = args["DocumentVersion"],
	}
	asserts.AssertUpdateDocumentDefaultVersionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledWindowExecution = { ["ExecutionTime"] = true, ["WindowId"] = true, ["Name"] = true, nil }

function asserts.AssertScheduledWindowExecution(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledWindowExecution to be of type 'table'")
	if struct["ExecutionTime"] then asserts.AssertMaintenanceWindowStringDateTime(struct["ExecutionTime"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledWindowExecution[k], "ScheduledWindowExecution contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledWindowExecution
-- <p>Information about a scheduled execution for a Maintenance Window.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExecutionTime [MaintenanceWindowStringDateTime] <p>The time, in ISO-8601 Extended format, that the Maintenance Window is scheduled to be run.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window to be run.</p>
-- * Name [MaintenanceWindowName] <p>The name of the Maintenance Window to be run.</p>
-- @return ScheduledWindowExecution structure as a key-value pair table
function M.ScheduledWindowExecution(args)
	assert(args, "You must provide an argument table when creating ScheduledWindowExecution")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExecutionTime"] = args["ExecutionTime"],
		["WindowId"] = args["WindowId"],
		["Name"] = args["Name"],
	}
	asserts.AssertScheduledWindowExecution(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPatchBaselineResult = { ["ApprovedPatchesEnableNonSecurity"] = true, ["BaselineId"] = true, ["Name"] = true, ["PatchGroups"] = true, ["RejectedPatches"] = true, ["GlobalFilters"] = true, ["Sources"] = true, ["ApprovalRules"] = true, ["ModifiedDate"] = true, ["CreatedDate"] = true, ["Description"] = true, ["ApprovedPatchesComplianceLevel"] = true, ["OperatingSystem"] = true, ["ApprovedPatches"] = true, ["RejectedPatchesAction"] = true, nil }

function asserts.AssertGetPatchBaselineResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPatchBaselineResult to be of type 'table'")
	if struct["ApprovedPatchesEnableNonSecurity"] then asserts.AssertBoolean(struct["ApprovedPatchesEnableNonSecurity"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["Name"] then asserts.AssertBaselineName(struct["Name"]) end
	if struct["PatchGroups"] then asserts.AssertPatchGroupList(struct["PatchGroups"]) end
	if struct["RejectedPatches"] then asserts.AssertPatchIdList(struct["RejectedPatches"]) end
	if struct["GlobalFilters"] then asserts.AssertPatchFilterGroup(struct["GlobalFilters"]) end
	if struct["Sources"] then asserts.AssertPatchSourceList(struct["Sources"]) end
	if struct["ApprovalRules"] then asserts.AssertPatchRuleGroup(struct["ApprovalRules"]) end
	if struct["ModifiedDate"] then asserts.AssertDateTime(struct["ModifiedDate"]) end
	if struct["CreatedDate"] then asserts.AssertDateTime(struct["CreatedDate"]) end
	if struct["Description"] then asserts.AssertBaselineDescription(struct["Description"]) end
	if struct["ApprovedPatchesComplianceLevel"] then asserts.AssertPatchComplianceLevel(struct["ApprovedPatchesComplianceLevel"]) end
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	if struct["ApprovedPatches"] then asserts.AssertPatchIdList(struct["ApprovedPatches"]) end
	if struct["RejectedPatchesAction"] then asserts.AssertPatchAction(struct["RejectedPatchesAction"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPatchBaselineResult[k], "GetPatchBaselineResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPatchBaselineResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ApprovedPatchesEnableNonSecurity [Boolean] <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
-- * BaselineId [BaselineId] <p>The ID of the retrieved patch baseline.</p>
-- * Name [BaselineName] <p>The name of the patch baseline.</p>
-- * PatchGroups [PatchGroupList] <p>Patch groups included in the patch baseline.</p>
-- * RejectedPatches [PatchIdList] <p>A list of explicitly rejected patches for the baseline.</p>
-- * GlobalFilters [PatchFilterGroup] <p>A set of global filters used to exclude patches from the baseline.</p>
-- * Sources [PatchSourceList] <p>Information about the patches to use to update the instances, including target operating systems and source repositories. Applies to Linux instances only.</p>
-- * ApprovalRules [PatchRuleGroup] <p>A set of rules used to include patches in the baseline.</p>
-- * ModifiedDate [DateTime] <p>The date the patch baseline was last modified.</p>
-- * CreatedDate [DateTime] <p>The date the patch baseline was created.</p>
-- * Description [BaselineDescription] <p>A description of the patch baseline.</p>
-- * ApprovedPatchesComplianceLevel [PatchComplianceLevel] <p>Returns the specified compliance severity level for approved patches in the patch baseline.</p>
-- * OperatingSystem [OperatingSystem] <p>Returns the operating system specified for the patch baseline.</p>
-- * ApprovedPatches [PatchIdList] <p>A list of explicitly approved patches for the baseline.</p>
-- * RejectedPatchesAction [PatchAction] <p>The action specified to take on patches included in the RejectedPatches list. A patch can be allowed only if it is a dependency of another package, or blocked entirely along with packages that include it as a dependency.</p>
-- @return GetPatchBaselineResult structure as a key-value pair table
function M.GetPatchBaselineResult(args)
	assert(args, "You must provide an argument table when creating GetPatchBaselineResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ApprovedPatchesEnableNonSecurity"] = args["ApprovedPatchesEnableNonSecurity"],
		["BaselineId"] = args["BaselineId"],
		["Name"] = args["Name"],
		["PatchGroups"] = args["PatchGroups"],
		["RejectedPatches"] = args["RejectedPatches"],
		["GlobalFilters"] = args["GlobalFilters"],
		["Sources"] = args["Sources"],
		["ApprovalRules"] = args["ApprovalRules"],
		["ModifiedDate"] = args["ModifiedDate"],
		["CreatedDate"] = args["CreatedDate"],
		["Description"] = args["Description"],
		["ApprovedPatchesComplianceLevel"] = args["ApprovedPatchesComplianceLevel"],
		["OperatingSystem"] = args["OperatingSystem"],
		["ApprovedPatches"] = args["ApprovedPatches"],
		["RejectedPatchesAction"] = args["RejectedPatchesAction"],
	}
	asserts.AssertGetPatchBaselineResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NotificationConfig = { ["NotificationArn"] = true, ["NotificationEvents"] = true, ["NotificationType"] = true, nil }

function asserts.AssertNotificationConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NotificationConfig to be of type 'table'")
	if struct["NotificationArn"] then asserts.AssertNotificationArn(struct["NotificationArn"]) end
	if struct["NotificationEvents"] then asserts.AssertNotificationEventList(struct["NotificationEvents"]) end
	if struct["NotificationType"] then asserts.AssertNotificationType(struct["NotificationType"]) end
	for k,_ in pairs(struct) do
		assert(keys.NotificationConfig[k], "NotificationConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NotificationConfig
-- <p>Configurations for sending notifications.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NotificationArn [NotificationArn] <p>An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.</p>
-- * NotificationEvents [NotificationEventList] <p>The different events for which you can receive notifications. These events include the following: All (events), InProgress, Success, TimedOut, Cancelled, Failed. To learn more about these events, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/rc-sns-notifications.html">Configuring Amazon SNS Notifications for Run Command</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * NotificationType [NotificationType] <p>Command: Receive notification when the status of a command changes. Invocation: For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes. </p>
-- @return NotificationConfig structure as a key-value pair table
function M.NotificationConfig(args)
	assert(args, "You must provide an argument table when creating NotificationConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NotificationArn"] = args["NotificationArn"],
		["NotificationEvents"] = args["NotificationEvents"],
		["NotificationType"] = args["NotificationType"],
	}
	asserts.AssertNotificationConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyDocumentPermissionRequest = { ["AccountIdsToAdd"] = true, ["PermissionType"] = true, ["AccountIdsToRemove"] = true, ["Name"] = true, nil }

function asserts.AssertModifyDocumentPermissionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyDocumentPermissionRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["PermissionType"], "Expected key PermissionType to exist in table")
	if struct["AccountIdsToAdd"] then asserts.AssertAccountIdList(struct["AccountIdsToAdd"]) end
	if struct["PermissionType"] then asserts.AssertDocumentPermissionType(struct["PermissionType"]) end
	if struct["AccountIdsToRemove"] then asserts.AssertAccountIdList(struct["AccountIdsToRemove"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyDocumentPermissionRequest[k], "ModifyDocumentPermissionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyDocumentPermissionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AccountIdsToAdd [AccountIdList] <p>The AWS user accounts that should have access to the document. The account IDs can either be a group of account IDs or <i>All</i>.</p>
-- * PermissionType [DocumentPermissionType] <p>The permission type for the document. The permission type can be <i>Share</i>.</p>
-- * AccountIdsToRemove [AccountIdList] <p>The AWS user accounts that should no longer have access to the document. The AWS user account can either be a group of account IDs or <i>All</i>. This action has a higher priority than <i>AccountIdsToAdd</i>. If you specify an account ID to add and the same ID to remove, the system removes access to the document.</p>
-- * Name [DocumentName] <p>The name of the document that you want to share.</p>
-- Required key: Name
-- Required key: PermissionType
-- @return ModifyDocumentPermissionRequest structure as a key-value pair table
function M.ModifyDocumentPermissionRequest(args)
	assert(args, "You must provide an argument table when creating ModifyDocumentPermissionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AccountIdsToAdd"] = args["AccountIdsToAdd"],
		["PermissionType"] = args["PermissionType"],
		["AccountIdsToRemove"] = args["AccountIdsToRemove"],
		["Name"] = args["Name"],
	}
	asserts.AssertModifyDocumentPermissionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterTargetWithMaintenanceWindowRequest = { ["Description"] = true, ["ResourceType"] = true, ["OwnerInformation"] = true, ["WindowId"] = true, ["ClientToken"] = true, ["Targets"] = true, ["Name"] = true, nil }

function asserts.AssertRegisterTargetWithMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterTargetWithMaintenanceWindowRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["Targets"], "Expected key Targets to exist in table")
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["ResourceType"] then asserts.AssertMaintenanceWindowResourceType(struct["ResourceType"]) end
	if struct["OwnerInformation"] then asserts.AssertOwnerInformation(struct["OwnerInformation"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["ClientToken"] then asserts.AssertClientToken(struct["ClientToken"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterTargetWithMaintenanceWindowRequest[k], "RegisterTargetWithMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterTargetWithMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [MaintenanceWindowDescription] <p>An optional description for the target.</p>
-- * ResourceType [MaintenanceWindowResourceType] <p>The type of target being registered with the Maintenance Window.</p>
-- * OwnerInformation [OwnerInformation] <p>User-provided value that will be included in any CloudWatch events raised while running tasks for these targets in this Maintenance Window.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window the target should be registered with.</p>
-- * ClientToken [ClientToken] <p>User-provided idempotency token.</p>
-- * Targets [Targets] <p>The targets (either instances or tags). </p> <p>Specify instances using the following format:</p> <p> <code>Key=InstanceIds,Values=&lt;instance-id-1&gt;,&lt;instance-id-2&gt;</code> </p> <p>Specify tags using either of the following formats:</p> <p> <code>Key=tag:&lt;tag-key&gt;,Values=&lt;tag-value-1&gt;,&lt;tag-value-2&gt;</code> </p> <p> <code>Key=tag-key,Values=&lt;tag-key-1&gt;,&lt;tag-key-2&gt;</code> </p>
-- * Name [MaintenanceWindowName] <p>An optional name for the target.</p>
-- Required key: WindowId
-- Required key: ResourceType
-- Required key: Targets
-- @return RegisterTargetWithMaintenanceWindowRequest structure as a key-value pair table
function M.RegisterTargetWithMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating RegisterTargetWithMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Description"] = args["Description"],
		["ResourceType"] = args["ResourceType"],
		["OwnerInformation"] = args["OwnerInformation"],
		["WindowId"] = args["WindowId"],
		["ClientToken"] = args["ClientToken"],
		["Targets"] = args["Targets"],
		["Name"] = args["Name"],
	}
	asserts.AssertRegisterTargetWithMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowResult = { ["StartDate"] = true, ["EndDate"] = true, ["Name"] = true, ["Schedule"] = true, ["CreatedDate"] = true, ["Enabled"] = true, ["ScheduleTimezone"] = true, ["Cutoff"] = true, ["AllowUnassociatedTargets"] = true, ["WindowId"] = true, ["ModifiedDate"] = true, ["NextExecutionTime"] = true, ["Duration"] = true, ["Description"] = true, nil }

function asserts.AssertGetMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowResult to be of type 'table'")
	if struct["StartDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["StartDate"]) end
	if struct["EndDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["EndDate"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	if struct["Schedule"] then asserts.AssertMaintenanceWindowSchedule(struct["Schedule"]) end
	if struct["CreatedDate"] then asserts.AssertDateTime(struct["CreatedDate"]) end
	if struct["Enabled"] then asserts.AssertMaintenanceWindowEnabled(struct["Enabled"]) end
	if struct["ScheduleTimezone"] then asserts.AssertMaintenanceWindowTimezone(struct["ScheduleTimezone"]) end
	if struct["Cutoff"] then asserts.AssertMaintenanceWindowCutoff(struct["Cutoff"]) end
	if struct["AllowUnassociatedTargets"] then asserts.AssertMaintenanceWindowAllowUnassociatedTargets(struct["AllowUnassociatedTargets"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["ModifiedDate"] then asserts.AssertDateTime(struct["ModifiedDate"]) end
	if struct["NextExecutionTime"] then asserts.AssertMaintenanceWindowStringDateTime(struct["NextExecutionTime"]) end
	if struct["Duration"] then asserts.AssertMaintenanceWindowDurationHours(struct["Duration"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowResult[k], "GetMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StartDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when the Maintenance Window is scheduled to become active. The Maintenance Window will not run before this specified time.</p>
-- * EndDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when the Maintenance Window is scheduled to become inactive. The Maintenance Window will not run after this specified time.</p>
-- * Name [MaintenanceWindowName] <p>The name of the Maintenance Window.</p>
-- * Schedule [MaintenanceWindowSchedule] <p>The schedule of the Maintenance Window in the form of a cron or rate expression.</p>
-- * CreatedDate [DateTime] <p>The date the Maintenance Window was created.</p>
-- * Enabled [MaintenanceWindowEnabled] <p>Whether the Maintenance Windows is enabled.</p>
-- * ScheduleTimezone [MaintenanceWindowTimezone] <p>The time zone that the scheduled Maintenance Window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "etc/UTC", or "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time Zone Database</a> on the IANA website.</p>
-- * Cutoff [MaintenanceWindowCutoff] <p>The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution.</p>
-- * AllowUnassociatedTargets [MaintenanceWindowAllowUnassociatedTargets] <p>Whether targets must be registered with the Maintenance Window before tasks can be defined for those targets.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the created Maintenance Window.</p>
-- * ModifiedDate [DateTime] <p>The date the Maintenance Window was last modified.</p>
-- * NextExecutionTime [MaintenanceWindowStringDateTime] <p>The next time the Maintenance Window will actually run, taking into account any specified times for the Maintenance Window to become active or inactive.</p>
-- * Duration [MaintenanceWindowDurationHours] <p>The duration of the Maintenance Window in hours.</p>
-- * Description [MaintenanceWindowDescription] <p>The description of the Maintenance Window.</p>
-- @return GetMaintenanceWindowResult structure as a key-value pair table
function M.GetMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StartDate"] = args["StartDate"],
		["EndDate"] = args["EndDate"],
		["Name"] = args["Name"],
		["Schedule"] = args["Schedule"],
		["CreatedDate"] = args["CreatedDate"],
		["Enabled"] = args["Enabled"],
		["ScheduleTimezone"] = args["ScheduleTimezone"],
		["Cutoff"] = args["Cutoff"],
		["AllowUnassociatedTargets"] = args["AllowUnassociatedTargets"],
		["WindowId"] = args["WindowId"],
		["ModifiedDate"] = args["ModifiedDate"],
		["NextExecutionTime"] = args["NextExecutionTime"],
		["Duration"] = args["Duration"],
		["Description"] = args["Description"],
	}
	asserts.AssertGetMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAssociationRequest = { ["MaxErrors"] = true, ["ScheduleExpression"] = true, ["OutputLocation"] = true, ["Name"] = true, ["Parameters"] = true, ["AssociationId"] = true, ["DocumentVersion"] = true, ["AssociationVersion"] = true, ["AssociationName"] = true, ["Targets"] = true, ["ComplianceSeverity"] = true, ["MaxConcurrency"] = true, nil }

function asserts.AssertUpdateAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["ScheduleExpression"] then asserts.AssertScheduleExpression(struct["ScheduleExpression"]) end
	if struct["OutputLocation"] then asserts.AssertInstanceAssociationOutputLocation(struct["OutputLocation"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	if struct["AssociationName"] then asserts.AssertAssociationName(struct["AssociationName"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["ComplianceSeverity"] then asserts.AssertAssociationComplianceSeverity(struct["ComplianceSeverity"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateAssociationRequest[k], "UpdateAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxErrors [MaxErrors] <p>The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 instances and set MaxError to 10%, then the system stops sending the request when the sixth error is received.</p> <p>Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.</p>
-- * ScheduleExpression [ScheduleExpression] <p>The cron expression used to schedule the association that you want to update.</p>
-- * OutputLocation [InstanceAssociationOutputLocation] <p>An Amazon S3 bucket where you want to store the results of this request.</p>
-- * Name [DocumentName] <p>The name of the association document.</p>
-- * Parameters [Parameters] <p>The parameters you want to update for the association. If you create a parameter using Parameter Store, you can reference the parameter using {{ssm:parameter-name}}</p>
-- * AssociationId [AssociationId] <p>The ID of the association you want to update. </p>
-- * DocumentVersion [DocumentVersion] <p>The document version you want update for the association. </p>
-- * AssociationVersion [AssociationVersion] <p>This parameter is provided for concurrency control purposes. You must specify the latest association version in the service. If you want to ensure that this request succeeds, either specify <code>$LATEST</code>, or omit this parameter.</p>
-- * AssociationName [AssociationName] <p>The name of the association that you want to update.</p>
-- * Targets [Targets] <p>The targets of the association.</p>
-- * ComplianceSeverity [AssociationComplianceSeverity] <p>The severity level to assign to the association.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time.</p> <p>If a new instance starts and attempts to execute an association while Systems Manager is executing MaxConcurrency associations, the association is allowed to run. During the next association interval, the new instance will process its association within the limit specified for MaxConcurrency.</p>
-- Required key: AssociationId
-- @return UpdateAssociationRequest structure as a key-value pair table
function M.UpdateAssociationRequest(args)
	assert(args, "You must provide an argument table when creating UpdateAssociationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxErrors"] = args["MaxErrors"],
		["ScheduleExpression"] = args["ScheduleExpression"],
		["OutputLocation"] = args["OutputLocation"],
		["Name"] = args["Name"],
		["Parameters"] = args["Parameters"],
		["AssociationId"] = args["AssociationId"],
		["DocumentVersion"] = args["DocumentVersion"],
		["AssociationVersion"] = args["AssociationVersion"],
		["AssociationName"] = args["AssociationName"],
		["Targets"] = args["Targets"],
		["ComplianceSeverity"] = args["ComplianceSeverity"],
		["MaxConcurrency"] = args["MaxConcurrency"],
	}
	asserts.AssertUpdateAssociationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAssociationStatusResult = { ["AssociationDescription"] = true, nil }

function asserts.AssertUpdateAssociationStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAssociationStatusResult to be of type 'table'")
	if struct["AssociationDescription"] then asserts.AssertAssociationDescription(struct["AssociationDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateAssociationStatusResult[k], "UpdateAssociationStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAssociationStatusResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationDescription [AssociationDescription] <p>Information about the association.</p>
-- @return UpdateAssociationStatusResult structure as a key-value pair table
function M.UpdateAssociationStatusResult(args)
	assert(args, "You must provide an argument table when creating UpdateAssociationStatusResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationDescription"] = args["AssociationDescription"],
	}
	asserts.AssertUpdateAssociationStatusResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListDocumentsResult = { ["DocumentIdentifiers"] = true, ["NextToken"] = true, nil }

function asserts.AssertListDocumentsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListDocumentsResult to be of type 'table'")
	if struct["DocumentIdentifiers"] then asserts.AssertDocumentIdentifierList(struct["DocumentIdentifiers"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListDocumentsResult[k], "ListDocumentsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListDocumentsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DocumentIdentifiers [DocumentIdentifierList] <p>The names of the Systems Manager documents.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return ListDocumentsResult structure as a key-value pair table
function M.ListDocumentsResult(args)
	assert(args, "You must provide an argument table when creating ListDocumentsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DocumentIdentifiers"] = args["DocumentIdentifiers"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertListDocumentsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowExecutionTaskInvocationResult = { ["Status"] = true, ["Parameters"] = true, ["OwnerInformation"] = true, ["WindowTargetId"] = true, ["ExecutionId"] = true, ["InvocationId"] = true, ["StartTime"] = true, ["TaskType"] = true, ["EndTime"] = true, ["WindowExecutionId"] = true, ["StatusDetails"] = true, ["TaskExecutionId"] = true, nil }

function asserts.AssertGetMaintenanceWindowExecutionTaskInvocationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowExecutionTaskInvocationResult to be of type 'table'")
	if struct["Status"] then asserts.AssertMaintenanceWindowExecutionStatus(struct["Status"]) end
	if struct["Parameters"] then asserts.AssertMaintenanceWindowExecutionTaskInvocationParameters(struct["Parameters"]) end
	if struct["OwnerInformation"] then asserts.AssertOwnerInformation(struct["OwnerInformation"]) end
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTaskTargetId(struct["WindowTargetId"]) end
	if struct["ExecutionId"] then asserts.AssertMaintenanceWindowExecutionTaskExecutionId(struct["ExecutionId"]) end
	if struct["InvocationId"] then asserts.AssertMaintenanceWindowExecutionTaskInvocationId(struct["InvocationId"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["TaskType"] then asserts.AssertMaintenanceWindowTaskType(struct["TaskType"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["StatusDetails"] then asserts.AssertMaintenanceWindowExecutionStatusDetails(struct["StatusDetails"]) end
	if struct["TaskExecutionId"] then asserts.AssertMaintenanceWindowExecutionTaskId(struct["TaskExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowExecutionTaskInvocationResult[k], "GetMaintenanceWindowExecutionTaskInvocationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowExecutionTaskInvocationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [MaintenanceWindowExecutionStatus] <p>The task status for an invocation.</p>
-- * Parameters [MaintenanceWindowExecutionTaskInvocationParameters] <p>The parameters used at the time that the task executed.</p>
-- * OwnerInformation [OwnerInformation] <p>User-provided value to be included in any CloudWatch events raised while running tasks for these targets in this Maintenance Window. </p>
-- * WindowTargetId [MaintenanceWindowTaskTargetId] <p>The Maintenance Window target ID.</p>
-- * ExecutionId [MaintenanceWindowExecutionTaskExecutionId] <p>The execution ID.</p>
-- * InvocationId [MaintenanceWindowExecutionTaskInvocationId] <p>The invocation ID.</p>
-- * StartTime [DateTime] <p>The time that the task started executing on the target.</p>
-- * TaskType [MaintenanceWindowTaskType] <p>Retrieves the task type for a Maintenance Window. Task types include the following: LAMBDA, STEP_FUNCTION, AUTOMATION, RUN_COMMAND.</p>
-- * EndTime [DateTime] <p>The time that the task finished executing on the target.</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The Maintenance Window execution ID.</p>
-- * StatusDetails [MaintenanceWindowExecutionStatusDetails] <p>The details explaining the status. Details are only available for certain status values.</p>
-- * TaskExecutionId [MaintenanceWindowExecutionTaskId] <p>The task execution ID.</p>
-- @return GetMaintenanceWindowExecutionTaskInvocationResult structure as a key-value pair table
function M.GetMaintenanceWindowExecutionTaskInvocationResult(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowExecutionTaskInvocationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Parameters"] = args["Parameters"],
		["OwnerInformation"] = args["OwnerInformation"],
		["WindowTargetId"] = args["WindowTargetId"],
		["ExecutionId"] = args["ExecutionId"],
		["InvocationId"] = args["InvocationId"],
		["StartTime"] = args["StartTime"],
		["TaskType"] = args["TaskType"],
		["EndTime"] = args["EndTime"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["StatusDetails"] = args["StatusDetails"],
		["TaskExecutionId"] = args["TaskExecutionId"],
	}
	asserts.AssertGetMaintenanceWindowExecutionTaskInvocationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceAggregatedAssociationOverview = { ["DetailedStatus"] = true, ["InstanceAssociationStatusAggregatedCount"] = true, nil }

function asserts.AssertInstanceAggregatedAssociationOverview(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAggregatedAssociationOverview to be of type 'table'")
	if struct["DetailedStatus"] then asserts.AssertStatusName(struct["DetailedStatus"]) end
	if struct["InstanceAssociationStatusAggregatedCount"] then asserts.AssertInstanceAssociationStatusAggregatedCount(struct["InstanceAssociationStatusAggregatedCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAggregatedAssociationOverview[k], "InstanceAggregatedAssociationOverview contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAggregatedAssociationOverview
-- <p>Status information about the aggregated associations.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DetailedStatus [StatusName] <p>Detailed status information about the aggregated associations.</p>
-- * InstanceAssociationStatusAggregatedCount [InstanceAssociationStatusAggregatedCount] <p>The number of associations for the instance(s).</p>
-- @return InstanceAggregatedAssociationOverview structure as a key-value pair table
function M.InstanceAggregatedAssociationOverview(args)
	assert(args, "You must provide an argument table when creating InstanceAggregatedAssociationOverview")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DetailedStatus"] = args["DetailedStatus"],
		["InstanceAssociationStatusAggregatedCount"] = args["InstanceAssociationStatusAggregatedCount"],
	}
	asserts.AssertInstanceAggregatedAssociationOverview(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancePatchesRequest = { ["InstanceId"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInstancePatchesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancePatchesRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertPatchComplianceMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertPatchOrchestratorFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancePatchesRequest[k], "DescribeInstancePatchesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancePatchesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The ID of the instance whose patch state information should be retrieved.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [PatchComplianceMaxResults] <p>The maximum number of patches to return (per page).</p>
-- * Filters [PatchOrchestratorFilterList] <p>Each entry in the array is a structure containing:</p> <p>Key (string, between 1 and 128 characters)</p> <p>Values (array of strings, each string between 1 and 256 characters)</p>
-- Required key: InstanceId
-- @return DescribeInstancePatchesRequest structure as a key-value pair table
function M.DescribeInstancePatchesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstancePatchesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInstancePatchesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceInformationStringFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertInstanceInformationStringFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceInformationStringFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Values"], "Expected key Values to exist in table")
	if struct["Values"] then asserts.AssertInstanceInformationFilterValueSet(struct["Values"]) end
	if struct["Key"] then asserts.AssertInstanceInformationStringFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceInformationStringFilter[k], "InstanceInformationStringFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceInformationStringFilter
-- <p>The filters to describe or get information about your managed instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [InstanceInformationFilterValueSet] <p>The filter values.</p>
-- * Key [InstanceInformationStringFilterKey] <p>The filter key name to describe your instances. For example:</p> <p>"InstanceIds"|"AgentVersion"|"PingStatus"|"PlatformTypes"|"ActivationIds"|"IamRole"|"ResourceType"|"AssociationStatus"|"Tag Key"</p>
-- Required key: Key
-- Required key: Values
-- @return InstanceInformationStringFilter structure as a key-value pair table
function M.InstanceInformationStringFilter(args)
	assert(args, "You must provide an argument table when creating InstanceInformationStringFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertInstanceInformationStringFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowRequest = { ["WindowId"] = true, nil }

function asserts.AssertGetMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowRequest[k], "GetMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the desired Maintenance Window.</p>
-- Required key: WindowId
-- @return GetMaintenanceWindowRequest structure as a key-value pair table
function M.GetMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
	}
	asserts.AssertGetMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteInventoryResult = { ["TypeName"] = true, ["DeletionSummary"] = true, ["DeletionId"] = true, nil }

function asserts.AssertDeleteInventoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteInventoryResult to be of type 'table'")
	if struct["TypeName"] then asserts.AssertInventoryItemTypeName(struct["TypeName"]) end
	if struct["DeletionSummary"] then asserts.AssertInventoryDeletionSummary(struct["DeletionSummary"]) end
	if struct["DeletionId"] then asserts.AssertInventoryDeletionId(struct["DeletionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteInventoryResult[k], "DeleteInventoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteInventoryResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TypeName [InventoryItemTypeName] <p>The name of the inventory data type specified in the request.</p>
-- * DeletionSummary [InventoryDeletionSummary] <p>A summary of the delete operation. For more information about this summary, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-inventory-delete.html#sysman-inventory-delete-summary">Understanding the Delete Inventory Summary</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * DeletionId [InventoryDeletionId] <p>Every <code>DeleteInventory</code> action is assigned a unique ID. This option returns a unique ID. You can use this ID to query the status of a delete operation. This option is useful for ensuring that a delete operation has completed before you begin other actions. </p>
-- @return DeleteInventoryResult structure as a key-value pair table
function M.DeleteInventoryResult(args)
	assert(args, "You must provide an argument table when creating DeleteInventoryResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TypeName"] = args["TypeName"],
		["DeletionSummary"] = args["DeletionSummary"],
		["DeletionId"] = args["DeletionId"],
	}
	asserts.AssertDeleteInventoryResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterTargetFromMaintenanceWindowResult = { ["WindowId"] = true, ["WindowTargetId"] = true, nil }

function asserts.AssertDeregisterTargetFromMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterTargetFromMaintenanceWindowResult to be of type 'table'")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTargetId(struct["WindowTargetId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterTargetFromMaintenanceWindowResult[k], "DeregisterTargetFromMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterTargetFromMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window the target was removed from.</p>
-- * WindowTargetId [MaintenanceWindowTargetId] <p>The ID of the removed target definition.</p>
-- @return DeregisterTargetFromMaintenanceWindowResult structure as a key-value pair table
function M.DeregisterTargetFromMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating DeregisterTargetFromMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
		["WindowTargetId"] = args["WindowTargetId"],
	}
	asserts.AssertDeregisterTargetFromMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateResourceDataSyncResult = { nil }

function asserts.AssertCreateResourceDataSyncResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateResourceDataSyncResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.CreateResourceDataSyncResult[k], "CreateResourceDataSyncResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateResourceDataSyncResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return CreateResourceDataSyncResult structure as a key-value pair table
function M.CreateResourceDataSyncResult(args)
	assert(args, "You must provide an argument table when creating CreateResourceDataSyncResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertCreateResourceDataSyncResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AddTagsToResourceResult = { nil }

function asserts.AssertAddTagsToResourceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AddTagsToResourceResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.AddTagsToResourceResult[k], "AddTagsToResourceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AddTagsToResourceResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return AddTagsToResourceResult structure as a key-value pair table
function M.AddTagsToResourceResult(args)
	assert(args, "You must provide an argument table when creating AddTagsToResourceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertAddTagsToResourceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateManagedInstanceRoleResult = { nil }

function asserts.AssertUpdateManagedInstanceRoleResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateManagedInstanceRoleResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.UpdateManagedInstanceRoleResult[k], "UpdateManagedInstanceRoleResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateManagedInstanceRoleResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return UpdateManagedInstanceRoleResult structure as a key-value pair table
function M.UpdateManagedInstanceRoleResult(args)
	assert(args, "You must provide an argument table when creating UpdateManagedInstanceRoleResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertUpdateManagedInstanceRoleResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertMaintenanceWindowFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowsRequest[k], "DescribeMaintenanceWindowsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaintenanceWindowMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [MaintenanceWindowFilterList] <p>Optional filters used to narrow down the scope of the returned Maintenance Windows. Supported filter keys are Name and Enabled.</p>
-- @return DescribeMaintenanceWindowsRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeMaintenanceWindowsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateActivationResult = { ["ActivationCode"] = true, ["ActivationId"] = true, nil }

function asserts.AssertCreateActivationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateActivationResult to be of type 'table'")
	if struct["ActivationCode"] then asserts.AssertActivationCode(struct["ActivationCode"]) end
	if struct["ActivationId"] then asserts.AssertActivationId(struct["ActivationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateActivationResult[k], "CreateActivationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateActivationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ActivationCode [ActivationCode] <p>The code the system generates when it processes the activation. The activation code functions like a password to validate the activation ID. </p>
-- * ActivationId [ActivationId] <p>The ID number generated by the system when it processed the activation. The activation ID functions like a user name.</p>
-- @return CreateActivationResult structure as a key-value pair table
function M.CreateActivationResult(args)
	assert(args, "You must provide an argument table when creating CreateActivationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ActivationCode"] = args["ActivationCode"],
		["ActivationId"] = args["ActivationId"],
	}
	asserts.AssertCreateActivationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Session = { ["Status"] = true, ["StartDate"] = true, ["EndDate"] = true, ["Target"] = true, ["DocumentName"] = true, ["SessionId"] = true, ["Details"] = true, ["Owner"] = true, ["OutputUrl"] = true, nil }

function asserts.AssertSession(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Session to be of type 'table'")
	if struct["Status"] then asserts.AssertSessionStatus(struct["Status"]) end
	if struct["StartDate"] then asserts.AssertDateTime(struct["StartDate"]) end
	if struct["EndDate"] then asserts.AssertDateTime(struct["EndDate"]) end
	if struct["Target"] then asserts.AssertSessionTarget(struct["Target"]) end
	if struct["DocumentName"] then asserts.AssertDocumentName(struct["DocumentName"]) end
	if struct["SessionId"] then asserts.AssertSessionId(struct["SessionId"]) end
	if struct["Details"] then asserts.AssertSessionDetails(struct["Details"]) end
	if struct["Owner"] then asserts.AssertSessionOwner(struct["Owner"]) end
	if struct["OutputUrl"] then asserts.AssertSessionManagerOutputUrl(struct["OutputUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.Session[k], "Session contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Session
-- <p>Information about a Session Manager connection to an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [SessionStatus] <p>The status of the session. For example, "Connected" or "Terminated".</p>
-- * StartDate [DateTime] <p>The date and time, in ISO-8601 Extended format, when the session began.</p>
-- * EndDate [DateTime] <p>The date and time, in ISO-8601 Extended format, when the session was terminated.</p>
-- * Target [SessionTarget] <p>The instance that the Session Manager session connected to.</p>
-- * DocumentName [DocumentName] <p>The name of the Session Manager SSM document used to define the parameters and plugin settings for the session. For example, <code>SSM-SessionManagerRunShell</code>.</p>
-- * SessionId [SessionId] <p>The ID of the session.</p>
-- * Details [SessionDetails] <p>Reserved for future use.</p>
-- * Owner [SessionOwner] <p>The ID of the AWS user account that started the session.</p>
-- * OutputUrl [SessionManagerOutputUrl] <p>Reserved for future use.</p>
-- @return Session structure as a key-value pair table
function M.Session(args)
	assert(args, "You must provide an argument table when creating Session")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["StartDate"] = args["StartDate"],
		["EndDate"] = args["EndDate"],
		["Target"] = args["Target"],
		["DocumentName"] = args["DocumentName"],
		["SessionId"] = args["SessionId"],
		["Details"] = args["Details"],
		["Owner"] = args["Owner"],
		["OutputUrl"] = args["OutputUrl"],
	}
	asserts.AssertSession(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LoggingInfo = { ["S3KeyPrefix"] = true, ["S3BucketName"] = true, ["S3Region"] = true, nil }

function asserts.AssertLoggingInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LoggingInfo to be of type 'table'")
	assert(struct["S3BucketName"], "Expected key S3BucketName to exist in table")
	assert(struct["S3Region"], "Expected key S3Region to exist in table")
	if struct["S3KeyPrefix"] then asserts.AssertS3KeyPrefix(struct["S3KeyPrefix"]) end
	if struct["S3BucketName"] then asserts.AssertS3BucketName(struct["S3BucketName"]) end
	if struct["S3Region"] then asserts.AssertS3Region(struct["S3Region"]) end
	for k,_ in pairs(struct) do
		assert(keys.LoggingInfo[k], "LoggingInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LoggingInfo
-- <p>Information about an Amazon S3 bucket to write instance-level logs to.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3KeyPrefix [S3KeyPrefix] <p>(Optional) The Amazon S3 bucket subfolder. </p>
-- * S3BucketName [S3BucketName] <p>The name of an Amazon S3 bucket where execution logs are stored .</p>
-- * S3Region [S3Region] <p>The region where the Amazon S3 bucket is located.</p>
-- Required key: S3BucketName
-- Required key: S3Region
-- @return LoggingInfo structure as a key-value pair table
function M.LoggingInfo(args)
	assert(args, "You must provide an argument table when creating LoggingInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3KeyPrefix"] = args["S3KeyPrefix"],
		["S3BucketName"] = args["S3BucketName"],
		["S3Region"] = args["S3Region"],
	}
	asserts.AssertLoggingInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CommandFilter = { ["value"] = true, ["key"] = true, nil }

function asserts.AssertCommandFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CommandFilter to be of type 'table'")
	assert(struct["key"], "Expected key key to exist in table")
	assert(struct["value"], "Expected key value to exist in table")
	if struct["value"] then asserts.AssertCommandFilterValue(struct["value"]) end
	if struct["key"] then asserts.AssertCommandFilterKey(struct["key"]) end
	for k,_ in pairs(struct) do
		assert(keys.CommandFilter[k], "CommandFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CommandFilter
-- <p>Describes a command filter.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * value [CommandFilterValue] <p>The filter value. Valid values for each filter key are as follows:</p> <ul> <li> <p>InvokedAfter: A timestamp to limit your results. For example, specify <code>2018-07-07T00:00:00Z</code> to see results occurring July 7, 2018, and later.</p> </li> <li> <p>InvokedBefore: A timestamp to limit your results. For example, specify <code>2018-07-07T00:00:00Z</code> to see results before July 7, 2018.</p> </li> <li> <p>Status: Specify a valid command status to see a list of all command executions with that status. Status values you can specify include:</p> <ul> <li> <p>Pending</p> </li> <li> <p>InProgress</p> </li> <li> <p>Success</p> </li> <li> <p>Cancelled</p> </li> <li> <p>Failed</p> </li> <li> <p>TimedOut</p> </li> <li> <p>Cancelling </p> </li> </ul> </li> <li> <p>DocumentName: The name of the SSM document for which you want to see command results.</p> <p>For example, specify <code>AWS-RunPatchBaseline</code> to see command executions that used this SSM document to perform security patching operations on instances. </p> </li> <li> <p>ExecutionStage: An enum whose value can be either <code>Executing</code> or <code>Complete</code>.</p> <ul> <li> <p>Specify <code>Executing</code> to see a list of command executions that are currently still running.</p> </li> <li> <p>Specify <code>Complete</code> to see a list of command exeuctions that have already completed.</p> </li> </ul> </li> </ul>
-- * key [CommandFilterKey] <p>The name of the filter.</p>
-- Required key: key
-- Required key: value
-- @return CommandFilter structure as a key-value pair table
function M.CommandFilter(args)
	assert(args, "You must provide an argument table when creating CommandFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["value"] = args["value"],
		["key"] = args["key"],
	}
	asserts.AssertCommandFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartAutomationExecutionRequest = { ["MaxErrors"] = true, ["MaxConcurrency"] = true, ["Parameters"] = true, ["DocumentName"] = true, ["DocumentVersion"] = true, ["Mode"] = true, ["ClientToken"] = true, ["TargetMaps"] = true, ["Targets"] = true, ["TargetParameterName"] = true, nil }

function asserts.AssertStartAutomationExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartAutomationExecutionRequest to be of type 'table'")
	assert(struct["DocumentName"], "Expected key DocumentName to exist in table")
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["Parameters"] then asserts.AssertAutomationParameterMap(struct["Parameters"]) end
	if struct["DocumentName"] then asserts.AssertDocumentARN(struct["DocumentName"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["Mode"] then asserts.AssertExecutionMode(struct["Mode"]) end
	if struct["ClientToken"] then asserts.AssertIdempotencyToken(struct["ClientToken"]) end
	if struct["TargetMaps"] then asserts.AssertTargetMaps(struct["TargetMaps"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["TargetParameterName"] then asserts.AssertAutomationParameterKey(struct["TargetParameterName"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartAutomationExecutionRequest[k], "StartAutomationExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartAutomationExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxErrors [MaxErrors] <p>The number of errors that are allowed before the system stops running the automation on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops running the automation when the fourth error is received. If you specify 0, then the system stops running the automation on additional targets after the first error result is returned. If you run an automation on 50 resources and set max-errors to 10%, then the system stops running the automation on additional targets when the sixth error is received.</p> <p>Executions that are already running an automation when max-errors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set max-concurrency to 1 so the executions proceed one at a time.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets allowed to run this task in parallel. You can specify a number, such as 10, or a percentage, such as 10%. The default value is 10.</p>
-- * Parameters [AutomationParameterMap] <p>A key-value map of execution parameters, which match the declared parameters in the Automation document.</p>
-- * DocumentName [DocumentARN] <p>The name of the Automation document to use for this execution.</p>
-- * DocumentVersion [DocumentVersion] <p>The version of the Automation document to use for this execution.</p>
-- * Mode [ExecutionMode] <p>The execution mode of the automation. Valid modes include the following: Auto and Interactive. The default mode is Auto.</p>
-- * ClientToken [IdempotencyToken] <p>User-provided idempotency token. The token must be unique, is case insensitive, enforces the UUID format, and can't be reused.</p>
-- * TargetMaps [TargetMaps] <p>A key-value mapping of document parameters to target resources. Both Targets and TargetMaps cannot be specified together.</p>
-- * Targets [Targets] <p>A key-value mapping to target resources. Required if you specify TargetParameterName.</p>
-- * TargetParameterName [AutomationParameterKey] <p>The name of the parameter used as the target resource for the rate-controlled execution. Required if you specify targets.</p>
-- Required key: DocumentName
-- @return StartAutomationExecutionRequest structure as a key-value pair table
function M.StartAutomationExecutionRequest(args)
	assert(args, "You must provide an argument table when creating StartAutomationExecutionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxErrors"] = args["MaxErrors"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["Parameters"] = args["Parameters"],
		["DocumentName"] = args["DocumentName"],
		["DocumentVersion"] = args["DocumentVersion"],
		["Mode"] = args["Mode"],
		["ClientToken"] = args["ClientToken"],
		["TargetMaps"] = args["TargetMaps"],
		["Targets"] = args["Targets"],
		["TargetParameterName"] = args["TargetParameterName"],
	}
	asserts.AssertStartAutomationExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DocumentKeyValuesFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertDocumentKeyValuesFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DocumentKeyValuesFilter to be of type 'table'")
	if struct["Values"] then asserts.AssertDocumentKeyValuesFilterValues(struct["Values"]) end
	if struct["Key"] then asserts.AssertDocumentKeyValuesFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.DocumentKeyValuesFilter[k], "DocumentKeyValuesFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DocumentKeyValuesFilter
-- <p>One or more filters. Use a filter to return a more specific list of documents.</p> <p>For keys, you can specify one or more tags that have been applied to a document. </p> <p>Other valid values include Owner, Name, PlatformTypes, and DocumentType.</p> <p>Note that only one Owner can be specified in a request. For example: <code>Key=Owner,Values=Self</code>.</p> <p>If you use Name as a key, you can use a name prefix to return a list of documents. For example, in the AWS CLI, to return a list of all documents that begin with <code>Te</code>, run the following command:</p> <p> <code>aws ssm list-documents --filters Key=Name,Values=Te</code> </p> <p>If you specify more than two keys, only documents that are identified by all the tags are returned in the results. If you specify more than two values for a key, documents that are identified by any of the values are returned in the results.</p> <p>To specify a custom key and value pair, use the format <code>Key=tag:[tagName],Values=[valueName]</code>.</p> <p>For example, if you created a Key called region and are using the AWS CLI to call the <code>list-documents</code> command: </p> <p> <code>aws ssm list-documents --filters Key=tag:region,Values=east,west Key=Owner,Values=Self</code> </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [DocumentKeyValuesFilterValues] <p>The value for the filter key.</p>
-- * Key [DocumentKeyValuesFilterKey] <p>The name of the filter key.</p>
-- @return DocumentKeyValuesFilter structure as a key-value pair table
function M.DocumentKeyValuesFilter(args)
	assert(args, "You must provide an argument table when creating DocumentKeyValuesFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertDocumentKeyValuesFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceAssociationsStatusRequest = { ["InstanceId"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeInstanceAssociationsStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceAssociationsStatusRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceAssociationsStatusRequest[k], "DescribeInstanceAssociationsStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceAssociationsStatusRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The instance IDs for which you want association status information.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: InstanceId
-- @return DescribeInstanceAssociationsStatusRequest structure as a key-value pair table
function M.DescribeInstanceAssociationsStatusRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceAssociationsStatusRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeInstanceAssociationsStatusRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetCommandInvocationResult = { ["Comment"] = true, ["ExecutionElapsedTime"] = true, ["ExecutionEndDateTime"] = true, ["StandardErrorContent"] = true, ["CloudWatchOutputConfig"] = true, ["InstanceId"] = true, ["StandardErrorUrl"] = true, ["DocumentName"] = true, ["DocumentVersion"] = true, ["Status"] = true, ["StatusDetails"] = true, ["PluginName"] = true, ["StandardOutputContent"] = true, ["ResponseCode"] = true, ["ExecutionStartDateTime"] = true, ["CommandId"] = true, ["StandardOutputUrl"] = true, nil }

function asserts.AssertGetCommandInvocationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetCommandInvocationResult to be of type 'table'")
	if struct["Comment"] then asserts.AssertComment(struct["Comment"]) end
	if struct["ExecutionElapsedTime"] then asserts.AssertStringDateTime(struct["ExecutionElapsedTime"]) end
	if struct["ExecutionEndDateTime"] then asserts.AssertStringDateTime(struct["ExecutionEndDateTime"]) end
	if struct["StandardErrorContent"] then asserts.AssertStandardErrorContent(struct["StandardErrorContent"]) end
	if struct["CloudWatchOutputConfig"] then asserts.AssertCloudWatchOutputConfig(struct["CloudWatchOutputConfig"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["StandardErrorUrl"] then asserts.AssertUrl(struct["StandardErrorUrl"]) end
	if struct["DocumentName"] then asserts.AssertDocumentName(struct["DocumentName"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["Status"] then asserts.AssertCommandInvocationStatus(struct["Status"]) end
	if struct["StatusDetails"] then asserts.AssertStatusDetails(struct["StatusDetails"]) end
	if struct["PluginName"] then asserts.AssertCommandPluginName(struct["PluginName"]) end
	if struct["StandardOutputContent"] then asserts.AssertStandardOutputContent(struct["StandardOutputContent"]) end
	if struct["ResponseCode"] then asserts.AssertResponseCode(struct["ResponseCode"]) end
	if struct["ExecutionStartDateTime"] then asserts.AssertStringDateTime(struct["ExecutionStartDateTime"]) end
	if struct["CommandId"] then asserts.AssertCommandId(struct["CommandId"]) end
	if struct["StandardOutputUrl"] then asserts.AssertUrl(struct["StandardOutputUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetCommandInvocationResult[k], "GetCommandInvocationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetCommandInvocationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Comment [Comment] <p>The comment text for the command.</p>
-- * ExecutionElapsedTime [StringDateTime] <p>Duration since ExecutionStartDateTime.</p>
-- * ExecutionEndDateTime [StringDateTime] <p>The date and time the plugin was finished executing. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample AWS CLI command uses the <code>InvokedAfter</code> filter.</p> <p> <code>aws ssm list-commands --filters key=InvokedAfter,value=2017-06-07T00:00:00Z</code> </p> <p>If the plugin has not started to execute, the string is empty.</p>
-- * StandardErrorContent [StandardErrorContent] <p>The first 8,000 characters written by the plugin to stderr. If the command has not finished executing, then this string is empty.</p>
-- * CloudWatchOutputConfig [CloudWatchOutputConfig] <p>CloudWatch Logs information where Systems Manager sent the command output.</p>
-- * InstanceId [InstanceId] <p>The ID of the managed instance targeted by the command. A managed instance can be an Amazon EC2 instance or an instance in your hybrid environment that is configured for Systems Manager.</p>
-- * StandardErrorUrl [Url] <p>The URL for the complete text written by the plugin to stderr. If the command has not finished executing, then this string is empty.</p>
-- * DocumentName [DocumentName] <p>The name of the document that was executed. For example, AWS-RunShellScript.</p>
-- * DocumentVersion [DocumentVersion] <p>The SSM document version used in the request.</p>
-- * Status [CommandInvocationStatus] <p>The status of this invocation plugin. This status can be different than StatusDetails.</p>
-- * StatusDetails [StatusDetails] <p>A detailed status of the command execution for an invocation. StatusDetails includes more information than Status because it includes states resulting from error and concurrency control parameters. StatusDetails can show different results than Status. For more information about these statuses, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/monitor-commands.html">Understanding Command Statuses</a> in the <i>AWS Systems Manager User Guide</i>. StatusDetails can be one of the following values:</p> <ul> <li> <p>Pending: The command has not been sent to the instance.</p> </li> <li> <p>In Progress: The command has been sent to the instance but has not reached a terminal state.</p> </li> <li> <p>Delayed: The system attempted to send the command to the target, but the target was not available. The instance might not be available because of network issues, the instance was stopped, etc. The system will try to deliver the command again.</p> </li> <li> <p>Success: The command or plugin was executed successfully. This is a terminal state.</p> </li> <li> <p>Delivery Timed Out: The command was not delivered to the instance before the delivery timeout expired. Delivery timeouts do not count against the parent command's MaxErrors limit, but they do contribute to whether the parent command status is Success or Incomplete. This is a terminal state.</p> </li> <li> <p>Execution Timed Out: The command started to execute on the instance, but the execution was not complete before the timeout expired. Execution timeouts count against the MaxErrors limit of the parent command. This is a terminal state.</p> </li> <li> <p>Failed: The command wasn't executed successfully on the instance. For a plugin, this indicates that the result code was not zero. For a command invocation, this indicates that the result code for one or more plugins was not zero. Invocation failures count against the MaxErrors limit of the parent command. This is a terminal state.</p> </li> <li> <p>Canceled: The command was terminated before it was completed. This is a terminal state.</p> </li> <li> <p>Undeliverable: The command can't be delivered to the instance. The instance might not exist or might not be responding. Undeliverable invocations don't count against the parent command's MaxErrors limit and don't contribute to whether the parent command status is Success or Incomplete. This is a terminal state.</p> </li> <li> <p>Terminated: The parent command exceeded its MaxErrors limit and subsequent command invocations were canceled by the system. This is a terminal state.</p> </li> </ul>
-- * PluginName [CommandPluginName] <p>The name of the plugin for which you want detailed results. For example, aws:RunShellScript is a plugin.</p>
-- * StandardOutputContent [StandardOutputContent] <p>The first 24,000 characters written by the plugin to stdout. If the command has not finished executing, if ExecutionStatus is neither Succeeded nor Failed, then this string is empty.</p>
-- * ResponseCode [ResponseCode] <p>The error level response code for the plugin script. If the response code is -1, then the command has not started executing on the instance, or it was not received by the instance.</p>
-- * ExecutionStartDateTime [StringDateTime] <p>The date and time the plugin started executing. Date and time are written in ISO 8601 format. For example, June 7, 2017 is represented as 2017-06-7. The following sample AWS CLI command uses the <code>InvokedBefore</code> filter.</p> <p> <code>aws ssm list-commands --filters key=InvokedBefore,value=2017-06-07T00:00:00Z</code> </p> <p>If the plugin has not started to execute, the string is empty.</p>
-- * CommandId [CommandId] <p>The parent command ID of the invocation plugin.</p>
-- * StandardOutputUrl [Url] <p>The URL for the complete text written by the plugin to stdout in Amazon S3. If an Amazon S3 bucket was not specified, then this string is empty.</p>
-- @return GetCommandInvocationResult structure as a key-value pair table
function M.GetCommandInvocationResult(args)
	assert(args, "You must provide an argument table when creating GetCommandInvocationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Comment"] = args["Comment"],
		["ExecutionElapsedTime"] = args["ExecutionElapsedTime"],
		["ExecutionEndDateTime"] = args["ExecutionEndDateTime"],
		["StandardErrorContent"] = args["StandardErrorContent"],
		["CloudWatchOutputConfig"] = args["CloudWatchOutputConfig"],
		["InstanceId"] = args["InstanceId"],
		["StandardErrorUrl"] = args["StandardErrorUrl"],
		["DocumentName"] = args["DocumentName"],
		["DocumentVersion"] = args["DocumentVersion"],
		["Status"] = args["Status"],
		["StatusDetails"] = args["StatusDetails"],
		["PluginName"] = args["PluginName"],
		["StandardOutputContent"] = args["StandardOutputContent"],
		["ResponseCode"] = args["ResponseCode"],
		["ExecutionStartDateTime"] = args["ExecutionStartDateTime"],
		["CommandId"] = args["CommandId"],
		["StandardOutputUrl"] = args["StandardOutputUrl"],
	}
	asserts.AssertGetCommandInvocationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FailedCreateAssociation = { ["Entry"] = true, ["Message"] = true, ["Fault"] = true, nil }

function asserts.AssertFailedCreateAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FailedCreateAssociation to be of type 'table'")
	if struct["Entry"] then asserts.AssertCreateAssociationBatchRequestEntry(struct["Entry"]) end
	if struct["Message"] then asserts.AssertBatchErrorMessage(struct["Message"]) end
	if struct["Fault"] then asserts.AssertFault(struct["Fault"]) end
	for k,_ in pairs(struct) do
		assert(keys.FailedCreateAssociation[k], "FailedCreateAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FailedCreateAssociation
-- <p>Describes a failed association.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Entry [CreateAssociationBatchRequestEntry] <p>The association.</p>
-- * Message [BatchErrorMessage] <p>A description of the failure.</p>
-- * Fault [Fault] <p>The source of the failure.</p>
-- @return FailedCreateAssociation structure as a key-value pair table
function M.FailedCreateAssociation(args)
	assert(args, "You must provide an argument table when creating FailedCreateAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Entry"] = args["Entry"],
		["Message"] = args["Message"],
		["Fault"] = args["Fault"],
	}
	asserts.AssertFailedCreateAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DocumentDescription = { ["Status"] = true, ["TargetType"] = true, ["Sha1"] = true, ["Hash"] = true, ["Name"] = true, ["Parameters"] = true, ["Tags"] = true, ["DocumentType"] = true, ["PlatformTypes"] = true, ["DocumentVersion"] = true, ["HashType"] = true, ["CreatedDate"] = true, ["Owner"] = true, ["SchemaVersion"] = true, ["DefaultVersion"] = true, ["DocumentFormat"] = true, ["LatestVersion"] = true, ["Description"] = true, nil }

function asserts.AssertDocumentDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DocumentDescription to be of type 'table'")
	if struct["Status"] then asserts.AssertDocumentStatus(struct["Status"]) end
	if struct["TargetType"] then asserts.AssertTargetType(struct["TargetType"]) end
	if struct["Sha1"] then asserts.AssertDocumentSha1(struct["Sha1"]) end
	if struct["Hash"] then asserts.AssertDocumentHash(struct["Hash"]) end
	if struct["Name"] then asserts.AssertDocumentARN(struct["Name"]) end
	if struct["Parameters"] then asserts.AssertDocumentParameterList(struct["Parameters"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["DocumentType"] then asserts.AssertDocumentType(struct["DocumentType"]) end
	if struct["PlatformTypes"] then asserts.AssertPlatformTypeList(struct["PlatformTypes"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["HashType"] then asserts.AssertDocumentHashType(struct["HashType"]) end
	if struct["CreatedDate"] then asserts.AssertDateTime(struct["CreatedDate"]) end
	if struct["Owner"] then asserts.AssertDocumentOwner(struct["Owner"]) end
	if struct["SchemaVersion"] then asserts.AssertDocumentSchemaVersion(struct["SchemaVersion"]) end
	if struct["DefaultVersion"] then asserts.AssertDocumentVersion(struct["DefaultVersion"]) end
	if struct["DocumentFormat"] then asserts.AssertDocumentFormat(struct["DocumentFormat"]) end
	if struct["LatestVersion"] then asserts.AssertDocumentVersion(struct["LatestVersion"]) end
	if struct["Description"] then asserts.AssertDescriptionInDocument(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DocumentDescription[k], "DocumentDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DocumentDescription
-- <p>Describes a Systems Manager document. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [DocumentStatus] <p>The status of the Systems Manager document.</p>
-- * TargetType [TargetType] <p>The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
-- * Sha1 [DocumentSha1] <p>The SHA1 hash of the document, which you can use for verification.</p>
-- * Hash [DocumentHash] <p>The Sha256 or Sha1 hash created by the system when the document was created. </p> <note> <p>Sha1 hashes have been deprecated.</p> </note>
-- * Name [DocumentARN] <p>The name of the Systems Manager document.</p>
-- * Parameters [DocumentParameterList] <p>A description of the parameters for a document.</p>
-- * Tags [TagList] <p>The tags, or metadata, that have been applied to the document.</p>
-- * DocumentType [DocumentType] <p>The type of document. </p>
-- * PlatformTypes [PlatformTypeList] <p>The list of OS platforms compatible with this Systems Manager document. </p>
-- * DocumentVersion [DocumentVersion] <p>The document version.</p>
-- * HashType [DocumentHashType] <p>Sha256 or Sha1.</p> <note> <p>Sha1 hashes have been deprecated.</p> </note>
-- * CreatedDate [DateTime] <p>The date when the document was created.</p>
-- * Owner [DocumentOwner] <p>The AWS user account that created the document.</p>
-- * SchemaVersion [DocumentSchemaVersion] <p>The schema version.</p>
-- * DefaultVersion [DocumentVersion] <p>The default version.</p>
-- * DocumentFormat [DocumentFormat] <p>The document format, either JSON or YAML.</p>
-- * LatestVersion [DocumentVersion] <p>The latest version of the document.</p>
-- * Description [DescriptionInDocument] <p>A description of the document. </p>
-- @return DocumentDescription structure as a key-value pair table
function M.DocumentDescription(args)
	assert(args, "You must provide an argument table when creating DocumentDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["TargetType"] = args["TargetType"],
		["Sha1"] = args["Sha1"],
		["Hash"] = args["Hash"],
		["Name"] = args["Name"],
		["Parameters"] = args["Parameters"],
		["Tags"] = args["Tags"],
		["DocumentType"] = args["DocumentType"],
		["PlatformTypes"] = args["PlatformTypes"],
		["DocumentVersion"] = args["DocumentVersion"],
		["HashType"] = args["HashType"],
		["CreatedDate"] = args["CreatedDate"],
		["Owner"] = args["Owner"],
		["SchemaVersion"] = args["SchemaVersion"],
		["DefaultVersion"] = args["DefaultVersion"],
		["DocumentFormat"] = args["DocumentFormat"],
		["LatestVersion"] = args["LatestVersion"],
		["Description"] = args["Description"],
	}
	asserts.AssertDocumentDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAssociationResult = { ["AssociationDescription"] = true, nil }

function asserts.AssertUpdateAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAssociationResult to be of type 'table'")
	if struct["AssociationDescription"] then asserts.AssertAssociationDescription(struct["AssociationDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateAssociationResult[k], "UpdateAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationDescription [AssociationDescription] <p>The description of the association that was updated.</p>
-- @return UpdateAssociationResult structure as a key-value pair table
function M.UpdateAssociationResult(args)
	assert(args, "You must provide an argument table when creating UpdateAssociationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationDescription"] = args["AssociationDescription"],
	}
	asserts.AssertUpdateAssociationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MaintenanceWindowTarget = { ["Name"] = true, ["ResourceType"] = true, ["OwnerInformation"] = true, ["WindowTargetId"] = true, ["WindowId"] = true, ["Targets"] = true, ["Description"] = true, nil }

function asserts.AssertMaintenanceWindowTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MaintenanceWindowTarget to be of type 'table'")
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	if struct["ResourceType"] then asserts.AssertMaintenanceWindowResourceType(struct["ResourceType"]) end
	if struct["OwnerInformation"] then asserts.AssertOwnerInformation(struct["OwnerInformation"]) end
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTargetId(struct["WindowTargetId"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.MaintenanceWindowTarget[k], "MaintenanceWindowTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MaintenanceWindowTarget
-- <p>The target registered with the Maintenance Window.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [MaintenanceWindowName] <p>The target name.</p>
-- * ResourceType [MaintenanceWindowResourceType] <p>The type of target.</p>
-- * OwnerInformation [OwnerInformation] <p>User-provided value that will be included in any CloudWatch events raised while running tasks for these targets in this Maintenance Window.</p>
-- * WindowTargetId [MaintenanceWindowTargetId] <p>The ID of the target.</p>
-- * WindowId [MaintenanceWindowId] <p>The Maintenance Window ID where the target is registered.</p>
-- * Targets [Targets] <p>The targets (either instances or tags). Instances are specified using Key=instanceids,Values=&lt;instanceid1&gt;,&lt;instanceid2&gt;. Tags are specified using Key=&lt;tag name&gt;,Values=&lt;tag value&gt;.</p>
-- * Description [MaintenanceWindowDescription] <p>A description of the target.</p>
-- @return MaintenanceWindowTarget structure as a key-value pair table
function M.MaintenanceWindowTarget(args)
	assert(args, "You must provide an argument table when creating MaintenanceWindowTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["ResourceType"] = args["ResourceType"],
		["OwnerInformation"] = args["OwnerInformation"],
		["WindowTargetId"] = args["WindowTargetId"],
		["WindowId"] = args["WindowId"],
		["Targets"] = args["Targets"],
		["Description"] = args["Description"],
	}
	asserts.AssertMaintenanceWindowTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowExecutionTaskResult = { ["Status"] = true, ["MaxErrors"] = true, ["TaskArn"] = true, ["MaxConcurrency"] = true, ["ServiceRole"] = true, ["WindowExecutionId"] = true, ["StatusDetails"] = true, ["Priority"] = true, ["StartTime"] = true, ["EndTime"] = true, ["Type"] = true, ["TaskParameters"] = true, ["TaskExecutionId"] = true, nil }

function asserts.AssertGetMaintenanceWindowExecutionTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowExecutionTaskResult to be of type 'table'")
	if struct["Status"] then asserts.AssertMaintenanceWindowExecutionStatus(struct["Status"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["TaskArn"] then asserts.AssertMaintenanceWindowTaskArn(struct["TaskArn"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["ServiceRole"] then asserts.AssertServiceRole(struct["ServiceRole"]) end
	if struct["WindowExecutionId"] then asserts.AssertMaintenanceWindowExecutionId(struct["WindowExecutionId"]) end
	if struct["StatusDetails"] then asserts.AssertMaintenanceWindowExecutionStatusDetails(struct["StatusDetails"]) end
	if struct["Priority"] then asserts.AssertMaintenanceWindowTaskPriority(struct["Priority"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["Type"] then asserts.AssertMaintenanceWindowTaskType(struct["Type"]) end
	if struct["TaskParameters"] then asserts.AssertMaintenanceWindowTaskParametersList(struct["TaskParameters"]) end
	if struct["TaskExecutionId"] then asserts.AssertMaintenanceWindowExecutionTaskId(struct["TaskExecutionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowExecutionTaskResult[k], "GetMaintenanceWindowExecutionTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowExecutionTaskResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [MaintenanceWindowExecutionStatus] <p>The status of the task.</p>
-- * MaxErrors [MaxErrors] <p>The defined maximum number of task execution errors allowed before scheduling of the task execution would have been stopped.</p>
-- * TaskArn [MaintenanceWindowTaskArn] <p>The ARN of the executed task.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The defined maximum number of task executions that could be run in parallel.</p>
-- * ServiceRole [ServiceRole] <p>The role that was assumed when executing the task.</p>
-- * WindowExecutionId [MaintenanceWindowExecutionId] <p>The ID of the Maintenance Window execution that includes the task.</p>
-- * StatusDetails [MaintenanceWindowExecutionStatusDetails] <p>The details explaining the Status. Only available for certain status values.</p>
-- * Priority [MaintenanceWindowTaskPriority] <p>The priority of the task.</p>
-- * StartTime [DateTime] <p>The time the task execution started.</p>
-- * EndTime [DateTime] <p>The time the task execution completed.</p>
-- * Type [MaintenanceWindowTaskType] <p>The type of task executed.</p>
-- * TaskParameters [MaintenanceWindowTaskParametersList] <p>The parameters passed to the task when it was executed.</p> <note> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note> <p>The map has the following format:</p> <p>Key: string, between 1 and 255 characters</p> <p>Value: an array of strings, each string is between 1 and 255 characters</p>
-- * TaskExecutionId [MaintenanceWindowExecutionTaskId] <p>The ID of the specific task execution in the Maintenance Window task that was retrieved.</p>
-- @return GetMaintenanceWindowExecutionTaskResult structure as a key-value pair table
function M.GetMaintenanceWindowExecutionTaskResult(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowExecutionTaskResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["MaxErrors"] = args["MaxErrors"],
		["TaskArn"] = args["TaskArn"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["ServiceRole"] = args["ServiceRole"],
		["WindowExecutionId"] = args["WindowExecutionId"],
		["StatusDetails"] = args["StatusDetails"],
		["Priority"] = args["Priority"],
		["StartTime"] = args["StartTime"],
		["EndTime"] = args["EndTime"],
		["Type"] = args["Type"],
		["TaskParameters"] = args["TaskParameters"],
		["TaskExecutionId"] = args["TaskExecutionId"],
	}
	asserts.AssertGetMaintenanceWindowExecutionTaskResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LabelParameterVersionRequest = { ["ParameterVersion"] = true, ["Labels"] = true, ["Name"] = true, nil }

function asserts.AssertLabelParameterVersionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LabelParameterVersionRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["Labels"], "Expected key Labels to exist in table")
	if struct["ParameterVersion"] then asserts.AssertPSParameterVersion(struct["ParameterVersion"]) end
	if struct["Labels"] then asserts.AssertParameterLabelList(struct["Labels"]) end
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.LabelParameterVersionRequest[k], "LabelParameterVersionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LabelParameterVersionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ParameterVersion [PSParameterVersion] <p>The specific version of the parameter on which you want to attach one or more labels. If no version is specified, the system attaches the label to the latest version.)</p>
-- * Labels [ParameterLabelList] <p>One or more labels to attach to the specified parameter version.</p>
-- * Name [PSParameterName] <p>The parameter name on which you want to attach one or more labels.</p>
-- Required key: Name
-- Required key: Labels
-- @return LabelParameterVersionRequest structure as a key-value pair table
function M.LabelParameterVersionRequest(args)
	assert(args, "You must provide an argument table when creating LabelParameterVersionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ParameterVersion"] = args["ParameterVersion"],
		["Labels"] = args["Labels"],
		["Name"] = args["Name"],
	}
	asserts.AssertLabelParameterVersionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetInventoryResult = { ["Entities"] = true, ["NextToken"] = true, nil }

function asserts.AssertGetInventoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetInventoryResult to be of type 'table'")
	if struct["Entities"] then asserts.AssertInventoryResultEntityList(struct["Entities"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetInventoryResult[k], "GetInventoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetInventoryResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Entities [InventoryResultEntityList] <p>Collection of inventory entities such as a collection of instance inventory. </p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return GetInventoryResult structure as a key-value pair table
function M.GetInventoryResult(args)
	assert(args, "You must provide an argument table when creating GetInventoryResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Entities"] = args["Entities"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertGetInventoryResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPatchBaselineRequest = { ["BaselineId"] = true, nil }

function asserts.AssertGetPatchBaselineRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPatchBaselineRequest to be of type 'table'")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPatchBaselineRequest[k], "GetPatchBaselineRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPatchBaselineRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineId [BaselineId] <p>The ID of the patch baseline to retrieve.</p>
-- Required key: BaselineId
-- @return GetPatchBaselineRequest structure as a key-value pair table
function M.GetPatchBaselineRequest(args)
	assert(args, "You must provide an argument table when creating GetPatchBaselineRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertGetPatchBaselineRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SeveritySummary = { ["InformationalCount"] = true, ["CriticalCount"] = true, ["HighCount"] = true, ["MediumCount"] = true, ["LowCount"] = true, ["UnspecifiedCount"] = true, nil }

function asserts.AssertSeveritySummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SeveritySummary to be of type 'table'")
	if struct["InformationalCount"] then asserts.AssertComplianceSummaryCount(struct["InformationalCount"]) end
	if struct["CriticalCount"] then asserts.AssertComplianceSummaryCount(struct["CriticalCount"]) end
	if struct["HighCount"] then asserts.AssertComplianceSummaryCount(struct["HighCount"]) end
	if struct["MediumCount"] then asserts.AssertComplianceSummaryCount(struct["MediumCount"]) end
	if struct["LowCount"] then asserts.AssertComplianceSummaryCount(struct["LowCount"]) end
	if struct["UnspecifiedCount"] then asserts.AssertComplianceSummaryCount(struct["UnspecifiedCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.SeveritySummary[k], "SeveritySummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SeveritySummary
-- <p>The number of managed instances found for each patch severity level defined in the request filter.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InformationalCount [ComplianceSummaryCount] <p>The total number of resources or compliance items that have a severity level of informational. Informational severity is determined by the organization that published the compliance items.</p>
-- * CriticalCount [ComplianceSummaryCount] <p>The total number of resources or compliance items that have a severity level of critical. Critical severity is determined by the organization that published the compliance items.</p>
-- * HighCount [ComplianceSummaryCount] <p>The total number of resources or compliance items that have a severity level of high. High severity is determined by the organization that published the compliance items.</p>
-- * MediumCount [ComplianceSummaryCount] <p>The total number of resources or compliance items that have a severity level of medium. Medium severity is determined by the organization that published the compliance items.</p>
-- * LowCount [ComplianceSummaryCount] <p>The total number of resources or compliance items that have a severity level of low. Low severity is determined by the organization that published the compliance items.</p>
-- * UnspecifiedCount [ComplianceSummaryCount] <p>The total number of resources or compliance items that have a severity level of unspecified. Unspecified severity is determined by the organization that published the compliance items.</p>
-- @return SeveritySummary structure as a key-value pair table
function M.SeveritySummary(args)
	assert(args, "You must provide an argument table when creating SeveritySummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InformationalCount"] = args["InformationalCount"],
		["CriticalCount"] = args["CriticalCount"],
		["HighCount"] = args["HighCount"],
		["MediumCount"] = args["MediumCount"],
		["LowCount"] = args["LowCount"],
		["UnspecifiedCount"] = args["UnspecifiedCount"],
	}
	asserts.AssertSeveritySummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterPatchBaselineForPatchGroupResult = { ["PatchGroup"] = true, ["BaselineId"] = true, nil }

function asserts.AssertRegisterPatchBaselineForPatchGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterPatchBaselineForPatchGroupResult to be of type 'table'")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterPatchBaselineForPatchGroupResult[k], "RegisterPatchBaselineForPatchGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterPatchBaselineForPatchGroupResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group registered with the patch baseline.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline the patch group was registered with.</p>
-- @return RegisterPatchBaselineForPatchGroupResult structure as a key-value pair table
function M.RegisterPatchBaselineForPatchGroupResult(args)
	assert(args, "You must provide an argument table when creating RegisterPatchBaselineForPatchGroupResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertRegisterPatchBaselineForPatchGroupResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PutComplianceItemsRequest = { ["ItemContentHash"] = true, ["ResourceType"] = true, ["ResourceId"] = true, ["ComplianceType"] = true, ["ExecutionSummary"] = true, ["Items"] = true, nil }

function asserts.AssertPutComplianceItemsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PutComplianceItemsRequest to be of type 'table'")
	assert(struct["ResourceId"], "Expected key ResourceId to exist in table")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["ComplianceType"], "Expected key ComplianceType to exist in table")
	assert(struct["ExecutionSummary"], "Expected key ExecutionSummary to exist in table")
	assert(struct["Items"], "Expected key Items to exist in table")
	if struct["ItemContentHash"] then asserts.AssertComplianceItemContentHash(struct["ItemContentHash"]) end
	if struct["ResourceType"] then asserts.AssertComplianceResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertComplianceResourceId(struct["ResourceId"]) end
	if struct["ComplianceType"] then asserts.AssertComplianceTypeName(struct["ComplianceType"]) end
	if struct["ExecutionSummary"] then asserts.AssertComplianceExecutionSummary(struct["ExecutionSummary"]) end
	if struct["Items"] then asserts.AssertComplianceItemEntryList(struct["Items"]) end
	for k,_ in pairs(struct) do
		assert(keys.PutComplianceItemsRequest[k], "PutComplianceItemsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PutComplianceItemsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ItemContentHash [ComplianceItemContentHash] <p>MD5 or SHA-256 content hash. The content hash is used to determine if existing information should be overwritten or ignored. If the content hashes match, the request to put compliance information is ignored.</p>
-- * ResourceType [ComplianceResourceType] <p>Specify the type of resource. <code>ManagedInstance</code> is currently the only supported resource type.</p>
-- * ResourceId [ComplianceResourceId] <p>Specify an ID for this resource. For a managed instance, this is the instance ID.</p>
-- * ComplianceType [ComplianceTypeName] <p>Specify the compliance type. For example, specify Association (for a State Manager association), Patch, or Custom:<code>string</code>.</p>
-- * ExecutionSummary [ComplianceExecutionSummary] <p>A summary of the call execution that includes an execution ID, the type of execution (for example, <code>Command</code>), and the date/time of the execution using a datetime object that is saved in the following format: yyyy-MM-dd'T'HH:mm:ss'Z'.</p>
-- * Items [ComplianceItemEntryList] <p>Information about the compliance as defined by the resource type. For example, for a patch compliance type, <code>Items</code> includes information about the PatchSeverity, Classification, etc.</p>
-- Required key: ResourceId
-- Required key: ResourceType
-- Required key: ComplianceType
-- Required key: ExecutionSummary
-- Required key: Items
-- @return PutComplianceItemsRequest structure as a key-value pair table
function M.PutComplianceItemsRequest(args)
	assert(args, "You must provide an argument table when creating PutComplianceItemsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ItemContentHash"] = args["ItemContentHash"],
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["ComplianceType"] = args["ComplianceType"],
		["ExecutionSummary"] = args["ExecutionSummary"],
		["Items"] = args["Items"],
	}
	asserts.AssertPutComplianceItemsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMaintenanceWindowScheduleRequest = { ["ResourceType"] = true, ["MaxResults"] = true, ["WindowId"] = true, ["Filters"] = true, ["NextToken"] = true, ["Targets"] = true, nil }

function asserts.AssertDescribeMaintenanceWindowScheduleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMaintenanceWindowScheduleRequest to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertMaintenanceWindowResourceType(struct["ResourceType"]) end
	if struct["MaxResults"] then asserts.AssertMaintenanceWindowSearchMaxResults(struct["MaxResults"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Filters"] then asserts.AssertPatchOrchestratorFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMaintenanceWindowScheduleRequest[k], "DescribeMaintenanceWindowScheduleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMaintenanceWindowScheduleRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [MaintenanceWindowResourceType] <p>The type of resource you want to retrieve information about. For example, "INSTANCE".</p>
-- * MaxResults [MaintenanceWindowSearchMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window to retrieve information about.</p>
-- * Filters [PatchOrchestratorFilterList] <p>Filters used to limit the range of results. For example, you can limit Maintenance Window executions to only those scheduled before or after a certain date and time.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * Targets [Targets] <p>The instance ID or key/value pair to retrieve information about.</p>
-- @return DescribeMaintenanceWindowScheduleRequest structure as a key-value pair table
function M.DescribeMaintenanceWindowScheduleRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMaintenanceWindowScheduleRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["MaxResults"] = args["MaxResults"],
		["WindowId"] = args["WindowId"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
		["Targets"] = args["Targets"],
	}
	asserts.AssertDescribeMaintenanceWindowScheduleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterTargetFromMaintenanceWindowRequest = { ["WindowId"] = true, ["Safe"] = true, ["WindowTargetId"] = true, nil }

function asserts.AssertDeregisterTargetFromMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterTargetFromMaintenanceWindowRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	assert(struct["WindowTargetId"], "Expected key WindowTargetId to exist in table")
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Safe"] then asserts.AssertBoolean(struct["Safe"]) end
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTargetId(struct["WindowTargetId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterTargetFromMaintenanceWindowRequest[k], "DeregisterTargetFromMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterTargetFromMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window the target should be removed from.</p>
-- * Safe [Boolean] <p>The system checks if the target is being referenced by a task. If the target is being referenced, the system returns an error and does not deregister the target from the Maintenance Window.</p>
-- * WindowTargetId [MaintenanceWindowTargetId] <p>The ID of the target definition to remove.</p>
-- Required key: WindowId
-- Required key: WindowTargetId
-- @return DeregisterTargetFromMaintenanceWindowRequest structure as a key-value pair table
function M.DeregisterTargetFromMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating DeregisterTargetFromMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowId"] = args["WindowId"],
		["Safe"] = args["Safe"],
		["WindowTargetId"] = args["WindowTargetId"],
	}
	asserts.AssertDeregisterTargetFromMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteActivationResult = { nil }

function asserts.AssertDeleteActivationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteActivationResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteActivationResult[k], "DeleteActivationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteActivationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteActivationResult structure as a key-value pair table
function M.DeleteActivationResult(args)
	assert(args, "You must provide an argument table when creating DeleteActivationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteActivationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteParameterResult = { nil }

function asserts.AssertDeleteParameterResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteParameterResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteParameterResult[k], "DeleteParameterResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteParameterResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteParameterResult structure as a key-value pair table
function M.DeleteParameterResult(args)
	assert(args, "You must provide an argument table when creating DeleteParameterResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteParameterResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.S3OutputLocation = { ["OutputS3KeyPrefix"] = true, ["OutputS3BucketName"] = true, ["OutputS3Region"] = true, nil }

function asserts.AssertS3OutputLocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3OutputLocation to be of type 'table'")
	if struct["OutputS3KeyPrefix"] then asserts.AssertS3KeyPrefix(struct["OutputS3KeyPrefix"]) end
	if struct["OutputS3BucketName"] then asserts.AssertS3BucketName(struct["OutputS3BucketName"]) end
	if struct["OutputS3Region"] then asserts.AssertS3Region(struct["OutputS3Region"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3OutputLocation[k], "S3OutputLocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3OutputLocation
-- <p>An Amazon S3 bucket where you want to store the results of this request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OutputS3KeyPrefix [S3KeyPrefix] <p>The Amazon S3 bucket subfolder.</p>
-- * OutputS3BucketName [S3BucketName] <p>The name of the Amazon S3 bucket.</p>
-- * OutputS3Region [S3Region] <p>(Deprecated) You can no longer specify this parameter. The system ignores it. Instead, Systems Manager automatically determines the Amazon S3 bucket region.</p>
-- @return S3OutputLocation structure as a key-value pair table
function M.S3OutputLocation(args)
	assert(args, "You must provide an argument table when creating S3OutputLocation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OutputS3KeyPrefix"] = args["OutputS3KeyPrefix"],
		["OutputS3BucketName"] = args["OutputS3BucketName"],
		["OutputS3Region"] = args["OutputS3Region"],
	}
	asserts.AssertS3OutputLocation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationExecution = { ["Status"] = true, ["DetailedStatus"] = true, ["LastExecutionDate"] = true, ["AssociationId"] = true, ["ResourceCountByStatus"] = true, ["ExecutionId"] = true, ["CreatedTime"] = true, ["AssociationVersion"] = true, nil }

function asserts.AssertAssociationExecution(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationExecution to be of type 'table'")
	if struct["Status"] then asserts.AssertStatusName(struct["Status"]) end
	if struct["DetailedStatus"] then asserts.AssertStatusName(struct["DetailedStatus"]) end
	if struct["LastExecutionDate"] then asserts.AssertDateTime(struct["LastExecutionDate"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["ResourceCountByStatus"] then asserts.AssertResourceCountByStatus(struct["ResourceCountByStatus"]) end
	if struct["ExecutionId"] then asserts.AssertAssociationExecutionId(struct["ExecutionId"]) end
	if struct["CreatedTime"] then asserts.AssertDateTime(struct["CreatedTime"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationExecution[k], "AssociationExecution contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationExecution
-- <p>Includes information about the specified association.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [StatusName] <p>The status of the association execution.</p>
-- * DetailedStatus [StatusName] <p>Detailed status information about the execution.</p>
-- * LastExecutionDate [DateTime] <p>The date of the last execution.</p>
-- * AssociationId [AssociationId] <p>The association ID.</p>
-- * ResourceCountByStatus [ResourceCountByStatus] <p>An aggregate status of the resources in the execution based on the status type.</p>
-- * ExecutionId [AssociationExecutionId] <p>The execution ID for the association. If the association does not run at intervals or according to a schedule, then the ExecutionID is the same as the AssociationID.</p>
-- * CreatedTime [DateTime] <p>The time the execution started.</p>
-- * AssociationVersion [AssociationVersion] <p>The association version.</p>
-- @return AssociationExecution structure as a key-value pair table
function M.AssociationExecution(args)
	assert(args, "You must provide an argument table when creating AssociationExecution")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DetailedStatus"] = args["DetailedStatus"],
		["LastExecutionDate"] = args["LastExecutionDate"],
		["AssociationId"] = args["AssociationId"],
		["ResourceCountByStatus"] = args["ResourceCountByStatus"],
		["ExecutionId"] = args["ExecutionId"],
		["CreatedTime"] = args["CreatedTime"],
		["AssociationVersion"] = args["AssociationVersion"],
	}
	asserts.AssertAssociationExecution(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationOverview = { ["Status"] = true, ["DetailedStatus"] = true, ["AssociationStatusAggregatedCount"] = true, nil }

function asserts.AssertAssociationOverview(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationOverview to be of type 'table'")
	if struct["Status"] then asserts.AssertStatusName(struct["Status"]) end
	if struct["DetailedStatus"] then asserts.AssertStatusName(struct["DetailedStatus"]) end
	if struct["AssociationStatusAggregatedCount"] then asserts.AssertAssociationStatusAggregatedCount(struct["AssociationStatusAggregatedCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationOverview[k], "AssociationOverview contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationOverview
-- <p>Information about the association.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [StatusName] <p>The status of the association. Status can be: Pending, Success, or Failed.</p>
-- * DetailedStatus [StatusName] <p>A detailed status of the association.</p>
-- * AssociationStatusAggregatedCount [AssociationStatusAggregatedCount] <p>Returns the number of targets for the association status. For example, if you created an association with two instances, and one of them was successful, this would return the count of instances by status.</p>
-- @return AssociationOverview structure as a key-value pair table
function M.AssociationOverview(args)
	assert(args, "You must provide an argument table when creating AssociationOverview")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DetailedStatus"] = args["DetailedStatus"],
		["AssociationStatusAggregatedCount"] = args["AssociationStatusAggregatedCount"],
	}
	asserts.AssertAssociationOverview(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DocumentDefaultVersionDescription = { ["DefaultVersion"] = true, ["Name"] = true, nil }

function asserts.AssertDocumentDefaultVersionDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DocumentDefaultVersionDescription to be of type 'table'")
	if struct["DefaultVersion"] then asserts.AssertDocumentVersion(struct["DefaultVersion"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.DocumentDefaultVersionDescription[k], "DocumentDefaultVersionDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DocumentDefaultVersionDescription
-- <p>A default version of a document.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DefaultVersion [DocumentVersion] <p>The default version of the document.</p>
-- * Name [DocumentName] <p>The name of the document.</p>
-- @return DocumentDefaultVersionDescription structure as a key-value pair table
function M.DocumentDefaultVersionDescription(args)
	assert(args, "You must provide an argument table when creating DocumentDefaultVersionDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DefaultVersion"] = args["DefaultVersion"],
		["Name"] = args["Name"],
	}
	asserts.AssertDocumentDefaultVersionDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCommandInvocationsRequest = { ["InstanceId"] = true, ["MaxResults"] = true, ["Details"] = true, ["Filters"] = true, ["NextToken"] = true, ["CommandId"] = true, nil }

function asserts.AssertListCommandInvocationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCommandInvocationsRequest to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["MaxResults"] then asserts.AssertCommandMaxResults(struct["MaxResults"]) end
	if struct["Details"] then asserts.AssertBoolean(struct["Details"]) end
	if struct["Filters"] then asserts.AssertCommandFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["CommandId"] then asserts.AssertCommandId(struct["CommandId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCommandInvocationsRequest[k], "ListCommandInvocationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCommandInvocationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>(Optional) The command execution details for a specific instance ID.</p>
-- * MaxResults [CommandMaxResults] <p>(Optional) The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Details [Boolean] <p>(Optional) If set this returns the response of the command executions and any command output. By default this is set to False. </p>
-- * Filters [CommandFilterList] <p>(Optional) One or more filters. Use a filter to return a more specific list of results.</p>
-- * NextToken [NextToken] <p>(Optional) The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * CommandId [CommandId] <p>(Optional) The invocations for a specific command ID.</p>
-- @return ListCommandInvocationsRequest structure as a key-value pair table
function M.ListCommandInvocationsRequest(args)
	assert(args, "You must provide an argument table when creating ListCommandInvocationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["MaxResults"] = args["MaxResults"],
		["Details"] = args["Details"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
		["CommandId"] = args["CommandId"],
	}
	asserts.AssertListCommandInvocationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstancePatchState = { ["InstallOverrideList"] = true, ["BaselineId"] = true, ["FailedCount"] = true, ["InstanceId"] = true, ["OwnerInformation"] = true, ["NotApplicableCount"] = true, ["OperationEndTime"] = true, ["PatchGroup"] = true, ["InstalledRejectedCount"] = true, ["InstalledOtherCount"] = true, ["MissingCount"] = true, ["SnapshotId"] = true, ["Operation"] = true, ["OperationStartTime"] = true, ["InstalledCount"] = true, nil }

function asserts.AssertInstancePatchState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstancePatchState to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["PatchGroup"], "Expected key PatchGroup to exist in table")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	assert(struct["OperationStartTime"], "Expected key OperationStartTime to exist in table")
	assert(struct["OperationEndTime"], "Expected key OperationEndTime to exist in table")
	assert(struct["Operation"], "Expected key Operation to exist in table")
	if struct["InstallOverrideList"] then asserts.AssertInstallOverrideList(struct["InstallOverrideList"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["FailedCount"] then asserts.AssertPatchFailedCount(struct["FailedCount"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["OwnerInformation"] then asserts.AssertOwnerInformation(struct["OwnerInformation"]) end
	if struct["NotApplicableCount"] then asserts.AssertPatchNotApplicableCount(struct["NotApplicableCount"]) end
	if struct["OperationEndTime"] then asserts.AssertDateTime(struct["OperationEndTime"]) end
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["InstalledRejectedCount"] then asserts.AssertPatchInstalledRejectedCount(struct["InstalledRejectedCount"]) end
	if struct["InstalledOtherCount"] then asserts.AssertPatchInstalledOtherCount(struct["InstalledOtherCount"]) end
	if struct["MissingCount"] then asserts.AssertPatchMissingCount(struct["MissingCount"]) end
	if struct["SnapshotId"] then asserts.AssertSnapshotId(struct["SnapshotId"]) end
	if struct["Operation"] then asserts.AssertPatchOperationType(struct["Operation"]) end
	if struct["OperationStartTime"] then asserts.AssertDateTime(struct["OperationStartTime"]) end
	if struct["InstalledCount"] then asserts.AssertPatchInstalledCount(struct["InstalledCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstancePatchState[k], "InstancePatchState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstancePatchState
-- <p>Defines the high-level patch compliance state for a managed instance, providing information about the number of installed, missing, not applicable, and failed patches along with metadata about the operation when this information was gathered for the instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstallOverrideList [InstallOverrideList] <p>An https URL or an Amazon S3 path-style URL to a list of patches to be installed. This patch installation list, which you maintain in an Amazon S3 bucket in YAML format and specify in the SSM document <code>AWS-RunPatchBaseline</code>, overrides the patches specified by the default patch baseline.</p> <p>For more information about the <code>InstallOverrideList</code> parameter, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-about-aws-runpatchbaseline.html">About the SSM Document AWS-RunPatchBaseline</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline used to patch the instance.</p>
-- * FailedCount [PatchFailedCount] <p>The number of patches from the patch baseline that were attempted to be installed during the last patching operation, but failed to install.</p>
-- * InstanceId [InstanceId] <p>The ID of the managed instance the high-level patch compliance information was collected for.</p>
-- * OwnerInformation [OwnerInformation] <p>Placeholder information. This field will always be empty in the current release of the service.</p>
-- * NotApplicableCount [PatchNotApplicableCount] <p>The number of patches from the patch baseline that aren't applicable for the instance and hence aren't installed on the instance.</p>
-- * OperationEndTime [DateTime] <p>The time the most recent patching operation completed on the instance.</p>
-- * PatchGroup [PatchGroup] <p>The name of the patch group the managed instance belongs to.</p>
-- * InstalledRejectedCount [PatchInstalledRejectedCount] <p>The number of instances with patches installed that are specified in a RejectedPatches list. Patches with a status of <i>InstalledRejected</i> were typically installed before they were added to a RejectedPatches list.</p> <note> <p>If ALLOW_AS_DEPENDENCY is the specified option for RejectedPatchesAction, the value of InstalledRejectedCount will always be 0 (zero).</p> </note>
-- * InstalledOtherCount [PatchInstalledOtherCount] <p>The number of patches not specified in the patch baseline that are installed on the instance.</p>
-- * MissingCount [PatchMissingCount] <p>The number of patches from the patch baseline that are applicable for the instance but aren't currently installed.</p>
-- * SnapshotId [SnapshotId] <p>The ID of the patch baseline snapshot used during the patching operation when this compliance data was collected.</p>
-- * Operation [PatchOperationType] <p>The type of patching operation that was performed: SCAN (assess patch compliance state) or INSTALL (install missing patches).</p>
-- * OperationStartTime [DateTime] <p>The time the most recent patching operation was started on the instance.</p>
-- * InstalledCount [PatchInstalledCount] <p>The number of patches from the patch baseline that are installed on the instance.</p>
-- Required key: InstanceId
-- Required key: PatchGroup
-- Required key: BaselineId
-- Required key: OperationStartTime
-- Required key: OperationEndTime
-- Required key: Operation
-- @return InstancePatchState structure as a key-value pair table
function M.InstancePatchState(args)
	assert(args, "You must provide an argument table when creating InstancePatchState")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstallOverrideList"] = args["InstallOverrideList"],
		["BaselineId"] = args["BaselineId"],
		["FailedCount"] = args["FailedCount"],
		["InstanceId"] = args["InstanceId"],
		["OwnerInformation"] = args["OwnerInformation"],
		["NotApplicableCount"] = args["NotApplicableCount"],
		["OperationEndTime"] = args["OperationEndTime"],
		["PatchGroup"] = args["PatchGroup"],
		["InstalledRejectedCount"] = args["InstalledRejectedCount"],
		["InstalledOtherCount"] = args["InstalledOtherCount"],
		["MissingCount"] = args["MissingCount"],
		["SnapshotId"] = args["SnapshotId"],
		["Operation"] = args["Operation"],
		["OperationStartTime"] = args["OperationStartTime"],
		["InstalledCount"] = args["InstalledCount"],
	}
	asserts.AssertInstancePatchState(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchOrchestratorFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertPatchOrchestratorFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchOrchestratorFilter to be of type 'table'")
	if struct["Values"] then asserts.AssertPatchOrchestratorFilterValues(struct["Values"]) end
	if struct["Key"] then asserts.AssertPatchOrchestratorFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchOrchestratorFilter[k], "PatchOrchestratorFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchOrchestratorFilter
-- <p>Defines a filter used in Patch Manager APIs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [PatchOrchestratorFilterValues] <p>The value for the filter.</p>
-- * Key [PatchOrchestratorFilterKey] <p>The key for the filter.</p>
-- @return PatchOrchestratorFilter structure as a key-value pair table
function M.PatchOrchestratorFilter(args)
	assert(args, "You must provide an argument table when creating PatchOrchestratorFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertPatchOrchestratorFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAssociationExecutionTargetsRequest = { ["ExecutionId"] = true, ["AssociationId"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAssociationExecutionTargetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAssociationExecutionTargetsRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["ExecutionId"], "Expected key ExecutionId to exist in table")
	if struct["ExecutionId"] then asserts.AssertAssociationExecutionId(struct["ExecutionId"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertAssociationExecutionTargetsFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAssociationExecutionTargetsRequest[k], "DescribeAssociationExecutionTargetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAssociationExecutionTargetsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExecutionId [AssociationExecutionId] <p>The execution ID for which you want to view details.</p>
-- * AssociationId [AssociationId] <p>The association ID that includes the execution for which you want to view details.</p>
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [AssociationExecutionTargetsFilterList] <p>Filters for the request. You can specify the following filters and values.</p> <p>Status (EQUAL)</p> <p>ResourceId (EQUAL)</p> <p>ResourceType (EQUAL)</p>
-- Required key: AssociationId
-- Required key: ExecutionId
-- @return DescribeAssociationExecutionTargetsRequest structure as a key-value pair table
function M.DescribeAssociationExecutionTargetsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAssociationExecutionTargetsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExecutionId"] = args["ExecutionId"],
		["AssociationId"] = args["AssociationId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeAssociationExecutionTargetsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationFilter = { ["value"] = true, ["key"] = true, nil }

function asserts.AssertAssociationFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationFilter to be of type 'table'")
	assert(struct["key"], "Expected key key to exist in table")
	assert(struct["value"], "Expected key value to exist in table")
	if struct["value"] then asserts.AssertAssociationFilterValue(struct["value"]) end
	if struct["key"] then asserts.AssertAssociationFilterKey(struct["key"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationFilter[k], "AssociationFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationFilter
-- <p>Describes a filter.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * value [AssociationFilterValue] <p>The filter value.</p>
-- * key [AssociationFilterKey] <p>The name of the filter.</p>
-- Required key: key
-- Required key: value
-- @return AssociationFilter structure as a key-value pair table
function M.AssociationFilter(args)
	assert(args, "You must provide an argument table when creating AssociationFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["value"] = args["value"],
		["key"] = args["key"],
	}
	asserts.AssertAssociationFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParameterHistoryRequest = { ["NextToken"] = true, ["Name"] = true, ["MaxResults"] = true, ["WithDecryption"] = true, nil }

function asserts.AssertGetParameterHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParameterHistoryRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["WithDecryption"] then asserts.AssertBoolean(struct["WithDecryption"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParameterHistoryRequest[k], "GetParameterHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParameterHistoryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * Name [PSParameterName] <p>The name of a parameter you want to query.</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * WithDecryption [Boolean] <p>Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.</p>
-- Required key: Name
-- @return GetParameterHistoryRequest structure as a key-value pair table
function M.GetParameterHistoryRequest(args)
	assert(args, "You must provide an argument table when creating GetParameterHistoryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Name"] = args["Name"],
		["MaxResults"] = args["MaxResults"],
		["WithDecryption"] = args["WithDecryption"],
	}
	asserts.AssertGetParameterHistoryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterDefaultPatchBaselineRequest = { ["BaselineId"] = true, nil }

function asserts.AssertRegisterDefaultPatchBaselineRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterDefaultPatchBaselineRequest to be of type 'table'")
	assert(struct["BaselineId"], "Expected key BaselineId to exist in table")
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterDefaultPatchBaselineRequest[k], "RegisterDefaultPatchBaselineRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterDefaultPatchBaselineRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineId [BaselineId] <p>The ID of the patch baseline that should be the default patch baseline.</p>
-- Required key: BaselineId
-- @return RegisterDefaultPatchBaselineRequest structure as a key-value pair table
function M.RegisterDefaultPatchBaselineRequest(args)
	assert(args, "You must provide an argument table when creating RegisterDefaultPatchBaselineRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineId"] = args["BaselineId"],
	}
	asserts.AssertRegisterDefaultPatchBaselineRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePatchGroupsResult = { ["NextToken"] = true, ["Mappings"] = true, nil }

function asserts.AssertDescribePatchGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePatchGroupsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Mappings"] then asserts.AssertPatchGroupPatchBaselineMappingList(struct["Mappings"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePatchGroupsResult[k], "DescribePatchGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePatchGroupsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * Mappings [PatchGroupPatchBaselineMappingList] <p>Each entry in the array contains:</p> <p>PatchGroup: string (between 1 and 256 characters, Regex: ^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$)</p> <p>PatchBaselineIdentity: A PatchBaselineIdentity element. </p>
-- @return DescribePatchGroupsResult structure as a key-value pair table
function M.DescribePatchGroupsResult(args)
	assert(args, "You must provide an argument table when creating DescribePatchGroupsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Mappings"] = args["Mappings"],
	}
	asserts.AssertDescribePatchGroupsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceInformationResult = { ["InstanceInformationList"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstanceInformationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceInformationResult to be of type 'table'")
	if struct["InstanceInformationList"] then asserts.AssertInstanceInformationList(struct["InstanceInformationList"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceInformationResult[k], "DescribeInstanceInformationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceInformationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceInformationList [InstanceInformationList] <p>The instance information list.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty. </p>
-- @return DescribeInstanceInformationResult structure as a key-value pair table
function M.DescribeInstanceInformationResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceInformationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceInformationList"] = args["InstanceInformationList"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstanceInformationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartAssociationsOnceRequest = { ["AssociationIds"] = true, nil }

function asserts.AssertStartAssociationsOnceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartAssociationsOnceRequest to be of type 'table'")
	assert(struct["AssociationIds"], "Expected key AssociationIds to exist in table")
	if struct["AssociationIds"] then asserts.AssertAssociationIdList(struct["AssociationIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartAssociationsOnceRequest[k], "StartAssociationsOnceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartAssociationsOnceRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationIds [AssociationIdList] <p>The association IDs that you want to execute immediately and only one time.</p>
-- Required key: AssociationIds
-- @return StartAssociationsOnceRequest structure as a key-value pair table
function M.StartAssociationsOnceRequest(args)
	assert(args, "You must provide an argument table when creating StartAssociationsOnceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationIds"] = args["AssociationIds"],
	}
	asserts.AssertStartAssociationsOnceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListComplianceItemsResult = { ["ComplianceItems"] = true, ["NextToken"] = true, nil }

function asserts.AssertListComplianceItemsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListComplianceItemsResult to be of type 'table'")
	if struct["ComplianceItems"] then asserts.AssertComplianceItemList(struct["ComplianceItems"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListComplianceItemsResult[k], "ListComplianceItemsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListComplianceItemsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ComplianceItems [ComplianceItemList] <p>A list of compliance information for the specified resource ID. </p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- @return ListComplianceItemsResult structure as a key-value pair table
function M.ListComplianceItemsResult(args)
	assert(args, "You must provide an argument table when creating ListComplianceItemsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ComplianceItems"] = args["ComplianceItems"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertListComplianceItemsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AutomationExecutionFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertAutomationExecutionFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AutomationExecutionFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Values"], "Expected key Values to exist in table")
	if struct["Values"] then asserts.AssertAutomationExecutionFilterValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertAutomationExecutionFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.AutomationExecutionFilter[k], "AutomationExecutionFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AutomationExecutionFilter
-- <p>A filter used to match specific automation executions. This is used to limit the scope of Automation execution information returned.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [AutomationExecutionFilterValueList] <p>The values used to limit the execution information associated with the filter's key.</p>
-- * Key [AutomationExecutionFilterKey] <p>One or more keys to limit the results. Valid filter keys include the following: DocumentNamePrefix, ExecutionStatus, ExecutionId, ParentExecutionId, CurrentAction, StartTimeBefore, StartTimeAfter.</p>
-- Required key: Key
-- Required key: Values
-- @return AutomationExecutionFilter structure as a key-value pair table
function M.AutomationExecutionFilter(args)
	assert(args, "You must provide an argument table when creating AutomationExecutionFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertAutomationExecutionFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetParameterRequest = { ["Name"] = true, ["WithDecryption"] = true, nil }

function asserts.AssertGetParameterRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetParameterRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["Name"] then asserts.AssertPSParameterName(struct["Name"]) end
	if struct["WithDecryption"] then asserts.AssertBoolean(struct["WithDecryption"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetParameterRequest[k], "GetParameterRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetParameterRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [PSParameterName] <p>The name of the parameter you want to query.</p>
-- * WithDecryption [Boolean] <p>Return decrypted values for secure string parameters. This flag is ignored for String and StringList parameter types.</p>
-- Required key: Name
-- @return GetParameterRequest structure as a key-value pair table
function M.GetParameterRequest(args)
	assert(args, "You must provide an argument table when creating GetParameterRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["WithDecryption"] = args["WithDecryption"],
	}
	asserts.AssertGetParameterRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchComplianceData = { ["KBId"] = true, ["Severity"] = true, ["Classification"] = true, ["Title"] = true, ["State"] = true, ["InstalledTime"] = true, nil }

function asserts.AssertPatchComplianceData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchComplianceData to be of type 'table'")
	assert(struct["Title"], "Expected key Title to exist in table")
	assert(struct["KBId"], "Expected key KBId to exist in table")
	assert(struct["Classification"], "Expected key Classification to exist in table")
	assert(struct["Severity"], "Expected key Severity to exist in table")
	assert(struct["State"], "Expected key State to exist in table")
	assert(struct["InstalledTime"], "Expected key InstalledTime to exist in table")
	if struct["KBId"] then asserts.AssertPatchKbNumber(struct["KBId"]) end
	if struct["Severity"] then asserts.AssertPatchSeverity(struct["Severity"]) end
	if struct["Classification"] then asserts.AssertPatchClassification(struct["Classification"]) end
	if struct["Title"] then asserts.AssertPatchTitle(struct["Title"]) end
	if struct["State"] then asserts.AssertPatchComplianceDataState(struct["State"]) end
	if struct["InstalledTime"] then asserts.AssertDateTime(struct["InstalledTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchComplianceData[k], "PatchComplianceData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchComplianceData
-- <p>Information about the state of a patch on a particular instance as it relates to the patch baseline used to patch the instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KBId [PatchKbNumber] <p>The operating system-specific ID of the patch.</p>
-- * Severity [PatchSeverity] <p>The severity of the patch (for example, Critical, Important, Moderate).</p>
-- * Classification [PatchClassification] <p>The classification of the patch (for example, SecurityUpdates, Updates, CriticalUpdates).</p>
-- * Title [PatchTitle] <p>The title of the patch.</p>
-- * State [PatchComplianceDataState] <p>The state of the patch on the instance, such as INSTALLED or FAILED.</p> <p>For descriptions of each patch state, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-compliance-about.html#sysman-compliance-monitor-patch">About Patch Compliance</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * InstalledTime [DateTime] <p>The date/time the patch was installed on the instance. Note that not all operating systems provide this level of information.</p>
-- Required key: Title
-- Required key: KBId
-- Required key: Classification
-- Required key: Severity
-- Required key: State
-- Required key: InstalledTime
-- @return PatchComplianceData structure as a key-value pair table
function M.PatchComplianceData(args)
	assert(args, "You must provide an argument table when creating PatchComplianceData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KBId"] = args["KBId"],
		["Severity"] = args["Severity"],
		["Classification"] = args["Classification"],
		["Title"] = args["Title"],
		["State"] = args["State"],
		["InstalledTime"] = args["InstalledTime"],
	}
	asserts.AssertPatchComplianceData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResourceComplianceSummaryItem = { ["Status"] = true, ["OverallSeverity"] = true, ["ComplianceType"] = true, ["ResourceType"] = true, ["ResourceId"] = true, ["NonCompliantSummary"] = true, ["ExecutionSummary"] = true, ["CompliantSummary"] = true, nil }

function asserts.AssertResourceComplianceSummaryItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResourceComplianceSummaryItem to be of type 'table'")
	if struct["Status"] then asserts.AssertComplianceStatus(struct["Status"]) end
	if struct["OverallSeverity"] then asserts.AssertComplianceSeverity(struct["OverallSeverity"]) end
	if struct["ComplianceType"] then asserts.AssertComplianceTypeName(struct["ComplianceType"]) end
	if struct["ResourceType"] then asserts.AssertComplianceResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertComplianceResourceId(struct["ResourceId"]) end
	if struct["NonCompliantSummary"] then asserts.AssertNonCompliantSummary(struct["NonCompliantSummary"]) end
	if struct["ExecutionSummary"] then asserts.AssertComplianceExecutionSummary(struct["ExecutionSummary"]) end
	if struct["CompliantSummary"] then asserts.AssertCompliantSummary(struct["CompliantSummary"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResourceComplianceSummaryItem[k], "ResourceComplianceSummaryItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResourceComplianceSummaryItem
-- <p>Compliance summary information for a specific resource. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [ComplianceStatus] <p>The compliance status for the resource.</p>
-- * OverallSeverity [ComplianceSeverity] <p>The highest severity item found for the resource. The resource is compliant for this item.</p>
-- * ComplianceType [ComplianceTypeName] <p>The compliance type.</p>
-- * ResourceType [ComplianceResourceType] <p>The resource type.</p>
-- * ResourceId [ComplianceResourceId] <p>The resource ID.</p>
-- * NonCompliantSummary [NonCompliantSummary] <p>A list of items that aren't compliant for the resource.</p>
-- * ExecutionSummary [ComplianceExecutionSummary] <p>Information about the execution.</p>
-- * CompliantSummary [CompliantSummary] <p>A list of items that are compliant for the resource.</p>
-- @return ResourceComplianceSummaryItem structure as a key-value pair table
function M.ResourceComplianceSummaryItem(args)
	assert(args, "You must provide an argument table when creating ResourceComplianceSummaryItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["OverallSeverity"] = args["OverallSeverity"],
		["ComplianceType"] = args["ComplianceType"],
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["NonCompliantSummary"] = args["NonCompliantSummary"],
		["ExecutionSummary"] = args["ExecutionSummary"],
		["CompliantSummary"] = args["CompliantSummary"],
	}
	asserts.AssertResourceComplianceSummaryItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateDocumentRequest = { ["Content"] = true, ["TargetType"] = true, ["DocumentFormat"] = true, ["Name"] = true, ["DocumentVersion"] = true, nil }

function asserts.AssertUpdateDocumentRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateDocumentRequest to be of type 'table'")
	assert(struct["Content"], "Expected key Content to exist in table")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["Content"] then asserts.AssertDocumentContent(struct["Content"]) end
	if struct["TargetType"] then asserts.AssertTargetType(struct["TargetType"]) end
	if struct["DocumentFormat"] then asserts.AssertDocumentFormat(struct["DocumentFormat"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateDocumentRequest[k], "UpdateDocumentRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateDocumentRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Content [DocumentContent] <p>The content in a document that you want to update.</p>
-- * TargetType [TargetType] <p>Specify a new target type for the document.</p>
-- * DocumentFormat [DocumentFormat] <p>Specify the document format for the new document version. Systems Manager supports JSON and YAML documents. JSON is the default format.</p>
-- * Name [DocumentName] <p>The name of the document that you want to update.</p>
-- * DocumentVersion [DocumentVersion] <p>The version of the document that you want to update.</p>
-- Required key: Content
-- Required key: Name
-- @return UpdateDocumentRequest structure as a key-value pair table
function M.UpdateDocumentRequest(args)
	assert(args, "You must provide an argument table when creating UpdateDocumentRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Content"] = args["Content"],
		["TargetType"] = args["TargetType"],
		["DocumentFormat"] = args["DocumentFormat"],
		["Name"] = args["Name"],
		["DocumentVersion"] = args["DocumentVersion"],
	}
	asserts.AssertUpdateDocumentRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PutInventoryResult = { ["Message"] = true, nil }

function asserts.AssertPutInventoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PutInventoryResult to be of type 'table'")
	if struct["Message"] then asserts.AssertPutInventoryMessage(struct["Message"]) end
	for k,_ in pairs(struct) do
		assert(keys.PutInventoryResult[k], "PutInventoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PutInventoryResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [PutInventoryMessage] <p>Information about the request.</p>
-- @return PutInventoryResult structure as a key-value pair table
function M.PutInventoryResult(args)
	assert(args, "You must provide an argument table when creating PutInventoryResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
	}
	asserts.AssertPutInventoryResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAssociationsResult = { ["Associations"] = true, ["NextToken"] = true, nil }

function asserts.AssertListAssociationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAssociationsResult to be of type 'table'")
	if struct["Associations"] then asserts.AssertAssociationList(struct["Associations"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAssociationsResult[k], "ListAssociationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAssociationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Associations [AssociationList] <p>The associations.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return ListAssociationsResult structure as a key-value pair table
function M.ListAssociationsResult(args)
	assert(args, "You must provide an argument table when creating ListAssociationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Associations"] = args["Associations"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertListAssociationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateMaintenanceWindowTaskRequest = { ["ServiceRoleArn"] = true, ["LoggingInfo"] = true, ["MaxErrors"] = true, ["TaskArn"] = true, ["MaxConcurrency"] = true, ["WindowTaskId"] = true, ["TaskParameters"] = true, ["Priority"] = true, ["TaskInvocationParameters"] = true, ["WindowId"] = true, ["Description"] = true, ["Replace"] = true, ["Targets"] = true, ["Name"] = true, nil }

function asserts.AssertUpdateMaintenanceWindowTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateMaintenanceWindowTaskRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	assert(struct["WindowTaskId"], "Expected key WindowTaskId to exist in table")
	if struct["ServiceRoleArn"] then asserts.AssertServiceRole(struct["ServiceRoleArn"]) end
	if struct["LoggingInfo"] then asserts.AssertLoggingInfo(struct["LoggingInfo"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["TaskArn"] then asserts.AssertMaintenanceWindowTaskArn(struct["TaskArn"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	if struct["TaskParameters"] then asserts.AssertMaintenanceWindowTaskParameters(struct["TaskParameters"]) end
	if struct["Priority"] then asserts.AssertMaintenanceWindowTaskPriority(struct["Priority"]) end
	if struct["TaskInvocationParameters"] then asserts.AssertMaintenanceWindowTaskInvocationParameters(struct["TaskInvocationParameters"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["Replace"] then asserts.AssertBoolean(struct["Replace"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateMaintenanceWindowTaskRequest[k], "UpdateMaintenanceWindowTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateMaintenanceWindowTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceRoleArn [ServiceRole] <p>The IAM service role ARN to modify. The system assumes this role during task execution.</p> <p>If you do not specify a service role ARN, Systems Manager will use your account's service-linked role for Systems Manager by default. If no service-linked role for Systems Manager exists in your account, it will be created when you run <code>RegisterTaskWithMaintenanceWindow</code> without specifying a service role ARN.</p> <p>For more information, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Service-Linked Role Permissions for Systems Manager</a> and <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I Use a Service-Linked Role or a Custom Service Role to Run Maintenance Window Tasks? </a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * LoggingInfo [LoggingInfo] <p>The new logging location in Amazon S3 to specify.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * MaxErrors [MaxErrors] <p>The new <code>MaxErrors</code> value to specify. <code>MaxErrors</code> is the maximum number of errors that are allowed before the task stops being scheduled.</p>
-- * TaskArn [MaintenanceWindowTaskArn] <p>The task ARN to modify.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The new <code>MaxConcurrency</code> value you want to specify. <code>MaxConcurrency</code> is the number of targets that are allowed to run this task in parallel.</p>
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The task ID to modify.</p>
-- * TaskParameters [MaintenanceWindowTaskParameters] <p>The parameters to modify.</p> <note> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note> <p>The map has the following format:</p> <p>Key: string, between 1 and 255 characters</p> <p>Value: an array of strings, each string is between 1 and 255 characters</p>
-- * Priority [MaintenanceWindowTaskPriority] <p>The new task priority to specify. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
-- * TaskInvocationParameters [MaintenanceWindowTaskInvocationParameters] <p>The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty.</p>
-- * WindowId [MaintenanceWindowId] <p>The Maintenance Window ID that contains the task to modify.</p>
-- * Description [MaintenanceWindowDescription] <p>The new task description to specify.</p>
-- * Replace [Boolean] <p>If True, then all fields that are required by the RegisterTaskWithMaintenanceWndow action are also required for this API request. Optional fields that are not specified are set to null.</p>
-- * Targets [Targets] <p>The targets (either instances or tags) to modify. Instances are specified using Key=instanceids,Values=instanceID_1,instanceID_2. Tags are specified using Key=tag_name,Values=tag_value. </p>
-- * Name [MaintenanceWindowName] <p>The new task name to specify.</p>
-- Required key: WindowId
-- Required key: WindowTaskId
-- @return UpdateMaintenanceWindowTaskRequest structure as a key-value pair table
function M.UpdateMaintenanceWindowTaskRequest(args)
	assert(args, "You must provide an argument table when creating UpdateMaintenanceWindowTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceRoleArn"] = args["ServiceRoleArn"],
		["LoggingInfo"] = args["LoggingInfo"],
		["MaxErrors"] = args["MaxErrors"],
		["TaskArn"] = args["TaskArn"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["WindowTaskId"] = args["WindowTaskId"],
		["TaskParameters"] = args["TaskParameters"],
		["Priority"] = args["Priority"],
		["TaskInvocationParameters"] = args["TaskInvocationParameters"],
		["WindowId"] = args["WindowId"],
		["Description"] = args["Description"],
		["Replace"] = args["Replace"],
		["Targets"] = args["Targets"],
		["Name"] = args["Name"],
	}
	asserts.AssertUpdateMaintenanceWindowTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CloudWatchOutputConfig = { ["CloudWatchLogGroupName"] = true, ["CloudWatchOutputEnabled"] = true, nil }

function asserts.AssertCloudWatchOutputConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CloudWatchOutputConfig to be of type 'table'")
	if struct["CloudWatchLogGroupName"] then asserts.AssertCloudWatchLogGroupName(struct["CloudWatchLogGroupName"]) end
	if struct["CloudWatchOutputEnabled"] then asserts.AssertCloudWatchOutputEnabled(struct["CloudWatchOutputEnabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.CloudWatchOutputConfig[k], "CloudWatchOutputConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CloudWatchOutputConfig
-- <p>Configuration options for sending command output to CloudWatch Logs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CloudWatchLogGroupName [CloudWatchLogGroupName] <p>The name of the CloudWatch log group where you want to send command output. If you don't specify a group name, Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/<i>SystemsManagerDocumentName</i>.</p>
-- * CloudWatchOutputEnabled [CloudWatchOutputEnabled] <p>Enables Systems Manager to send command output to CloudWatch Logs.</p>
-- @return CloudWatchOutputConfig structure as a key-value pair table
function M.CloudWatchOutputConfig(args)
	assert(args, "You must provide an argument table when creating CloudWatchOutputConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CloudWatchLogGroupName"] = args["CloudWatchLogGroupName"],
		["CloudWatchOutputEnabled"] = args["CloudWatchOutputEnabled"],
	}
	asserts.AssertCloudWatchOutputConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteDocumentResult = { nil }

function asserts.AssertDeleteDocumentResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteDocumentResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteDocumentResult[k], "DeleteDocumentResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteDocumentResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteDocumentResult structure as a key-value pair table
function M.DeleteDocumentResult(args)
	assert(args, "You must provide an argument table when creating DeleteDocumentResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteDocumentResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateMaintenanceWindowRequest = { ["StartDate"] = true, ["EndDate"] = true, ["Name"] = true, ["Schedule"] = true, ["ScheduleTimezone"] = true, ["Cutoff"] = true, ["AllowUnassociatedTargets"] = true, ["ClientToken"] = true, ["Duration"] = true, ["Description"] = true, nil }

function asserts.AssertCreateMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateMaintenanceWindowRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["Schedule"], "Expected key Schedule to exist in table")
	assert(struct["Duration"], "Expected key Duration to exist in table")
	assert(struct["Cutoff"], "Expected key Cutoff to exist in table")
	assert(struct["AllowUnassociatedTargets"], "Expected key AllowUnassociatedTargets to exist in table")
	if struct["StartDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["StartDate"]) end
	if struct["EndDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["EndDate"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	if struct["Schedule"] then asserts.AssertMaintenanceWindowSchedule(struct["Schedule"]) end
	if struct["ScheduleTimezone"] then asserts.AssertMaintenanceWindowTimezone(struct["ScheduleTimezone"]) end
	if struct["Cutoff"] then asserts.AssertMaintenanceWindowCutoff(struct["Cutoff"]) end
	if struct["AllowUnassociatedTargets"] then asserts.AssertMaintenanceWindowAllowUnassociatedTargets(struct["AllowUnassociatedTargets"]) end
	if struct["ClientToken"] then asserts.AssertClientToken(struct["ClientToken"]) end
	if struct["Duration"] then asserts.AssertMaintenanceWindowDurationHours(struct["Duration"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateMaintenanceWindowRequest[k], "CreateMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StartDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when you want the Maintenance Window to become active. StartDate allows you to delay activation of the Maintenance Window until the specified future date.</p>
-- * EndDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when you want the Maintenance Window to become inactive. EndDate allows you to set a date and time in the future when the Maintenance Window will no longer run.</p>
-- * Name [MaintenanceWindowName] <p>The name of the Maintenance Window.</p>
-- * Schedule [MaintenanceWindowSchedule] <p>The schedule of the Maintenance Window in the form of a cron or rate expression.</p>
-- * ScheduleTimezone [MaintenanceWindowTimezone] <p>The time zone that the scheduled Maintenance Window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "etc/UTC", or "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time Zone Database</a> on the IANA website.</p>
-- * Cutoff [MaintenanceWindowCutoff] <p>The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution.</p>
-- * AllowUnassociatedTargets [MaintenanceWindowAllowUnassociatedTargets] <p>Enables a Maintenance Window task to execute on managed instances, even if you have not registered those instances as targets. If enabled, then you must specify the unregistered instances (by instance ID) when you register a task with the Maintenance Window </p> <p>If you don't enable this option, then you must specify previously-registered targets when you register a task with the Maintenance Window. </p>
-- * ClientToken [ClientToken] <p>User-provided idempotency token.</p>
-- * Duration [MaintenanceWindowDurationHours] <p>The duration of the Maintenance Window in hours.</p>
-- * Description [MaintenanceWindowDescription] <p>An optional description for the Maintenance Window. We recommend specifying a description to help you organize your Maintenance Windows. </p>
-- Required key: Name
-- Required key: Schedule
-- Required key: Duration
-- Required key: Cutoff
-- Required key: AllowUnassociatedTargets
-- @return CreateMaintenanceWindowRequest structure as a key-value pair table
function M.CreateMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating CreateMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StartDate"] = args["StartDate"],
		["EndDate"] = args["EndDate"],
		["Name"] = args["Name"],
		["Schedule"] = args["Schedule"],
		["ScheduleTimezone"] = args["ScheduleTimezone"],
		["Cutoff"] = args["Cutoff"],
		["AllowUnassociatedTargets"] = args["AllowUnassociatedTargets"],
		["ClientToken"] = args["ClientToken"],
		["Duration"] = args["Duration"],
		["Description"] = args["Description"],
	}
	asserts.AssertCreateMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancePatchStatesForPatchGroupRequest = { ["PatchGroup"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInstancePatchStatesForPatchGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancePatchStatesForPatchGroupRequest to be of type 'table'")
	assert(struct["PatchGroup"], "Expected key PatchGroup to exist in table")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertPatchComplianceMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertInstancePatchStateFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancePatchStatesForPatchGroupRequest[k], "DescribeInstancePatchStatesForPatchGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancePatchStatesForPatchGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group for which the patch state information should be retrieved.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [PatchComplianceMaxResults] <p>The maximum number of patches to return (per page).</p>
-- * Filters [InstancePatchStateFilterList] <p>Each entry in the array is a structure containing:</p> <p>Key (string between 1 and 200 characters)</p> <p> Values (array containing a single string)</p> <p> Type (string "Equal", "NotEqual", "LessThan", "GreaterThan")</p>
-- Required key: PatchGroup
-- @return DescribeInstancePatchStatesForPatchGroupRequest structure as a key-value pair table
function M.DescribeInstancePatchStatesForPatchGroupRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstancePatchStatesForPatchGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInstancePatchStatesForPatchGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TerminateSessionRequest = { ["SessionId"] = true, nil }

function asserts.AssertTerminateSessionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateSessionRequest to be of type 'table'")
	assert(struct["SessionId"], "Expected key SessionId to exist in table")
	if struct["SessionId"] then asserts.AssertSessionId(struct["SessionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateSessionRequest[k], "TerminateSessionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateSessionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SessionId [SessionId] <p>The ID of the session to terminate.</p>
-- Required key: SessionId
-- @return TerminateSessionRequest structure as a key-value pair table
function M.TerminateSessionRequest(args)
	assert(args, "You must provide an argument table when creating TerminateSessionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SessionId"] = args["SessionId"],
	}
	asserts.AssertTerminateSessionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAssociationVersionsRequest = { ["AssociationId"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertListAssociationVersionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAssociationVersionsRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAssociationVersionsRequest[k], "ListAssociationVersionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAssociationVersionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [AssociationId] <p>The association ID for which you want to view all versions.</p>
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: AssociationId
-- @return ListAssociationVersionsRequest structure as a key-value pair table
function M.ListAssociationVersionsRequest(args)
	assert(args, "You must provide an argument table when creating ListAssociationVersionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertListAssociationVersionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetDefaultPatchBaselineResult = { ["BaselineId"] = true, ["OperatingSystem"] = true, nil }

function asserts.AssertGetDefaultPatchBaselineResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetDefaultPatchBaselineResult to be of type 'table'")
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetDefaultPatchBaselineResult[k], "GetDefaultPatchBaselineResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetDefaultPatchBaselineResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineId [BaselineId] <p>The ID of the default patch baseline.</p>
-- * OperatingSystem [OperatingSystem] <p>The operating system for the returned patch baseline. </p>
-- @return GetDefaultPatchBaselineResult structure as a key-value pair table
function M.GetDefaultPatchBaselineResult(args)
	assert(args, "You must provide an argument table when creating GetDefaultPatchBaselineResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineId"] = args["BaselineId"],
		["OperatingSystem"] = args["OperatingSystem"],
	}
	asserts.AssertGetDefaultPatchBaselineResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetDefaultPatchBaselineRequest = { ["OperatingSystem"] = true, nil }

function asserts.AssertGetDefaultPatchBaselineRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetDefaultPatchBaselineRequest to be of type 'table'")
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetDefaultPatchBaselineRequest[k], "GetDefaultPatchBaselineRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetDefaultPatchBaselineRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OperatingSystem [OperatingSystem] <p>Returns the default patch baseline for the specified operating system.</p>
-- @return GetDefaultPatchBaselineRequest structure as a key-value pair table
function M.GetDefaultPatchBaselineRequest(args)
	assert(args, "You must provide an argument table when creating GetDefaultPatchBaselineRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OperatingSystem"] = args["OperatingSystem"],
	}
	asserts.AssertGetDefaultPatchBaselineRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAssociationRequest = { ["InstanceId"] = true, ["AssociationVersion"] = true, ["AssociationId"] = true, ["Name"] = true, nil }

function asserts.AssertDescribeAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAssociationRequest to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAssociationRequest[k], "DescribeAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The instance ID.</p>
-- * AssociationVersion [AssociationVersion] <p>Specify the association version to retrieve. To view the latest version, either specify <code>$LATEST</code> for this parameter, or omit this parameter. To view a list of all associations for an instance, use ListInstanceAssociations. To get a list of versions for a specific association, use ListAssociationVersions. </p>
-- * AssociationId [AssociationId] <p>The association ID for which you want information.</p>
-- * Name [DocumentName] <p>The name of the Systems Manager document.</p>
-- @return DescribeAssociationRequest structure as a key-value pair table
function M.DescribeAssociationRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAssociationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["AssociationVersion"] = args["AssociationVersion"],
		["AssociationId"] = args["AssociationId"],
		["Name"] = args["Name"],
	}
	asserts.AssertDescribeAssociationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceInformationRequest = { ["InstanceInformationFilterList"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInstanceInformationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceInformationRequest to be of type 'table'")
	if struct["InstanceInformationFilterList"] then asserts.AssertInstanceInformationFilterList(struct["InstanceInformationFilterList"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResultsEC2Compatible(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertInstanceInformationStringFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceInformationRequest[k], "DescribeInstanceInformationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceInformationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceInformationFilterList [InstanceInformationFilterList] <p>This is a legacy method. We recommend that you don't use this method. Instead, use the <a>InstanceInformationFilter</a> action. The <code>InstanceInformationFilter</code> action enables you to return instance information by using tags that are specified as a key-value mapping. </p> <p>If you do use this method, then you can't use the <code>InstanceInformationFilter</code> action. Using this method and the <code>InstanceInformationFilter</code> action causes an exception error. </p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [MaxResultsEC2Compatible] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results. </p>
-- * Filters [InstanceInformationStringFilterList] <p>One or more filters. Use a filter to return a more specific list of instances. You can filter on Amazon EC2 tag. Specify tags by using a key-value mapping.</p>
-- @return DescribeInstanceInformationRequest structure as a key-value pair table
function M.DescribeInstanceInformationRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceInformationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceInformationFilterList"] = args["InstanceInformationFilterList"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInstanceInformationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCommandsResult = { ["Commands"] = true, ["NextToken"] = true, nil }

function asserts.AssertListCommandsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCommandsResult to be of type 'table'")
	if struct["Commands"] then asserts.AssertCommandList(struct["Commands"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCommandsResult[k], "ListCommandsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCommandsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Commands [CommandList] <p>(Optional) The list of commands requested by the user. </p>
-- * NextToken [NextToken] <p>(Optional) The token for the next set of items to return. (You received this token from a previous call.)</p>
-- @return ListCommandsResult structure as a key-value pair table
function M.ListCommandsResult(args)
	assert(args, "You must provide an argument table when creating ListCommandsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Commands"] = args["Commands"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertListCommandsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowTaskRequest = { ["WindowTaskId"] = true, ["WindowId"] = true, nil }

function asserts.AssertGetMaintenanceWindowTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowTaskRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	assert(struct["WindowTaskId"], "Expected key WindowTaskId to exist in table")
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowTaskRequest[k], "GetMaintenanceWindowTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The Maintenance Window task ID to retrieve.</p>
-- * WindowId [MaintenanceWindowId] <p>The Maintenance Window ID that includes the task to retrieve.</p>
-- Required key: WindowId
-- Required key: WindowTaskId
-- @return GetMaintenanceWindowTaskRequest structure as a key-value pair table
function M.GetMaintenanceWindowTaskRequest(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowTaskId"] = args["WindowTaskId"],
		["WindowId"] = args["WindowId"],
	}
	asserts.AssertGetMaintenanceWindowTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetCommandInvocationRequest = { ["InstanceId"] = true, ["PluginName"] = true, ["CommandId"] = true, nil }

function asserts.AssertGetCommandInvocationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetCommandInvocationRequest to be of type 'table'")
	assert(struct["CommandId"], "Expected key CommandId to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["PluginName"] then asserts.AssertCommandPluginName(struct["PluginName"]) end
	if struct["CommandId"] then asserts.AssertCommandId(struct["CommandId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetCommandInvocationRequest[k], "GetCommandInvocationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetCommandInvocationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>(Required) The ID of the managed instance targeted by the command. A managed instance can be an Amazon EC2 instance or an instance in your hybrid environment that is configured for Systems Manager.</p>
-- * PluginName [CommandPluginName] <p>(Optional) The name of the plugin for which you want detailed results. If the document contains only one plugin, the name can be omitted and the details will be returned.</p>
-- * CommandId [CommandId] <p>(Required) The parent command ID of the invocation plugin.</p>
-- Required key: CommandId
-- Required key: InstanceId
-- @return GetCommandInvocationRequest structure as a key-value pair table
function M.GetCommandInvocationRequest(args)
	assert(args, "You must provide an argument table when creating GetCommandInvocationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["PluginName"] = args["PluginName"],
		["CommandId"] = args["CommandId"],
	}
	asserts.AssertGetCommandInvocationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDocumentRequest = { ["Content"] = true, ["TargetType"] = true, ["DocumentFormat"] = true, ["Name"] = true, ["DocumentType"] = true, nil }

function asserts.AssertCreateDocumentRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDocumentRequest to be of type 'table'")
	assert(struct["Content"], "Expected key Content to exist in table")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["Content"] then asserts.AssertDocumentContent(struct["Content"]) end
	if struct["TargetType"] then asserts.AssertTargetType(struct["TargetType"]) end
	if struct["DocumentFormat"] then asserts.AssertDocumentFormat(struct["DocumentFormat"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["DocumentType"] then asserts.AssertDocumentType(struct["DocumentType"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDocumentRequest[k], "CreateDocumentRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDocumentRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Content [DocumentContent] <p>A valid JSON or YAML string.</p>
-- * TargetType [TargetType] <p>Specify a target type to define the kinds of resources the document can run on. For example, to run a document on EC2 instances, specify the following value: /AWS::EC2::Instance. If you specify a value of '/' the document can run on all types of resources. If you don't specify a value, the document can't run on any resources. For a list of valid resource types, see <a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html">AWS Resource Types Reference</a> in the <i>AWS CloudFormation User Guide</i>. </p>
-- * DocumentFormat [DocumentFormat] <p>Specify the document format for the request. The document format can be either JSON or YAML. JSON is the default format.</p>
-- * Name [DocumentName] <p>A name for the Systems Manager document.</p> <important> <p>Do not use the following to begin the names of documents you create. They are reserved by AWS for use as document prefixes:</p> <ul> <li> <p> <code>aws</code> </p> </li> <li> <p> <code>amazon</code> </p> </li> <li> <p> <code>amzn</code> </p> </li> </ul> </important>
-- * DocumentType [DocumentType] <p>The type of document to create. Valid document types include: Policy, Automation, and Command.</p>
-- Required key: Content
-- Required key: Name
-- @return CreateDocumentRequest structure as a key-value pair table
function M.CreateDocumentRequest(args)
	assert(args, "You must provide an argument table when creating CreateDocumentRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Content"] = args["Content"],
		["TargetType"] = args["TargetType"],
		["DocumentFormat"] = args["DocumentFormat"],
		["Name"] = args["Name"],
		["DocumentType"] = args["DocumentType"],
	}
	asserts.AssertCreateDocumentRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceAssociationStatusInfo = { ["Status"] = true, ["DetailedStatus"] = true, ["OutputUrl"] = true, ["Name"] = true, ["InstanceId"] = true, ["AssociationId"] = true, ["DocumentVersion"] = true, ["ErrorCode"] = true, ["ExecutionSummary"] = true, ["AssociationVersion"] = true, ["AssociationName"] = true, ["ExecutionDate"] = true, nil }

function asserts.AssertInstanceAssociationStatusInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAssociationStatusInfo to be of type 'table'")
	if struct["Status"] then asserts.AssertStatusName(struct["Status"]) end
	if struct["DetailedStatus"] then asserts.AssertStatusName(struct["DetailedStatus"]) end
	if struct["OutputUrl"] then asserts.AssertInstanceAssociationOutputUrl(struct["OutputUrl"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["ErrorCode"] then asserts.AssertAgentErrorCode(struct["ErrorCode"]) end
	if struct["ExecutionSummary"] then asserts.AssertInstanceAssociationExecutionSummary(struct["ExecutionSummary"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	if struct["AssociationName"] then asserts.AssertAssociationName(struct["AssociationName"]) end
	if struct["ExecutionDate"] then asserts.AssertDateTime(struct["ExecutionDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAssociationStatusInfo[k], "InstanceAssociationStatusInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAssociationStatusInfo
-- <p>Status information about the instance association.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [StatusName] <p>Status information about the instance association.</p>
-- * DetailedStatus [StatusName] <p>Detailed status information about the instance association.</p>
-- * OutputUrl [InstanceAssociationOutputUrl] <p>A URL for an Amazon S3 bucket where you want to store the results of this request.</p>
-- * Name [DocumentName] <p>The name of the association.</p>
-- * InstanceId [InstanceId] <p>The instance ID where the association was created.</p>
-- * AssociationId [AssociationId] <p>The association ID.</p>
-- * DocumentVersion [DocumentVersion] <p>The association document verions.</p>
-- * ErrorCode [AgentErrorCode] <p>An error code returned by the request to create the association.</p>
-- * ExecutionSummary [InstanceAssociationExecutionSummary] <p>Summary information about association execution.</p>
-- * AssociationVersion [AssociationVersion] <p>The version of the association applied to the instance.</p>
-- * AssociationName [AssociationName] <p>The name of the association applied to the instance.</p>
-- * ExecutionDate [DateTime] <p>The date the instance association executed. </p>
-- @return InstanceAssociationStatusInfo structure as a key-value pair table
function M.InstanceAssociationStatusInfo(args)
	assert(args, "You must provide an argument table when creating InstanceAssociationStatusInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DetailedStatus"] = args["DetailedStatus"],
		["OutputUrl"] = args["OutputUrl"],
		["Name"] = args["Name"],
		["InstanceId"] = args["InstanceId"],
		["AssociationId"] = args["AssociationId"],
		["DocumentVersion"] = args["DocumentVersion"],
		["ErrorCode"] = args["ErrorCode"],
		["ExecutionSummary"] = args["ExecutionSummary"],
		["AssociationVersion"] = args["AssociationVersion"],
		["AssociationName"] = args["AssociationName"],
		["ExecutionDate"] = args["ExecutionDate"],
	}
	asserts.AssertInstanceAssociationStatusInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ParametersFilter = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertParametersFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ParametersFilter to be of type 'table'")
	assert(struct["Key"], "Expected key Key to exist in table")
	assert(struct["Values"], "Expected key Values to exist in table")
	if struct["Values"] then asserts.AssertParametersFilterValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertParametersFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.ParametersFilter[k], "ParametersFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ParametersFilter
-- <p>This data type is deprecated. Instead, use <a>ParameterStringFilter</a>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [ParametersFilterValueList] <p>The filter values.</p>
-- * Key [ParametersFilterKey] <p>The name of the filter.</p>
-- Required key: Key
-- Required key: Values
-- @return ParametersFilter structure as a key-value pair table
function M.ParametersFilter(args)
	assert(args, "You must provide an argument table when creating ParametersFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertParametersFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancePatchesResult = { ["NextToken"] = true, ["Patches"] = true, nil }

function asserts.AssertDescribeInstancePatchesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancePatchesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Patches"] then asserts.AssertPatchComplianceDataList(struct["Patches"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancePatchesResult[k], "DescribeInstancePatchesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancePatchesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * Patches [PatchComplianceDataList] <p>Each entry in the array is a structure containing:</p> <p>Title (string)</p> <p>KBId (string)</p> <p>Classification (string)</p> <p>Severity (string)</p> <p>State (string, such as "INSTALLED" or "FAILED")</p> <p>InstalledTime (DateTime)</p> <p>InstalledBy (string)</p>
-- @return DescribeInstancePatchesResult structure as a key-value pair table
function M.DescribeInstancePatchesResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstancePatchesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Patches"] = args["Patches"],
	}
	asserts.AssertDescribeInstancePatchesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociationVersionInfo = { ["MaxErrors"] = true, ["ScheduleExpression"] = true, ["OutputLocation"] = true, ["Name"] = true, ["Parameters"] = true, ["AssociationId"] = true, ["DocumentVersion"] = true, ["CreatedDate"] = true, ["AssociationVersion"] = true, ["AssociationName"] = true, ["Targets"] = true, ["ComplianceSeverity"] = true, ["MaxConcurrency"] = true, nil }

function asserts.AssertAssociationVersionInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociationVersionInfo to be of type 'table'")
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["ScheduleExpression"] then asserts.AssertScheduleExpression(struct["ScheduleExpression"]) end
	if struct["OutputLocation"] then asserts.AssertInstanceAssociationOutputLocation(struct["OutputLocation"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	if struct["Parameters"] then asserts.AssertParameters(struct["Parameters"]) end
	if struct["AssociationId"] then asserts.AssertAssociationId(struct["AssociationId"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	if struct["CreatedDate"] then asserts.AssertDateTime(struct["CreatedDate"]) end
	if struct["AssociationVersion"] then asserts.AssertAssociationVersion(struct["AssociationVersion"]) end
	if struct["AssociationName"] then asserts.AssertAssociationName(struct["AssociationName"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["ComplianceSeverity"] then asserts.AssertAssociationComplianceSeverity(struct["ComplianceSeverity"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociationVersionInfo[k], "AssociationVersionInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociationVersionInfo
-- <p>Information about the association version.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxErrors [MaxErrors] <p>The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify either an absolute number of errors, for example 10, or a percentage of the target set, for example 10%. If you specify 3, for example, the system stops sending requests when the fourth error is received. If you specify 0, then the system stops sending requests after the first error is returned. If you run an association on 50 instances and set MaxError to 10%, then the system stops sending the request when the sixth error is received.</p> <p>Executions that are already running an association when MaxErrors is reached are allowed to complete, but some of these executions may fail as well. If you need to ensure that there won't be more than max-errors failed executions, set MaxConcurrency to 1 so that executions proceed one at a time.</p>
-- * ScheduleExpression [ScheduleExpression] <p>The cron or rate schedule specified for the association when the association version was created.</p>
-- * OutputLocation [InstanceAssociationOutputLocation] <p>The location in Amazon S3 specified for the association when the association version was created.</p>
-- * Name [DocumentName] <p>The name specified when the association was created.</p>
-- * Parameters [Parameters] <p>Parameters specified when the association version was created.</p>
-- * AssociationId [AssociationId] <p>The ID created by the system when the association was created.</p>
-- * DocumentVersion [DocumentVersion] <p>The version of a Systems Manager document used when the association version was created.</p>
-- * CreatedDate [DateTime] <p>The date the association version was created.</p>
-- * AssociationVersion [AssociationVersion] <p>The association version.</p>
-- * AssociationName [AssociationName] <p>The name specified for the association version when the association version was created.</p>
-- * Targets [Targets] <p>The targets specified for the association when the association version was created. </p>
-- * ComplianceSeverity [AssociationComplianceSeverity] <p>The severity level that is assigned to the association.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%. The default value is 100%, which means all targets run the association at the same time.</p> <p>If a new instance starts and attempts to execute an association while Systems Manager is executing MaxConcurrency associations, the association is allowed to run. During the next association interval, the new instance will process its association within the limit specified for MaxConcurrency.</p>
-- @return AssociationVersionInfo structure as a key-value pair table
function M.AssociationVersionInfo(args)
	assert(args, "You must provide an argument table when creating AssociationVersionInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxErrors"] = args["MaxErrors"],
		["ScheduleExpression"] = args["ScheduleExpression"],
		["OutputLocation"] = args["OutputLocation"],
		["Name"] = args["Name"],
		["Parameters"] = args["Parameters"],
		["AssociationId"] = args["AssociationId"],
		["DocumentVersion"] = args["DocumentVersion"],
		["CreatedDate"] = args["CreatedDate"],
		["AssociationVersion"] = args["AssociationVersion"],
		["AssociationName"] = args["AssociationName"],
		["Targets"] = args["Targets"],
		["ComplianceSeverity"] = args["ComplianceSeverity"],
		["MaxConcurrency"] = args["MaxConcurrency"],
	}
	asserts.AssertAssociationVersionInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDocumentPermissionRequest = { ["PermissionType"] = true, ["Name"] = true, nil }

function asserts.AssertDescribeDocumentPermissionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDocumentPermissionRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["PermissionType"], "Expected key PermissionType to exist in table")
	if struct["PermissionType"] then asserts.AssertDocumentPermissionType(struct["PermissionType"]) end
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDocumentPermissionRequest[k], "DescribeDocumentPermissionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDocumentPermissionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PermissionType [DocumentPermissionType] <p>The permission type for the document. The permission type can be <i>Share</i>.</p>
-- * Name [DocumentName] <p>The name of the document for which you are the owner.</p>
-- Required key: Name
-- Required key: PermissionType
-- @return DescribeDocumentPermissionRequest structure as a key-value pair table
function M.DescribeDocumentPermissionRequest(args)
	assert(args, "You must provide an argument table when creating DescribeDocumentPermissionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PermissionType"] = args["PermissionType"],
		["Name"] = args["Name"],
	}
	asserts.AssertDescribeDocumentPermissionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartAssociationsOnceResult = { nil }

function asserts.AssertStartAssociationsOnceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartAssociationsOnceResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.StartAssociationsOnceResult[k], "StartAssociationsOnceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartAssociationsOnceResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return StartAssociationsOnceResult structure as a key-value pair table
function M.StartAssociationsOnceResult(args)
	assert(args, "You must provide an argument table when creating StartAssociationsOnceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertStartAssociationsOnceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SendAutomationSignalResult = { nil }

function asserts.AssertSendAutomationSignalResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SendAutomationSignalResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.SendAutomationSignalResult[k], "SendAutomationSignalResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SendAutomationSignalResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return SendAutomationSignalResult structure as a key-value pair table
function M.SendAutomationSignalResult(args)
	assert(args, "You must provide an argument table when creating SendAutomationSignalResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertSendAutomationSignalResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartSessionRequest = { ["DocumentName"] = true, ["Target"] = true, ["Parameters"] = true, nil }

function asserts.AssertStartSessionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartSessionRequest to be of type 'table'")
	assert(struct["Target"], "Expected key Target to exist in table")
	if struct["DocumentName"] then asserts.AssertDocumentARN(struct["DocumentName"]) end
	if struct["Target"] then asserts.AssertSessionTarget(struct["Target"]) end
	if struct["Parameters"] then asserts.AssertSessionManagerParameters(struct["Parameters"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartSessionRequest[k], "StartSessionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartSessionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DocumentName [DocumentARN] <p>The name of the SSM document to define the parameters and plugin settings for the session. For example, <code>SSM-SessionManagerRunShell</code>. If no document name is provided, a shell to the instance is launched by default.</p>
-- * Target [SessionTarget] <p>The instance to connect to for the session.</p>
-- * Parameters [SessionManagerParameters] <p>Reserved for future use.</p>
-- Required key: Target
-- @return StartSessionRequest structure as a key-value pair table
function M.StartSessionRequest(args)
	assert(args, "You must provide an argument table when creating StartSessionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DocumentName"] = args["DocumentName"],
		["Target"] = args["Target"],
		["Parameters"] = args["Parameters"],
	}
	asserts.AssertStartSessionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteDocumentRequest = { ["Name"] = true, nil }

function asserts.AssertDeleteDocumentRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteDocumentRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["Name"] then asserts.AssertDocumentName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteDocumentRequest[k], "DeleteDocumentRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteDocumentRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [DocumentName] <p>The name of the document.</p>
-- Required key: Name
-- @return DeleteDocumentRequest structure as a key-value pair table
function M.DeleteDocumentRequest(args)
	assert(args, "You must provide an argument table when creating DeleteDocumentRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
	}
	asserts.AssertDeleteDocumentRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancePatchStatesForPatchGroupResult = { ["InstancePatchStates"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstancePatchStatesForPatchGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancePatchStatesForPatchGroupResult to be of type 'table'")
	if struct["InstancePatchStates"] then asserts.AssertInstancePatchStatesList(struct["InstancePatchStates"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancePatchStatesForPatchGroupResult[k], "DescribeInstancePatchStatesForPatchGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancePatchStatesForPatchGroupResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstancePatchStates [InstancePatchStatesList] <p>The high-level patch state for the requested instances. </p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeInstancePatchStatesForPatchGroupResult structure as a key-value pair table
function M.DescribeInstancePatchStatesForPatchGroupResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstancePatchStatesForPatchGroupResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstancePatchStates"] = args["InstancePatchStates"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstancePatchStatesForPatchGroupResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteResourceDataSyncResult = { nil }

function asserts.AssertDeleteResourceDataSyncResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteResourceDataSyncResult to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteResourceDataSyncResult[k], "DeleteResourceDataSyncResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteResourceDataSyncResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteResourceDataSyncResult structure as a key-value pair table
function M.DeleteResourceDataSyncResult(args)
	assert(args, "You must provide an argument table when creating DeleteResourceDataSyncResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteResourceDataSyncResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetConnectionStatusRequest = { ["Target"] = true, nil }

function asserts.AssertGetConnectionStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConnectionStatusRequest to be of type 'table'")
	assert(struct["Target"], "Expected key Target to exist in table")
	if struct["Target"] then asserts.AssertSessionTarget(struct["Target"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConnectionStatusRequest[k], "GetConnectionStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConnectionStatusRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Target [SessionTarget] <p>The ID of the instance.</p>
-- Required key: Target
-- @return GetConnectionStatusRequest structure as a key-value pair table
function M.GetConnectionStatusRequest(args)
	assert(args, "You must provide an argument table when creating GetConnectionStatusRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Target"] = args["Target"],
	}
	asserts.AssertGetConnectionStatusRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListComplianceItemsRequest = { ["ResourceIds"] = true, ["ResourceTypes"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertListComplianceItemsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListComplianceItemsRequest to be of type 'table'")
	if struct["ResourceIds"] then asserts.AssertComplianceResourceIdList(struct["ResourceIds"]) end
	if struct["ResourceTypes"] then asserts.AssertComplianceResourceTypeList(struct["ResourceTypes"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertComplianceStringFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListComplianceItemsRequest[k], "ListComplianceItemsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListComplianceItemsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceIds [ComplianceResourceIdList] <p>The ID for the resources from which to get compliance information. Currently, you can only specify one resource ID.</p>
-- * ResourceTypes [ComplianceResourceTypeList] <p>The type of resource from which to get compliance information. Currently, the only supported resource type is <code>ManagedInstance</code>.</p>
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [ComplianceStringFilterList] <p>One or more compliance filters. Use a filter to return a more specific list of results.</p>
-- @return ListComplianceItemsRequest structure as a key-value pair table
function M.ListComplianceItemsRequest(args)
	assert(args, "You must provide an argument table when creating ListComplianceItemsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceIds"] = args["ResourceIds"],
		["ResourceTypes"] = args["ResourceTypes"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertListComplianceItemsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInventoryDeletionsResult = { ["NextToken"] = true, ["InventoryDeletions"] = true, nil }

function asserts.AssertDescribeInventoryDeletionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInventoryDeletionsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["InventoryDeletions"] then asserts.AssertInventoryDeletionsList(struct["InventoryDeletions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInventoryDeletionsResult[k], "DescribeInventoryDeletionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInventoryDeletionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. Use this token to get the next set of results.</p>
-- * InventoryDeletions [InventoryDeletionsList] <p>A list of status items for deleted inventory.</p>
-- @return DescribeInventoryDeletionsResult structure as a key-value pair table
function M.DescribeInventoryDeletionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeInventoryDeletionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["InventoryDeletions"] = args["InventoryDeletions"],
	}
	asserts.AssertDescribeInventoryDeletionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryItemAttribute = { ["DataType"] = true, ["Name"] = true, nil }

function asserts.AssertInventoryItemAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryItemAttribute to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["DataType"], "Expected key DataType to exist in table")
	if struct["DataType"] then asserts.AssertInventoryAttributeDataType(struct["DataType"]) end
	if struct["Name"] then asserts.AssertInventoryItemAttributeName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryItemAttribute[k], "InventoryItemAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryItemAttribute
-- <p>Attributes are the entries within the inventory item content. It contains name and value.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DataType [InventoryAttributeDataType] <p>The data type of the inventory item attribute. </p>
-- * Name [InventoryItemAttributeName] <p>Name of the inventory item attribute.</p>
-- Required key: Name
-- Required key: DataType
-- @return InventoryItemAttribute structure as a key-value pair table
function M.InventoryItemAttribute(args)
	assert(args, "You must provide an argument table when creating InventoryItemAttribute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DataType"] = args["DataType"],
		["Name"] = args["Name"],
	}
	asserts.AssertInventoryItemAttribute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateMaintenanceWindowResult = { ["StartDate"] = true, ["EndDate"] = true, ["Name"] = true, ["Schedule"] = true, ["Enabled"] = true, ["ScheduleTimezone"] = true, ["Cutoff"] = true, ["AllowUnassociatedTargets"] = true, ["WindowId"] = true, ["Duration"] = true, ["Description"] = true, nil }

function asserts.AssertUpdateMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateMaintenanceWindowResult to be of type 'table'")
	if struct["StartDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["StartDate"]) end
	if struct["EndDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["EndDate"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	if struct["Schedule"] then asserts.AssertMaintenanceWindowSchedule(struct["Schedule"]) end
	if struct["Enabled"] then asserts.AssertMaintenanceWindowEnabled(struct["Enabled"]) end
	if struct["ScheduleTimezone"] then asserts.AssertMaintenanceWindowTimezone(struct["ScheduleTimezone"]) end
	if struct["Cutoff"] then asserts.AssertMaintenanceWindowCutoff(struct["Cutoff"]) end
	if struct["AllowUnassociatedTargets"] then asserts.AssertMaintenanceWindowAllowUnassociatedTargets(struct["AllowUnassociatedTargets"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Duration"] then asserts.AssertMaintenanceWindowDurationHours(struct["Duration"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateMaintenanceWindowResult[k], "UpdateMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StartDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when the Maintenance Window is scheduled to become active. The Maintenance Window will not run before this specified time.</p>
-- * EndDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when the Maintenance Window is scheduled to become inactive. The Maintenance Window will not run after this specified time.</p>
-- * Name [MaintenanceWindowName] <p>The name of the Maintenance Window.</p>
-- * Schedule [MaintenanceWindowSchedule] <p>The schedule of the Maintenance Window in the form of a cron or rate expression.</p>
-- * Enabled [MaintenanceWindowEnabled] <p>Whether the Maintenance Window is enabled.</p>
-- * ScheduleTimezone [MaintenanceWindowTimezone] <p>The time zone that the scheduled Maintenance Window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "etc/UTC", or "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time Zone Database</a> on the IANA website.</p>
-- * Cutoff [MaintenanceWindowCutoff] <p>The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution.</p>
-- * AllowUnassociatedTargets [MaintenanceWindowAllowUnassociatedTargets] <p>Whether targets must be registered with the Maintenance Window before tasks can be defined for those targets.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the created Maintenance Window.</p>
-- * Duration [MaintenanceWindowDurationHours] <p>The duration of the Maintenance Window in hours.</p>
-- * Description [MaintenanceWindowDescription] <p>An optional description of the update.</p>
-- @return UpdateMaintenanceWindowResult structure as a key-value pair table
function M.UpdateMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating UpdateMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StartDate"] = args["StartDate"],
		["EndDate"] = args["EndDate"],
		["Name"] = args["Name"],
		["Schedule"] = args["Schedule"],
		["Enabled"] = args["Enabled"],
		["ScheduleTimezone"] = args["ScheduleTimezone"],
		["Cutoff"] = args["Cutoff"],
		["AllowUnassociatedTargets"] = args["AllowUnassociatedTargets"],
		["WindowId"] = args["WindowId"],
		["Duration"] = args["Duration"],
		["Description"] = args["Description"],
	}
	asserts.AssertUpdateMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateActivationRequest = { ["DefaultInstanceName"] = true, ["IamRole"] = true, ["ExpirationDate"] = true, ["Description"] = true, ["RegistrationLimit"] = true, nil }

function asserts.AssertCreateActivationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateActivationRequest to be of type 'table'")
	assert(struct["IamRole"], "Expected key IamRole to exist in table")
	if struct["DefaultInstanceName"] then asserts.AssertDefaultInstanceName(struct["DefaultInstanceName"]) end
	if struct["IamRole"] then asserts.AssertIamRole(struct["IamRole"]) end
	if struct["ExpirationDate"] then asserts.AssertExpirationDate(struct["ExpirationDate"]) end
	if struct["Description"] then asserts.AssertActivationDescription(struct["Description"]) end
	if struct["RegistrationLimit"] then asserts.AssertRegistrationLimit(struct["RegistrationLimit"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateActivationRequest[k], "CreateActivationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateActivationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DefaultInstanceName [DefaultInstanceName] <p>The name of the registered, managed instance as it will appear in the Amazon EC2 console or when you use the AWS command line tools to list EC2 resources.</p> <important> <p>Do not enter personally identifiable information in this field.</p> </important>
-- * IamRole [IamRole] <p>The Amazon Identity and Access Management (IAM) role that you want to assign to the managed instance. </p>
-- * ExpirationDate [ExpirationDate] <p>The date by which this activation request should expire. The default value is 24 hours.</p>
-- * Description [ActivationDescription] <p>A user-defined description of the resource that you want to register with Amazon EC2. </p> <important> <p>Do not enter personally identifiable information in this field.</p> </important>
-- * RegistrationLimit [RegistrationLimit] <p>Specify the maximum number of managed instances you want to register. The default value is 1 instance.</p>
-- Required key: IamRole
-- @return CreateActivationRequest structure as a key-value pair table
function M.CreateActivationRequest(args)
	assert(args, "You must provide an argument table when creating CreateActivationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DefaultInstanceName"] = args["DefaultInstanceName"],
		["IamRole"] = args["IamRole"],
		["ExpirationDate"] = args["ExpirationDate"],
		["Description"] = args["Description"],
		["RegistrationLimit"] = args["RegistrationLimit"],
	}
	asserts.AssertCreateActivationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAssociationResult = { ["AssociationDescription"] = true, nil }

function asserts.AssertDescribeAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAssociationResult to be of type 'table'")
	if struct["AssociationDescription"] then asserts.AssertAssociationDescription(struct["AssociationDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAssociationResult[k], "DescribeAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationDescription [AssociationDescription] <p>Information about the association.</p>
-- @return DescribeAssociationResult structure as a key-value pair table
function M.DescribeAssociationResult(args)
	assert(args, "You must provide an argument table when creating DescribeAssociationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationDescription"] = args["AssociationDescription"],
	}
	asserts.AssertDescribeAssociationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InventoryResultEntity = { ["Data"] = true, ["Id"] = true, nil }

function asserts.AssertInventoryResultEntity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InventoryResultEntity to be of type 'table'")
	if struct["Data"] then asserts.AssertInventoryResultItemMap(struct["Data"]) end
	if struct["Id"] then asserts.AssertInventoryResultEntityId(struct["Id"]) end
	for k,_ in pairs(struct) do
		assert(keys.InventoryResultEntity[k], "InventoryResultEntity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InventoryResultEntity
-- <p>Inventory query results.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Data [InventoryResultItemMap] <p>The data section in the inventory result entity JSON.</p>
-- * Id [InventoryResultEntityId] <p>ID of the inventory result entity. For example, for managed instance inventory the result will be the managed instance ID. For EC2 instance inventory, the result will be the instance ID. </p>
-- @return InventoryResultEntity structure as a key-value pair table
function M.InventoryResultEntity(args)
	assert(args, "You must provide an argument table when creating InventoryResultEntity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Data"] = args["Data"],
		["Id"] = args["Id"],
	}
	asserts.AssertInventoryResultEntity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeParametersResult = { ["NextToken"] = true, ["Parameters"] = true, nil }

function asserts.AssertDescribeParametersResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeParametersResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Parameters"] then asserts.AssertParameterMetadataList(struct["Parameters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeParametersResult[k], "DescribeParametersResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeParametersResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * Parameters [ParameterMetadataList] <p>Parameters returned by the request.</p>
-- @return DescribeParametersResult structure as a key-value pair table
function M.DescribeParametersResult(args)
	assert(args, "You must provide an argument table when creating DescribeParametersResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Parameters"] = args["Parameters"],
	}
	asserts.AssertDescribeParametersResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterTaskWithMaintenanceWindowRequest = { ["ServiceRoleArn"] = true, ["LoggingInfo"] = true, ["MaxErrors"] = true, ["TaskArn"] = true, ["MaxConcurrency"] = true, ["ClientToken"] = true, ["Targets"] = true, ["Priority"] = true, ["TaskInvocationParameters"] = true, ["WindowId"] = true, ["TaskType"] = true, ["Description"] = true, ["TaskParameters"] = true, ["Name"] = true, nil }

function asserts.AssertRegisterTaskWithMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterTaskWithMaintenanceWindowRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	assert(struct["Targets"], "Expected key Targets to exist in table")
	assert(struct["TaskArn"], "Expected key TaskArn to exist in table")
	assert(struct["TaskType"], "Expected key TaskType to exist in table")
	assert(struct["MaxConcurrency"], "Expected key MaxConcurrency to exist in table")
	assert(struct["MaxErrors"], "Expected key MaxErrors to exist in table")
	if struct["ServiceRoleArn"] then asserts.AssertServiceRole(struct["ServiceRoleArn"]) end
	if struct["LoggingInfo"] then asserts.AssertLoggingInfo(struct["LoggingInfo"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["TaskArn"] then asserts.AssertMaintenanceWindowTaskArn(struct["TaskArn"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["ClientToken"] then asserts.AssertClientToken(struct["ClientToken"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Priority"] then asserts.AssertMaintenanceWindowTaskPriority(struct["Priority"]) end
	if struct["TaskInvocationParameters"] then asserts.AssertMaintenanceWindowTaskInvocationParameters(struct["TaskInvocationParameters"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["TaskType"] then asserts.AssertMaintenanceWindowTaskType(struct["TaskType"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["TaskParameters"] then asserts.AssertMaintenanceWindowTaskParameters(struct["TaskParameters"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterTaskWithMaintenanceWindowRequest[k], "RegisterTaskWithMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterTaskWithMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceRoleArn [ServiceRole] <p>The role to assume when running the Maintenance Window task.</p> <p>If you do not specify a service role ARN, Systems Manager will use your account's service-linked role for Systems Manager by default. If no service-linked role for Systems Manager exists in your account, it will be created when you run <code>RegisterTaskWithMaintenanceWindow</code> without specifying a service role ARN.</p> <p>For more information, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/using-service-linked-roles.html#slr-permissions">Service-Linked Role Permissions for Systems Manager</a> and <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html#maintenance-window-tasks-service-role">Should I Use a Service-Linked Role or a Custom Service Role to Run Maintenance Window Tasks? </a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * LoggingInfo [LoggingInfo] <p>A structure containing information about an Amazon S3 bucket to write instance-level logs to. </p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * MaxErrors [MaxErrors] <p>The maximum number of errors allowed before this task stops being scheduled.</p>
-- * TaskArn [MaintenanceWindowTaskArn] <p>The ARN of the task to execute </p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets this task can be run for in parallel.</p>
-- * ClientToken [ClientToken] <p>User-provided idempotency token.</p>
-- * Targets [Targets] <p>The targets (either instances or Maintenance Window targets).</p> <p>Specify instances using the following format: </p> <p> <code>Key=InstanceIds,Values=&lt;instance-id-1&gt;,&lt;instance-id-2&gt;</code> </p> <p>Specify Maintenance Window targets using the following format:</p> <p> <code>Key=&lt;WindowTargetIds&gt;,Values=&lt;window-target-id-1&gt;,&lt;window-target-id-2&gt;</code> </p>
-- * Priority [MaintenanceWindowTaskPriority] <p>The priority of the task in the Maintenance Window, the lower the number the higher the priority. Tasks in a Maintenance Window are scheduled in priority order with tasks that have the same priority scheduled in parallel.</p>
-- * TaskInvocationParameters [MaintenanceWindowTaskInvocationParameters] <p>The parameters that the task should use during execution. Populate only the fields that match the task type. All other fields should be empty. </p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window the task should be added to.</p>
-- * TaskType [MaintenanceWindowTaskType] <p>The type of task being registered.</p>
-- * Description [MaintenanceWindowDescription] <p>An optional description for the task.</p>
-- * TaskParameters [MaintenanceWindowTaskParameters] <p>The parameters that should be passed to the task when it is executed.</p> <note> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * Name [MaintenanceWindowName] <p>An optional name for the task.</p>
-- Required key: WindowId
-- Required key: Targets
-- Required key: TaskArn
-- Required key: TaskType
-- Required key: MaxConcurrency
-- Required key: MaxErrors
-- @return RegisterTaskWithMaintenanceWindowRequest structure as a key-value pair table
function M.RegisterTaskWithMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating RegisterTaskWithMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceRoleArn"] = args["ServiceRoleArn"],
		["LoggingInfo"] = args["LoggingInfo"],
		["MaxErrors"] = args["MaxErrors"],
		["TaskArn"] = args["TaskArn"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["ClientToken"] = args["ClientToken"],
		["Targets"] = args["Targets"],
		["Priority"] = args["Priority"],
		["TaskInvocationParameters"] = args["TaskInvocationParameters"],
		["WindowId"] = args["WindowId"],
		["TaskType"] = args["TaskType"],
		["Description"] = args["Description"],
		["TaskParameters"] = args["TaskParameters"],
		["Name"] = args["Name"],
	}
	asserts.AssertRegisterTaskWithMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDocumentResult = { ["Document"] = true, nil }

function asserts.AssertDescribeDocumentResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDocumentResult to be of type 'table'")
	if struct["Document"] then asserts.AssertDocumentDescription(struct["Document"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDocumentResult[k], "DescribeDocumentResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDocumentResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Document [DocumentDescription] <p>Information about the Systems Manager document.</p>
-- @return DescribeDocumentResult structure as a key-value pair table
function M.DescribeDocumentResult(args)
	assert(args, "You must provide an argument table when creating DescribeDocumentResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Document"] = args["Document"],
	}
	asserts.AssertDescribeDocumentResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceAssociationOutputUrl = { ["S3OutputUrl"] = true, nil }

function asserts.AssertInstanceAssociationOutputUrl(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAssociationOutputUrl to be of type 'table'")
	if struct["S3OutputUrl"] then asserts.AssertS3OutputUrl(struct["S3OutputUrl"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAssociationOutputUrl[k], "InstanceAssociationOutputUrl contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAssociationOutputUrl
-- <p>The URL of Amazon S3 bucket where you want to store the results of this request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3OutputUrl [S3OutputUrl] <p>The URL of Amazon S3 bucket where you want to store the results of this request.</p>
-- @return InstanceAssociationOutputUrl structure as a key-value pair table
function M.InstanceAssociationOutputUrl(args)
	assert(args, "You must provide an argument table when creating InstanceAssociationOutputUrl")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3OutputUrl"] = args["S3OutputUrl"],
	}
	asserts.AssertInstanceAssociationOutputUrl(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteParametersRequest = { ["Names"] = true, nil }

function asserts.AssertDeleteParametersRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteParametersRequest to be of type 'table'")
	assert(struct["Names"], "Expected key Names to exist in table")
	if struct["Names"] then asserts.AssertParameterNameList(struct["Names"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteParametersRequest[k], "DeleteParametersRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteParametersRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Names [ParameterNameList] <p>The names of the parameters to delete.</p>
-- Required key: Names
-- @return DeleteParametersRequest structure as a key-value pair table
function M.DeleteParametersRequest(args)
	assert(args, "You must provide an argument table when creating DeleteParametersRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Names"] = args["Names"],
	}
	asserts.AssertDeleteParametersRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreatePatchBaselineRequest = { ["ApprovedPatchesEnableNonSecurity"] = true, ["Name"] = true, ["RejectedPatches"] = true, ["GlobalFilters"] = true, ["Sources"] = true, ["ApprovalRules"] = true, ["ClientToken"] = true, ["Description"] = true, ["ApprovedPatchesComplianceLevel"] = true, ["OperatingSystem"] = true, ["ApprovedPatches"] = true, ["RejectedPatchesAction"] = true, nil }

function asserts.AssertCreatePatchBaselineRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePatchBaselineRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["ApprovedPatchesEnableNonSecurity"] then asserts.AssertBoolean(struct["ApprovedPatchesEnableNonSecurity"]) end
	if struct["Name"] then asserts.AssertBaselineName(struct["Name"]) end
	if struct["RejectedPatches"] then asserts.AssertPatchIdList(struct["RejectedPatches"]) end
	if struct["GlobalFilters"] then asserts.AssertPatchFilterGroup(struct["GlobalFilters"]) end
	if struct["Sources"] then asserts.AssertPatchSourceList(struct["Sources"]) end
	if struct["ApprovalRules"] then asserts.AssertPatchRuleGroup(struct["ApprovalRules"]) end
	if struct["ClientToken"] then asserts.AssertClientToken(struct["ClientToken"]) end
	if struct["Description"] then asserts.AssertBaselineDescription(struct["Description"]) end
	if struct["ApprovedPatchesComplianceLevel"] then asserts.AssertPatchComplianceLevel(struct["ApprovedPatchesComplianceLevel"]) end
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	if struct["ApprovedPatches"] then asserts.AssertPatchIdList(struct["ApprovedPatches"]) end
	if struct["RejectedPatchesAction"] then asserts.AssertPatchAction(struct["RejectedPatchesAction"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePatchBaselineRequest[k], "CreatePatchBaselineRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePatchBaselineRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ApprovedPatchesEnableNonSecurity [Boolean] <p>Indicates whether the list of approved patches includes non-security updates that should be applied to the instances. The default value is 'false'. Applies to Linux instances only.</p>
-- * Name [BaselineName] <p>The name of the patch baseline.</p>
-- * RejectedPatches [PatchIdList] <p>A list of explicitly rejected patches for the baseline.</p> <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package Name Formats for Approved and Rejected Patch Lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * GlobalFilters [PatchFilterGroup] <p>A set of global filters used to exclude patches from the baseline.</p>
-- * Sources [PatchSourceList] <p>Information about the patches to use to update the instances, including target operating systems and source repositories. Applies to Linux instances only.</p>
-- * ApprovalRules [PatchRuleGroup] <p>A set of rules used to include patches in the baseline.</p>
-- * ClientToken [ClientToken] <p>User-provided idempotency token.</p>
-- * Description [BaselineDescription] <p>A description of the patch baseline.</p>
-- * ApprovedPatchesComplianceLevel [PatchComplianceLevel] <p>Defines the compliance level for approved patches. This means that if an approved patch is reported as missing, this is the severity of the compliance violation. The default value is UNSPECIFIED.</p>
-- * OperatingSystem [OperatingSystem] <p>Defines the operating system the patch baseline applies to. The Default value is WINDOWS.</p>
-- * ApprovedPatches [PatchIdList] <p>A list of explicitly approved patches for the baseline.</p> <p>For information about accepted formats for lists of approved patches and rejected patches, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-approved-rejected-package-name-formats.html">Package Name Formats for Approved and Rejected Patch Lists</a> in the <i>AWS Systems Manager User Guide</i>.</p>
-- * RejectedPatchesAction [PatchAction] <p>The action for Patch Manager to take on patches included in the RejectedPackages list.</p> <ul> <li> <p> <b>ALLOW_AS_DEPENDENCY</b>: A package in the Rejected patches list is installed only if it is a dependency of another package. It is considered compliant with the patch baseline, and its status is reported as <i>InstalledOther</i>. This is the default action if no option is specified.</p> </li> <li> <p> <b>BLOCK</b>: Packages in the RejectedPatches list, and packages that include them as dependencies, are not installed under any circumstances. If a package was installed before it was added to the Rejected patches list, it is considered non-compliant with the patch baseline, and its status is reported as <i>InstalledRejected</i>.</p> </li> </ul>
-- Required key: Name
-- @return CreatePatchBaselineRequest structure as a key-value pair table
function M.CreatePatchBaselineRequest(args)
	assert(args, "You must provide an argument table when creating CreatePatchBaselineRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ApprovedPatchesEnableNonSecurity"] = args["ApprovedPatchesEnableNonSecurity"],
		["Name"] = args["Name"],
		["RejectedPatches"] = args["RejectedPatches"],
		["GlobalFilters"] = args["GlobalFilters"],
		["Sources"] = args["Sources"],
		["ApprovalRules"] = args["ApprovalRules"],
		["ClientToken"] = args["ClientToken"],
		["Description"] = args["Description"],
		["ApprovedPatchesComplianceLevel"] = args["ApprovedPatchesComplianceLevel"],
		["OperatingSystem"] = args["OperatingSystem"],
		["ApprovedPatches"] = args["ApprovedPatches"],
		["RejectedPatchesAction"] = args["RejectedPatchesAction"],
	}
	asserts.AssertCreatePatchBaselineRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListResourceComplianceSummariesRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertListResourceComplianceSummariesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListResourceComplianceSummariesRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertComplianceStringFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListResourceComplianceSummariesRequest[k], "ListResourceComplianceSummariesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListResourceComplianceSummariesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [ComplianceStringFilterList] <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- @return ListResourceComplianceSummariesRequest structure as a key-value pair table
function M.ListResourceComplianceSummariesRequest(args)
	assert(args, "You must provide an argument table when creating ListResourceComplianceSummariesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertListResourceComplianceSummariesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetMaintenanceWindowTaskResult = { ["ServiceRoleArn"] = true, ["LoggingInfo"] = true, ["MaxErrors"] = true, ["TaskArn"] = true, ["MaxConcurrency"] = true, ["WindowTaskId"] = true, ["TaskParameters"] = true, ["Priority"] = true, ["TaskInvocationParameters"] = true, ["WindowId"] = true, ["TaskType"] = true, ["Description"] = true, ["Targets"] = true, ["Name"] = true, nil }

function asserts.AssertGetMaintenanceWindowTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetMaintenanceWindowTaskResult to be of type 'table'")
	if struct["ServiceRoleArn"] then asserts.AssertServiceRole(struct["ServiceRoleArn"]) end
	if struct["LoggingInfo"] then asserts.AssertLoggingInfo(struct["LoggingInfo"]) end
	if struct["MaxErrors"] then asserts.AssertMaxErrors(struct["MaxErrors"]) end
	if struct["TaskArn"] then asserts.AssertMaintenanceWindowTaskArn(struct["TaskArn"]) end
	if struct["MaxConcurrency"] then asserts.AssertMaxConcurrency(struct["MaxConcurrency"]) end
	if struct["WindowTaskId"] then asserts.AssertMaintenanceWindowTaskId(struct["WindowTaskId"]) end
	if struct["TaskParameters"] then asserts.AssertMaintenanceWindowTaskParameters(struct["TaskParameters"]) end
	if struct["Priority"] then asserts.AssertMaintenanceWindowTaskPriority(struct["Priority"]) end
	if struct["TaskInvocationParameters"] then asserts.AssertMaintenanceWindowTaskInvocationParameters(struct["TaskInvocationParameters"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["TaskType"] then asserts.AssertMaintenanceWindowTaskType(struct["TaskType"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetMaintenanceWindowTaskResult[k], "GetMaintenanceWindowTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetMaintenanceWindowTaskResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceRoleArn [ServiceRole] <p>The IAM service role to assume during task execution.</p>
-- * LoggingInfo [LoggingInfo] <p>The location in Amazon S3 where the task results are logged.</p> <note> <p> <code>LoggingInfo</code> has been deprecated. To specify an S3 bucket to contain logs, instead use the <code>OutputS3BucketName</code> and <code>OutputS3KeyPrefix</code> options in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * MaxErrors [MaxErrors] <p>The maximum number of errors allowed before the task stops being scheduled.</p>
-- * TaskArn [MaintenanceWindowTaskArn] <p>The resource that the task used during execution. For RUN_COMMAND and AUTOMATION task types, the TaskArn is the Systems Manager Document name/ARN. For LAMBDA tasks, the value is the function name/ARN. For STEP_FUNCTION tasks, the value is the state machine ARN.</p>
-- * MaxConcurrency [MaxConcurrency] <p>The maximum number of targets allowed to run this task in parallel.</p>
-- * WindowTaskId [MaintenanceWindowTaskId] <p>The retrieved Maintenance Window task ID.</p>
-- * TaskParameters [MaintenanceWindowTaskParameters] <p>The parameters to pass to the task when it executes.</p> <note> <p> <code>TaskParameters</code> has been deprecated. To specify parameters to pass to a task when it runs, instead use the <code>Parameters</code> option in the <code>TaskInvocationParameters</code> structure. For information about how Systems Manager handles these options for the supported Maintenance Window task types, see <a>MaintenanceWindowTaskInvocationParameters</a>.</p> </note>
-- * Priority [MaintenanceWindowTaskPriority] <p>The priority of the task when it executes. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.</p>
-- * TaskInvocationParameters [MaintenanceWindowTaskInvocationParameters] <p>The parameters to pass to the task when it executes.</p>
-- * WindowId [MaintenanceWindowId] <p>The retrieved Maintenance Window ID.</p>
-- * TaskType [MaintenanceWindowTaskType] <p>The type of task to execute.</p>
-- * Description [MaintenanceWindowDescription] <p>The retrieved task description.</p>
-- * Targets [Targets] <p>The targets where the task should execute.</p>
-- * Name [MaintenanceWindowName] <p>The retrieved task name.</p>
-- @return GetMaintenanceWindowTaskResult structure as a key-value pair table
function M.GetMaintenanceWindowTaskResult(args)
	assert(args, "You must provide an argument table when creating GetMaintenanceWindowTaskResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceRoleArn"] = args["ServiceRoleArn"],
		["LoggingInfo"] = args["LoggingInfo"],
		["MaxErrors"] = args["MaxErrors"],
		["TaskArn"] = args["TaskArn"],
		["MaxConcurrency"] = args["MaxConcurrency"],
		["WindowTaskId"] = args["WindowTaskId"],
		["TaskParameters"] = args["TaskParameters"],
		["Priority"] = args["Priority"],
		["TaskInvocationParameters"] = args["TaskInvocationParameters"],
		["WindowId"] = args["WindowId"],
		["TaskType"] = args["TaskType"],
		["Description"] = args["Description"],
		["Targets"] = args["Targets"],
		["Name"] = args["Name"],
	}
	asserts.AssertGetMaintenanceWindowTaskResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSessionsRequest = { ["State"] = true, ["NextToken"] = true, ["Filters"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeSessionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSessionsRequest to be of type 'table'")
	assert(struct["State"], "Expected key State to exist in table")
	if struct["State"] then asserts.AssertSessionState(struct["State"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["Filters"] then asserts.AssertSessionFilterList(struct["Filters"]) end
	if struct["MaxResults"] then asserts.AssertSessionMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSessionsRequest[k], "DescribeSessionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSessionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [SessionState] <p>The session status to retrieve a list of sessions for. For example, "Active".</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * Filters [SessionFilterList] <p>One or more filters to limit the type of sessions returned by the request.</p>
-- * MaxResults [SessionMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: State
-- @return DescribeSessionsRequest structure as a key-value pair table
function M.DescribeSessionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSessionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["NextToken"] = args["NextToken"],
		["Filters"] = args["Filters"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeSessionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEffectiveInstanceAssociationsRequest = { ["InstanceId"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeEffectiveInstanceAssociationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEffectiveInstanceAssociationsRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertInstanceId(struct["InstanceId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertEffectiveInstanceAssociationMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEffectiveInstanceAssociationsRequest[k], "DescribeEffectiveInstanceAssociationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEffectiveInstanceAssociationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [InstanceId] <p>The instance ID for which you want to view all associations.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a previous call.)</p>
-- * MaxResults [EffectiveInstanceAssociationMaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: InstanceId
-- @return DescribeEffectiveInstanceAssociationsRequest structure as a key-value pair table
function M.DescribeEffectiveInstanceAssociationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeEffectiveInstanceAssociationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeEffectiveInstanceAssociationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetDocumentRequest = { ["DocumentFormat"] = true, ["Name"] = true, ["DocumentVersion"] = true, nil }

function asserts.AssertGetDocumentRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetDocumentRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["DocumentFormat"] then asserts.AssertDocumentFormat(struct["DocumentFormat"]) end
	if struct["Name"] then asserts.AssertDocumentARN(struct["Name"]) end
	if struct["DocumentVersion"] then asserts.AssertDocumentVersion(struct["DocumentVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetDocumentRequest[k], "GetDocumentRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetDocumentRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DocumentFormat [DocumentFormat] <p>Returns the document in the specified format. The document format can be either JSON or YAML. JSON is the default format.</p>
-- * Name [DocumentARN] <p>The name of the Systems Manager document.</p>
-- * DocumentVersion [DocumentVersion] <p>The document version for which you want information.</p>
-- Required key: Name
-- @return GetDocumentRequest structure as a key-value pair table
function M.GetDocumentRequest(args)
	assert(args, "You must provide an argument table when creating GetDocumentRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DocumentFormat"] = args["DocumentFormat"],
		["Name"] = args["Name"],
		["DocumentVersion"] = args["DocumentVersion"],
	}
	asserts.AssertGetDocumentRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateResourceDataSyncRequest = { ["SyncName"] = true, ["S3Destination"] = true, nil }

function asserts.AssertCreateResourceDataSyncRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateResourceDataSyncRequest to be of type 'table'")
	assert(struct["SyncName"], "Expected key SyncName to exist in table")
	assert(struct["S3Destination"], "Expected key S3Destination to exist in table")
	if struct["SyncName"] then asserts.AssertResourceDataSyncName(struct["SyncName"]) end
	if struct["S3Destination"] then asserts.AssertResourceDataSyncS3Destination(struct["S3Destination"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateResourceDataSyncRequest[k], "CreateResourceDataSyncRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateResourceDataSyncRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SyncName [ResourceDataSyncName] <p>A name for the configuration.</p>
-- * S3Destination [ResourceDataSyncS3Destination] <p>Amazon S3 configuration details for the sync.</p>
-- Required key: SyncName
-- Required key: S3Destination
-- @return CreateResourceDataSyncRequest structure as a key-value pair table
function M.CreateResourceDataSyncRequest(args)
	assert(args, "You must provide an argument table when creating CreateResourceDataSyncRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SyncName"] = args["SyncName"],
		["S3Destination"] = args["S3Destination"],
	}
	asserts.AssertCreateResourceDataSyncRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListResourceDataSyncRequest = { ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertListResourceDataSyncRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListResourceDataSyncRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListResourceDataSyncRequest[k], "ListResourceDataSyncRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListResourceDataSyncRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- @return ListResourceDataSyncRequest structure as a key-value pair table
function M.ListResourceDataSyncRequest(args)
	assert(args, "You must provide an argument table when creating ListResourceDataSyncRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertListResourceDataSyncRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePatchGroupStateRequest = { ["PatchGroup"] = true, nil }

function asserts.AssertDescribePatchGroupStateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePatchGroupStateRequest to be of type 'table'")
	assert(struct["PatchGroup"], "Expected key PatchGroup to exist in table")
	if struct["PatchGroup"] then asserts.AssertPatchGroup(struct["PatchGroup"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePatchGroupStateRequest[k], "DescribePatchGroupStateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePatchGroupStateRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PatchGroup [PatchGroup] <p>The name of the patch group whose patch snapshot should be retrieved.</p>
-- Required key: PatchGroup
-- @return DescribePatchGroupStateRequest structure as a key-value pair table
function M.DescribePatchGroupStateRequest(args)
	assert(args, "You must provide an argument table when creating DescribePatchGroupStateRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PatchGroup"] = args["PatchGroup"],
	}
	asserts.AssertDescribePatchGroupStateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PatchBaselineIdentity = { ["BaselineName"] = true, ["DefaultBaseline"] = true, ["BaselineDescription"] = true, ["BaselineId"] = true, ["OperatingSystem"] = true, nil }

function asserts.AssertPatchBaselineIdentity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PatchBaselineIdentity to be of type 'table'")
	if struct["BaselineName"] then asserts.AssertBaselineName(struct["BaselineName"]) end
	if struct["DefaultBaseline"] then asserts.AssertDefaultBaseline(struct["DefaultBaseline"]) end
	if struct["BaselineDescription"] then asserts.AssertBaselineDescription(struct["BaselineDescription"]) end
	if struct["BaselineId"] then asserts.AssertBaselineId(struct["BaselineId"]) end
	if struct["OperatingSystem"] then asserts.AssertOperatingSystem(struct["OperatingSystem"]) end
	for k,_ in pairs(struct) do
		assert(keys.PatchBaselineIdentity[k], "PatchBaselineIdentity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PatchBaselineIdentity
-- <p>Defines the basic information about a patch baseline.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BaselineName [BaselineName] <p>The name of the patch baseline.</p>
-- * DefaultBaseline [DefaultBaseline] <p>Whether this is the default baseline. Note that Systems Manager supports creating multiple default patch baselines. For example, you can create a default patch baseline for each operating system.</p>
-- * BaselineDescription [BaselineDescription] <p>The description of the patch baseline.</p>
-- * BaselineId [BaselineId] <p>The ID of the patch baseline.</p>
-- * OperatingSystem [OperatingSystem] <p>Defines the operating system the patch baseline applies to. The Default value is WINDOWS. </p>
-- @return PatchBaselineIdentity structure as a key-value pair table
function M.PatchBaselineIdentity(args)
	assert(args, "You must provide an argument table when creating PatchBaselineIdentity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BaselineName"] = args["BaselineName"],
		["DefaultBaseline"] = args["DefaultBaseline"],
		["BaselineDescription"] = args["BaselineDescription"],
		["BaselineId"] = args["BaselineId"],
		["OperatingSystem"] = args["OperatingSystem"],
	}
	asserts.AssertPatchBaselineIdentity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeActivationsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeActivationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeActivationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertDescribeActivationsFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeActivationsRequest[k], "DescribeActivationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeActivationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>A token to start the list. Use this token to get the next set of results. </p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [DescribeActivationsFilterList] <p>A filter to view information about your activations.</p>
-- @return DescribeActivationsRequest structure as a key-value pair table
function M.DescribeActivationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeActivationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeActivationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterTargetWithMaintenanceWindowResult = { ["WindowTargetId"] = true, nil }

function asserts.AssertRegisterTargetWithMaintenanceWindowResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterTargetWithMaintenanceWindowResult to be of type 'table'")
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTargetId(struct["WindowTargetId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterTargetWithMaintenanceWindowResult[k], "RegisterTargetWithMaintenanceWindowResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterTargetWithMaintenanceWindowResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WindowTargetId [MaintenanceWindowTargetId] <p>The ID of the target definition in this Maintenance Window.</p>
-- @return RegisterTargetWithMaintenanceWindowResult structure as a key-value pair table
function M.RegisterTargetWithMaintenanceWindowResult(args)
	assert(args, "You must provide an argument table when creating RegisterTargetWithMaintenanceWindowResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WindowTargetId"] = args["WindowTargetId"],
	}
	asserts.AssertRegisterTargetWithMaintenanceWindowResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetConnectionStatusResponse = { ["Status"] = true, ["Target"] = true, nil }

function asserts.AssertGetConnectionStatusResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConnectionStatusResponse to be of type 'table'")
	if struct["Status"] then asserts.AssertConnectionStatus(struct["Status"]) end
	if struct["Target"] then asserts.AssertSessionTarget(struct["Target"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConnectionStatusResponse[k], "GetConnectionStatusResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConnectionStatusResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [ConnectionStatus] <p>The status of the connection to the instance. For example, 'Connected' or 'Not Connected'.</p>
-- * Target [SessionTarget] <p>The ID of the instance to check connection status. </p>
-- @return GetConnectionStatusResponse structure as a key-value pair table
function M.GetConnectionStatusResponse(args)
	assert(args, "You must provide an argument table when creating GetConnectionStatusResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Target"] = args["Target"],
	}
	asserts.AssertGetConnectionStatusResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateMaintenanceWindowTargetResult = { ["Description"] = true, ["OwnerInformation"] = true, ["WindowTargetId"] = true, ["WindowId"] = true, ["Targets"] = true, ["Name"] = true, nil }

function asserts.AssertUpdateMaintenanceWindowTargetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateMaintenanceWindowTargetResult to be of type 'table'")
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	if struct["OwnerInformation"] then asserts.AssertOwnerInformation(struct["OwnerInformation"]) end
	if struct["WindowTargetId"] then asserts.AssertMaintenanceWindowTargetId(struct["WindowTargetId"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Targets"] then asserts.AssertTargets(struct["Targets"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateMaintenanceWindowTargetResult[k], "UpdateMaintenanceWindowTargetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateMaintenanceWindowTargetResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [MaintenanceWindowDescription] <p>The updated description.</p>
-- * OwnerInformation [OwnerInformation] <p>The updated owner.</p>
-- * WindowTargetId [MaintenanceWindowTargetId] <p>The target ID specified in the update request.</p>
-- * WindowId [MaintenanceWindowId] <p>The Maintenance Window ID specified in the update request.</p>
-- * Targets [Targets] <p>The updated targets.</p>
-- * Name [MaintenanceWindowName] <p>The updated name.</p>
-- @return UpdateMaintenanceWindowTargetResult structure as a key-value pair table
function M.UpdateMaintenanceWindowTargetResult(args)
	assert(args, "You must provide an argument table when creating UpdateMaintenanceWindowTargetResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Description"] = args["Description"],
		["OwnerInformation"] = args["OwnerInformation"],
		["WindowTargetId"] = args["WindowTargetId"],
		["WindowId"] = args["WindowId"],
		["Targets"] = args["Targets"],
		["Name"] = args["Name"],
	}
	asserts.AssertUpdateMaintenanceWindowTargetResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ComplianceStringFilter = { ["Type"] = true, ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertComplianceStringFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ComplianceStringFilter to be of type 'table'")
	if struct["Type"] then asserts.AssertComplianceQueryOperatorType(struct["Type"]) end
	if struct["Values"] then asserts.AssertComplianceStringFilterValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertComplianceStringFilterKey(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.ComplianceStringFilter[k], "ComplianceStringFilter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ComplianceStringFilter
-- <p>One or more filters. Use a filter to return a more specific list of results.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [ComplianceQueryOperatorType] <p>The type of comparison that should be performed for the value: Equal, NotEqual, BeginWith, LessThan, or GreaterThan.</p>
-- * Values [ComplianceStringFilterValueList] <p>The value for which to search.</p>
-- * Key [ComplianceStringFilterKey] <p>The name of the filter.</p>
-- @return ComplianceStringFilter structure as a key-value pair table
function M.ComplianceStringFilter(args)
	assert(args, "You must provide an argument table when creating ComplianceStringFilter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertComplianceStringFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PutParameterResult = { ["Version"] = true, nil }

function asserts.AssertPutParameterResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PutParameterResult to be of type 'table'")
	if struct["Version"] then asserts.AssertPSParameterVersion(struct["Version"]) end
	for k,_ in pairs(struct) do
		assert(keys.PutParameterResult[k], "PutParameterResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PutParameterResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Version [PSParameterVersion] <p>The new version number of a parameter. If you edit a parameter value, Parameter Store automatically creates a new version and assigns this new version a unique ID. You can reference a parameter version ID in API actions or in Systems Manager documents (SSM documents). By default, if you don't specify a specific version, the system returns the latest parameter value when a parameter is called.</p>
-- @return PutParameterResult structure as a key-value pair table
function M.PutParameterResult(args)
	assert(args, "You must provide an argument table when creating PutParameterResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Version"] = args["Version"],
	}
	asserts.AssertPutParameterResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateMaintenanceWindowRequest = { ["StartDate"] = true, ["EndDate"] = true, ["Name"] = true, ["Schedule"] = true, ["Enabled"] = true, ["ScheduleTimezone"] = true, ["Replace"] = true, ["Cutoff"] = true, ["AllowUnassociatedTargets"] = true, ["WindowId"] = true, ["Duration"] = true, ["Description"] = true, nil }

function asserts.AssertUpdateMaintenanceWindowRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateMaintenanceWindowRequest to be of type 'table'")
	assert(struct["WindowId"], "Expected key WindowId to exist in table")
	if struct["StartDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["StartDate"]) end
	if struct["EndDate"] then asserts.AssertMaintenanceWindowStringDateTime(struct["EndDate"]) end
	if struct["Name"] then asserts.AssertMaintenanceWindowName(struct["Name"]) end
	if struct["Schedule"] then asserts.AssertMaintenanceWindowSchedule(struct["Schedule"]) end
	if struct["Enabled"] then asserts.AssertMaintenanceWindowEnabled(struct["Enabled"]) end
	if struct["ScheduleTimezone"] then asserts.AssertMaintenanceWindowTimezone(struct["ScheduleTimezone"]) end
	if struct["Replace"] then asserts.AssertBoolean(struct["Replace"]) end
	if struct["Cutoff"] then asserts.AssertMaintenanceWindowCutoff(struct["Cutoff"]) end
	if struct["AllowUnassociatedTargets"] then asserts.AssertMaintenanceWindowAllowUnassociatedTargets(struct["AllowUnassociatedTargets"]) end
	if struct["WindowId"] then asserts.AssertMaintenanceWindowId(struct["WindowId"]) end
	if struct["Duration"] then asserts.AssertMaintenanceWindowDurationHours(struct["Duration"]) end
	if struct["Description"] then asserts.AssertMaintenanceWindowDescription(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateMaintenanceWindowRequest[k], "UpdateMaintenanceWindowRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateMaintenanceWindowRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StartDate [MaintenanceWindowStringDateTime] <p>The time zone that the scheduled Maintenance Window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "etc/UTC", or "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time Zone Database</a> on the IANA website.</p>
-- * EndDate [MaintenanceWindowStringDateTime] <p>The date and time, in ISO-8601 Extended format, for when you want the Maintenance Window to become inactive. EndDate allows you to set a date and time in the future when the Maintenance Window will no longer run.</p>
-- * Name [MaintenanceWindowName] <p>The name of the Maintenance Window.</p>
-- * Schedule [MaintenanceWindowSchedule] <p>The schedule of the Maintenance Window in the form of a cron or rate expression.</p>
-- * Enabled [MaintenanceWindowEnabled] <p>Whether the Maintenance Window is enabled.</p>
-- * ScheduleTimezone [MaintenanceWindowTimezone] <p>The time zone that the scheduled Maintenance Window executions are based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "etc/UTC", or "Asia/Seoul". For more information, see the <a href="https://www.iana.org/time-zones">Time Zone Database</a> on the IANA website.</p>
-- * Replace [Boolean] <p>If True, then all fields that are required by the CreateMaintenanceWindow action are also required for this API request. Optional fields that are not specified are set to null. </p>
-- * Cutoff [MaintenanceWindowCutoff] <p>The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution.</p>
-- * AllowUnassociatedTargets [MaintenanceWindowAllowUnassociatedTargets] <p>Whether targets must be registered with the Maintenance Window before tasks can be defined for those targets.</p>
-- * WindowId [MaintenanceWindowId] <p>The ID of the Maintenance Window to update.</p>
-- * Duration [MaintenanceWindowDurationHours] <p>The duration of the Maintenance Window in hours.</p>
-- * Description [MaintenanceWindowDescription] <p>An optional description for the update request.</p>
-- Required key: WindowId
-- @return UpdateMaintenanceWindowRequest structure as a key-value pair table
function M.UpdateMaintenanceWindowRequest(args)
	assert(args, "You must provide an argument table when creating UpdateMaintenanceWindowRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StartDate"] = args["StartDate"],
		["EndDate"] = args["EndDate"],
		["Name"] = args["Name"],
		["Schedule"] = args["Schedule"],
		["Enabled"] = args["Enabled"],
		["ScheduleTimezone"] = args["ScheduleTimezone"],
		["Replace"] = args["Replace"],
		["Cutoff"] = args["Cutoff"],
		["AllowUnassociatedTargets"] = args["AllowUnassociatedTargets"],
		["WindowId"] = args["WindowId"],
		["Duration"] = args["Duration"],
		["Description"] = args["Description"],
	}
	asserts.AssertUpdateMaintenanceWindowRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

function asserts.AssertAutomationExecutionStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AutomationExecutionStatus to be of type 'string'")
end

--  
function M.AutomationExecutionStatus(str)
	asserts.AssertAutomationExecutionStatus(str)
	return str
end

function asserts.AssertComplianceItemId(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceItemId to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ComplianceItemId(str)
	asserts.AssertComplianceItemId(str)
	return str
end

function asserts.AssertS3Region(str)
	assert(str)
	assert(type(str) == "string", "Expected S3Region to be of type 'string'")
	assert(#str <= 20, "Expected string to be max 20 characters")
	assert(#str >= 3, "Expected string to be min 3 characters")
end

--  
function M.S3Region(str)
	asserts.AssertS3Region(str)
	return str
end

function asserts.AssertPatchAction(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchAction to be of type 'string'")
end

--  
function M.PatchAction(str)
	asserts.AssertPatchAction(str)
	return str
end

function asserts.AssertAssociationStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationStatusName to be of type 'string'")
end

--  
function M.AssociationStatusName(str)
	asserts.AssertAssociationStatusName(str)
	return str
end

function asserts.AssertDocumentKeyValuesFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentKeyValuesFilterValue to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.DocumentKeyValuesFilterValue(str)
	asserts.AssertDocumentKeyValuesFilterValue(str)
	return str
end

function asserts.AssertPutInventoryMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected PutInventoryMessage to be of type 'string'")
end

--  
function M.PutInventoryMessage(str)
	asserts.AssertPutInventoryMessage(str)
	return str
end

function asserts.AssertInventoryResultItemKey(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryResultItemKey to be of type 'string'")
end

--  
function M.InventoryResultItemKey(str)
	asserts.AssertInventoryResultItemKey(str)
	return str
end

function asserts.AssertAssociationFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationFilterValue to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AssociationFilterValue(str)
	asserts.AssertAssociationFilterValue(str)
	return str
end

function asserts.AssertInstanceAssociationExecutionSummary(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceAssociationExecutionSummary to be of type 'string'")
	assert(#str <= 512, "Expected string to be max 512 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InstanceAssociationExecutionSummary(str)
	asserts.AssertInstanceAssociationExecutionSummary(str)
	return str
end

function asserts.AssertMaintenanceWindowStepFunctionsInput(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowStepFunctionsInput to be of type 'string'")
	assert(#str <= 4096, "Expected string to be max 4096 characters")
end

--  
function M.MaintenanceWindowStepFunctionsInput(str)
	asserts.AssertMaintenanceWindowStepFunctionsInput(str)
	return str
end

function asserts.AssertDocumentStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentStatus to be of type 'string'")
end

--  
function M.DocumentStatus(str)
	asserts.AssertDocumentStatus(str)
	return str
end

function asserts.AssertStatusAdditionalInfo(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusAdditionalInfo to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
end

--  
function M.StatusAdditionalInfo(str)
	asserts.AssertStatusAdditionalInfo(str)
	return str
end

function asserts.AssertPatchProduct(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchProduct to be of type 'string'")
end

--  
function M.PatchProduct(str)
	asserts.AssertPatchProduct(str)
	return str
end

function asserts.AssertOutputSourceId(str)
	assert(str)
	assert(type(str) == "string", "Expected OutputSourceId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.OutputSourceId(str)
	asserts.AssertOutputSourceId(str)
	return str
end

function asserts.AssertCloudWatchLogGroupName(str)
	assert(str)
	assert(type(str) == "string", "Expected CloudWatchLogGroupName to be of type 'string'")
	assert(#str <= 512, "Expected string to be max 512 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.CloudWatchLogGroupName(str)
	asserts.AssertCloudWatchLogGroupName(str)
	return str
end

function asserts.AssertPatchDeploymentStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchDeploymentStatus to be of type 'string'")
end

--  
function M.PatchDeploymentStatus(str)
	asserts.AssertPatchDeploymentStatus(str)
	return str
end

function asserts.AssertInventoryItemTypeName(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryItemTypeName to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InventoryItemTypeName(str)
	asserts.AssertInventoryItemTypeName(str)
	return str
end

function asserts.AssertDocumentVersionNumber(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentVersionNumber to be of type 'string'")
end

--  
function M.DocumentVersionNumber(str)
	asserts.AssertDocumentVersionNumber(str)
	return str
end

function asserts.AssertStatusDetails(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusDetails to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
end

--  
function M.StatusDetails(str)
	asserts.AssertStatusDetails(str)
	return str
end

function asserts.AssertPatchMsrcSeverity(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchMsrcSeverity to be of type 'string'")
end

--  
function M.PatchMsrcSeverity(str)
	asserts.AssertPatchMsrcSeverity(str)
	return str
end

function asserts.AssertInventoryDeletionId(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryDeletionId to be of type 'string'")
end

--  
function M.InventoryDeletionId(str)
	asserts.AssertInventoryDeletionId(str)
	return str
end

function asserts.AssertInventoryFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryFilterValue to be of type 'string'")
end

--  
function M.InventoryFilterValue(str)
	asserts.AssertInventoryFilterValue(str)
	return str
end

function asserts.AssertInstallOverrideList(str)
	assert(str)
	assert(type(str) == "string", "Expected InstallOverrideList to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InstallOverrideList(str)
	asserts.AssertInstallOverrideList(str)
	return str
end

function asserts.AssertComplianceFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceFilterValue to be of type 'string'")
end

--  
function M.ComplianceFilterValue(str)
	asserts.AssertComplianceFilterValue(str)
	return str
end

function asserts.AssertDocumentParameterType(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentParameterType to be of type 'string'")
end

--  
function M.DocumentParameterType(str)
	asserts.AssertDocumentParameterType(str)
	return str
end

function asserts.AssertAssociationResourceId(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationResourceId to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AssociationResourceId(str)
	asserts.AssertAssociationResourceId(str)
	return str
end

function asserts.AssertBatchErrorMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected BatchErrorMessage to be of type 'string'")
end

--  
function M.BatchErrorMessage(str)
	asserts.AssertBatchErrorMessage(str)
	return str
end

function asserts.AssertDocumentParameterDefaultValue(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentParameterDefaultValue to be of type 'string'")
end

--  
function M.DocumentParameterDefaultValue(str)
	asserts.AssertDocumentParameterDefaultValue(str)
	return str
end

function asserts.AssertMaintenanceWindowLambdaQualifier(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowLambdaQualifier to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowLambdaQualifier(str)
	asserts.AssertMaintenanceWindowLambdaQualifier(str)
	return str
end

function asserts.AssertParametersFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected ParametersFilterValue to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ParametersFilterValue(str)
	asserts.AssertParametersFilterValue(str)
	return str
end

function asserts.AssertDocumentHash(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentHash to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
end

--  
function M.DocumentHash(str)
	asserts.AssertDocumentHash(str)
	return str
end

function asserts.AssertComplianceExecutionType(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceExecutionType to be of type 'string'")
	assert(#str <= 50, "Expected string to be max 50 characters")
end

--  
function M.ComplianceExecutionType(str)
	asserts.AssertComplianceExecutionType(str)
	return str
end

function asserts.AssertInventoryFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryFilterKey to be of type 'string'")
	assert(#str <= 200, "Expected string to be max 200 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InventoryFilterKey(str)
	asserts.AssertInventoryFilterKey(str)
	return str
end

function asserts.AssertClientToken(str)
	assert(str)
	assert(type(str) == "string", "Expected ClientToken to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ClientToken(str)
	asserts.AssertClientToken(str)
	return str
end

function asserts.AssertDocumentFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentFormat to be of type 'string'")
end

--  
function M.DocumentFormat(str)
	asserts.AssertDocumentFormat(str)
	return str
end

function asserts.AssertDocumentName(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentName to be of type 'string'")
end

--  
function M.DocumentName(str)
	asserts.AssertDocumentName(str)
	return str
end

function asserts.AssertMaintenanceWindowDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowDescription to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowDescription(str)
	asserts.AssertMaintenanceWindowDescription(str)
	return str
end

function asserts.AssertStreamUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected StreamUrl to be of type 'string'")
end

--  
function M.StreamUrl(str)
	asserts.AssertStreamUrl(str)
	return str
end

function asserts.AssertMaintenanceWindowExecutionTaskInvocationParameters(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowExecutionTaskInvocationParameters to be of type 'string'")
end

--  
function M.MaintenanceWindowExecutionTaskInvocationParameters(str)
	asserts.AssertMaintenanceWindowExecutionTaskInvocationParameters(str)
	return str
end

function asserts.AssertMaintenanceWindowTaskType(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTaskType to be of type 'string'")
end

--  
function M.MaintenanceWindowTaskType(str)
	asserts.AssertMaintenanceWindowTaskType(str)
	return str
end

function asserts.AssertPatchId(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchId to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PatchId(str)
	asserts.AssertPatchId(str)
	return str
end

function asserts.AssertPatchClassification(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchClassification to be of type 'string'")
end

--  
function M.PatchClassification(str)
	asserts.AssertPatchClassification(str)
	return str
end

function asserts.AssertInstanceInformationFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceInformationFilterKey to be of type 'string'")
end

--  
function M.InstanceInformationFilterKey(str)
	asserts.AssertInstanceInformationFilterKey(str)
	return str
end

function asserts.AssertTargetMapValue(str)
	assert(str)
	assert(type(str) == "string", "Expected TargetMapValue to be of type 'string'")
	assert(#str <= 50, "Expected string to be max 50 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.TargetMapValue(str)
	asserts.AssertTargetMapValue(str)
	return str
end

function asserts.AssertMaintenanceWindowTaskArn(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTaskArn to be of type 'string'")
	assert(#str <= 1600, "Expected string to be max 1600 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowTaskArn(str)
	asserts.AssertMaintenanceWindowTaskArn(str)
	return str
end

function asserts.AssertParameterKeyId(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterKeyId to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ParameterKeyId(str)
	asserts.AssertParameterKeyId(str)
	return str
end

function asserts.AssertPatchOrchestratorFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchOrchestratorFilterKey to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PatchOrchestratorFilterKey(str)
	asserts.AssertPatchOrchestratorFilterKey(str)
	return str
end

function asserts.AssertOperatingSystem(str)
	assert(str)
	assert(type(str) == "string", "Expected OperatingSystem to be of type 'string'")
end

--  
function M.OperatingSystem(str)
	asserts.AssertOperatingSystem(str)
	return str
end

function asserts.AssertComplianceExecutionId(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceExecutionId to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
end

--  
function M.ComplianceExecutionId(str)
	asserts.AssertComplianceExecutionId(str)
	return str
end

function asserts.AssertAssociationFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationFilterKey to be of type 'string'")
end

--  
function M.AssociationFilterKey(str)
	asserts.AssertAssociationFilterKey(str)
	return str
end

function asserts.AssertResourceId(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceId to be of type 'string'")
end

--  
function M.ResourceId(str)
	asserts.AssertResourceId(str)
	return str
end

function asserts.AssertDocumentARN(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentARN to be of type 'string'")
end

--  
function M.DocumentARN(str)
	asserts.AssertDocumentARN(str)
	return str
end

function asserts.AssertMaintenanceWindowExecutionTaskExecutionId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowExecutionTaskExecutionId to be of type 'string'")
end

--  
function M.MaintenanceWindowExecutionTaskExecutionId(str)
	asserts.AssertMaintenanceWindowExecutionTaskExecutionId(str)
	return str
end

function asserts.AssertMaintenanceWindowTargetId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTargetId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.MaintenanceWindowTargetId(str)
	asserts.AssertMaintenanceWindowTargetId(str)
	return str
end

function asserts.AssertDocumentSchemaVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentSchemaVersion to be of type 'string'")
end

--  
function M.DocumentSchemaVersion(str)
	asserts.AssertDocumentSchemaVersion(str)
	return str
end

function asserts.AssertInstanceInformationStringFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceInformationStringFilterKey to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InstanceInformationStringFilterKey(str)
	asserts.AssertInstanceInformationStringFilterKey(str)
	return str
end

function asserts.AssertUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected Url to be of type 'string'")
end

--  
function M.Url(str)
	asserts.AssertUrl(str)
	return str
end

function asserts.AssertMaintenanceWindowExecutionTaskInvocationId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowExecutionTaskInvocationId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.MaintenanceWindowExecutionTaskInvocationId(str)
	asserts.AssertMaintenanceWindowExecutionTaskInvocationId(str)
	return str
end

function asserts.AssertInventoryAggregatorExpression(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryAggregatorExpression to be of type 'string'")
	assert(#str <= 1000, "Expected string to be max 1000 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InventoryAggregatorExpression(str)
	asserts.AssertInventoryAggregatorExpression(str)
	return str
end

function asserts.AssertDocumentVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentVersion to be of type 'string'")
end

--  
function M.DocumentVersion(str)
	asserts.AssertDocumentVersion(str)
	return str
end

function asserts.AssertIdempotencyToken(str)
	assert(str)
	assert(type(str) == "string", "Expected IdempotencyToken to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.IdempotencyToken(str)
	asserts.AssertIdempotencyToken(str)
	return str
end

function asserts.AssertScheduleExpression(str)
	assert(str)
	assert(type(str) == "string", "Expected ScheduleExpression to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ScheduleExpression(str)
	asserts.AssertScheduleExpression(str)
	return str
end

function asserts.AssertInventoryItemAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryItemAttributeName to be of type 'string'")
end

--  
function M.InventoryItemAttributeName(str)
	asserts.AssertInventoryItemAttributeName(str)
	return str
end

function asserts.AssertNotificationArn(str)
	assert(str)
	assert(type(str) == "string", "Expected NotificationArn to be of type 'string'")
end

--  
function M.NotificationArn(str)
	asserts.AssertNotificationArn(str)
	return str
end

function asserts.AssertInventoryItemCaptureTime(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryItemCaptureTime to be of type 'string'")
end

--  
function M.InventoryItemCaptureTime(str)
	asserts.AssertInventoryItemCaptureTime(str)
	return str
end

function asserts.AssertParameterStringQueryOption(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterStringQueryOption to be of type 'string'")
	assert(#str <= 10, "Expected string to be max 10 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ParameterStringQueryOption(str)
	asserts.AssertParameterStringQueryOption(str)
	return str
end

function asserts.AssertDefaultInstanceName(str)
	assert(str)
	assert(type(str) == "string", "Expected DefaultInstanceName to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
end

--  
function M.DefaultInstanceName(str)
	asserts.AssertDefaultInstanceName(str)
	return str
end

function asserts.AssertMaintenanceWindowTaskParameterName(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTaskParameterName to be of type 'string'")
	assert(#str <= 255, "Expected string to be max 255 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowTaskParameterName(str)
	asserts.AssertMaintenanceWindowTaskParameterName(str)
	return str
end

function asserts.AssertAutomationParameterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected AutomationParameterValue to be of type 'string'")
	assert(#str <= 512, "Expected string to be max 512 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AutomationParameterValue(str)
	asserts.AssertAutomationParameterValue(str)
	return str
end

function asserts.AssertResourceDataSyncS3Region(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceDataSyncS3Region to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ResourceDataSyncS3Region(str)
	asserts.AssertResourceDataSyncS3Region(str)
	return str
end

function asserts.AssertDescribeActivationsFilterKeys(str)
	assert(str)
	assert(type(str) == "string", "Expected DescribeActivationsFilterKeys to be of type 'string'")
end

--  
function M.DescribeActivationsFilterKeys(str)
	asserts.AssertDescribeActivationsFilterKeys(str)
	return str
end

function asserts.AssertActivationDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected ActivationDescription to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
end

--  
function M.ActivationDescription(str)
	asserts.AssertActivationDescription(str)
	return str
end

function asserts.AssertResourceDataSyncName(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceDataSyncName to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ResourceDataSyncName(str)
	asserts.AssertResourceDataSyncName(str)
	return str
end

function asserts.AssertTagKey(str)
	assert(str)
	assert(type(str) == "string", "Expected TagKey to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.TagKey(str)
	asserts.AssertTagKey(str)
	return str
end

function asserts.AssertPatchSourceName(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchSourceName to be of type 'string'")
end

--  
function M.PatchSourceName(str)
	asserts.AssertPatchSourceName(str)
	return str
end

function asserts.AssertInventoryQueryOperatorType(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryQueryOperatorType to be of type 'string'")
end

--  
function M.InventoryQueryOperatorType(str)
	asserts.AssertInventoryQueryOperatorType(str)
	return str
end

function asserts.AssertCommandId(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.CommandId(str)
	asserts.AssertCommandId(str)
	return str
end

function asserts.AssertInventoryItemTypeNameFilter(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryItemTypeNameFilter to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
end

--  
function M.InventoryItemTypeNameFilter(str)
	asserts.AssertInventoryItemTypeNameFilter(str)
	return str
end

function asserts.AssertAttributeValue(str)
	assert(str)
	assert(type(str) == "string", "Expected AttributeValue to be of type 'string'")
	assert(#str <= 4096, "Expected string to be max 4096 characters")
end

--  
function M.AttributeValue(str)
	asserts.AssertAttributeValue(str)
	return str
end

function asserts.AssertSessionManagerCloudWatchOutputUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionManagerCloudWatchOutputUrl to be of type 'string'")
	assert(#str <= 2083, "Expected string to be max 2083 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionManagerCloudWatchOutputUrl(str)
	asserts.AssertSessionManagerCloudWatchOutputUrl(str)
	return str
end

function asserts.AssertInventorySchemaDeleteOption(str)
	assert(str)
	assert(type(str) == "string", "Expected InventorySchemaDeleteOption to be of type 'string'")
end

--  
function M.InventorySchemaDeleteOption(str)
	asserts.AssertInventorySchemaDeleteOption(str)
	return str
end

function asserts.AssertPatchKbNumber(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchKbNumber to be of type 'string'")
end

--  
function M.PatchKbNumber(str)
	asserts.AssertPatchKbNumber(str)
	return str
end

function asserts.AssertStepExecutionFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected StepExecutionFilterKey to be of type 'string'")
end

--  
function M.StepExecutionFilterKey(str)
	asserts.AssertStepExecutionFilterKey(str)
	return str
end

function asserts.AssertMaintenanceWindowTaskTargetId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTaskTargetId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
end

--  
function M.MaintenanceWindowTaskTargetId(str)
	asserts.AssertMaintenanceWindowTaskTargetId(str)
	return str
end

function asserts.AssertPatchProductFamily(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchProductFamily to be of type 'string'")
end

--  
function M.PatchProductFamily(str)
	asserts.AssertPatchProductFamily(str)
	return str
end

function asserts.AssertPatchSourceProduct(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchSourceProduct to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PatchSourceProduct(str)
	asserts.AssertPatchSourceProduct(str)
	return str
end

function asserts.AssertValidNextStep(str)
	assert(str)
	assert(type(str) == "string", "Expected ValidNextStep to be of type 'string'")
	assert(#str <= 65535, "Expected string to be max 65535 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ValidNextStep(str)
	asserts.AssertValidNextStep(str)
	return str
end

function asserts.AssertAssociationName(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationName to be of type 'string'")
end

--  
function M.AssociationName(str)
	asserts.AssertAssociationName(str)
	return str
end

function asserts.AssertComplianceSeverity(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceSeverity to be of type 'string'")
end

--  
function M.ComplianceSeverity(str)
	asserts.AssertComplianceSeverity(str)
	return str
end

function asserts.AssertAssociationComplianceSeverity(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationComplianceSeverity to be of type 'string'")
end

--  
function M.AssociationComplianceSeverity(str)
	asserts.AssertAssociationComplianceSeverity(str)
	return str
end

function asserts.AssertInventoryAttributeDataType(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryAttributeDataType to be of type 'string'")
end

--  
function M.InventoryAttributeDataType(str)
	asserts.AssertInventoryAttributeDataType(str)
	return str
end

function asserts.AssertBaselineDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected BaselineDescription to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.BaselineDescription(str)
	asserts.AssertBaselineDescription(str)
	return str
end

function asserts.AssertInventoryGroupName(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryGroupName to be of type 'string'")
	assert(#str <= 200, "Expected string to be max 200 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InventoryGroupName(str)
	asserts.AssertInventoryGroupName(str)
	return str
end

function asserts.AssertPatchOperationType(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchOperationType to be of type 'string'")
end

--  
function M.PatchOperationType(str)
	asserts.AssertPatchOperationType(str)
	return str
end

function asserts.AssertTargetType(str)
	assert(str)
	assert(type(str) == "string", "Expected TargetType to be of type 'string'")
	assert(#str <= 200, "Expected string to be max 200 characters")
end

--  
function M.TargetType(str)
	asserts.AssertTargetType(str)
	return str
end

function asserts.AssertCommandInvocationStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandInvocationStatus to be of type 'string'")
end

--  
function M.CommandInvocationStatus(str)
	asserts.AssertCommandInvocationStatus(str)
	return str
end

function asserts.AssertString(str)
	assert(str)
	assert(type(str) == "string", "Expected String to be of type 'string'")
end

--  
function M.String(str)
	asserts.AssertString(str)
	return str
end

function asserts.AssertMaintenanceWindowExecutionId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowExecutionId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.MaintenanceWindowExecutionId(str)
	asserts.AssertMaintenanceWindowExecutionId(str)
	return str
end

function asserts.AssertPatchContentUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchContentUrl to be of type 'string'")
end

--  
function M.PatchContentUrl(str)
	asserts.AssertPatchContentUrl(str)
	return str
end

function asserts.AssertAssociationId(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationId to be of type 'string'")
end

--  
function M.AssociationId(str)
	asserts.AssertAssociationId(str)
	return str
end

function asserts.AssertSnapshotId(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.SnapshotId(str)
	asserts.AssertSnapshotId(str)
	return str
end

function asserts.AssertParameterStringFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterStringFilterValue to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ParameterStringFilterValue(str)
	asserts.AssertParameterStringFilterValue(str)
	return str
end

function asserts.AssertAllowedPattern(str)
	assert(str)
	assert(type(str) == "string", "Expected AllowedPattern to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
end

--  
function M.AllowedPattern(str)
	asserts.AssertAllowedPattern(str)
	return str
end

function asserts.AssertMaintenanceWindowExecutionStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowExecutionStatus to be of type 'string'")
end

--  
function M.MaintenanceWindowExecutionStatus(str)
	asserts.AssertMaintenanceWindowExecutionStatus(str)
	return str
end

function asserts.AssertDocumentFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentFilterKey to be of type 'string'")
end

--  
function M.DocumentFilterKey(str)
	asserts.AssertDocumentFilterKey(str)
	return str
end

function asserts.AssertParameterName(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterName to be of type 'string'")
end

--  
function M.ParameterName(str)
	asserts.AssertParameterName(str)
	return str
end

function asserts.AssertParameterType(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterType to be of type 'string'")
end

--  
function M.ParameterType(str)
	asserts.AssertParameterType(str)
	return str
end

function asserts.AssertMaintenanceWindowTimezone(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTimezone to be of type 'string'")
end

--  
function M.MaintenanceWindowTimezone(str)
	asserts.AssertMaintenanceWindowTimezone(str)
	return str
end

function asserts.AssertDocumentHashType(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentHashType to be of type 'string'")
end

--  
function M.DocumentHashType(str)
	asserts.AssertDocumentHashType(str)
	return str
end

function asserts.AssertComplianceTypeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceTypeName to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ComplianceTypeName(str)
	asserts.AssertComplianceTypeName(str)
	return str
end

function asserts.AssertVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected Version to be of type 'string'")
end

--  
function M.Version(str)
	asserts.AssertVersion(str)
	return str
end

function asserts.AssertOwnerInformation(str)
	assert(str)
	assert(type(str) == "string", "Expected OwnerInformation to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.OwnerInformation(str)
	asserts.AssertOwnerInformation(str)
	return str
end

function asserts.AssertStopType(str)
	assert(str)
	assert(type(str) == "string", "Expected StopType to be of type 'string'")
end

--  
function M.StopType(str)
	asserts.AssertStopType(str)
	return str
end

function asserts.AssertAssociationVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationVersion to be of type 'string'")
end

--  
function M.AssociationVersion(str)
	asserts.AssertAssociationVersion(str)
	return str
end

function asserts.AssertSessionManagerParameterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionManagerParameterValue to be of type 'string'")
	assert(#str <= 65535, "Expected string to be max 65535 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionManagerParameterValue(str)
	asserts.AssertSessionManagerParameterValue(str)
	return str
end

function asserts.AssertOutputSourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected OutputSourceType to be of type 'string'")
end

--  
function M.OutputSourceType(str)
	asserts.AssertOutputSourceType(str)
	return str
end

function asserts.AssertComputerName(str)
	assert(str)
	assert(type(str) == "string", "Expected ComputerName to be of type 'string'")
	assert(#str <= 255, "Expected string to be max 255 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ComputerName(str)
	asserts.AssertComputerName(str)
	return str
end

function asserts.AssertStandardOutputContent(str)
	assert(str)
	assert(type(str) == "string", "Expected StandardOutputContent to be of type 'string'")
	assert(#str <= 24000, "Expected string to be max 24000 characters")
end

--  
function M.StandardOutputContent(str)
	asserts.AssertStandardOutputContent(str)
	return str
end

function asserts.AssertAssociationExecutionTargetsFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationExecutionTargetsFilterKey to be of type 'string'")
end

--  
function M.AssociationExecutionTargetsFilterKey(str)
	asserts.AssertAssociationExecutionTargetsFilterKey(str)
	return str
end

function asserts.AssertComplianceItemContentHash(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceItemContentHash to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
end

--  
function M.ComplianceItemContentHash(str)
	asserts.AssertComplianceItemContentHash(str)
	return str
end

function asserts.AssertResourceDataSyncS3BucketName(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceDataSyncS3BucketName to be of type 'string'")
	assert(#str <= 2048, "Expected string to be max 2048 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ResourceDataSyncS3BucketName(str)
	asserts.AssertResourceDataSyncS3BucketName(str)
	return str
end

function asserts.AssertPatchFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchFilterValue to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PatchFilterValue(str)
	asserts.AssertPatchFilterValue(str)
	return str
end

function asserts.AssertFault(str)
	assert(str)
	assert(type(str) == "string", "Expected Fault to be of type 'string'")
end

--  
function M.Fault(str)
	asserts.AssertFault(str)
	return str
end

function asserts.AssertInventoryItemContentHash(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryItemContentHash to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
end

--  
function M.InventoryItemContentHash(str)
	asserts.AssertInventoryItemContentHash(str)
	return str
end

function asserts.AssertParameterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterValue to be of type 'string'")
end

--  
function M.ParameterValue(str)
	asserts.AssertParameterValue(str)
	return str
end

function asserts.AssertSnapshotDownloadUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotDownloadUrl to be of type 'string'")
end

--  
function M.SnapshotDownloadUrl(str)
	asserts.AssertSnapshotDownloadUrl(str)
	return str
end

function asserts.AssertMaintenanceWindowExecutionStatusDetails(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowExecutionStatusDetails to be of type 'string'")
	assert(#str <= 250, "Expected string to be max 250 characters")
end

--  
function M.MaintenanceWindowExecutionStatusDetails(str)
	asserts.AssertMaintenanceWindowExecutionStatusDetails(str)
	return str
end

function asserts.AssertParameterStringFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterStringFilterKey to be of type 'string'")
	assert(#str <= 132, "Expected string to be max 132 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ParameterStringFilterKey(str)
	asserts.AssertParameterStringFilterKey(str)
	return str
end

function asserts.AssertDocumentKeyValuesFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentKeyValuesFilterKey to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.DocumentKeyValuesFilterKey(str)
	asserts.AssertDocumentKeyValuesFilterKey(str)
	return str
end

function asserts.AssertCommandStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandStatus to be of type 'string'")
end

--  
function M.CommandStatus(str)
	asserts.AssertCommandStatus(str)
	return str
end

function asserts.AssertSessionFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionFilterKey to be of type 'string'")
end

--  
function M.SessionFilterKey(str)
	asserts.AssertSessionFilterKey(str)
	return str
end

function asserts.AssertResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceType to be of type 'string'")
end

--  
function M.ResourceType(str)
	asserts.AssertResourceType(str)
	return str
end

function asserts.AssertPatchComplianceLevel(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchComplianceLevel to be of type 'string'")
end

--  
function M.PatchComplianceLevel(str)
	asserts.AssertPatchComplianceLevel(str)
	return str
end

function asserts.AssertSignalType(str)
	assert(str)
	assert(type(str) == "string", "Expected SignalType to be of type 'string'")
end

--  
function M.SignalType(str)
	asserts.AssertSignalType(str)
	return str
end

function asserts.AssertNotificationType(str)
	assert(str)
	assert(type(str) == "string", "Expected NotificationType to be of type 'string'")
end

--  
function M.NotificationType(str)
	asserts.AssertNotificationType(str)
	return str
end

function asserts.AssertParameterLabel(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterLabel to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ParameterLabel(str)
	asserts.AssertParameterLabel(str)
	return str
end

function asserts.AssertTargetKey(str)
	assert(str)
	assert(type(str) == "string", "Expected TargetKey to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.TargetKey(str)
	asserts.AssertTargetKey(str)
	return str
end

function asserts.AssertManagedInstanceId(str)
	assert(str)
	assert(type(str) == "string", "Expected ManagedInstanceId to be of type 'string'")
end

--  
function M.ManagedInstanceId(str)
	asserts.AssertManagedInstanceId(str)
	return str
end

function asserts.AssertAssociationFilterOperatorType(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationFilterOperatorType to be of type 'string'")
end

--  
function M.AssociationFilterOperatorType(str)
	asserts.AssertAssociationFilterOperatorType(str)
	return str
end

function asserts.AssertDocumentType(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentType to be of type 'string'")
end

--  
function M.DocumentType(str)
	asserts.AssertDocumentType(str)
	return str
end

function asserts.AssertAutomationExecutionFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected AutomationExecutionFilterValue to be of type 'string'")
	assert(#str <= 150, "Expected string to be max 150 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AutomationExecutionFilterValue(str)
	asserts.AssertAutomationExecutionFilterValue(str)
	return str
end

function asserts.AssertCommandPluginStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandPluginStatus to be of type 'string'")
end

--  
function M.CommandPluginStatus(str)
	asserts.AssertCommandPluginStatus(str)
	return str
end

function asserts.AssertComplianceItemTitle(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceItemTitle to be of type 'string'")
	assert(#str <= 500, "Expected string to be max 500 characters")
end

--  
function M.ComplianceItemTitle(str)
	asserts.AssertComplianceItemTitle(str)
	return str
end

function asserts.AssertCommandFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandFilterValue to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.CommandFilterValue(str)
	asserts.AssertCommandFilterValue(str)
	return str
end

function asserts.AssertInventoryTypeDisplayName(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryTypeDisplayName to be of type 'string'")
end

--  
function M.InventoryTypeDisplayName(str)
	asserts.AssertInventoryTypeDisplayName(str)
	return str
end

function asserts.AssertMaintenanceWindowExecutionTaskId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowExecutionTaskId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.MaintenanceWindowExecutionTaskId(str)
	asserts.AssertMaintenanceWindowExecutionTaskId(str)
	return str
end

function asserts.AssertPlatformType(str)
	assert(str)
	assert(type(str) == "string", "Expected PlatformType to be of type 'string'")
end

--  
function M.PlatformType(str)
	asserts.AssertPlatformType(str)
	return str
end

function asserts.AssertExecutionMode(str)
	assert(str)
	assert(type(str) == "string", "Expected ExecutionMode to be of type 'string'")
end

--  
function M.ExecutionMode(str)
	asserts.AssertExecutionMode(str)
	return str
end

function asserts.AssertTargetMapKey(str)
	assert(str)
	assert(type(str) == "string", "Expected TargetMapKey to be of type 'string'")
	assert(#str <= 50, "Expected string to be max 50 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.TargetMapKey(str)
	asserts.AssertTargetMapKey(str)
	return str
end

function asserts.AssertDocumentOwner(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentOwner to be of type 'string'")
end

--  
function M.DocumentOwner(str)
	asserts.AssertDocumentOwner(str)
	return str
end

function asserts.AssertResourceDataSyncS3Prefix(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceDataSyncS3Prefix to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ResourceDataSyncS3Prefix(str)
	asserts.AssertResourceDataSyncS3Prefix(str)
	return str
end

function asserts.AssertPSParameterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected PSParameterValue to be of type 'string'")
	assert(#str <= 4096, "Expected string to be max 4096 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PSParameterValue(str)
	asserts.AssertPSParameterValue(str)
	return str
end

function asserts.AssertComplianceResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceResourceType to be of type 'string'")
	assert(#str <= 50, "Expected string to be max 50 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ComplianceResourceType(str)
	asserts.AssertComplianceResourceType(str)
	return str
end

function asserts.AssertComplianceResourceId(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceResourceId to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ComplianceResourceId(str)
	asserts.AssertComplianceResourceId(str)
	return str
end

function asserts.AssertLastResourceDataSyncMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected LastResourceDataSyncMessage to be of type 'string'")
end

--  
function M.LastResourceDataSyncMessage(str)
	asserts.AssertLastResourceDataSyncMessage(str)
	return str
end

function asserts.AssertDocumentContent(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentContent to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.DocumentContent(str)
	asserts.AssertDocumentContent(str)
	return str
end

function asserts.AssertComplianceStringFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceStringFilterKey to be of type 'string'")
	assert(#str <= 200, "Expected string to be max 200 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ComplianceStringFilterKey(str)
	asserts.AssertComplianceStringFilterKey(str)
	return str
end

function asserts.AssertMaintenanceWindowId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowId to be of type 'string'")
	assert(#str <= 20, "Expected string to be max 20 characters")
	assert(#str >= 20, "Expected string to be min 20 characters")
end

--  
function M.MaintenanceWindowId(str)
	asserts.AssertMaintenanceWindowId(str)
	return str
end

function asserts.AssertS3BucketName(str)
	assert(str)
	assert(type(str) == "string", "Expected S3BucketName to be of type 'string'")
	assert(#str <= 63, "Expected string to be max 63 characters")
	assert(#str >= 3, "Expected string to be min 3 characters")
end

--  
function M.S3BucketName(str)
	asserts.AssertS3BucketName(str)
	return str
end

function asserts.AssertMaintenanceWindowTaskId(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTaskId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.MaintenanceWindowTaskId(str)
	asserts.AssertMaintenanceWindowTaskId(str)
	return str
end

function asserts.AssertActivationCode(str)
	assert(str)
	assert(type(str) == "string", "Expected ActivationCode to be of type 'string'")
	assert(#str <= 250, "Expected string to be max 250 characters")
	assert(#str >= 20, "Expected string to be min 20 characters")
end

--  
function M.ActivationCode(str)
	asserts.AssertActivationCode(str)
	return str
end

function asserts.AssertCommandPluginName(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandPluginName to be of type 'string'")
	assert(#str >= 4, "Expected string to be min 4 characters")
end

--  
function M.CommandPluginName(str)
	asserts.AssertCommandPluginName(str)
	return str
end

function asserts.AssertAutomationExecutionFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected AutomationExecutionFilterKey to be of type 'string'")
end

--  
function M.AutomationExecutionFilterKey(str)
	asserts.AssertAutomationExecutionFilterKey(str)
	return str
end

function asserts.AssertMaxErrors(str)
	assert(str)
	assert(type(str) == "string", "Expected MaxErrors to be of type 'string'")
	assert(#str <= 7, "Expected string to be max 7 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaxErrors(str)
	asserts.AssertMaxErrors(str)
	return str
end

function asserts.AssertInstancePatchStateFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected InstancePatchStateFilterKey to be of type 'string'")
	assert(#str <= 200, "Expected string to be max 200 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InstancePatchStateFilterKey(str)
	asserts.AssertInstancePatchStateFilterKey(str)
	return str
end

function asserts.AssertNotificationEvent(str)
	assert(str)
	assert(type(str) == "string", "Expected NotificationEvent to be of type 'string'")
end

--  
function M.NotificationEvent(str)
	asserts.AssertNotificationEvent(str)
	return str
end

function asserts.AssertPatchComplianceDataState(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchComplianceDataState to be of type 'string'")
end

--  
function M.PatchComplianceDataState(str)
	asserts.AssertPatchComplianceDataState(str)
	return str
end

function asserts.AssertPatchOrchestratorFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchOrchestratorFilterValue to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PatchOrchestratorFilterValue(str)
	asserts.AssertPatchOrchestratorFilterValue(str)
	return str
end

function asserts.AssertS3KeyPrefix(str)
	assert(str)
	assert(type(str) == "string", "Expected S3KeyPrefix to be of type 'string'")
	assert(#str <= 500, "Expected string to be max 500 characters")
end

--  
function M.S3KeyPrefix(str)
	asserts.AssertS3KeyPrefix(str)
	return str
end

function asserts.AssertMaintenanceWindowTaskParameterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowTaskParameterValue to be of type 'string'")
	assert(#str <= 255, "Expected string to be max 255 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowTaskParameterValue(str)
	asserts.AssertMaintenanceWindowTaskParameterValue(str)
	return str
end

function asserts.AssertInstanceTagName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceTagName to be of type 'string'")
	assert(#str <= 255, "Expected string to be max 255 characters")
end

--  
function M.InstanceTagName(str)
	asserts.AssertInstanceTagName(str)
	return str
end

function asserts.AssertSessionState(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionState to be of type 'string'")
end

--  
function M.SessionState(str)
	asserts.AssertSessionState(str)
	return str
end

function asserts.AssertInventoryDeletionStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryDeletionStatus to be of type 'string'")
end

--  
function M.InventoryDeletionStatus(str)
	asserts.AssertInventoryDeletionStatus(str)
	return str
end

function asserts.AssertLastResourceDataSyncStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected LastResourceDataSyncStatus to be of type 'string'")
end

--  
function M.LastResourceDataSyncStatus(str)
	asserts.AssertLastResourceDataSyncStatus(str)
	return str
end

function asserts.AssertBaselineId(str)
	assert(str)
	assert(type(str) == "string", "Expected BaselineId to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 20, "Expected string to be min 20 characters")
end

--  
function M.BaselineId(str)
	asserts.AssertBaselineId(str)
	return str
end

function asserts.AssertAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected AttributeName to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AttributeName(str)
	asserts.AssertAttributeName(str)
	return str
end

function asserts.AssertParametersFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected ParametersFilterKey to be of type 'string'")
end

--  
function M.ParametersFilterKey(str)
	asserts.AssertParametersFilterKey(str)
	return str
end

function asserts.AssertComplianceStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceStatus to be of type 'string'")
end

--  
function M.ComplianceStatus(str)
	asserts.AssertComplianceStatus(str)
	return str
end

function asserts.AssertPingStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected PingStatus to be of type 'string'")
end

--  
function M.PingStatus(str)
	asserts.AssertPingStatus(str)
	return str
end

function asserts.AssertSessionId(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionId to be of type 'string'")
	assert(#str <= 96, "Expected string to be max 96 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionId(str)
	asserts.AssertSessionId(str)
	return str
end

function asserts.AssertDocumentSha1(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentSha1 to be of type 'string'")
end

--  
function M.DocumentSha1(str)
	asserts.AssertDocumentSha1(str)
	return str
end

function asserts.AssertInvocationTraceOutput(str)
	assert(str)
	assert(type(str) == "string", "Expected InvocationTraceOutput to be of type 'string'")
	assert(#str <= 2500, "Expected string to be max 2500 characters")
end

--  
function M.InvocationTraceOutput(str)
	asserts.AssertInvocationTraceOutput(str)
	return str
end

function asserts.AssertSessionTarget(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionTarget to be of type 'string'")
	assert(#str <= 50, "Expected string to be max 50 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionTarget(str)
	asserts.AssertSessionTarget(str)
	return str
end

function asserts.AssertProduct(str)
	assert(str)
	assert(type(str) == "string", "Expected Product to be of type 'string'")
end

--  
function M.Product(str)
	asserts.AssertProduct(str)
	return str
end

function asserts.AssertAssociationExecutionFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationExecutionFilterKey to be of type 'string'")
end

--  
function M.AssociationExecutionFilterKey(str)
	asserts.AssertAssociationExecutionFilterKey(str)
	return str
end

function asserts.AssertSessionFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionFilterValue to be of type 'string'")
	assert(#str <= 200, "Expected string to be max 200 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionFilterValue(str)
	asserts.AssertSessionFilterValue(str)
	return str
end

function asserts.AssertResourceCountByStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceCountByStatus to be of type 'string'")
end

--  
function M.ResourceCountByStatus(str)
	asserts.AssertResourceCountByStatus(str)
	return str
end

function asserts.AssertServiceRole(str)
	assert(str)
	assert(type(str) == "string", "Expected ServiceRole to be of type 'string'")
end

--  
function M.ServiceRole(str)
	asserts.AssertServiceRole(str)
	return str
end

function asserts.AssertActivationId(str)
	assert(str)
	assert(type(str) == "string", "Expected ActivationId to be of type 'string'")
end

--  
function M.ActivationId(str)
	asserts.AssertActivationId(str)
	return str
end

function asserts.AssertMaintenanceWindowLambdaClientContext(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowLambdaClientContext to be of type 'string'")
	assert(#str <= 8000, "Expected string to be max 8000 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowLambdaClientContext(str)
	asserts.AssertMaintenanceWindowLambdaClientContext(str)
	return str
end

function asserts.AssertSessionDetails(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionDetails to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionDetails(str)
	asserts.AssertSessionDetails(str)
	return str
end

function asserts.AssertPatchSourceConfiguration(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchSourceConfiguration to be of type 'string'")
	assert(#str <= 512, "Expected string to be max 512 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PatchSourceConfiguration(str)
	asserts.AssertPatchSourceConfiguration(str)
	return str
end

function asserts.AssertCommandFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandFilterKey to be of type 'string'")
end

--  
function M.CommandFilterKey(str)
	asserts.AssertCommandFilterKey(str)
	return str
end

function asserts.AssertPatchVendor(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchVendor to be of type 'string'")
end

--  
function M.PatchVendor(str)
	asserts.AssertPatchVendor(str)
	return str
end

function asserts.AssertPatchDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchDescription to be of type 'string'")
end

--  
function M.PatchDescription(str)
	asserts.AssertPatchDescription(str)
	return str
end

function asserts.AssertAutomationParameterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected AutomationParameterKey to be of type 'string'")
	assert(#str <= 30, "Expected string to be max 30 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AutomationParameterKey(str)
	asserts.AssertAutomationParameterKey(str)
	return str
end

function asserts.AssertParameterDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected ParameterDescription to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
end

--  
function M.ParameterDescription(str)
	asserts.AssertParameterDescription(str)
	return str
end

function asserts.AssertIPAddress(str)
	assert(str)
	assert(type(str) == "string", "Expected IPAddress to be of type 'string'")
	assert(#str <= 46, "Expected string to be max 46 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.IPAddress(str)
	asserts.AssertIPAddress(str)
	return str
end

function asserts.AssertCommandPluginOutput(str)
	assert(str)
	assert(type(str) == "string", "Expected CommandPluginOutput to be of type 'string'")
	assert(#str <= 2500, "Expected string to be max 2500 characters")
end

--  
function M.CommandPluginOutput(str)
	asserts.AssertCommandPluginOutput(str)
	return str
end

function asserts.AssertAccountId(str)
	assert(str)
	assert(type(str) == "string", "Expected AccountId to be of type 'string'")
end

--  
function M.AccountId(str)
	asserts.AssertAccountId(str)
	return str
end

function asserts.AssertComplianceQueryOperatorType(str)
	assert(str)
	assert(type(str) == "string", "Expected ComplianceQueryOperatorType to be of type 'string'")
end

--  
function M.ComplianceQueryOperatorType(str)
	asserts.AssertComplianceQueryOperatorType(str)
	return str
end

function asserts.AssertPSParameterName(str)
	assert(str)
	assert(type(str) == "string", "Expected PSParameterName to be of type 'string'")
	assert(#str <= 2048, "Expected string to be max 2048 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PSParameterName(str)
	asserts.AssertPSParameterName(str)
	return str
end

function asserts.AssertAssociationResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationResourceType to be of type 'string'")
	assert(#str <= 50, "Expected string to be max 50 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AssociationResourceType(str)
	asserts.AssertAssociationResourceType(str)
	return str
end

function asserts.AssertPSParameterSelector(str)
	assert(str)
	assert(type(str) == "string", "Expected PSParameterSelector to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
end

--  
function M.PSParameterSelector(str)
	asserts.AssertPSParameterSelector(str)
	return str
end

function asserts.AssertPatchSeverity(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchSeverity to be of type 'string'")
end

--  
function M.PatchSeverity(str)
	asserts.AssertPatchSeverity(str)
	return str
end

function asserts.AssertAssociationExecutionId(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationExecutionId to be of type 'string'")
end

--  
function M.AssociationExecutionId(str)
	asserts.AssertAssociationExecutionId(str)
	return str
end

function asserts.AssertStatusMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusMessage to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.StatusMessage(str)
	asserts.AssertStatusMessage(str)
	return str
end

function asserts.AssertStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusName to be of type 'string'")
end

--  
function M.StatusName(str)
	asserts.AssertStatusName(str)
	return str
end

function asserts.AssertDocumentParameterDescrption(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentParameterDescrption to be of type 'string'")
end

--  
function M.DocumentParameterDescrption(str)
	asserts.AssertDocumentParameterDescrption(str)
	return str
end

function asserts.AssertDocumentPermissionType(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentPermissionType to be of type 'string'")
end

--  
function M.DocumentPermissionType(str)
	asserts.AssertDocumentPermissionType(str)
	return str
end

function asserts.AssertDocumentFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentFilterValue to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.DocumentFilterValue(str)
	asserts.AssertDocumentFilterValue(str)
	return str
end

function asserts.AssertSessionOwner(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionOwner to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionOwner(str)
	asserts.AssertSessionOwner(str)
	return str
end

function asserts.AssertConnectionStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ConnectionStatus to be of type 'string'")
end

--  
function M.ConnectionStatus(str)
	asserts.AssertConnectionStatus(str)
	return str
end

function asserts.AssertAutomationActionName(str)
	assert(str)
	assert(type(str) == "string", "Expected AutomationActionName to be of type 'string'")
end

--  
function M.AutomationActionName(str)
	asserts.AssertAutomationActionName(str)
	return str
end

function asserts.AssertTagValue(str)
	assert(str)
	assert(type(str) == "string", "Expected TagValue to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.TagValue(str)
	asserts.AssertTagValue(str)
	return str
end

function asserts.AssertStandardErrorContent(str)
	assert(str)
	assert(type(str) == "string", "Expected StandardErrorContent to be of type 'string'")
	assert(#str <= 8000, "Expected string to be max 8000 characters")
end

--  
function M.StandardErrorContent(str)
	asserts.AssertStandardErrorContent(str)
	return str
end

function asserts.AssertPatchLanguage(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchLanguage to be of type 'string'")
end

--  
function M.PatchLanguage(str)
	asserts.AssertPatchLanguage(str)
	return str
end

function asserts.AssertInstanceInformationFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceInformationFilterValue to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.InstanceInformationFilterValue(str)
	asserts.AssertInstanceInformationFilterValue(str)
	return str
end

function asserts.AssertComment(str)
	assert(str)
	assert(type(str) == "string", "Expected Comment to be of type 'string'")
	assert(#str <= 100, "Expected string to be max 100 characters")
end

--  
function M.Comment(str)
	asserts.AssertComment(str)
	return str
end

function asserts.AssertSessionManagerS3OutputUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionManagerS3OutputUrl to be of type 'string'")
	assert(#str <= 2083, "Expected string to be max 2083 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionManagerS3OutputUrl(str)
	asserts.AssertSessionManagerS3OutputUrl(str)
	return str
end

function asserts.AssertResourceDataSyncAWSKMSKeyARN(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceDataSyncAWSKMSKeyARN to be of type 'string'")
	assert(#str <= 512, "Expected string to be max 512 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ResourceDataSyncAWSKMSKeyARN(str)
	asserts.AssertResourceDataSyncAWSKMSKeyARN(str)
	return str
end

function asserts.AssertAutomationExecutionId(str)
	assert(str)
	assert(type(str) == "string", "Expected AutomationExecutionId to be of type 'string'")
	assert(#str <= 36, "Expected string to be max 36 characters")
	assert(#str >= 36, "Expected string to be min 36 characters")
end

--  
function M.AutomationExecutionId(str)
	asserts.AssertAutomationExecutionId(str)
	return str
end

function asserts.AssertResourceDataSyncS3Format(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceDataSyncS3Format to be of type 'string'")
end

--  
function M.ResourceDataSyncS3Format(str)
	asserts.AssertResourceDataSyncS3Format(str)
	return str
end

function asserts.AssertStepExecutionFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected StepExecutionFilterValue to be of type 'string'")
	assert(#str <= 150, "Expected string to be max 150 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.StepExecutionFilterValue(str)
	asserts.AssertStepExecutionFilterValue(str)
	return str
end

function asserts.AssertMaintenanceWindowFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowFilterValue to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowFilterValue(str)
	asserts.AssertMaintenanceWindowFilterValue(str)
	return str
end

function asserts.AssertAssociationExecutionFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationExecutionFilterValue to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AssociationExecutionFilterValue(str)
	asserts.AssertAssociationExecutionFilterValue(str)
	return str
end

function asserts.AssertPatchGroup(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchGroup to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PatchGroup(str)
	asserts.AssertPatchGroup(str)
	return str
end

function asserts.AssertAgentErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected AgentErrorCode to be of type 'string'")
	assert(#str <= 10, "Expected string to be max 10 characters")
end

--  
function M.AgentErrorCode(str)
	asserts.AssertAgentErrorCode(str)
	return str
end

function asserts.AssertTargetValue(str)
	assert(str)
	assert(type(str) == "string", "Expected TargetValue to be of type 'string'")
end

--  
function M.TargetValue(str)
	asserts.AssertTargetValue(str)
	return str
end

function asserts.AssertDescriptionInDocument(str)
	assert(str)
	assert(type(str) == "string", "Expected DescriptionInDocument to be of type 'string'")
end

--  
function M.DescriptionInDocument(str)
	asserts.AssertDescriptionInDocument(str)
	return str
end

function asserts.AssertMaintenanceWindowStepFunctionsName(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowStepFunctionsName to be of type 'string'")
	assert(#str <= 80, "Expected string to be max 80 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowStepFunctionsName(str)
	asserts.AssertMaintenanceWindowStepFunctionsName(str)
	return str
end

function asserts.AssertPatchTitle(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchTitle to be of type 'string'")
end

--  
function M.PatchTitle(str)
	asserts.AssertPatchTitle(str)
	return str
end

function asserts.AssertPatchFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchFilterKey to be of type 'string'")
end

--  
function M.PatchFilterKey(str)
	asserts.AssertPatchFilterKey(str)
	return str
end

function asserts.AssertSessionStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionStatus to be of type 'string'")
end

--  
function M.SessionStatus(str)
	asserts.AssertSessionStatus(str)
	return str
end

function asserts.AssertDocumentParameterName(str)
	assert(str)
	assert(type(str) == "string", "Expected DocumentParameterName to be of type 'string'")
end

--  
function M.DocumentParameterName(str)
	asserts.AssertDocumentParameterName(str)
	return str
end

function asserts.AssertResourceTypeForTagging(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceTypeForTagging to be of type 'string'")
end

--  
function M.ResourceTypeForTagging(str)
	asserts.AssertResourceTypeForTagging(str)
	return str
end

function asserts.AssertSessionManagerParameterName(str)
	assert(str)
	assert(type(str) == "string", "Expected SessionManagerParameterName to be of type 'string'")
	assert(#str <= 255, "Expected string to be max 255 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SessionManagerParameterName(str)
	asserts.AssertSessionManagerParameterName(str)
	return str
end

function asserts.AssertInstancePatchStateFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected InstancePatchStateFilterValue to be of type 'string'")
end

--  
function M.InstancePatchStateFilterValue(str)
	asserts.AssertInstancePatchStateFilterValue(str)
	return str
end

function asserts.AssertStringDateTime(str)
	assert(str)
	assert(type(str) == "string", "Expected StringDateTime to be of type 'string'")
end

--  
function M.StringDateTime(str)
	asserts.AssertStringDateTime(str)
	return str
end

function asserts.AssertBaselineName(str)
	assert(str)
	assert(type(str) == "string", "Expected BaselineName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 3, "Expected string to be min 3 characters")
end

--  
function M.BaselineName(str)
	asserts.AssertBaselineName(str)
	return str
end

function asserts.AssertInventoryDeletionLastStatusMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryDeletionLastStatusMessage to be of type 'string'")
end

--  
function M.InventoryDeletionLastStatusMessage(str)
	asserts.AssertInventoryDeletionLastStatusMessage(str)
	return str
end

function asserts.AssertInventoryResultEntityId(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryResultEntityId to be of type 'string'")
end

--  
function M.InventoryResultEntityId(str)
	asserts.AssertInventoryResultEntityId(str)
	return str
end

function asserts.AssertMaintenanceWindowStringDateTime(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowStringDateTime to be of type 'string'")
end

--  
function M.MaintenanceWindowStringDateTime(str)
	asserts.AssertMaintenanceWindowStringDateTime(str)
	return str
end

function asserts.AssertMaintenanceWindowSchedule(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowSchedule to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowSchedule(str)
	asserts.AssertMaintenanceWindowSchedule(str)
	return str
end

function asserts.AssertIamRole(str)
	assert(str)
	assert(type(str) == "string", "Expected IamRole to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
end

--  
function M.IamRole(str)
	asserts.AssertIamRole(str)
	return str
end

function asserts.AssertNextToken(str)
	assert(str)
	assert(type(str) == "string", "Expected NextToken to be of type 'string'")
end

--  
function M.NextToken(str)
	asserts.AssertNextToken(str)
	return str
end

function asserts.AssertInstanceId(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceId to be of type 'string'")
end

--  
function M.InstanceId(str)
	asserts.AssertInstanceId(str)
	return str
end

function asserts.AssertMaintenanceWindowResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowResourceType to be of type 'string'")
end

--  
function M.MaintenanceWindowResourceType(str)
	asserts.AssertMaintenanceWindowResourceType(str)
	return str
end

function asserts.AssertInstancePatchStateOperatorType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstancePatchStateOperatorType to be of type 'string'")
end

--  
function M.InstancePatchStateOperatorType(str)
	asserts.AssertInstancePatchStateOperatorType(str)
	return str
end

function asserts.AssertMaintenanceWindowFilterKey(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowFilterKey to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaintenanceWindowFilterKey(str)
	asserts.AssertMaintenanceWindowFilterKey(str)
	return str
end

function asserts.AssertMaxConcurrency(str)
	assert(str)
	assert(type(str) == "string", "Expected MaxConcurrency to be of type 'string'")
	assert(#str <= 7, "Expected string to be max 7 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.MaxConcurrency(str)
	asserts.AssertMaxConcurrency(str)
	return str
end

function asserts.AssertPatchMsrcNumber(str)
	assert(str)
	assert(type(str) == "string", "Expected PatchMsrcNumber to be of type 'string'")
end

--  
function M.PatchMsrcNumber(str)
	asserts.AssertPatchMsrcNumber(str)
	return str
end

function asserts.AssertMaintenanceWindowName(str)
	assert(str)
	assert(type(str) == "string", "Expected MaintenanceWindowName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 3, "Expected string to be min 3 characters")
end

--  
function M.MaintenanceWindowName(str)
	asserts.AssertMaintenanceWindowName(str)
	return str
end

function asserts.AssertTokenValue(str)
	assert(str)
	assert(type(str) == "string", "Expected TokenValue to be of type 'string'")
	assert(#str <= 300, "Expected string to be max 300 characters")
end

--  
function M.TokenValue(str)
	asserts.AssertTokenValue(str)
	return str
end

function asserts.AssertAssociationExecutionTargetsFilterValue(str)
	assert(str)
	assert(type(str) == "string", "Expected AssociationExecutionTargetsFilterValue to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AssociationExecutionTargetsFilterValue(str)
	asserts.AssertAssociationExecutionTargetsFilterValue(str)
	return str
end

function asserts.AssertInventoryItemSchemaVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected InventoryItemSchemaVersion to be of type 'string'")
end

--  
function M.InventoryItemSchemaVersion(str)
	asserts.AssertInventoryItemSchemaVersion(str)
	return str
end

function asserts.AssertPSParameterVersion(long)
	assert(long)
	assert(type(long) == "number", "Expected PSParameterVersion to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.PSParameterVersion(long)
	asserts.AssertPSParameterVersion(long)
	return long
end

function asserts.AssertLong(long)
	assert(long)
	assert(type(long) == "number", "Expected Long to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.Long(long)
	asserts.AssertLong(long)
	return long
end

function asserts.AssertPatchMissingCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchMissingCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.PatchMissingCount(integer)
	asserts.AssertPatchMissingCount(integer)
	return integer
end

function asserts.AssertRegistrationLimit(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected RegistrationLimit to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 1000, "Expected integer to be max 1000")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.RegistrationLimit(integer)
	asserts.AssertRegistrationLimit(integer)
	return integer
end

function asserts.AssertRemainingCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected RemainingCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.RemainingCount(integer)
	asserts.AssertRemainingCount(integer)
	return integer
end

function asserts.AssertPatchBaselineMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchBaselineMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 100, "Expected integer to be max 100")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.PatchBaselineMaxResults(integer)
	asserts.AssertPatchBaselineMaxResults(integer)
	return integer
end

function asserts.AssertCommandMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected CommandMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 50, "Expected integer to be max 50")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.CommandMaxResults(integer)
	asserts.AssertCommandMaxResults(integer)
	return integer
end

function asserts.AssertPatchInstalledOtherCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchInstalledOtherCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.PatchInstalledOtherCount(integer)
	asserts.AssertPatchInstalledOtherCount(integer)
	return integer
end

function asserts.AssertApproveAfterDays(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected ApproveAfterDays to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 100, "Expected integer to be max 100")
end

function M.ApproveAfterDays(integer)
	asserts.AssertApproveAfterDays(integer)
	return integer
end

function asserts.AssertInteger(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Integer to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.Integer(integer)
	asserts.AssertInteger(integer)
	return integer
end

function asserts.AssertMaxResultsEC2Compatible(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxResultsEC2Compatible to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 50, "Expected integer to be max 50")
	assert(integer >= 5, "Expected integer to be min 5")
end

function M.MaxResultsEC2Compatible(integer)
	asserts.AssertMaxResultsEC2Compatible(integer)
	return integer
end

function asserts.AssertResponseCode(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected ResponseCode to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.ResponseCode(integer)
	asserts.AssertResponseCode(integer)
	return integer
end

function asserts.AssertPatchComplianceMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchComplianceMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 100, "Expected integer to be max 100")
	assert(integer >= 10, "Expected integer to be min 10")
end

function M.PatchComplianceMaxResults(integer)
	asserts.AssertPatchComplianceMaxResults(integer)
	return integer
end

function asserts.AssertTimeoutSeconds(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected TimeoutSeconds to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 2592000, "Expected integer to be max 2592000")
	assert(integer >= 30, "Expected integer to be min 30")
end

function M.TimeoutSeconds(integer)
	asserts.AssertTimeoutSeconds(integer)
	return integer
end

function asserts.AssertTargetCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected TargetCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.TargetCount(integer)
	asserts.AssertTargetCount(integer)
	return integer
end

function asserts.AssertDeliveryTimedOutCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected DeliveryTimedOutCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.DeliveryTimedOutCount(integer)
	asserts.AssertDeliveryTimedOutCount(integer)
	return integer
end

function asserts.AssertMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 50, "Expected integer to be max 50")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.MaxResults(integer)
	asserts.AssertMaxResults(integer)
	return integer
end

function asserts.AssertInstanceCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected InstanceCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.InstanceCount(integer)
	asserts.AssertInstanceCount(integer)
	return integer
end

function asserts.AssertResourceCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected ResourceCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.ResourceCount(integer)
	asserts.AssertResourceCount(integer)
	return integer
end

function asserts.AssertCompletedCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected CompletedCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.CompletedCount(integer)
	asserts.AssertCompletedCount(integer)
	return integer
end

function asserts.AssertMaintenanceWindowSearchMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaintenanceWindowSearchMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.MaintenanceWindowSearchMaxResults(integer)
	asserts.AssertMaintenanceWindowSearchMaxResults(integer)
	return integer
end

function asserts.AssertSessionMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected SessionMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 200, "Expected integer to be max 200")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.SessionMaxResults(integer)
	asserts.AssertSessionMaxResults(integer)
	return integer
end

function asserts.AssertTotalCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected TotalCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.TotalCount(integer)
	asserts.AssertTotalCount(integer)
	return integer
end

function asserts.AssertMaintenanceWindowDurationHours(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaintenanceWindowDurationHours to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 24, "Expected integer to be max 24")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.MaintenanceWindowDurationHours(integer)
	asserts.AssertMaintenanceWindowDurationHours(integer)
	return integer
end

function asserts.AssertGetInventorySchemaMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected GetInventorySchemaMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 200, "Expected integer to be max 200")
	assert(integer >= 50, "Expected integer to be min 50")
end

function M.GetInventorySchemaMaxResults(integer)
	asserts.AssertGetInventorySchemaMaxResults(integer)
	return integer
end

function asserts.AssertPatchFailedCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchFailedCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.PatchFailedCount(integer)
	asserts.AssertPatchFailedCount(integer)
	return integer
end

function asserts.AssertMaintenanceWindowCutoff(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaintenanceWindowCutoff to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 23, "Expected integer to be max 23")
end

function M.MaintenanceWindowCutoff(integer)
	asserts.AssertMaintenanceWindowCutoff(integer)
	return integer
end

function asserts.AssertGetParametersByPathMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected GetParametersByPathMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 10, "Expected integer to be max 10")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.GetParametersByPathMaxResults(integer)
	asserts.AssertGetParametersByPathMaxResults(integer)
	return integer
end

function asserts.AssertMaintenanceWindowTaskPriority(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaintenanceWindowTaskPriority to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.MaintenanceWindowTaskPriority(integer)
	asserts.AssertMaintenanceWindowTaskPriority(integer)
	return integer
end

function asserts.AssertInstancesCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected InstancesCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.InstancesCount(integer)
	asserts.AssertInstancesCount(integer)
	return integer
end

function asserts.AssertPatchNotApplicableCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchNotApplicableCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.PatchNotApplicableCount(integer)
	asserts.AssertPatchNotApplicableCount(integer)
	return integer
end

function asserts.AssertEffectiveInstanceAssociationMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected EffectiveInstanceAssociationMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 5, "Expected integer to be max 5")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.EffectiveInstanceAssociationMaxResults(integer)
	asserts.AssertEffectiveInstanceAssociationMaxResults(integer)
	return integer
end

function asserts.AssertPatchInstalledCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchInstalledCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.PatchInstalledCount(integer)
	asserts.AssertPatchInstalledCount(integer)
	return integer
end

function asserts.AssertPatchInstalledRejectedCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PatchInstalledRejectedCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.PatchInstalledRejectedCount(integer)
	asserts.AssertPatchInstalledRejectedCount(integer)
	return integer
end

function asserts.AssertComplianceSummaryCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected ComplianceSummaryCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.ComplianceSummaryCount(integer)
	asserts.AssertComplianceSummaryCount(integer)
	return integer
end

function asserts.AssertRegistrationsCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected RegistrationsCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 1000, "Expected integer to be max 1000")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.RegistrationsCount(integer)
	asserts.AssertRegistrationsCount(integer)
	return integer
end

function asserts.AssertErrorCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected ErrorCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.ErrorCount(integer)
	asserts.AssertErrorCount(integer)
	return integer
end

function asserts.AssertMaintenanceWindowMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaintenanceWindowMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 100, "Expected integer to be max 100")
	assert(integer >= 10, "Expected integer to be min 10")
end

function M.MaintenanceWindowMaxResults(integer)
	asserts.AssertMaintenanceWindowMaxResults(integer)
	return integer
end

function asserts.AssertDefaultBaseline(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected DefaultBaseline to be of type 'boolean'")
end

function M.DefaultBaseline(boolean)
	asserts.AssertDefaultBaseline(boolean)
	return boolean
end

function asserts.AssertMaintenanceWindowAllowUnassociatedTargets(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected MaintenanceWindowAllowUnassociatedTargets to be of type 'boolean'")
end

function M.MaintenanceWindowAllowUnassociatedTargets(boolean)
	asserts.AssertMaintenanceWindowAllowUnassociatedTargets(boolean)
	return boolean
end

function asserts.AssertBoolean(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Boolean to be of type 'boolean'")
end

function M.Boolean(boolean)
	asserts.AssertBoolean(boolean)
	return boolean
end

function asserts.AssertDryRun(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected DryRun to be of type 'boolean'")
end

function M.DryRun(boolean)
	asserts.AssertDryRun(boolean)
	return boolean
end

function asserts.AssertIsSubTypeSchema(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected IsSubTypeSchema to be of type 'boolean'")
end

function M.IsSubTypeSchema(boolean)
	asserts.AssertIsSubTypeSchema(boolean)
	return boolean
end

function asserts.AssertMaintenanceWindowEnabled(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected MaintenanceWindowEnabled to be of type 'boolean'")
end

function M.MaintenanceWindowEnabled(boolean)
	asserts.AssertMaintenanceWindowEnabled(boolean)
	return boolean
end

function asserts.AssertAggregatorSchemaOnly(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected AggregatorSchemaOnly to be of type 'boolean'")
end

function M.AggregatorSchemaOnly(boolean)
	asserts.AssertAggregatorSchemaOnly(boolean)
	return boolean
end

function asserts.AssertCloudWatchOutputEnabled(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected CloudWatchOutputEnabled to be of type 'boolean'")
end

function M.CloudWatchOutputEnabled(boolean)
	asserts.AssertCloudWatchOutputEnabled(boolean)
	return boolean
end

function asserts.AssertSessionManagerParameters(map)
	assert(map)
	assert(type(map) == "table", "Expected SessionManagerParameters to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertSessionManagerParameterName(k)
		asserts.AssertSessionManagerParameterValueList(v)
	end
end

function M.SessionManagerParameters(map)
	asserts.AssertSessionManagerParameters(map)
	return map
end

function asserts.AssertAutomationParameterMap(map)
	assert(map)
	assert(type(map) == "table", "Expected AutomationParameterMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAutomationParameterKey(k)
		asserts.AssertAutomationParameterValueList(v)
	end
end

function M.AutomationParameterMap(map)
	asserts.AssertAutomationParameterMap(map)
	return map
end

function asserts.AssertInstanceAssociationStatusAggregatedCount(map)
	assert(map)
	assert(type(map) == "table", "Expected InstanceAssociationStatusAggregatedCount to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertStatusName(k)
		asserts.AssertInstanceCount(v)
	end
end

function M.InstanceAssociationStatusAggregatedCount(map)
	asserts.AssertInstanceAssociationStatusAggregatedCount(map)
	return map
end

function asserts.AssertTargetMap(map)
	assert(map)
	assert(type(map) == "table", "Expected TargetMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertTargetMapKey(k)
		asserts.AssertTargetMapValueList(v)
	end
end

function M.TargetMap(map)
	asserts.AssertTargetMap(map)
	return map
end

function asserts.AssertInventoryItemEntry(map)
	assert(map)
	assert(type(map) == "table", "Expected InventoryItemEntry to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAttributeName(k)
		asserts.AssertAttributeValue(v)
	end
end

function M.InventoryItemEntry(map)
	asserts.AssertInventoryItemEntry(map)
	return map
end

function asserts.AssertComplianceItemDetails(map)
	assert(map)
	assert(type(map) == "table", "Expected ComplianceItemDetails to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAttributeName(k)
		asserts.AssertAttributeValue(v)
	end
end

function M.ComplianceItemDetails(map)
	asserts.AssertComplianceItemDetails(map)
	return map
end

function asserts.AssertMaintenanceWindowTaskParameters(map)
	assert(map)
	assert(type(map) == "table", "Expected MaintenanceWindowTaskParameters to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertMaintenanceWindowTaskParameterName(k)
		asserts.AssertMaintenanceWindowTaskParameterValueExpression(v)
	end
end

function M.MaintenanceWindowTaskParameters(map)
	asserts.AssertMaintenanceWindowTaskParameters(map)
	return map
end

function asserts.AssertInventoryResultItemMap(map)
	assert(map)
	assert(type(map) == "table", "Expected InventoryResultItemMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertInventoryResultItemKey(k)
		asserts.AssertInventoryResultItem(v)
	end
end

function M.InventoryResultItemMap(map)
	asserts.AssertInventoryResultItemMap(map)
	return map
end

function asserts.AssertParameters(map)
	assert(map)
	assert(type(map) == "table", "Expected Parameters to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertParameterName(k)
		asserts.AssertParameterValueList(v)
	end
end

function M.Parameters(map)
	asserts.AssertParameters(map)
	return map
end

function asserts.AssertNormalStringMap(map)
	assert(map)
	assert(type(map) == "table", "Expected NormalStringMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertString(k)
		asserts.AssertString(v)
	end
end

function M.NormalStringMap(map)
	asserts.AssertNormalStringMap(map)
	return map
end

function asserts.AssertAssociationStatusAggregatedCount(map)
	assert(map)
	assert(type(map) == "table", "Expected AssociationStatusAggregatedCount to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertStatusName(k)
		asserts.AssertInstanceCount(v)
	end
end

function M.AssociationStatusAggregatedCount(map)
	asserts.AssertAssociationStatusAggregatedCount(map)
	return map
end

function asserts.AssertInventoryItemContentContext(map)
	assert(map)
	assert(type(map) == "table", "Expected InventoryItemContentContext to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAttributeName(k)
		asserts.AssertAttributeValue(v)
	end
end

function M.InventoryItemContentContext(map)
	asserts.AssertInventoryItemContentContext(map)
	return map
end

function asserts.AssertDateTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected DateTime to be of type 'string'")
end

function M.DateTime(timestamp)
	asserts.AssertDateTime(timestamp)
	return timestamp
end

function asserts.AssertInventoryDeletionLastStatusUpdateTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected InventoryDeletionLastStatusUpdateTime to be of type 'string'")
end

function M.InventoryDeletionLastStatusUpdateTime(timestamp)
	asserts.AssertInventoryDeletionLastStatusUpdateTime(timestamp)
	return timestamp
end

function asserts.AssertExpirationDate(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected ExpirationDate to be of type 'string'")
end

function M.ExpirationDate(timestamp)
	asserts.AssertExpirationDate(timestamp)
	return timestamp
end

function asserts.AssertLastSuccessfulResourceDataSyncTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected LastSuccessfulResourceDataSyncTime to be of type 'string'")
end

function M.LastSuccessfulResourceDataSyncTime(timestamp)
	asserts.AssertLastSuccessfulResourceDataSyncTime(timestamp)
	return timestamp
end

function asserts.AssertInventoryDeletionStartTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected InventoryDeletionStartTime to be of type 'string'")
end

function M.InventoryDeletionStartTime(timestamp)
	asserts.AssertInventoryDeletionStartTime(timestamp)
	return timestamp
end

function asserts.AssertResourceDataSyncCreatedTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected ResourceDataSyncCreatedTime to be of type 'string'")
end

function M.ResourceDataSyncCreatedTime(timestamp)
	asserts.AssertResourceDataSyncCreatedTime(timestamp)
	return timestamp
end

function asserts.AssertLastResourceDataSyncTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected LastResourceDataSyncTime to be of type 'string'")
end

function M.LastResourceDataSyncTime(timestamp)
	asserts.AssertLastResourceDataSyncTime(timestamp)
	return timestamp
end

function asserts.AssertCreatedDate(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected CreatedDate to be of type 'string'")
end

function M.CreatedDate(timestamp)
	asserts.AssertCreatedDate(timestamp)
	return timestamp
end

function asserts.AssertMaintenanceWindowLambdaPayload(blob)
	assert(blob)
	assert(type(blob) == "string", "Expected MaintenanceWindowLambdaPayload to be of type 'string'")
	assert(#blob <= 4096, "Expected blob to be max 4096")
end

function M.MaintenanceWindowLambdaPayload(blob)
	asserts.AssertMaintenanceWindowLambdaPayload(blob)
	return blob
end

function asserts.AssertDocumentParameterList(list)
	assert(list)
	assert(type(list) == "table", "Expected DocumentParameterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDocumentParameter(v)
	end
end

--  
-- List of DocumentParameter objects
function M.DocumentParameterList(list)
	asserts.AssertDocumentParameterList(list)
	return list
end

function asserts.AssertInstanceAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceAssociation(v)
	end
end

--  
-- List of InstanceAssociation objects
function M.InstanceAssociationList(list)
	asserts.AssertInstanceAssociationList(list)
	return list
end

function asserts.AssertSessionList(list)
	assert(list)
	assert(type(list) == "table", "Expected SessionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSession(v)
	end
end

--  
-- List of Session objects
function M.SessionList(list)
	asserts.AssertSessionList(list)
	return list
end

function asserts.AssertParameterStringFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterStringFilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertParameterStringFilter(v)
	end
end

--  
-- List of ParameterStringFilter objects
function M.ParameterStringFilterList(list)
	asserts.AssertParameterStringFilterList(list)
	return list
end

function asserts.AssertComplianceResourceTypeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ComplianceResourceTypeList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertComplianceResourceType(v)
	end
end

--  
-- List of ComplianceResourceType objects
function M.ComplianceResourceTypeList(list)
	asserts.AssertComplianceResourceTypeList(list)
	return list
end

function asserts.AssertInstanceInformationFilterValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceInformationFilterValueSet to be of type ''table")
	assert(#list <= 100, "Expected list to be contain 100 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInstanceInformationFilterValue(v)
	end
end

--  
-- List of InstanceInformationFilterValue objects
function M.InstanceInformationFilterValueSet(list)
	asserts.AssertInstanceInformationFilterValueSet(list)
	return list
end

function asserts.AssertComplianceStringFilterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected ComplianceStringFilterValueList to be of type ''table")
	assert(#list <= 20, "Expected list to be contain 20 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertComplianceFilterValue(v)
	end
end

--  
-- List of ComplianceFilterValue objects
function M.ComplianceStringFilterValueList(list)
	asserts.AssertComplianceStringFilterValueList(list)
	return list
end

function asserts.AssertInventoryResultEntityList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryResultEntityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInventoryResultEntity(v)
	end
end

--  
-- List of InventoryResultEntity objects
function M.InventoryResultEntityList(list)
	asserts.AssertInventoryResultEntityList(list)
	return list
end

function asserts.AssertAccountIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountIdList to be of type ''table")
	assert(#list <= 20, "Expected list to be contain 20 elements")
	for _,v in ipairs(list) do
		asserts.AssertAccountId(v)
	end
end

--  
-- List of AccountId objects
function M.AccountIdList(list)
	asserts.AssertAccountIdList(list)
	return list
end

function asserts.AssertPatchFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchFilterList to be of type ''table")
	assert(#list <= 4, "Expected list to be contain 4 elements")
	for _,v in ipairs(list) do
		asserts.AssertPatchFilter(v)
	end
end

--  
-- List of PatchFilter objects
function M.PatchFilterList(list)
	asserts.AssertPatchFilterList(list)
	return list
end

function asserts.AssertPatchOrchestratorFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchOrchestratorFilterList to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	for _,v in ipairs(list) do
		asserts.AssertPatchOrchestratorFilter(v)
	end
end

--  
-- List of PatchOrchestratorFilter objects
function M.PatchOrchestratorFilterList(list)
	asserts.AssertPatchOrchestratorFilterList(list)
	return list
end

function asserts.AssertParametersFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParametersFilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertParametersFilter(v)
	end
end

--  
-- List of ParametersFilter objects
function M.ParametersFilterList(list)
	asserts.AssertParametersFilterList(list)
	return list
end

function asserts.AssertSessionFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected SessionFilterList to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertSessionFilter(v)
	end
end

--  
-- List of SessionFilter objects
function M.SessionFilterList(list)
	asserts.AssertSessionFilterList(list)
	return list
end

function asserts.AssertDocumentFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected DocumentFilterList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertDocumentFilter(v)
	end
end

--  
-- List of DocumentFilter objects
function M.DocumentFilterList(list)
	asserts.AssertDocumentFilterList(list)
	return list
end

function asserts.AssertPatchRuleList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchRuleList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	for _,v in ipairs(list) do
		asserts.AssertPatchRule(v)
	end
end

--  
-- List of PatchRule objects
function M.PatchRuleList(list)
	asserts.AssertPatchRuleList(list)
	return list
end

function asserts.AssertEffectivePatchList(list)
	assert(list)
	assert(type(list) == "table", "Expected EffectivePatchList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEffectivePatch(v)
	end
end

--  
-- List of EffectivePatch objects
function M.EffectivePatchList(list)
	asserts.AssertEffectivePatchList(list)
	return list
end

function asserts.AssertMaintenanceWindowIdentityList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowIdentityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowIdentity(v)
	end
end

--  
-- List of MaintenanceWindowIdentity objects
function M.MaintenanceWindowIdentityList(list)
	asserts.AssertMaintenanceWindowIdentityList(list)
	return list
end

function asserts.AssertTargetMaps(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetMaps to be of type ''table")
	assert(#list <= 300, "Expected list to be contain 300 elements")
	for _,v in ipairs(list) do
		asserts.AssertTargetMap(v)
	end
end

--  
-- List of TargetMap objects
function M.TargetMaps(list)
	asserts.AssertTargetMaps(list)
	return list
end

function asserts.AssertPatchOrchestratorFilterValues(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchOrchestratorFilterValues to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPatchOrchestratorFilterValue(v)
	end
end

--  
-- List of PatchOrchestratorFilterValue objects
function M.PatchOrchestratorFilterValues(list)
	asserts.AssertPatchOrchestratorFilterValues(list)
	return list
end

function asserts.AssertAssociationExecutionTargetsFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationExecutionTargetsFilterList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAssociationExecutionTargetsFilter(v)
	end
end

--  
-- List of AssociationExecutionTargetsFilter objects
function M.AssociationExecutionTargetsFilterList(list)
	asserts.AssertAssociationExecutionTargetsFilterList(list)
	return list
end

function asserts.AssertMaintenanceWindowExecutionTaskIdentityList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowExecutionTaskIdentityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowExecutionTaskIdentity(v)
	end
end

--  
-- List of MaintenanceWindowExecutionTaskIdentity objects
function M.MaintenanceWindowExecutionTaskIdentityList(list)
	asserts.AssertMaintenanceWindowExecutionTaskIdentityList(list)
	return list
end

function asserts.AssertPatchGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPatchGroup(v)
	end
end

--  
-- List of PatchGroup objects
function M.PatchGroupList(list)
	asserts.AssertPatchGroupList(list)
	return list
end

function asserts.AssertInstanceInformationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceInformationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceInformation(v)
	end
end

--  
-- List of InstanceInformation objects
function M.InstanceInformationList(list)
	asserts.AssertInstanceInformationList(list)
	return list
end

function asserts.AssertDescribeActivationsFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected DescribeActivationsFilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDescribeActivationsFilter(v)
	end
end

--  
-- List of DescribeActivationsFilter objects
function M.DescribeActivationsFilterList(list)
	asserts.AssertDescribeActivationsFilterList(list)
	return list
end

function asserts.AssertPatchFilterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchFilterValueList to be of type ''table")
	assert(#list <= 20, "Expected list to be contain 20 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertPatchFilterValue(v)
	end
end

--  
-- List of PatchFilterValue objects
function M.PatchFilterValueList(list)
	asserts.AssertPatchFilterValueList(list)
	return list
end

function asserts.AssertAutomationExecutionFilterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected AutomationExecutionFilterValueList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAutomationExecutionFilterValue(v)
	end
end

--  
-- List of AutomationExecutionFilterValue objects
function M.AutomationExecutionFilterValueList(list)
	asserts.AssertAutomationExecutionFilterValueList(list)
	return list
end

function asserts.AssertAssociationExecutionTargetsList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationExecutionTargetsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAssociationExecutionTarget(v)
	end
end

--  
-- List of AssociationExecutionTarget objects
function M.AssociationExecutionTargetsList(list)
	asserts.AssertAssociationExecutionTargetsList(list)
	return list
end

function asserts.AssertAutomationParameterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected AutomationParameterValueList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	for _,v in ipairs(list) do
		asserts.AssertAutomationParameterValue(v)
	end
end

--  
-- List of AutomationParameterValue objects
function M.AutomationParameterValueList(list)
	asserts.AssertAutomationParameterValueList(list)
	return list
end

function asserts.AssertResourceDataSyncItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResourceDataSyncItemList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertResourceDataSyncItem(v)
	end
end

--  
-- List of ResourceDataSyncItem objects
function M.ResourceDataSyncItemList(list)
	asserts.AssertResourceDataSyncItemList(list)
	return list
end

function asserts.AssertInventoryItemAttributeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryItemAttributeList to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInventoryItemAttribute(v)
	end
end

--  
-- List of InventoryItemAttribute objects
function M.InventoryItemAttributeList(list)
	asserts.AssertInventoryItemAttributeList(list)
	return list
end

function asserts.AssertInstancePatchStateFilterValues(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePatchStateFilterValues to be of type ''table")
	assert(#list <= 1, "Expected list to be contain 1 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInstancePatchStateFilterValue(v)
	end
end

--  
-- List of InstancePatchStateFilterValue objects
function M.InstancePatchStateFilterValues(list)
	asserts.AssertInstancePatchStateFilterValues(list)
	return list
end

function asserts.AssertInstanceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdList to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	for _,v in ipairs(list) do
		asserts.AssertInstanceId(v)
	end
end

--  
-- List of InstanceId objects
function M.InstanceIdList(list)
	asserts.AssertInstanceIdList(list)
	return list
end

function asserts.AssertDocumentIdentifierList(list)
	assert(list)
	assert(type(list) == "table", "Expected DocumentIdentifierList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDocumentIdentifier(v)
	end
end

--  
-- List of DocumentIdentifier objects
function M.DocumentIdentifierList(list)
	asserts.AssertDocumentIdentifierList(list)
	return list
end

function asserts.AssertParameterStringFilterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterStringFilterValueList to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertParameterStringFilterValue(v)
	end
end

--  
-- List of ParameterStringFilterValue objects
function M.ParameterStringFilterValueList(list)
	asserts.AssertParameterStringFilterValueList(list)
	return list
end

function asserts.AssertPatchList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPatch(v)
	end
end

--  
-- List of Patch objects
function M.PatchList(list)
	asserts.AssertPatchList(list)
	return list
end

function asserts.AssertActivationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ActivationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertActivation(v)
	end
end

--  
-- List of Activation objects
function M.ActivationList(list)
	asserts.AssertActivationList(list)
	return list
end

function asserts.AssertAssociationDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAssociationDescription(v)
	end
end

--  
-- List of AssociationDescription objects
function M.AssociationDescriptionList(list)
	asserts.AssertAssociationDescriptionList(list)
	return list
end

function asserts.AssertInventoryGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryGroupList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInventoryGroup(v)
	end
end

--  
-- List of InventoryGroup objects
function M.InventoryGroupList(list)
	asserts.AssertInventoryGroupList(list)
	return list
end

function asserts.AssertInstanceInformationStringFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceInformationStringFilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceInformationStringFilter(v)
	end
end

--  
-- List of InstanceInformationStringFilter objects
function M.InstanceInformationStringFilterList(list)
	asserts.AssertInstanceInformationStringFilterList(list)
	return list
end

function asserts.AssertInventoryItemEntryList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryItemEntryList to be of type ''table")
	assert(#list <= 10000, "Expected list to be contain 10000 elements")
	for _,v in ipairs(list) do
		asserts.AssertInventoryItemEntry(v)
	end
end

--  
-- List of InventoryItemEntry objects
function M.InventoryItemEntryList(list)
	asserts.AssertInventoryItemEntryList(list)
	return list
end

function asserts.AssertStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected StringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.StringList(list)
	asserts.AssertStringList(list)
	return list
end

function asserts.AssertPatchGroupPatchBaselineMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchGroupPatchBaselineMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPatchGroupPatchBaselineMapping(v)
	end
end

--  
-- List of PatchGroupPatchBaselineMapping objects
function M.PatchGroupPatchBaselineMappingList(list)
	asserts.AssertPatchGroupPatchBaselineMappingList(list)
	return list
end

function asserts.AssertComplianceItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected ComplianceItemList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertComplianceItem(v)
	end
end

--  
-- List of ComplianceItem objects
function M.ComplianceItemList(list)
	asserts.AssertComplianceItemList(list)
	return list
end

function asserts.AssertCreateAssociationBatchRequestEntries(list)
	assert(list)
	assert(type(list) == "table", "Expected CreateAssociationBatchRequestEntries to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertCreateAssociationBatchRequestEntry(v)
	end
end

--  
-- List of CreateAssociationBatchRequestEntry objects
function M.CreateAssociationBatchRequestEntries(list)
	asserts.AssertCreateAssociationBatchRequestEntries(list)
	return list
end

function asserts.AssertNotificationEventList(list)
	assert(list)
	assert(type(list) == "table", "Expected NotificationEventList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNotificationEvent(v)
	end
end

--  
-- List of NotificationEvent objects
function M.NotificationEventList(list)
	asserts.AssertNotificationEventList(list)
	return list
end

function asserts.AssertDocumentKeyValuesFilterValues(list)
	assert(list)
	assert(type(list) == "table", "Expected DocumentKeyValuesFilterValues to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDocumentKeyValuesFilterValue(v)
	end
end

--  
-- List of DocumentKeyValuesFilterValue objects
function M.DocumentKeyValuesFilterValues(list)
	asserts.AssertDocumentKeyValuesFilterValues(list)
	return list
end

function asserts.AssertComplianceStringFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected ComplianceStringFilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertComplianceStringFilter(v)
	end
end

--  
-- List of ComplianceStringFilter objects
function M.ComplianceStringFilterList(list)
	asserts.AssertComplianceStringFilterList(list)
	return list
end

function asserts.AssertTargetMapValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetMapValueList to be of type ''table")
	assert(#list <= 25, "Expected list to be contain 25 elements")
	for _,v in ipairs(list) do
		asserts.AssertTargetMapValue(v)
	end
end

--  
-- List of TargetMapValue objects
function M.TargetMapValueList(list)
	asserts.AssertTargetMapValueList(list)
	return list
end

function asserts.AssertStepExecutionFilterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected StepExecutionFilterValueList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertStepExecutionFilterValue(v)
	end
end

--  
-- List of StepExecutionFilterValue objects
function M.StepExecutionFilterValueList(list)
	asserts.AssertStepExecutionFilterValueList(list)
	return list
end

function asserts.AssertDocumentVersionList(list)
	assert(list)
	assert(type(list) == "table", "Expected DocumentVersionList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertDocumentVersionInfo(v)
	end
end

--  
-- List of DocumentVersionInfo objects
function M.DocumentVersionList(list)
	asserts.AssertDocumentVersionList(list)
	return list
end

function asserts.AssertMaintenanceWindowTargetList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowTargetList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowTarget(v)
	end
end

--  
-- List of MaintenanceWindowTarget objects
function M.MaintenanceWindowTargetList(list)
	asserts.AssertMaintenanceWindowTargetList(list)
	return list
end

function asserts.AssertStepExecutionFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected StepExecutionFilterList to be of type ''table")
	assert(#list <= 6, "Expected list to be contain 6 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertStepExecutionFilter(v)
	end
end

--  
-- List of StepExecutionFilter objects
function M.StepExecutionFilterList(list)
	asserts.AssertStepExecutionFilterList(list)
	return list
end

function asserts.AssertMaintenanceWindowFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowFilterList to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowFilter(v)
	end
end

--  
-- List of MaintenanceWindowFilter objects
function M.MaintenanceWindowFilterList(list)
	asserts.AssertMaintenanceWindowFilterList(list)
	return list
end

function asserts.AssertMaintenanceWindowFilterValues(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowFilterValues to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowFilterValue(v)
	end
end

--  
-- List of MaintenanceWindowFilterValue objects
function M.MaintenanceWindowFilterValues(list)
	asserts.AssertMaintenanceWindowFilterValues(list)
	return list
end

function asserts.AssertMaintenanceWindowExecutionTaskInvocationIdentityList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowExecutionTaskInvocationIdentityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowExecutionTaskInvocationIdentity(v)
	end
end

--  
-- List of MaintenanceWindowExecutionTaskInvocationIdentity objects
function M.MaintenanceWindowExecutionTaskInvocationIdentityList(list)
	asserts.AssertMaintenanceWindowExecutionTaskInvocationIdentityList(list)
	return list
end

function asserts.AssertPatchBaselineIdentityList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchBaselineIdentityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPatchBaselineIdentity(v)
	end
end

--  
-- List of PatchBaselineIdentity objects
function M.PatchBaselineIdentityList(list)
	asserts.AssertPatchBaselineIdentityList(list)
	return list
end

function asserts.AssertInventoryFilterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryFilterValueList to be of type ''table")
	assert(#list <= 40, "Expected list to be contain 40 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInventoryFilterValue(v)
	end
end

--  
-- List of InventoryFilterValue objects
function M.InventoryFilterValueList(list)
	asserts.AssertInventoryFilterValueList(list)
	return list
end

function asserts.AssertTagList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTag(v)
	end
end

--  
-- List of Tag objects
function M.TagList(list)
	asserts.AssertTagList(list)
	return list
end

function asserts.AssertInventoryAggregatorList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryAggregatorList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInventoryAggregator(v)
	end
end

--  
-- List of InventoryAggregator objects
function M.InventoryAggregatorList(list)
	asserts.AssertInventoryAggregatorList(list)
	return list
end

function asserts.AssertCommandFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected CommandFilterList to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertCommandFilter(v)
	end
end

--  
-- List of CommandFilter objects
function M.CommandFilterList(list)
	asserts.AssertCommandFilterList(list)
	return list
end

function asserts.AssertAssociationFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationFilterList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAssociationFilter(v)
	end
end

--  
-- List of AssociationFilter objects
function M.AssociationFilterList(list)
	asserts.AssertAssociationFilterList(list)
	return list
end

function asserts.AssertComplianceItemEntryList(list)
	assert(list)
	assert(type(list) == "table", "Expected ComplianceItemEntryList to be of type ''table")
	assert(#list <= 10000, "Expected list to be contain 10000 elements")
	for _,v in ipairs(list) do
		asserts.AssertComplianceItemEntry(v)
	end
end

--  
-- List of ComplianceItemEntry objects
function M.ComplianceItemEntryList(list)
	asserts.AssertComplianceItemEntryList(list)
	return list
end

function asserts.AssertAutomationExecutionMetadataList(list)
	assert(list)
	assert(type(list) == "table", "Expected AutomationExecutionMetadataList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAutomationExecutionMetadata(v)
	end
end

--  
-- List of AutomationExecutionMetadata objects
function M.AutomationExecutionMetadataList(list)
	asserts.AssertAutomationExecutionMetadataList(list)
	return list
end

function asserts.AssertPatchComplianceDataList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchComplianceDataList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPatchComplianceData(v)
	end
end

--  
-- List of PatchComplianceData objects
function M.PatchComplianceDataList(list)
	asserts.AssertPatchComplianceDataList(list)
	return list
end

function asserts.AssertAssociationExecutionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationExecutionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAssociationExecution(v)
	end
end

--  
-- List of AssociationExecution objects
function M.AssociationExecutionsList(list)
	asserts.AssertAssociationExecutionsList(list)
	return list
end

function asserts.AssertParametersFilterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParametersFilterValueList to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertParametersFilterValue(v)
	end
end

--  
-- List of ParametersFilterValue objects
function M.ParametersFilterValueList(list)
	asserts.AssertParametersFilterValueList(list)
	return list
end

function asserts.AssertMaintenanceWindowExecutionTaskIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowExecutionTaskIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowExecutionTaskId(v)
	end
end

--  
-- List of MaintenanceWindowExecutionTaskId objects
function M.MaintenanceWindowExecutionTaskIdList(list)
	asserts.AssertMaintenanceWindowExecutionTaskIdList(list)
	return list
end

function asserts.AssertComplianceSummaryItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected ComplianceSummaryItemList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertComplianceSummaryItem(v)
	end
end

--  
-- List of ComplianceSummaryItem objects
function M.ComplianceSummaryItemList(list)
	asserts.AssertComplianceSummaryItemList(list)
	return list
end

function asserts.AssertAssociationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationIdList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAssociationId(v)
	end
end

--  
-- List of AssociationId objects
function M.AssociationIdList(list)
	asserts.AssertAssociationIdList(list)
	return list
end

function asserts.AssertStepExecutionList(list)
	assert(list)
	assert(type(list) == "table", "Expected StepExecutionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStepExecution(v)
	end
end

--  
-- List of StepExecution objects
function M.StepExecutionList(list)
	asserts.AssertStepExecutionList(list)
	return list
end

function asserts.AssertPatchIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchIdList to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	for _,v in ipairs(list) do
		asserts.AssertPatchId(v)
	end
end

--  
-- List of PatchId objects
function M.PatchIdList(list)
	asserts.AssertPatchIdList(list)
	return list
end

function asserts.AssertComplianceResourceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ComplianceResourceIdList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertComplianceResourceId(v)
	end
end

--  
-- List of ComplianceResourceId objects
function M.ComplianceResourceIdList(list)
	asserts.AssertComplianceResourceIdList(list)
	return list
end

function asserts.AssertFailedCreateAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected FailedCreateAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFailedCreateAssociation(v)
	end
end

--  
-- List of FailedCreateAssociation objects
function M.FailedCreateAssociationList(list)
	asserts.AssertFailedCreateAssociationList(list)
	return list
end

function asserts.AssertTargets(list)
	assert(list)
	assert(type(list) == "table", "Expected Targets to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	for _,v in ipairs(list) do
		asserts.AssertTarget(v)
	end
end

--  
-- List of Target objects
function M.Targets(list)
	asserts.AssertTargets(list)
	return list
end

function asserts.AssertDocumentKeyValuesFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected DocumentKeyValuesFilterList to be of type ''table")
	assert(#list <= 6, "Expected list to be contain 6 elements")
	for _,v in ipairs(list) do
		asserts.AssertDocumentKeyValuesFilter(v)
	end
end

--  
-- List of DocumentKeyValuesFilter objects
function M.DocumentKeyValuesFilterList(list)
	asserts.AssertDocumentKeyValuesFilterList(list)
	return list
end

function asserts.AssertMaintenanceWindowTaskParameterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowTaskParameterValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowTaskParameterValue(v)
	end
end

--  
-- List of MaintenanceWindowTaskParameterValue objects
function M.MaintenanceWindowTaskParameterValueList(list)
	asserts.AssertMaintenanceWindowTaskParameterValueList(list)
	return list
end

function asserts.AssertParameterMetadataList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterMetadataList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertParameterMetadata(v)
	end
end

--  
-- List of ParameterMetadata objects
function M.ParameterMetadataList(list)
	asserts.AssertParameterMetadataList(list)
	return list
end

function asserts.AssertInstancePatchStatesList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePatchStatesList to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInstancePatchState(v)
	end
end

--  
-- List of InstancePatchState objects
function M.InstancePatchStatesList(list)
	asserts.AssertInstancePatchStatesList(list)
	return list
end

function asserts.AssertInventoryDeletionSummaryItems(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryDeletionSummaryItems to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInventoryDeletionSummaryItem(v)
	end
end

--  
-- List of InventoryDeletionSummaryItem objects
function M.InventoryDeletionSummaryItems(list)
	asserts.AssertInventoryDeletionSummaryItems(list)
	return list
end

function asserts.AssertInventoryDeletionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryDeletionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInventoryDeletionStatusItem(v)
	end
end

--  
-- List of InventoryDeletionStatusItem objects
function M.InventoryDeletionsList(list)
	asserts.AssertInventoryDeletionsList(list)
	return list
end

function asserts.AssertPatchSourceList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchSourceList to be of type ''table")
	assert(#list <= 20, "Expected list to be contain 20 elements")
	for _,v in ipairs(list) do
		asserts.AssertPatchSource(v)
	end
end

--  
-- List of PatchSource objects
function M.PatchSourceList(list)
	asserts.AssertPatchSourceList(list)
	return list
end

function asserts.AssertMaintenanceWindowsForTargetList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowsForTargetList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowIdentityForTarget(v)
	end
end

--  
-- List of MaintenanceWindowIdentityForTarget objects
function M.MaintenanceWindowsForTargetList(list)
	asserts.AssertMaintenanceWindowsForTargetList(list)
	return list
end

function asserts.AssertResultAttributeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResultAttributeList to be of type ''table")
	assert(#list <= 1, "Expected list to be contain 1 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertResultAttribute(v)
	end
end

--  
-- List of ResultAttribute objects
function M.ResultAttributeList(list)
	asserts.AssertResultAttributeList(list)
	return list
end

function asserts.AssertInventoryItemSchemaResultList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryItemSchemaResultList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInventoryItemSchema(v)
	end
end

--  
-- List of InventoryItemSchema objects
function M.InventoryItemSchemaResultList(list)
	asserts.AssertInventoryItemSchemaResultList(list)
	return list
end

function asserts.AssertPlatformTypeList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlatformTypeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPlatformType(v)
	end
end

--  
-- List of PlatformType objects
function M.PlatformTypeList(list)
	asserts.AssertPlatformTypeList(list)
	return list
end

function asserts.AssertAssociationExecutionFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationExecutionFilterList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAssociationExecutionFilter(v)
	end
end

--  
-- List of AssociationExecutionFilter objects
function M.AssociationExecutionFilterList(list)
	asserts.AssertAssociationExecutionFilterList(list)
	return list
end

function asserts.AssertInstanceAssociationStatusInfos(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceAssociationStatusInfos to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceAssociationStatusInfo(v)
	end
end

--  
-- List of InstanceAssociationStatusInfo objects
function M.InstanceAssociationStatusInfos(list)
	asserts.AssertInstanceAssociationStatusInfos(list)
	return list
end

function asserts.AssertValidNextStepList(list)
	assert(list)
	assert(type(list) == "table", "Expected ValidNextStepList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertValidNextStep(v)
	end
end

--  
-- List of ValidNextStep objects
function M.ValidNextStepList(list)
	asserts.AssertValidNextStepList(list)
	return list
end

function asserts.AssertScheduledWindowExecutionList(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledWindowExecutionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledWindowExecution(v)
	end
end

--  
-- List of ScheduledWindowExecution objects
function M.ScheduledWindowExecutionList(list)
	asserts.AssertScheduledWindowExecutionList(list)
	return list
end

function asserts.AssertInstancePatchStateList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePatchStateList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstancePatchState(v)
	end
end

--  
-- List of InstancePatchState objects
function M.InstancePatchStateList(list)
	asserts.AssertInstancePatchStateList(list)
	return list
end

function asserts.AssertMaintenanceWindowExecutionList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowExecutionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowExecution(v)
	end
end

--  
-- List of MaintenanceWindowExecution objects
function M.MaintenanceWindowExecutionList(list)
	asserts.AssertMaintenanceWindowExecutionList(list)
	return list
end

function asserts.AssertInstanceInformationFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceInformationFilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceInformationFilter(v)
	end
end

--  
-- List of InstanceInformationFilter objects
function M.InstanceInformationFilterList(list)
	asserts.AssertInstanceInformationFilterList(list)
	return list
end

function asserts.AssertCommandList(list)
	assert(list)
	assert(type(list) == "table", "Expected CommandList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCommand(v)
	end
end

--  
-- List of Command objects
function M.CommandList(list)
	asserts.AssertCommandList(list)
	return list
end

function asserts.AssertParameterLabelList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterLabelList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertParameterLabel(v)
	end
end

--  
-- List of ParameterLabel objects
function M.ParameterLabelList(list)
	asserts.AssertParameterLabelList(list)
	return list
end

function asserts.AssertAutomationExecutionFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected AutomationExecutionFilterList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAutomationExecutionFilter(v)
	end
end

--  
-- List of AutomationExecutionFilter objects
function M.AutomationExecutionFilterList(list)
	asserts.AssertAutomationExecutionFilterList(list)
	return list
end

function asserts.AssertMaintenanceWindowTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowTask(v)
	end
end

--  
-- List of MaintenanceWindowTask objects
function M.MaintenanceWindowTaskList(list)
	asserts.AssertMaintenanceWindowTaskList(list)
	return list
end

function asserts.AssertPatchSourceProductList(list)
	assert(list)
	assert(type(list) == "table", "Expected PatchSourceProductList to be of type ''table")
	assert(#list <= 20, "Expected list to be contain 20 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertPatchSourceProduct(v)
	end
end

--  
-- List of PatchSourceProduct objects
function M.PatchSourceProductList(list)
	asserts.AssertPatchSourceProductList(list)
	return list
end

function asserts.AssertResourceComplianceSummaryItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResourceComplianceSummaryItemList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertResourceComplianceSummaryItem(v)
	end
end

--  
-- List of ResourceComplianceSummaryItem objects
function M.ResourceComplianceSummaryItemList(list)
	asserts.AssertResourceComplianceSummaryItemList(list)
	return list
end

function asserts.AssertCommandPluginList(list)
	assert(list)
	assert(type(list) == "table", "Expected CommandPluginList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCommandPlugin(v)
	end
end

--  
-- List of CommandPlugin objects
function M.CommandPluginList(list)
	asserts.AssertCommandPluginList(list)
	return list
end

function asserts.AssertSessionManagerParameterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected SessionManagerParameterValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSessionManagerParameterValue(v)
	end
end

--  
-- List of SessionManagerParameterValue objects
function M.SessionManagerParameterValueList(list)
	asserts.AssertSessionManagerParameterValueList(list)
	return list
end

function asserts.AssertKeyList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTagKey(v)
	end
end

--  
-- List of TagKey objects
function M.KeyList(list)
	asserts.AssertKeyList(list)
	return list
end

function asserts.AssertMaintenanceWindowTaskParametersList(list)
	assert(list)
	assert(type(list) == "table", "Expected MaintenanceWindowTaskParametersList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMaintenanceWindowTaskParameters(v)
	end
end

--  
-- List of MaintenanceWindowTaskParameters objects
function M.MaintenanceWindowTaskParametersList(list)
	asserts.AssertMaintenanceWindowTaskParametersList(list)
	return list
end

function asserts.AssertInstancePatchStateFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePatchStateFilterList to be of type ''table")
	assert(#list <= 4, "Expected list to be contain 4 elements")
	for _,v in ipairs(list) do
		asserts.AssertInstancePatchStateFilter(v)
	end
end

--  
-- List of InstancePatchStateFilter objects
function M.InstancePatchStateFilterList(list)
	asserts.AssertInstancePatchStateFilterList(list)
	return list
end

function asserts.AssertTargetValues(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetValues to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	for _,v in ipairs(list) do
		asserts.AssertTargetValue(v)
	end
end

--  
-- List of TargetValue objects
function M.TargetValues(list)
	asserts.AssertTargetValues(list)
	return list
end

function asserts.AssertParameterNameList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterNameList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertPSParameterName(v)
	end
end

--  
-- List of PSParameterName objects
function M.ParameterNameList(list)
	asserts.AssertParameterNameList(list)
	return list
end

function asserts.AssertParameterList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertParameter(v)
	end
end

--  
-- List of Parameter objects
function M.ParameterList(list)
	asserts.AssertParameterList(list)
	return list
end

function asserts.AssertParameterHistoryList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterHistoryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertParameterHistory(v)
	end
end

--  
-- List of ParameterHistory objects
function M.ParameterHistoryList(list)
	asserts.AssertParameterHistoryList(list)
	return list
end

function asserts.AssertCommandInvocationList(list)
	assert(list)
	assert(type(list) == "table", "Expected CommandInvocationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCommandInvocation(v)
	end
end

--  
-- List of CommandInvocation objects
function M.CommandInvocationList(list)
	asserts.AssertCommandInvocationList(list)
	return list
end

function asserts.AssertTargetParameterList(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetParameterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertParameterValue(v)
	end
end

--  
-- List of ParameterValue objects
function M.TargetParameterList(list)
	asserts.AssertTargetParameterList(list)
	return list
end

function asserts.AssertInventoryItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryItemList to be of type ''table")
	assert(#list <= 30, "Expected list to be contain 30 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInventoryItem(v)
	end
end

--  
-- List of InventoryItem objects
function M.InventoryItemList(list)
	asserts.AssertInventoryItemList(list)
	return list
end

function asserts.AssertParameterValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected ParameterValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertParameterValue(v)
	end
end

--  
-- List of ParameterValue objects
function M.ParameterValueList(list)
	asserts.AssertParameterValueList(list)
	return list
end

function asserts.AssertInventoryFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected InventoryFilterList to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertInventoryFilter(v)
	end
end

--  
-- List of InventoryFilter objects
function M.InventoryFilterList(list)
	asserts.AssertInventoryFilterList(list)
	return list
end

function asserts.AssertAssociationVersionList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationVersionList to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAssociationVersionInfo(v)
	end
end

--  
-- List of AssociationVersionInfo objects
function M.AssociationVersionList(list)
	asserts.AssertAssociationVersionList(list)
	return list
end

function asserts.AssertAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAssociation(v)
	end
end

--  
-- List of Association objects
function M.AssociationList(list)
	asserts.AssertAssociationList(list)
	return list
end


local content_type = require "aws-sdk.core.content_type"
local request_headers = require "aws-sdk.core.request_headers"
local request_handlers = require "aws-sdk.core.request_handlers"

local settings = {}


local function endpoint_for_region(region, use_dualstack)
	if not use_dualstack then
		if region == "us-east-1" then
			return "ssm.amazonaws.com"
		end
	end
	local ss = { "ssm" }
	if use_dualstack then
		ss[#ss + 1] = "dualstack"
	end
	ss[#ss + 1] = region
	ss[#ss + 1] = "amazonaws.com"
	if region == "cn-north-1" then
		ss[#ss + 1] = "cn"
	end
	return table.concat(ss, ".")
end


function M.init(config)
	assert(config, "You must provide a config table")
	assert(config.region, "You must provide a region in the config table")

	settings.service = M.metadata.endpoint_prefix
	settings.protocol = M.metadata.protocol
	settings.region = config.region
	settings.endpoint = config.endpoint_override or endpoint_for_region(config.region, config.use_dualstack)
	settings.signature_version = M.metadata.signature_version
	settings.uri = (config.scheme or "https") .. "://" .. settings.endpoint
end


--
-- OPERATIONS
--
--- Call DescribeInventoryDeletions asynchronously, invoking a callback when done
-- @param DescribeInventoryDeletionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInventoryDeletionsAsync(DescribeInventoryDeletionsRequest, cb)
	assert(DescribeInventoryDeletionsRequest, "You must provide a DescribeInventoryDeletionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeInventoryDeletions",
	}
	for header,value in pairs(DescribeInventoryDeletionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInventoryDeletionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInventoryDeletions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInventoryDeletionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInventoryDeletionsSync(DescribeInventoryDeletionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInventoryDeletionsAsync(DescribeInventoryDeletionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetPatchBaselineForPatchGroup asynchronously, invoking a callback when done
-- @param GetPatchBaselineForPatchGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetPatchBaselineForPatchGroupAsync(GetPatchBaselineForPatchGroupRequest, cb)
	assert(GetPatchBaselineForPatchGroupRequest, "You must provide a GetPatchBaselineForPatchGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetPatchBaselineForPatchGroup",
	}
	for header,value in pairs(GetPatchBaselineForPatchGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetPatchBaselineForPatchGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetPatchBaselineForPatchGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetPatchBaselineForPatchGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetPatchBaselineForPatchGroupSync(GetPatchBaselineForPatchGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetPatchBaselineForPatchGroupAsync(GetPatchBaselineForPatchGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAssociation asynchronously, invoking a callback when done
-- @param DescribeAssociationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAssociationAsync(DescribeAssociationRequest, cb)
	assert(DescribeAssociationRequest, "You must provide a DescribeAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeAssociation",
	}
	for header,value in pairs(DescribeAssociationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAssociationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAssociationSync(DescribeAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAssociationAsync(DescribeAssociationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAssociationExecutionTargets asynchronously, invoking a callback when done
-- @param DescribeAssociationExecutionTargetsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAssociationExecutionTargetsAsync(DescribeAssociationExecutionTargetsRequest, cb)
	assert(DescribeAssociationExecutionTargetsRequest, "You must provide a DescribeAssociationExecutionTargetsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeAssociationExecutionTargets",
	}
	for header,value in pairs(DescribeAssociationExecutionTargetsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAssociationExecutionTargetsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAssociationExecutionTargets synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAssociationExecutionTargetsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAssociationExecutionTargetsSync(DescribeAssociationExecutionTargetsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAssociationExecutionTargetsAsync(DescribeAssociationExecutionTargetsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstancePatchStatesForPatchGroup asynchronously, invoking a callback when done
-- @param DescribeInstancePatchStatesForPatchGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstancePatchStatesForPatchGroupAsync(DescribeInstancePatchStatesForPatchGroupRequest, cb)
	assert(DescribeInstancePatchStatesForPatchGroupRequest, "You must provide a DescribeInstancePatchStatesForPatchGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeInstancePatchStatesForPatchGroup",
	}
	for header,value in pairs(DescribeInstancePatchStatesForPatchGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstancePatchStatesForPatchGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstancePatchStatesForPatchGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstancePatchStatesForPatchGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstancePatchStatesForPatchGroupSync(DescribeInstancePatchStatesForPatchGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstancePatchStatesForPatchGroupAsync(DescribeInstancePatchStatesForPatchGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetDefaultPatchBaseline asynchronously, invoking a callback when done
-- @param GetDefaultPatchBaselineRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetDefaultPatchBaselineAsync(GetDefaultPatchBaselineRequest, cb)
	assert(GetDefaultPatchBaselineRequest, "You must provide a GetDefaultPatchBaselineRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetDefaultPatchBaseline",
	}
	for header,value in pairs(GetDefaultPatchBaselineRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetDefaultPatchBaselineRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetDefaultPatchBaseline synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetDefaultPatchBaselineRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetDefaultPatchBaselineSync(GetDefaultPatchBaselineRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetDefaultPatchBaselineAsync(GetDefaultPatchBaselineRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetDocument asynchronously, invoking a callback when done
-- @param GetDocumentRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetDocumentAsync(GetDocumentRequest, cb)
	assert(GetDocumentRequest, "You must provide a GetDocumentRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetDocument",
	}
	for header,value in pairs(GetDocumentRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetDocumentRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetDocument synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetDocumentRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetDocumentSync(GetDocumentRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetDocumentAsync(GetDocumentRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateDocument asynchronously, invoking a callback when done
-- @param CreateDocumentRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateDocumentAsync(CreateDocumentRequest, cb)
	assert(CreateDocumentRequest, "You must provide a CreateDocumentRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CreateDocument",
	}
	for header,value in pairs(CreateDocumentRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateDocumentRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateDocument synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateDocumentRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateDocumentSync(CreateDocumentRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateDocumentAsync(CreateDocumentRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteAssociation asynchronously, invoking a callback when done
-- @param DeleteAssociationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteAssociationAsync(DeleteAssociationRequest, cb)
	assert(DeleteAssociationRequest, "You must provide a DeleteAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteAssociation",
	}
	for header,value in pairs(DeleteAssociationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteAssociationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteAssociationSync(DeleteAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteAssociationAsync(DeleteAssociationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreatePatchBaseline asynchronously, invoking a callback when done
-- @param CreatePatchBaselineRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreatePatchBaselineAsync(CreatePatchBaselineRequest, cb)
	assert(CreatePatchBaselineRequest, "You must provide a CreatePatchBaselineRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CreatePatchBaseline",
	}
	for header,value in pairs(CreatePatchBaselineRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreatePatchBaselineRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreatePatchBaseline synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreatePatchBaselineRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreatePatchBaselineSync(CreatePatchBaselineRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreatePatchBaselineAsync(CreatePatchBaselineRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListResourceComplianceSummaries asynchronously, invoking a callback when done
-- @param ListResourceComplianceSummariesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListResourceComplianceSummariesAsync(ListResourceComplianceSummariesRequest, cb)
	assert(ListResourceComplianceSummariesRequest, "You must provide a ListResourceComplianceSummariesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListResourceComplianceSummaries",
	}
	for header,value in pairs(ListResourceComplianceSummariesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListResourceComplianceSummariesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListResourceComplianceSummaries synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListResourceComplianceSummariesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListResourceComplianceSummariesSync(ListResourceComplianceSummariesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListResourceComplianceSummariesAsync(ListResourceComplianceSummariesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeregisterTargetFromMaintenanceWindow asynchronously, invoking a callback when done
-- @param DeregisterTargetFromMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeregisterTargetFromMaintenanceWindowAsync(DeregisterTargetFromMaintenanceWindowRequest, cb)
	assert(DeregisterTargetFromMaintenanceWindowRequest, "You must provide a DeregisterTargetFromMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeregisterTargetFromMaintenanceWindow",
	}
	for header,value in pairs(DeregisterTargetFromMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeregisterTargetFromMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeregisterTargetFromMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeregisterTargetFromMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeregisterTargetFromMaintenanceWindowSync(DeregisterTargetFromMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeregisterTargetFromMaintenanceWindowAsync(DeregisterTargetFromMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call TerminateSession asynchronously, invoking a callback when done
-- @param TerminateSessionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.TerminateSessionAsync(TerminateSessionRequest, cb)
	assert(TerminateSessionRequest, "You must provide a TerminateSessionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.TerminateSession",
	}
	for header,value in pairs(TerminateSessionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", TerminateSessionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call TerminateSession synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param TerminateSessionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.TerminateSessionSync(TerminateSessionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.TerminateSessionAsync(TerminateSessionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListComplianceSummaries asynchronously, invoking a callback when done
-- @param ListComplianceSummariesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListComplianceSummariesAsync(ListComplianceSummariesRequest, cb)
	assert(ListComplianceSummariesRequest, "You must provide a ListComplianceSummariesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListComplianceSummaries",
	}
	for header,value in pairs(ListComplianceSummariesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListComplianceSummariesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListComplianceSummaries synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListComplianceSummariesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListComplianceSummariesSync(ListComplianceSummariesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListComplianceSummariesAsync(ListComplianceSummariesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetParameter asynchronously, invoking a callback when done
-- @param GetParameterRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetParameterAsync(GetParameterRequest, cb)
	assert(GetParameterRequest, "You must provide a GetParameterRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetParameter",
	}
	for header,value in pairs(GetParameterRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetParameterRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetParameter synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetParameterRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetParameterSync(GetParameterRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetParameterAsync(GetParameterRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StartAssociationsOnce asynchronously, invoking a callback when done
-- @param StartAssociationsOnceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StartAssociationsOnceAsync(StartAssociationsOnceRequest, cb)
	assert(StartAssociationsOnceRequest, "You must provide a StartAssociationsOnceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.StartAssociationsOnce",
	}
	for header,value in pairs(StartAssociationsOnceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", StartAssociationsOnceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StartAssociationsOnce synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartAssociationsOnceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StartAssociationsOnceSync(StartAssociationsOnceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartAssociationsOnceAsync(StartAssociationsOnceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindowTasks asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowTasksAsync(DescribeMaintenanceWindowTasksRequest, cb)
	assert(DescribeMaintenanceWindowTasksRequest, "You must provide a DescribeMaintenanceWindowTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindowTasks",
	}
	for header,value in pairs(DescribeMaintenanceWindowTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindowTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowTasksSync(DescribeMaintenanceWindowTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowTasksAsync(DescribeMaintenanceWindowTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetConnectionStatus asynchronously, invoking a callback when done
-- @param GetConnectionStatusRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetConnectionStatusAsync(GetConnectionStatusRequest, cb)
	assert(GetConnectionStatusRequest, "You must provide a GetConnectionStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetConnectionStatus",
	}
	for header,value in pairs(GetConnectionStatusRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetConnectionStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetConnectionStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetConnectionStatusRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetConnectionStatusSync(GetConnectionStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetConnectionStatusAsync(GetConnectionStatusRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateActivation asynchronously, invoking a callback when done
-- @param CreateActivationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateActivationAsync(CreateActivationRequest, cb)
	assert(CreateActivationRequest, "You must provide a CreateActivationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CreateActivation",
	}
	for header,value in pairs(CreateActivationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateActivationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateActivation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateActivationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateActivationSync(CreateActivationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateActivationAsync(CreateActivationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateDocument asynchronously, invoking a callback when done
-- @param UpdateDocumentRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateDocumentAsync(UpdateDocumentRequest, cb)
	assert(UpdateDocumentRequest, "You must provide a UpdateDocumentRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateDocument",
	}
	for header,value in pairs(UpdateDocumentRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateDocumentRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateDocument synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateDocumentRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateDocumentSync(UpdateDocumentRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateDocumentAsync(UpdateDocumentRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeDocumentPermission asynchronously, invoking a callback when done
-- @param DescribeDocumentPermissionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeDocumentPermissionAsync(DescribeDocumentPermissionRequest, cb)
	assert(DescribeDocumentPermissionRequest, "You must provide a DescribeDocumentPermissionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeDocumentPermission",
	}
	for header,value in pairs(DescribeDocumentPermissionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeDocumentPermissionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeDocumentPermission synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeDocumentPermissionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeDocumentPermissionSync(DescribeDocumentPermissionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeDocumentPermissionAsync(DescribeDocumentPermissionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListCommandInvocations asynchronously, invoking a callback when done
-- @param ListCommandInvocationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListCommandInvocationsAsync(ListCommandInvocationsRequest, cb)
	assert(ListCommandInvocationsRequest, "You must provide a ListCommandInvocationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListCommandInvocations",
	}
	for header,value in pairs(ListCommandInvocationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListCommandInvocationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListCommandInvocations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListCommandInvocationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListCommandInvocationsSync(ListCommandInvocationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListCommandInvocationsAsync(ListCommandInvocationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateMaintenanceWindowTarget asynchronously, invoking a callback when done
-- @param UpdateMaintenanceWindowTargetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateMaintenanceWindowTargetAsync(UpdateMaintenanceWindowTargetRequest, cb)
	assert(UpdateMaintenanceWindowTargetRequest, "You must provide a UpdateMaintenanceWindowTargetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateMaintenanceWindowTarget",
	}
	for header,value in pairs(UpdateMaintenanceWindowTargetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateMaintenanceWindowTargetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateMaintenanceWindowTarget synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateMaintenanceWindowTargetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateMaintenanceWindowTargetSync(UpdateMaintenanceWindowTargetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateMaintenanceWindowTargetAsync(UpdateMaintenanceWindowTargetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteDocument asynchronously, invoking a callback when done
-- @param DeleteDocumentRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteDocumentAsync(DeleteDocumentRequest, cb)
	assert(DeleteDocumentRequest, "You must provide a DeleteDocumentRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteDocument",
	}
	for header,value in pairs(DeleteDocumentRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteDocumentRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteDocument synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteDocumentRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteDocumentSync(DeleteDocumentRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteDocumentAsync(DeleteDocumentRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindowExecutions asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowExecutionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowExecutionsAsync(DescribeMaintenanceWindowExecutionsRequest, cb)
	assert(DescribeMaintenanceWindowExecutionsRequest, "You must provide a DescribeMaintenanceWindowExecutionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindowExecutions",
	}
	for header,value in pairs(DescribeMaintenanceWindowExecutionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowExecutionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindowExecutions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowExecutionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowExecutionsSync(DescribeMaintenanceWindowExecutionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowExecutionsAsync(DescribeMaintenanceWindowExecutionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindowSchedule asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowScheduleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowScheduleAsync(DescribeMaintenanceWindowScheduleRequest, cb)
	assert(DescribeMaintenanceWindowScheduleRequest, "You must provide a DescribeMaintenanceWindowScheduleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindowSchedule",
	}
	for header,value in pairs(DescribeMaintenanceWindowScheduleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowScheduleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindowSchedule synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowScheduleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowScheduleSync(DescribeMaintenanceWindowScheduleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowScheduleAsync(DescribeMaintenanceWindowScheduleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListInventoryEntries asynchronously, invoking a callback when done
-- @param ListInventoryEntriesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListInventoryEntriesAsync(ListInventoryEntriesRequest, cb)
	assert(ListInventoryEntriesRequest, "You must provide a ListInventoryEntriesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListInventoryEntries",
	}
	for header,value in pairs(ListInventoryEntriesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListInventoryEntriesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListInventoryEntries synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListInventoryEntriesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListInventoryEntriesSync(ListInventoryEntriesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListInventoryEntriesAsync(ListInventoryEntriesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeregisterPatchBaselineForPatchGroup asynchronously, invoking a callback when done
-- @param DeregisterPatchBaselineForPatchGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeregisterPatchBaselineForPatchGroupAsync(DeregisterPatchBaselineForPatchGroupRequest, cb)
	assert(DeregisterPatchBaselineForPatchGroupRequest, "You must provide a DeregisterPatchBaselineForPatchGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeregisterPatchBaselineForPatchGroup",
	}
	for header,value in pairs(DeregisterPatchBaselineForPatchGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeregisterPatchBaselineForPatchGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeregisterPatchBaselineForPatchGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeregisterPatchBaselineForPatchGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeregisterPatchBaselineForPatchGroupSync(DeregisterPatchBaselineForPatchGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeregisterPatchBaselineForPatchGroupAsync(DeregisterPatchBaselineForPatchGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListTagsForResource asynchronously, invoking a callback when done
-- @param ListTagsForResourceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListTagsForResourceAsync(ListTagsForResourceRequest, cb)
	assert(ListTagsForResourceRequest, "You must provide a ListTagsForResourceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListTagsForResource",
	}
	for header,value in pairs(ListTagsForResourceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListTagsForResourceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListTagsForResource synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListTagsForResourceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListTagsForResourceSync(ListTagsForResourceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListTagsForResourceAsync(ListTagsForResourceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StartAutomationExecution asynchronously, invoking a callback when done
-- @param StartAutomationExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StartAutomationExecutionAsync(StartAutomationExecutionRequest, cb)
	assert(StartAutomationExecutionRequest, "You must provide a StartAutomationExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.StartAutomationExecution",
	}
	for header,value in pairs(StartAutomationExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", StartAutomationExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StartAutomationExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartAutomationExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StartAutomationExecutionSync(StartAutomationExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartAutomationExecutionAsync(StartAutomationExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetDeployablePatchSnapshotForInstance asynchronously, invoking a callback when done
-- @param GetDeployablePatchSnapshotForInstanceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetDeployablePatchSnapshotForInstanceAsync(GetDeployablePatchSnapshotForInstanceRequest, cb)
	assert(GetDeployablePatchSnapshotForInstanceRequest, "You must provide a GetDeployablePatchSnapshotForInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetDeployablePatchSnapshotForInstance",
	}
	for header,value in pairs(GetDeployablePatchSnapshotForInstanceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetDeployablePatchSnapshotForInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetDeployablePatchSnapshotForInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetDeployablePatchSnapshotForInstanceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetDeployablePatchSnapshotForInstanceSync(GetDeployablePatchSnapshotForInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetDeployablePatchSnapshotForInstanceAsync(GetDeployablePatchSnapshotForInstanceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SendAutomationSignal asynchronously, invoking a callback when done
-- @param SendAutomationSignalRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SendAutomationSignalAsync(SendAutomationSignalRequest, cb)
	assert(SendAutomationSignalRequest, "You must provide a SendAutomationSignalRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.SendAutomationSignal",
	}
	for header,value in pairs(SendAutomationSignalRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", SendAutomationSignalRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SendAutomationSignal synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SendAutomationSignalRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SendAutomationSignalSync(SendAutomationSignalRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SendAutomationSignalAsync(SendAutomationSignalRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterDefaultPatchBaseline asynchronously, invoking a callback when done
-- @param RegisterDefaultPatchBaselineRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterDefaultPatchBaselineAsync(RegisterDefaultPatchBaselineRequest, cb)
	assert(RegisterDefaultPatchBaselineRequest, "You must provide a RegisterDefaultPatchBaselineRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.RegisterDefaultPatchBaseline",
	}
	for header,value in pairs(RegisterDefaultPatchBaselineRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RegisterDefaultPatchBaselineRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterDefaultPatchBaseline synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterDefaultPatchBaselineRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterDefaultPatchBaselineSync(RegisterDefaultPatchBaselineRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterDefaultPatchBaselineAsync(RegisterDefaultPatchBaselineRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetParametersByPath asynchronously, invoking a callback when done
-- @param GetParametersByPathRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetParametersByPathAsync(GetParametersByPathRequest, cb)
	assert(GetParametersByPathRequest, "You must provide a GetParametersByPathRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetParametersByPath",
	}
	for header,value in pairs(GetParametersByPathRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetParametersByPathRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetParametersByPath synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetParametersByPathRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetParametersByPathSync(GetParametersByPathRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetParametersByPathAsync(GetParametersByPathRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateAssociationStatus asynchronously, invoking a callback when done
-- @param UpdateAssociationStatusRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateAssociationStatusAsync(UpdateAssociationStatusRequest, cb)
	assert(UpdateAssociationStatusRequest, "You must provide a UpdateAssociationStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateAssociationStatus",
	}
	for header,value in pairs(UpdateAssociationStatusRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateAssociationStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateAssociationStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateAssociationStatusRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateAssociationStatusSync(UpdateAssociationStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateAssociationStatusAsync(UpdateAssociationStatusRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AddTagsToResource asynchronously, invoking a callback when done
-- @param AddTagsToResourceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AddTagsToResourceAsync(AddTagsToResourceRequest, cb)
	assert(AddTagsToResourceRequest, "You must provide a AddTagsToResourceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.AddTagsToResource",
	}
	for header,value in pairs(AddTagsToResourceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AddTagsToResourceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AddTagsToResource synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AddTagsToResourceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AddTagsToResourceSync(AddTagsToResourceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AddTagsToResourceAsync(AddTagsToResourceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetInventory asynchronously, invoking a callback when done
-- @param GetInventoryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetInventoryAsync(GetInventoryRequest, cb)
	assert(GetInventoryRequest, "You must provide a GetInventoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetInventory",
	}
	for header,value in pairs(GetInventoryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetInventoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetInventory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetInventoryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetInventorySync(GetInventoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetInventoryAsync(GetInventoryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RemoveTagsFromResource asynchronously, invoking a callback when done
-- @param RemoveTagsFromResourceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RemoveTagsFromResourceAsync(RemoveTagsFromResourceRequest, cb)
	assert(RemoveTagsFromResourceRequest, "You must provide a RemoveTagsFromResourceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.RemoveTagsFromResource",
	}
	for header,value in pairs(RemoveTagsFromResourceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RemoveTagsFromResourceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RemoveTagsFromResource synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RemoveTagsFromResourceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RemoveTagsFromResourceSync(RemoveTagsFromResourceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RemoveTagsFromResourceAsync(RemoveTagsFromResourceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceAssociationsStatus asynchronously, invoking a callback when done
-- @param DescribeInstanceAssociationsStatusRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstanceAssociationsStatusAsync(DescribeInstanceAssociationsStatusRequest, cb)
	assert(DescribeInstanceAssociationsStatusRequest, "You must provide a DescribeInstanceAssociationsStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeInstanceAssociationsStatus",
	}
	for header,value in pairs(DescribeInstanceAssociationsStatusRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstanceAssociationsStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceAssociationsStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceAssociationsStatusRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstanceAssociationsStatusSync(DescribeInstanceAssociationsStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceAssociationsStatusAsync(DescribeInstanceAssociationsStatusRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindowsForTarget asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowsForTargetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowsForTargetAsync(DescribeMaintenanceWindowsForTargetRequest, cb)
	assert(DescribeMaintenanceWindowsForTargetRequest, "You must provide a DescribeMaintenanceWindowsForTargetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindowsForTarget",
	}
	for header,value in pairs(DescribeMaintenanceWindowsForTargetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowsForTargetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindowsForTarget synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowsForTargetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowsForTargetSync(DescribeMaintenanceWindowsForTargetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowsForTargetAsync(DescribeMaintenanceWindowsForTargetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetInventorySchema asynchronously, invoking a callback when done
-- @param GetInventorySchemaRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetInventorySchemaAsync(GetInventorySchemaRequest, cb)
	assert(GetInventorySchemaRequest, "You must provide a GetInventorySchemaRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetInventorySchema",
	}
	for header,value in pairs(GetInventorySchemaRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetInventorySchemaRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetInventorySchema synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetInventorySchemaRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetInventorySchemaSync(GetInventorySchemaRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetInventorySchemaAsync(GetInventorySchemaRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call LabelParameterVersion asynchronously, invoking a callback when done
-- @param LabelParameterVersionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.LabelParameterVersionAsync(LabelParameterVersionRequest, cb)
	assert(LabelParameterVersionRequest, "You must provide a LabelParameterVersionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.LabelParameterVersion",
	}
	for header,value in pairs(LabelParameterVersionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", LabelParameterVersionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call LabelParameterVersion synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param LabelParameterVersionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.LabelParameterVersionSync(LabelParameterVersionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.LabelParameterVersionAsync(LabelParameterVersionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeParameters asynchronously, invoking a callback when done
-- @param DescribeParametersRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeParametersAsync(DescribeParametersRequest, cb)
	assert(DescribeParametersRequest, "You must provide a DescribeParametersRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeParameters",
	}
	for header,value in pairs(DescribeParametersRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeParametersRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeParameters synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeParametersRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeParametersSync(DescribeParametersRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeParametersAsync(DescribeParametersRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetMaintenanceWindowExecutionTaskInvocation asynchronously, invoking a callback when done
-- @param GetMaintenanceWindowExecutionTaskInvocationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetMaintenanceWindowExecutionTaskInvocationAsync(GetMaintenanceWindowExecutionTaskInvocationRequest, cb)
	assert(GetMaintenanceWindowExecutionTaskInvocationRequest, "You must provide a GetMaintenanceWindowExecutionTaskInvocationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetMaintenanceWindowExecutionTaskInvocation",
	}
	for header,value in pairs(GetMaintenanceWindowExecutionTaskInvocationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetMaintenanceWindowExecutionTaskInvocationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetMaintenanceWindowExecutionTaskInvocation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetMaintenanceWindowExecutionTaskInvocationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetMaintenanceWindowExecutionTaskInvocationSync(GetMaintenanceWindowExecutionTaskInvocationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetMaintenanceWindowExecutionTaskInvocationAsync(GetMaintenanceWindowExecutionTaskInvocationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteInventory asynchronously, invoking a callback when done
-- @param DeleteInventoryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteInventoryAsync(DeleteInventoryRequest, cb)
	assert(DeleteInventoryRequest, "You must provide a DeleteInventoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteInventory",
	}
	for header,value in pairs(DeleteInventoryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteInventoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteInventory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteInventoryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteInventorySync(DeleteInventoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteInventoryAsync(DeleteInventoryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAutomationStepExecutions asynchronously, invoking a callback when done
-- @param DescribeAutomationStepExecutionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAutomationStepExecutionsAsync(DescribeAutomationStepExecutionsRequest, cb)
	assert(DescribeAutomationStepExecutionsRequest, "You must provide a DescribeAutomationStepExecutionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeAutomationStepExecutions",
	}
	for header,value in pairs(DescribeAutomationStepExecutionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAutomationStepExecutionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAutomationStepExecutions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAutomationStepExecutionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAutomationStepExecutionsSync(DescribeAutomationStepExecutionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAutomationStepExecutionsAsync(DescribeAutomationStepExecutionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeEffectiveInstanceAssociations asynchronously, invoking a callback when done
-- @param DescribeEffectiveInstanceAssociationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeEffectiveInstanceAssociationsAsync(DescribeEffectiveInstanceAssociationsRequest, cb)
	assert(DescribeEffectiveInstanceAssociationsRequest, "You must provide a DescribeEffectiveInstanceAssociationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeEffectiveInstanceAssociations",
	}
	for header,value in pairs(DescribeEffectiveInstanceAssociationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeEffectiveInstanceAssociationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeEffectiveInstanceAssociations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeEffectiveInstanceAssociationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeEffectiveInstanceAssociationsSync(DescribeEffectiveInstanceAssociationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeEffectiveInstanceAssociationsAsync(DescribeEffectiveInstanceAssociationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelMaintenanceWindowExecution asynchronously, invoking a callback when done
-- @param CancelMaintenanceWindowExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelMaintenanceWindowExecutionAsync(CancelMaintenanceWindowExecutionRequest, cb)
	assert(CancelMaintenanceWindowExecutionRequest, "You must provide a CancelMaintenanceWindowExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CancelMaintenanceWindowExecution",
	}
	for header,value in pairs(CancelMaintenanceWindowExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelMaintenanceWindowExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelMaintenanceWindowExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelMaintenanceWindowExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelMaintenanceWindowExecutionSync(CancelMaintenanceWindowExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelMaintenanceWindowExecutionAsync(CancelMaintenanceWindowExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindowExecutionTaskInvocations asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowExecutionTaskInvocationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowExecutionTaskInvocationsAsync(DescribeMaintenanceWindowExecutionTaskInvocationsRequest, cb)
	assert(DescribeMaintenanceWindowExecutionTaskInvocationsRequest, "You must provide a DescribeMaintenanceWindowExecutionTaskInvocationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindowExecutionTaskInvocations",
	}
	for header,value in pairs(DescribeMaintenanceWindowExecutionTaskInvocationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowExecutionTaskInvocationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindowExecutionTaskInvocations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowExecutionTaskInvocationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowExecutionTaskInvocationsSync(DescribeMaintenanceWindowExecutionTaskInvocationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowExecutionTaskInvocationsAsync(DescribeMaintenanceWindowExecutionTaskInvocationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateDocumentDefaultVersion asynchronously, invoking a callback when done
-- @param UpdateDocumentDefaultVersionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateDocumentDefaultVersionAsync(UpdateDocumentDefaultVersionRequest, cb)
	assert(UpdateDocumentDefaultVersionRequest, "You must provide a UpdateDocumentDefaultVersionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateDocumentDefaultVersion",
	}
	for header,value in pairs(UpdateDocumentDefaultVersionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateDocumentDefaultVersionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateDocumentDefaultVersion synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateDocumentDefaultVersionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateDocumentDefaultVersionSync(UpdateDocumentDefaultVersionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateDocumentDefaultVersionAsync(UpdateDocumentDefaultVersionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListComplianceItems asynchronously, invoking a callback when done
-- @param ListComplianceItemsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListComplianceItemsAsync(ListComplianceItemsRequest, cb)
	assert(ListComplianceItemsRequest, "You must provide a ListComplianceItemsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListComplianceItems",
	}
	for header,value in pairs(ListComplianceItemsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListComplianceItemsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListComplianceItems synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListComplianceItemsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListComplianceItemsSync(ListComplianceItemsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListComplianceItemsAsync(ListComplianceItemsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListAssociationVersions asynchronously, invoking a callback when done
-- @param ListAssociationVersionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListAssociationVersionsAsync(ListAssociationVersionsRequest, cb)
	assert(ListAssociationVersionsRequest, "You must provide a ListAssociationVersionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListAssociationVersions",
	}
	for header,value in pairs(ListAssociationVersionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListAssociationVersionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListAssociationVersions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListAssociationVersionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListAssociationVersionsSync(ListAssociationVersionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListAssociationVersionsAsync(ListAssociationVersionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListDocuments asynchronously, invoking a callback when done
-- @param ListDocumentsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListDocumentsAsync(ListDocumentsRequest, cb)
	assert(ListDocumentsRequest, "You must provide a ListDocumentsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListDocuments",
	}
	for header,value in pairs(ListDocumentsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListDocumentsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListDocuments synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListDocumentsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListDocumentsSync(ListDocumentsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListDocumentsAsync(ListDocumentsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteActivation asynchronously, invoking a callback when done
-- @param DeleteActivationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteActivationAsync(DeleteActivationRequest, cb)
	assert(DeleteActivationRequest, "You must provide a DeleteActivationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteActivation",
	}
	for header,value in pairs(DeleteActivationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteActivationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteActivation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteActivationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteActivationSync(DeleteActivationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteActivationAsync(DeleteActivationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAvailablePatches asynchronously, invoking a callback when done
-- @param DescribeAvailablePatchesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAvailablePatchesAsync(DescribeAvailablePatchesRequest, cb)
	assert(DescribeAvailablePatchesRequest, "You must provide a DescribeAvailablePatchesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeAvailablePatches",
	}
	for header,value in pairs(DescribeAvailablePatchesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAvailablePatchesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAvailablePatches synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAvailablePatchesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAvailablePatchesSync(DescribeAvailablePatchesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAvailablePatchesAsync(DescribeAvailablePatchesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstancePatches asynchronously, invoking a callback when done
-- @param DescribeInstancePatchesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstancePatchesAsync(DescribeInstancePatchesRequest, cb)
	assert(DescribeInstancePatchesRequest, "You must provide a DescribeInstancePatchesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeInstancePatches",
	}
	for header,value in pairs(DescribeInstancePatchesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstancePatchesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstancePatches synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstancePatchesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstancePatchesSync(DescribeInstancePatchesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstancePatchesAsync(DescribeInstancePatchesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstancePatchStates asynchronously, invoking a callback when done
-- @param DescribeInstancePatchStatesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstancePatchStatesAsync(DescribeInstancePatchStatesRequest, cb)
	assert(DescribeInstancePatchStatesRequest, "You must provide a DescribeInstancePatchStatesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeInstancePatchStates",
	}
	for header,value in pairs(DescribeInstancePatchStatesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstancePatchStatesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstancePatchStates synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstancePatchStatesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstancePatchStatesSync(DescribeInstancePatchStatesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstancePatchStatesAsync(DescribeInstancePatchStatesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyDocumentPermission asynchronously, invoking a callback when done
-- @param ModifyDocumentPermissionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyDocumentPermissionAsync(ModifyDocumentPermissionRequest, cb)
	assert(ModifyDocumentPermissionRequest, "You must provide a ModifyDocumentPermissionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ModifyDocumentPermission",
	}
	for header,value in pairs(ModifyDocumentPermissionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyDocumentPermissionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyDocumentPermission synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyDocumentPermissionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyDocumentPermissionSync(ModifyDocumentPermissionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyDocumentPermissionAsync(ModifyDocumentPermissionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call PutComplianceItems asynchronously, invoking a callback when done
-- @param PutComplianceItemsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.PutComplianceItemsAsync(PutComplianceItemsRequest, cb)
	assert(PutComplianceItemsRequest, "You must provide a PutComplianceItemsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.PutComplianceItems",
	}
	for header,value in pairs(PutComplianceItemsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", PutComplianceItemsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PutComplianceItems synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PutComplianceItemsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.PutComplianceItemsSync(PutComplianceItemsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PutComplianceItemsAsync(PutComplianceItemsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateManagedInstanceRole asynchronously, invoking a callback when done
-- @param UpdateManagedInstanceRoleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateManagedInstanceRoleAsync(UpdateManagedInstanceRoleRequest, cb)
	assert(UpdateManagedInstanceRoleRequest, "You must provide a UpdateManagedInstanceRoleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateManagedInstanceRole",
	}
	for header,value in pairs(UpdateManagedInstanceRoleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateManagedInstanceRoleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateManagedInstanceRole synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateManagedInstanceRoleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateManagedInstanceRoleSync(UpdateManagedInstanceRoleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateManagedInstanceRoleAsync(UpdateManagedInstanceRoleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAssociationExecutions asynchronously, invoking a callback when done
-- @param DescribeAssociationExecutionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAssociationExecutionsAsync(DescribeAssociationExecutionsRequest, cb)
	assert(DescribeAssociationExecutionsRequest, "You must provide a DescribeAssociationExecutionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeAssociationExecutions",
	}
	for header,value in pairs(DescribeAssociationExecutionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAssociationExecutionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAssociationExecutions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAssociationExecutionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAssociationExecutionsSync(DescribeAssociationExecutionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAssociationExecutionsAsync(DescribeAssociationExecutionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StopAutomationExecution asynchronously, invoking a callback when done
-- @param StopAutomationExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StopAutomationExecutionAsync(StopAutomationExecutionRequest, cb)
	assert(StopAutomationExecutionRequest, "You must provide a StopAutomationExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.StopAutomationExecution",
	}
	for header,value in pairs(StopAutomationExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", StopAutomationExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StopAutomationExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StopAutomationExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StopAutomationExecutionSync(StopAutomationExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StopAutomationExecutionAsync(StopAutomationExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StartSession asynchronously, invoking a callback when done
-- @param StartSessionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StartSessionAsync(StartSessionRequest, cb)
	assert(StartSessionRequest, "You must provide a StartSessionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.StartSession",
	}
	for header,value in pairs(StartSessionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", StartSessionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StartSession synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartSessionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StartSessionSync(StartSessionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartSessionAsync(StartSessionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SendCommand asynchronously, invoking a callback when done
-- @param SendCommandRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SendCommandAsync(SendCommandRequest, cb)
	assert(SendCommandRequest, "You must provide a SendCommandRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.SendCommand",
	}
	for header,value in pairs(SendCommandRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", SendCommandRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SendCommand synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SendCommandRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SendCommandSync(SendCommandRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SendCommandAsync(SendCommandRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetPatchBaseline asynchronously, invoking a callback when done
-- @param GetPatchBaselineRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetPatchBaselineAsync(GetPatchBaselineRequest, cb)
	assert(GetPatchBaselineRequest, "You must provide a GetPatchBaselineRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetPatchBaseline",
	}
	for header,value in pairs(GetPatchBaselineRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetPatchBaselineRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetPatchBaseline synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetPatchBaselineRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetPatchBaselineSync(GetPatchBaselineRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetPatchBaselineAsync(GetPatchBaselineRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdatePatchBaseline asynchronously, invoking a callback when done
-- @param UpdatePatchBaselineRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdatePatchBaselineAsync(UpdatePatchBaselineRequest, cb)
	assert(UpdatePatchBaselineRequest, "You must provide a UpdatePatchBaselineRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdatePatchBaseline",
	}
	for header,value in pairs(UpdatePatchBaselineRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdatePatchBaselineRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdatePatchBaseline synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdatePatchBaselineRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdatePatchBaselineSync(UpdatePatchBaselineRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdatePatchBaselineAsync(UpdatePatchBaselineRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePatchGroupState asynchronously, invoking a callback when done
-- @param DescribePatchGroupStateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribePatchGroupStateAsync(DescribePatchGroupStateRequest, cb)
	assert(DescribePatchGroupStateRequest, "You must provide a DescribePatchGroupStateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribePatchGroupState",
	}
	for header,value in pairs(DescribePatchGroupStateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePatchGroupStateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePatchGroupState synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePatchGroupStateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribePatchGroupStateSync(DescribePatchGroupStateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePatchGroupStateAsync(DescribePatchGroupStateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateAssociation asynchronously, invoking a callback when done
-- @param UpdateAssociationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateAssociationAsync(UpdateAssociationRequest, cb)
	assert(UpdateAssociationRequest, "You must provide a UpdateAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateAssociation",
	}
	for header,value in pairs(UpdateAssociationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateAssociationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateAssociationSync(UpdateAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateAssociationAsync(UpdateAssociationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSessions asynchronously, invoking a callback when done
-- @param DescribeSessionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSessionsAsync(DescribeSessionsRequest, cb)
	assert(DescribeSessionsRequest, "You must provide a DescribeSessionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeSessions",
	}
	for header,value in pairs(DescribeSessionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSessionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSessions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSessionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSessionsSync(DescribeSessionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSessionsAsync(DescribeSessionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListDocumentVersions asynchronously, invoking a callback when done
-- @param ListDocumentVersionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListDocumentVersionsAsync(ListDocumentVersionsRequest, cb)
	assert(ListDocumentVersionsRequest, "You must provide a ListDocumentVersionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListDocumentVersions",
	}
	for header,value in pairs(ListDocumentVersionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListDocumentVersionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListDocumentVersions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListDocumentVersionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListDocumentVersionsSync(ListDocumentVersionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListDocumentVersionsAsync(ListDocumentVersionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindowExecutionTasks asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowExecutionTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowExecutionTasksAsync(DescribeMaintenanceWindowExecutionTasksRequest, cb)
	assert(DescribeMaintenanceWindowExecutionTasksRequest, "You must provide a DescribeMaintenanceWindowExecutionTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindowExecutionTasks",
	}
	for header,value in pairs(DescribeMaintenanceWindowExecutionTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowExecutionTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindowExecutionTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowExecutionTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowExecutionTasksSync(DescribeMaintenanceWindowExecutionTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowExecutionTasksAsync(DescribeMaintenanceWindowExecutionTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetMaintenanceWindow asynchronously, invoking a callback when done
-- @param GetMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetMaintenanceWindowAsync(GetMaintenanceWindowRequest, cb)
	assert(GetMaintenanceWindowRequest, "You must provide a GetMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetMaintenanceWindow",
	}
	for header,value in pairs(GetMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetMaintenanceWindowSync(GetMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetMaintenanceWindowAsync(GetMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteParameters asynchronously, invoking a callback when done
-- @param DeleteParametersRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteParametersAsync(DeleteParametersRequest, cb)
	assert(DeleteParametersRequest, "You must provide a DeleteParametersRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteParameters",
	}
	for header,value in pairs(DeleteParametersRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteParametersRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteParameters synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteParametersRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteParametersSync(DeleteParametersRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteParametersAsync(DeleteParametersRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindowTargets asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowTargetsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowTargetsAsync(DescribeMaintenanceWindowTargetsRequest, cb)
	assert(DescribeMaintenanceWindowTargetsRequest, "You must provide a DescribeMaintenanceWindowTargetsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindowTargets",
	}
	for header,value in pairs(DescribeMaintenanceWindowTargetsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowTargetsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindowTargets synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowTargetsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowTargetsSync(DescribeMaintenanceWindowTargetsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowTargetsAsync(DescribeMaintenanceWindowTargetsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceInformation asynchronously, invoking a callback when done
-- @param DescribeInstanceInformationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstanceInformationAsync(DescribeInstanceInformationRequest, cb)
	assert(DescribeInstanceInformationRequest, "You must provide a DescribeInstanceInformationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeInstanceInformation",
	}
	for header,value in pairs(DescribeInstanceInformationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstanceInformationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceInformation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceInformationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstanceInformationSync(DescribeInstanceInformationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceInformationAsync(DescribeInstanceInformationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListAssociations asynchronously, invoking a callback when done
-- @param ListAssociationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListAssociationsAsync(ListAssociationsRequest, cb)
	assert(ListAssociationsRequest, "You must provide a ListAssociationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListAssociations",
	}
	for header,value in pairs(ListAssociationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListAssociationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListAssociations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListAssociationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListAssociationsSync(ListAssociationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListAssociationsAsync(ListAssociationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteMaintenanceWindow asynchronously, invoking a callback when done
-- @param DeleteMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteMaintenanceWindowAsync(DeleteMaintenanceWindowRequest, cb)
	assert(DeleteMaintenanceWindowRequest, "You must provide a DeleteMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteMaintenanceWindow",
	}
	for header,value in pairs(DeleteMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteMaintenanceWindowSync(DeleteMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteMaintenanceWindowAsync(DeleteMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeDocument asynchronously, invoking a callback when done
-- @param DescribeDocumentRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeDocumentAsync(DescribeDocumentRequest, cb)
	assert(DescribeDocumentRequest, "You must provide a DescribeDocumentRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeDocument",
	}
	for header,value in pairs(DescribeDocumentRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeDocumentRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeDocument synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeDocumentRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeDocumentSync(DescribeDocumentRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeDocumentAsync(DescribeDocumentRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeletePatchBaseline asynchronously, invoking a callback when done
-- @param DeletePatchBaselineRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeletePatchBaselineAsync(DeletePatchBaselineRequest, cb)
	assert(DeletePatchBaselineRequest, "You must provide a DeletePatchBaselineRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeletePatchBaseline",
	}
	for header,value in pairs(DeletePatchBaselineRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeletePatchBaselineRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeletePatchBaseline synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeletePatchBaselineRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeletePatchBaselineSync(DeletePatchBaselineRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeletePatchBaselineAsync(DeletePatchBaselineRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterTaskWithMaintenanceWindow asynchronously, invoking a callback when done
-- @param RegisterTaskWithMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterTaskWithMaintenanceWindowAsync(RegisterTaskWithMaintenanceWindowRequest, cb)
	assert(RegisterTaskWithMaintenanceWindowRequest, "You must provide a RegisterTaskWithMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.RegisterTaskWithMaintenanceWindow",
	}
	for header,value in pairs(RegisterTaskWithMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RegisterTaskWithMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterTaskWithMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterTaskWithMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterTaskWithMaintenanceWindowSync(RegisterTaskWithMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterTaskWithMaintenanceWindowAsync(RegisterTaskWithMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetParameters asynchronously, invoking a callback when done
-- @param GetParametersRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetParametersAsync(GetParametersRequest, cb)
	assert(GetParametersRequest, "You must provide a GetParametersRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetParameters",
	}
	for header,value in pairs(GetParametersRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetParametersRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetParameters synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetParametersRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetParametersSync(GetParametersRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetParametersAsync(GetParametersRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeregisterManagedInstance asynchronously, invoking a callback when done
-- @param DeregisterManagedInstanceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeregisterManagedInstanceAsync(DeregisterManagedInstanceRequest, cb)
	assert(DeregisterManagedInstanceRequest, "You must provide a DeregisterManagedInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeregisterManagedInstance",
	}
	for header,value in pairs(DeregisterManagedInstanceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeregisterManagedInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeregisterManagedInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeregisterManagedInstanceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeregisterManagedInstanceSync(DeregisterManagedInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeregisterManagedInstanceAsync(DeregisterManagedInstanceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ResumeSession asynchronously, invoking a callback when done
-- @param ResumeSessionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ResumeSessionAsync(ResumeSessionRequest, cb)
	assert(ResumeSessionRequest, "You must provide a ResumeSessionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ResumeSession",
	}
	for header,value in pairs(ResumeSessionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ResumeSessionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResumeSession synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResumeSessionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ResumeSessionSync(ResumeSessionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResumeSessionAsync(ResumeSessionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateMaintenanceWindow asynchronously, invoking a callback when done
-- @param CreateMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateMaintenanceWindowAsync(CreateMaintenanceWindowRequest, cb)
	assert(CreateMaintenanceWindowRequest, "You must provide a CreateMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CreateMaintenanceWindow",
	}
	for header,value in pairs(CreateMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateMaintenanceWindowSync(CreateMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateMaintenanceWindowAsync(CreateMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListResourceDataSync asynchronously, invoking a callback when done
-- @param ListResourceDataSyncRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListResourceDataSyncAsync(ListResourceDataSyncRequest, cb)
	assert(ListResourceDataSyncRequest, "You must provide a ListResourceDataSyncRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListResourceDataSync",
	}
	for header,value in pairs(ListResourceDataSyncRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListResourceDataSyncRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListResourceDataSync synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListResourceDataSyncRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListResourceDataSyncSync(ListResourceDataSyncRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListResourceDataSyncAsync(ListResourceDataSyncRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateMaintenanceWindow asynchronously, invoking a callback when done
-- @param UpdateMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateMaintenanceWindowAsync(UpdateMaintenanceWindowRequest, cb)
	assert(UpdateMaintenanceWindowRequest, "You must provide a UpdateMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateMaintenanceWindow",
	}
	for header,value in pairs(UpdateMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateMaintenanceWindowSync(UpdateMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateMaintenanceWindowAsync(UpdateMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeEffectivePatchesForPatchBaseline asynchronously, invoking a callback when done
-- @param DescribeEffectivePatchesForPatchBaselineRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeEffectivePatchesForPatchBaselineAsync(DescribeEffectivePatchesForPatchBaselineRequest, cb)
	assert(DescribeEffectivePatchesForPatchBaselineRequest, "You must provide a DescribeEffectivePatchesForPatchBaselineRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeEffectivePatchesForPatchBaseline",
	}
	for header,value in pairs(DescribeEffectivePatchesForPatchBaselineRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeEffectivePatchesForPatchBaselineRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeEffectivePatchesForPatchBaseline synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeEffectivePatchesForPatchBaselineRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeEffectivePatchesForPatchBaselineSync(DescribeEffectivePatchesForPatchBaselineRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeEffectivePatchesForPatchBaselineAsync(DescribeEffectivePatchesForPatchBaselineRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateResourceDataSync asynchronously, invoking a callback when done
-- @param CreateResourceDataSyncRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateResourceDataSyncAsync(CreateResourceDataSyncRequest, cb)
	assert(CreateResourceDataSyncRequest, "You must provide a CreateResourceDataSyncRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CreateResourceDataSync",
	}
	for header,value in pairs(CreateResourceDataSyncRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateResourceDataSyncRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateResourceDataSync synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateResourceDataSyncRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateResourceDataSyncSync(CreateResourceDataSyncRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateResourceDataSyncAsync(CreateResourceDataSyncRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call PutParameter asynchronously, invoking a callback when done
-- @param PutParameterRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.PutParameterAsync(PutParameterRequest, cb)
	assert(PutParameterRequest, "You must provide a PutParameterRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.PutParameter",
	}
	for header,value in pairs(PutParameterRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", PutParameterRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PutParameter synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PutParameterRequest
-- @return response
-- @return error_type
-- @return error_message
function M.PutParameterSync(PutParameterRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PutParameterAsync(PutParameterRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetAutomationExecution asynchronously, invoking a callback when done
-- @param GetAutomationExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetAutomationExecutionAsync(GetAutomationExecutionRequest, cb)
	assert(GetAutomationExecutionRequest, "You must provide a GetAutomationExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetAutomationExecution",
	}
	for header,value in pairs(GetAutomationExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetAutomationExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetAutomationExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetAutomationExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetAutomationExecutionSync(GetAutomationExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetAutomationExecutionAsync(GetAutomationExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call PutInventory asynchronously, invoking a callback when done
-- @param PutInventoryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.PutInventoryAsync(PutInventoryRequest, cb)
	assert(PutInventoryRequest, "You must provide a PutInventoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.PutInventory",
	}
	for header,value in pairs(PutInventoryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", PutInventoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PutInventory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PutInventoryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.PutInventorySync(PutInventoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PutInventoryAsync(PutInventoryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAutomationExecutions asynchronously, invoking a callback when done
-- @param DescribeAutomationExecutionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAutomationExecutionsAsync(DescribeAutomationExecutionsRequest, cb)
	assert(DescribeAutomationExecutionsRequest, "You must provide a DescribeAutomationExecutionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeAutomationExecutions",
	}
	for header,value in pairs(DescribeAutomationExecutionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAutomationExecutionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAutomationExecutions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAutomationExecutionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAutomationExecutionsSync(DescribeAutomationExecutionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAutomationExecutionsAsync(DescribeAutomationExecutionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetMaintenanceWindowTask asynchronously, invoking a callback when done
-- @param GetMaintenanceWindowTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetMaintenanceWindowTaskAsync(GetMaintenanceWindowTaskRequest, cb)
	assert(GetMaintenanceWindowTaskRequest, "You must provide a GetMaintenanceWindowTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetMaintenanceWindowTask",
	}
	for header,value in pairs(GetMaintenanceWindowTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetMaintenanceWindowTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetMaintenanceWindowTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetMaintenanceWindowTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetMaintenanceWindowTaskSync(GetMaintenanceWindowTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetMaintenanceWindowTaskAsync(GetMaintenanceWindowTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePatchBaselines asynchronously, invoking a callback when done
-- @param DescribePatchBaselinesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribePatchBaselinesAsync(DescribePatchBaselinesRequest, cb)
	assert(DescribePatchBaselinesRequest, "You must provide a DescribePatchBaselinesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribePatchBaselines",
	}
	for header,value in pairs(DescribePatchBaselinesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePatchBaselinesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePatchBaselines synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePatchBaselinesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribePatchBaselinesSync(DescribePatchBaselinesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePatchBaselinesAsync(DescribePatchBaselinesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateAssociationBatch asynchronously, invoking a callback when done
-- @param CreateAssociationBatchRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateAssociationBatchAsync(CreateAssociationBatchRequest, cb)
	assert(CreateAssociationBatchRequest, "You must provide a CreateAssociationBatchRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CreateAssociationBatch",
	}
	for header,value in pairs(CreateAssociationBatchRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateAssociationBatchRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateAssociationBatch synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateAssociationBatchRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateAssociationBatchSync(CreateAssociationBatchRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateAssociationBatchAsync(CreateAssociationBatchRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteResourceDataSync asynchronously, invoking a callback when done
-- @param DeleteResourceDataSyncRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteResourceDataSyncAsync(DeleteResourceDataSyncRequest, cb)
	assert(DeleteResourceDataSyncRequest, "You must provide a DeleteResourceDataSyncRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteResourceDataSync",
	}
	for header,value in pairs(DeleteResourceDataSyncRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteResourceDataSyncRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteResourceDataSync synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteResourceDataSyncRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteResourceDataSyncSync(DeleteResourceDataSyncRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteResourceDataSyncAsync(DeleteResourceDataSyncRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetMaintenanceWindowExecutionTask asynchronously, invoking a callback when done
-- @param GetMaintenanceWindowExecutionTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetMaintenanceWindowExecutionTaskAsync(GetMaintenanceWindowExecutionTaskRequest, cb)
	assert(GetMaintenanceWindowExecutionTaskRequest, "You must provide a GetMaintenanceWindowExecutionTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetMaintenanceWindowExecutionTask",
	}
	for header,value in pairs(GetMaintenanceWindowExecutionTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetMaintenanceWindowExecutionTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetMaintenanceWindowExecutionTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetMaintenanceWindowExecutionTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetMaintenanceWindowExecutionTaskSync(GetMaintenanceWindowExecutionTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetMaintenanceWindowExecutionTaskAsync(GetMaintenanceWindowExecutionTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelCommand asynchronously, invoking a callback when done
-- @param CancelCommandRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelCommandAsync(CancelCommandRequest, cb)
	assert(CancelCommandRequest, "You must provide a CancelCommandRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CancelCommand",
	}
	for header,value in pairs(CancelCommandRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelCommandRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelCommand synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelCommandRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelCommandSync(CancelCommandRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelCommandAsync(CancelCommandRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetCommandInvocation asynchronously, invoking a callback when done
-- @param GetCommandInvocationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetCommandInvocationAsync(GetCommandInvocationRequest, cb)
	assert(GetCommandInvocationRequest, "You must provide a GetCommandInvocationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetCommandInvocation",
	}
	for header,value in pairs(GetCommandInvocationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetCommandInvocationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetCommandInvocation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetCommandInvocationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetCommandInvocationSync(GetCommandInvocationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetCommandInvocationAsync(GetCommandInvocationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetParameterHistory asynchronously, invoking a callback when done
-- @param GetParameterHistoryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetParameterHistoryAsync(GetParameterHistoryRequest, cb)
	assert(GetParameterHistoryRequest, "You must provide a GetParameterHistoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetParameterHistory",
	}
	for header,value in pairs(GetParameterHistoryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetParameterHistoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetParameterHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetParameterHistoryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetParameterHistorySync(GetParameterHistoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetParameterHistoryAsync(GetParameterHistoryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeregisterTaskFromMaintenanceWindow asynchronously, invoking a callback when done
-- @param DeregisterTaskFromMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeregisterTaskFromMaintenanceWindowAsync(DeregisterTaskFromMaintenanceWindowRequest, cb)
	assert(DeregisterTaskFromMaintenanceWindowRequest, "You must provide a DeregisterTaskFromMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeregisterTaskFromMaintenanceWindow",
	}
	for header,value in pairs(DeregisterTaskFromMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeregisterTaskFromMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeregisterTaskFromMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeregisterTaskFromMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeregisterTaskFromMaintenanceWindowSync(DeregisterTaskFromMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeregisterTaskFromMaintenanceWindowAsync(DeregisterTaskFromMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterPatchBaselineForPatchGroup asynchronously, invoking a callback when done
-- @param RegisterPatchBaselineForPatchGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterPatchBaselineForPatchGroupAsync(RegisterPatchBaselineForPatchGroupRequest, cb)
	assert(RegisterPatchBaselineForPatchGroupRequest, "You must provide a RegisterPatchBaselineForPatchGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.RegisterPatchBaselineForPatchGroup",
	}
	for header,value in pairs(RegisterPatchBaselineForPatchGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RegisterPatchBaselineForPatchGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterPatchBaselineForPatchGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterPatchBaselineForPatchGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterPatchBaselineForPatchGroupSync(RegisterPatchBaselineForPatchGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterPatchBaselineForPatchGroupAsync(RegisterPatchBaselineForPatchGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMaintenanceWindows asynchronously, invoking a callback when done
-- @param DescribeMaintenanceWindowsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMaintenanceWindowsAsync(DescribeMaintenanceWindowsRequest, cb)
	assert(DescribeMaintenanceWindowsRequest, "You must provide a DescribeMaintenanceWindowsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeMaintenanceWindows",
	}
	for header,value in pairs(DescribeMaintenanceWindowsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMaintenanceWindowsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMaintenanceWindows synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMaintenanceWindowsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMaintenanceWindowsSync(DescribeMaintenanceWindowsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMaintenanceWindowsAsync(DescribeMaintenanceWindowsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePatchGroups asynchronously, invoking a callback when done
-- @param DescribePatchGroupsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribePatchGroupsAsync(DescribePatchGroupsRequest, cb)
	assert(DescribePatchGroupsRequest, "You must provide a DescribePatchGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribePatchGroups",
	}
	for header,value in pairs(DescribePatchGroupsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePatchGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePatchGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePatchGroupsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribePatchGroupsSync(DescribePatchGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePatchGroupsAsync(DescribePatchGroupsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateAssociation asynchronously, invoking a callback when done
-- @param CreateAssociationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateAssociationAsync(CreateAssociationRequest, cb)
	assert(CreateAssociationRequest, "You must provide a CreateAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.CreateAssociation",
	}
	for header,value in pairs(CreateAssociationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateAssociationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateAssociationSync(CreateAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateAssociationAsync(CreateAssociationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateMaintenanceWindowTask asynchronously, invoking a callback when done
-- @param UpdateMaintenanceWindowTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateMaintenanceWindowTaskAsync(UpdateMaintenanceWindowTaskRequest, cb)
	assert(UpdateMaintenanceWindowTaskRequest, "You must provide a UpdateMaintenanceWindowTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.UpdateMaintenanceWindowTask",
	}
	for header,value in pairs(UpdateMaintenanceWindowTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateMaintenanceWindowTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateMaintenanceWindowTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateMaintenanceWindowTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateMaintenanceWindowTaskSync(UpdateMaintenanceWindowTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateMaintenanceWindowTaskAsync(UpdateMaintenanceWindowTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListCommands asynchronously, invoking a callback when done
-- @param ListCommandsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListCommandsAsync(ListCommandsRequest, cb)
	assert(ListCommandsRequest, "You must provide a ListCommandsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.ListCommands",
	}
	for header,value in pairs(ListCommandsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ListCommandsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListCommands synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListCommandsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListCommandsSync(ListCommandsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListCommandsAsync(ListCommandsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetMaintenanceWindowExecution asynchronously, invoking a callback when done
-- @param GetMaintenanceWindowExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetMaintenanceWindowExecutionAsync(GetMaintenanceWindowExecutionRequest, cb)
	assert(GetMaintenanceWindowExecutionRequest, "You must provide a GetMaintenanceWindowExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.GetMaintenanceWindowExecution",
	}
	for header,value in pairs(GetMaintenanceWindowExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetMaintenanceWindowExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetMaintenanceWindowExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetMaintenanceWindowExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetMaintenanceWindowExecutionSync(GetMaintenanceWindowExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetMaintenanceWindowExecutionAsync(GetMaintenanceWindowExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteParameter asynchronously, invoking a callback when done
-- @param DeleteParameterRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteParameterAsync(DeleteParameterRequest, cb)
	assert(DeleteParameterRequest, "You must provide a DeleteParameterRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DeleteParameter",
	}
	for header,value in pairs(DeleteParameterRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteParameterRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteParameter synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteParameterRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteParameterSync(DeleteParameterRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteParameterAsync(DeleteParameterRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterTargetWithMaintenanceWindow asynchronously, invoking a callback when done
-- @param RegisterTargetWithMaintenanceWindowRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterTargetWithMaintenanceWindowAsync(RegisterTargetWithMaintenanceWindowRequest, cb)
	assert(RegisterTargetWithMaintenanceWindowRequest, "You must provide a RegisterTargetWithMaintenanceWindowRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.RegisterTargetWithMaintenanceWindow",
	}
	for header,value in pairs(RegisterTargetWithMaintenanceWindowRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RegisterTargetWithMaintenanceWindowRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterTargetWithMaintenanceWindow synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterTargetWithMaintenanceWindowRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterTargetWithMaintenanceWindowSync(RegisterTargetWithMaintenanceWindowRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterTargetWithMaintenanceWindowAsync(RegisterTargetWithMaintenanceWindowRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeActivations asynchronously, invoking a callback when done
-- @param DescribeActivationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeActivationsAsync(DescribeActivationsRequest, cb)
	assert(DescribeActivationsRequest, "You must provide a DescribeActivationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = "AmazonSSM.DescribeActivations",
	}
	for header,value in pairs(DescribeActivationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("json", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeActivationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeActivations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeActivationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeActivationsSync(DescribeActivationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeActivationsAsync(DescribeActivationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end


return M
