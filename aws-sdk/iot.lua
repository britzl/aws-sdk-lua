--- GENERATED CODE - DO NOT MODIFY
-- AWS IoT (iot-2015-05-28)

local M = {}

M.metadata = {
	api_version = "2015-05-28",
	json_version = "",
	protocol = "rest-json",
	checksum_format = "",
	endpoint_prefix = "iot",
	service_abbreviation = "",
	service_full_name = "AWS IoT",
	signature_version = "v4",
	target_prefix = "",
	timestamp_format = "",
	global_endpoint = "",
	uid = "iot-2015-05-28",
}

local keys = {}
local asserts = {}

keys.ViolationEvent = { ["securityProfileName"] = true, ["metricValue"] = true, ["violationId"] = true, ["violationEventType"] = true, ["thingName"] = true, ["behavior"] = true, ["violationEventTime"] = true, nil }

function asserts.AssertViolationEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ViolationEvent to be of type 'table'")
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["metricValue"] then asserts.AssertMetricValue(struct["metricValue"]) end
	if struct["violationId"] then asserts.AssertViolationId(struct["violationId"]) end
	if struct["violationEventType"] then asserts.AssertViolationEventType(struct["violationEventType"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["behavior"] then asserts.AssertBehavior(struct["behavior"]) end
	if struct["violationEventTime"] then asserts.AssertTimestamp(struct["violationEventTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ViolationEvent[k], "ViolationEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ViolationEvent
-- <p>Information about a Device Defender security profile behavior violation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileName [SecurityProfileName] <p>The name of the security profile whose behavior was violated.</p>
-- * metricValue [MetricValue] <p>The value of the metric (the measurement).</p>
-- * violationId [ViolationId] <p>The ID of the violation event.</p>
-- * violationEventType [ViolationEventType] <p>The type of violation event.</p>
-- * thingName [ThingName] <p>The name of the thing responsible for the violation event.</p>
-- * behavior [Behavior] <p>The behavior which was violated.</p>
-- * violationEventTime [Timestamp] <p>The time the violation event occurred.</p>
-- @return ViolationEvent structure as a key-value pair table
function M.ViolationEvent(args)
	assert(args, "You must provide an argument table when creating ViolationEvent")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileName"] = args["securityProfileName"],
		["metricValue"] = args["metricValue"],
		["violationId"] = args["violationId"],
		["violationEventType"] = args["violationEventType"],
		["thingName"] = args["thingName"],
		["behavior"] = args["behavior"],
		["violationEventTime"] = args["violationEventTime"],
	}
	asserts.AssertViolationEvent(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachThingPrincipalResponse = { nil }

function asserts.AssertDetachThingPrincipalResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachThingPrincipalResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DetachThingPrincipalResponse[k], "DetachThingPrincipalResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachThingPrincipalResponse
-- <p>The output from the DetachThingPrincipal operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DetachThingPrincipalResponse structure as a key-value pair table
function M.DetachThingPrincipalResponse(args)
	assert(args, "You must provide an argument table when creating DetachThingPrincipalResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDetachThingPrincipalResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTargetsForPolicyResponse = { ["nextMarker"] = true, ["targets"] = true, nil }

function asserts.AssertListTargetsForPolicyResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTargetsForPolicyResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["targets"] then asserts.AssertPolicyTargets(struct["targets"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTargetsForPolicyResponse[k], "ListTargetsForPolicyResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTargetsForPolicyResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>A marker used to get the next set of results.</p>
-- * targets [PolicyTargets] <p>The policy targets.</p>
-- @return ListTargetsForPolicyResponse structure as a key-value pair table
function M.ListTargetsForPolicyResponse(args)
	assert(args, "You must provide an argument table when creating ListTargetsForPolicyResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["targets"] = args["targets"],
	}
	asserts.AssertListTargetsForPolicyResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteRoleAliasResponse = { nil }

function asserts.AssertDeleteRoleAliasResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRoleAliasResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteRoleAliasResponse[k], "DeleteRoleAliasResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRoleAliasResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteRoleAliasResponse structure as a key-value pair table
function M.DeleteRoleAliasResponse(args)
	assert(args, "You must provide an argument table when creating DeleteRoleAliasResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteRoleAliasResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.S3Action = { ["cannedAcl"] = true, ["roleArn"] = true, ["bucketName"] = true, ["key"] = true, nil }

function asserts.AssertS3Action(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3Action to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["bucketName"], "Expected key bucketName to exist in table")
	assert(struct["key"], "Expected key key to exist in table")
	if struct["cannedAcl"] then asserts.AssertCannedAccessControlList(struct["cannedAcl"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["bucketName"] then asserts.AssertBucketName(struct["bucketName"]) end
	if struct["key"] then asserts.AssertKey(struct["key"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3Action[k], "S3Action contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3Action
-- <p>Describes an action to write data to an Amazon S3 bucket.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * cannedAcl [CannedAccessControlList] <p>The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl">S3 canned ACLs</a>.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access.</p>
-- * bucketName [BucketName] <p>The Amazon S3 bucket.</p>
-- * key [Key] <p>The object key.</p>
-- Required key: roleArn
-- Required key: bucketName
-- Required key: key
-- @return S3Action structure as a key-value pair table
function M.S3Action(args)
	assert(args, "You must provide an argument table when creating S3Action")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["cannedAcl"] = args["cannedAcl"],
		["roleArn"] = args["roleArn"],
		["bucketName"] = args["bucketName"],
		["key"] = args["key"],
	}
	asserts.AssertS3Action(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuthResult = { ["authDecision"] = true, ["authInfo"] = true, ["denied"] = true, ["missingContextValues"] = true, ["allowed"] = true, nil }

function asserts.AssertAuthResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthResult to be of type 'table'")
	if struct["authDecision"] then asserts.AssertAuthDecision(struct["authDecision"]) end
	if struct["authInfo"] then asserts.AssertAuthInfo(struct["authInfo"]) end
	if struct["denied"] then asserts.AssertDenied(struct["denied"]) end
	if struct["missingContextValues"] then asserts.AssertMissingContextValues(struct["missingContextValues"]) end
	if struct["allowed"] then asserts.AssertAllowed(struct["allowed"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthResult[k], "AuthResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthResult
-- <p>The authorizer result.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authDecision [AuthDecision] <p>The final authorization decision of this scenario. Multiple statements are taken into account when determining the authorization decision. An explicit deny statement can override multiple allow statements.</p>
-- * authInfo [AuthInfo] <p>Authorization information.</p>
-- * denied [Denied] <p>The policies and statements that denied the specified action.</p>
-- * missingContextValues [MissingContextValues] <p>Contains any missing context values found while evaluating policy.</p>
-- * allowed [Allowed] <p>The policies and statements that allowed the specified action.</p>
-- @return AuthResult structure as a key-value pair table
function M.AuthResult(args)
	assert(args, "You must provide an argument table when creating AuthResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authDecision"] = args["authDecision"],
		["authInfo"] = args["authInfo"],
		["denied"] = args["denied"],
		["missingContextValues"] = args["missingContextValues"],
		["allowed"] = args["allowed"],
	}
	asserts.AssertAuthResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SnsAction = { ["targetArn"] = true, ["roleArn"] = true, ["messageFormat"] = true, nil }

function asserts.AssertSnsAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnsAction to be of type 'table'")
	assert(struct["targetArn"], "Expected key targetArn to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["targetArn"] then asserts.AssertAwsArn(struct["targetArn"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["messageFormat"] then asserts.AssertMessageFormat(struct["messageFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnsAction[k], "SnsAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnsAction
-- <p>Describes an action to publish to an Amazon SNS topic.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * targetArn [AwsArn] <p>The ARN of the SNS topic.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access.</p>
-- * messageFormat [MessageFormat] <p>(Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see <a href="http://docs.aws.amazon.com/sns/latest/dg/json-formats.html">http://docs.aws.amazon.com/sns/latest/dg/json-formats.html</a> refer to their official documentation.</p>
-- Required key: targetArn
-- Required key: roleArn
-- @return SnsAction structure as a key-value pair table
function M.SnsAction(args)
	assert(args, "You must provide an argument table when creating SnsAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["targetArn"] = args["targetArn"],
		["roleArn"] = args["roleArn"],
		["messageFormat"] = args["messageFormat"],
	}
	asserts.AssertSnsAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IotAnalyticsAction = { ["channelArn"] = true, ["roleArn"] = true, ["channelName"] = true, nil }

function asserts.AssertIotAnalyticsAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IotAnalyticsAction to be of type 'table'")
	if struct["channelArn"] then asserts.AssertAwsArn(struct["channelArn"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["channelName"] then asserts.AssertChannelName(struct["channelName"]) end
	for k,_ in pairs(struct) do
		assert(keys.IotAnalyticsAction[k], "IotAnalyticsAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IotAnalyticsAction
-- <p>Sends messge data to an AWS IoT Analytics channel.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * channelArn [AwsArn] <p>(deprecated) The ARN of the IoT Analytics channel to which message data will be sent.</p>
-- * roleArn [AwsArn] <p>The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).</p>
-- * channelName [ChannelName] <p>The name of the IoT Analytics channel to which message data will be sent.</p>
-- @return IotAnalyticsAction structure as a key-value pair table
function M.IotAnalyticsAction(args)
	assert(args, "You must provide an argument table when creating IotAnalyticsAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["channelArn"] = args["channelArn"],
		["roleArn"] = args["roleArn"],
		["channelName"] = args["channelName"],
	}
	asserts.AssertIotAnalyticsAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAuthorizersResponse = { ["nextMarker"] = true, ["authorizers"] = true, nil }

function asserts.AssertListAuthorizersResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAuthorizersResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["authorizers"] then asserts.AssertAuthorizers(struct["authorizers"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAuthorizersResponse[k], "ListAuthorizersResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAuthorizersResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>A marker used to get the next set of results.</p>
-- * authorizers [Authorizers] <p>The authorizers.</p>
-- @return ListAuthorizersResponse structure as a key-value pair table
function M.ListAuthorizersResponse(args)
	assert(args, "You must provide an argument table when creating ListAuthorizersResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["authorizers"] = args["authorizers"],
	}
	asserts.AssertListAuthorizersResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterCertificateRequest = { ["status"] = true, ["certificatePem"] = true, ["caCertificatePem"] = true, ["setAsActive"] = true, nil }

function asserts.AssertRegisterCertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterCertificateRequest to be of type 'table'")
	assert(struct["certificatePem"], "Expected key certificatePem to exist in table")
	if struct["status"] then asserts.AssertCertificateStatus(struct["status"]) end
	if struct["certificatePem"] then asserts.AssertCertificatePem(struct["certificatePem"]) end
	if struct["caCertificatePem"] then asserts.AssertCertificatePem(struct["caCertificatePem"]) end
	if struct["setAsActive"] then asserts.AssertSetAsActiveFlag(struct["setAsActive"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterCertificateRequest[k], "RegisterCertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterCertificateRequest
-- <p>The input to the RegisterCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [CertificateStatus] <p>The status of the register certificate request.</p>
-- * certificatePem [CertificatePem] <p>The certificate data, in PEM format.</p>
-- * caCertificatePem [CertificatePem] <p>The CA certificate used to sign the device certificate being registered.</p>
-- * setAsActive [SetAsActiveFlag] <p>A boolean value that specifies if the CA certificate is set to active.</p>
-- Required key: certificatePem
-- @return RegisterCertificateRequest structure as a key-value pair table
function M.RegisterCertificateRequest(args)
	assert(args, "You must provide an argument table when creating RegisterCertificateRequest")
    local query_args = { 
        ["setAsActive"] = args["setAsActive"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["certificatePem"] = args["certificatePem"],
		["caCertificatePem"] = args["caCertificatePem"],
		["setAsActive"] = args["setAsActive"],
	}
	asserts.AssertRegisterCertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartSigningJobParameter = { ["destination"] = true, ["signingProfileParameter"] = true, ["signingProfileName"] = true, nil }

function asserts.AssertStartSigningJobParameter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartSigningJobParameter to be of type 'table'")
	if struct["destination"] then asserts.AssertDestination(struct["destination"]) end
	if struct["signingProfileParameter"] then asserts.AssertSigningProfileParameter(struct["signingProfileParameter"]) end
	if struct["signingProfileName"] then asserts.AssertSigningProfileName(struct["signingProfileName"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartSigningJobParameter[k], "StartSigningJobParameter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartSigningJobParameter
-- <p>Information required to start a signing job.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * destination [Destination] <p>The location to write the code-signed file.</p>
-- * signingProfileParameter [SigningProfileParameter] <p>Describes the code-signing profile.</p>
-- * signingProfileName [SigningProfileName] <p>The code-signing profile name.</p>
-- @return StartSigningJobParameter structure as a key-value pair table
function M.StartSigningJobParameter(args)
	assert(args, "You must provide an argument table when creating StartSigningJobParameter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["destination"] = args["destination"],
		["signingProfileParameter"] = args["signingProfileParameter"],
		["signingProfileName"] = args["signingProfileName"],
	}
	asserts.AssertStartSigningJobParameter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateThingGroupsForThingRequest = { ["thingGroupsToAdd"] = true, ["thingGroupsToRemove"] = true, ["thingName"] = true, nil }

function asserts.AssertUpdateThingGroupsForThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateThingGroupsForThingRequest to be of type 'table'")
	if struct["thingGroupsToAdd"] then asserts.AssertThingGroupList(struct["thingGroupsToAdd"]) end
	if struct["thingGroupsToRemove"] then asserts.AssertThingGroupList(struct["thingGroupsToRemove"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateThingGroupsForThingRequest[k], "UpdateThingGroupsForThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateThingGroupsForThingRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupsToAdd [ThingGroupList] <p>The groups to which the thing will be added.</p>
-- * thingGroupsToRemove [ThingGroupList] <p>The groups from which the thing will be removed.</p>
-- * thingName [ThingName] <p>The thing whose group memberships will be updated.</p>
-- @return UpdateThingGroupsForThingRequest structure as a key-value pair table
function M.UpdateThingGroupsForThingRequest(args)
	assert(args, "You must provide an argument table when creating UpdateThingGroupsForThingRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupsToAdd"] = args["thingGroupsToAdd"],
		["thingGroupsToRemove"] = args["thingGroupsToRemove"],
		["thingName"] = args["thingName"],
	}
	asserts.AssertUpdateThingGroupsForThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateAuthorizerResponse = { ["authorizerName"] = true, ["authorizerArn"] = true, nil }

function asserts.AssertCreateAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateAuthorizerResponse to be of type 'table'")
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	if struct["authorizerArn"] then asserts.AssertAuthorizerArn(struct["authorizerArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateAuthorizerResponse[k], "CreateAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerName [AuthorizerName] <p>The authorizer's name.</p>
-- * authorizerArn [AuthorizerArn] <p>The authorizer ARN.</p>
-- @return CreateAuthorizerResponse structure as a key-value pair table
function M.CreateAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating CreateAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerName"] = args["authorizerName"],
		["authorizerArn"] = args["authorizerArn"],
	}
	asserts.AssertCreateAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterCACertificateRequest = { ["caCertificate"] = true, ["verificationCertificate"] = true, ["registrationConfig"] = true, ["allowAutoRegistration"] = true, ["setAsActive"] = true, nil }

function asserts.AssertRegisterCACertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterCACertificateRequest to be of type 'table'")
	assert(struct["caCertificate"], "Expected key caCertificate to exist in table")
	assert(struct["verificationCertificate"], "Expected key verificationCertificate to exist in table")
	if struct["caCertificate"] then asserts.AssertCertificatePem(struct["caCertificate"]) end
	if struct["verificationCertificate"] then asserts.AssertCertificatePem(struct["verificationCertificate"]) end
	if struct["registrationConfig"] then asserts.AssertRegistrationConfig(struct["registrationConfig"]) end
	if struct["allowAutoRegistration"] then asserts.AssertAllowAutoRegistration(struct["allowAutoRegistration"]) end
	if struct["setAsActive"] then asserts.AssertSetAsActive(struct["setAsActive"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterCACertificateRequest[k], "RegisterCACertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterCACertificateRequest
-- <p>The input to the RegisterCACertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * caCertificate [CertificatePem] <p>The CA certificate.</p>
-- * verificationCertificate [CertificatePem] <p>The private key verification certificate.</p>
-- * registrationConfig [RegistrationConfig] <p>Information about the registration configuration.</p>
-- * allowAutoRegistration [AllowAutoRegistration] <p>Allows this CA certificate to be used for auto registration of device certificates.</p>
-- * setAsActive [SetAsActive] <p>A boolean value that specifies if the CA certificate is set to active.</p>
-- Required key: caCertificate
-- Required key: verificationCertificate
-- @return RegisterCACertificateRequest structure as a key-value pair table
function M.RegisterCACertificateRequest(args)
	assert(args, "You must provide an argument table when creating RegisterCACertificateRequest")
    local query_args = { 
        ["allowAutoRegistration"] = args["allowAutoRegistration"],
        ["setAsActive"] = args["setAsActive"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["caCertificate"] = args["caCertificate"],
		["verificationCertificate"] = args["verificationCertificate"],
		["registrationConfig"] = args["registrationConfig"],
		["allowAutoRegistration"] = args["allowAutoRegistration"],
		["setAsActive"] = args["setAsActive"],
	}
	asserts.AssertRegisterCACertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SearchIndexRequest = { ["queryString"] = true, ["nextToken"] = true, ["indexName"] = true, ["maxResults"] = true, ["queryVersion"] = true, nil }

function asserts.AssertSearchIndexRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SearchIndexRequest to be of type 'table'")
	assert(struct["queryString"], "Expected key queryString to exist in table")
	if struct["queryString"] then asserts.AssertQueryString(struct["queryString"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["indexName"] then asserts.AssertIndexName(struct["indexName"]) end
	if struct["maxResults"] then asserts.AssertQueryMaxResults(struct["maxResults"]) end
	if struct["queryVersion"] then asserts.AssertQueryVersion(struct["queryVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.SearchIndexRequest[k], "SearchIndexRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SearchIndexRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * queryString [QueryString] <p>The search query string.</p>
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * indexName [IndexName] <p>The search index name.</p>
-- * maxResults [QueryMaxResults] <p>The maximum number of results to return at one time.</p>
-- * queryVersion [QueryVersion] <p>The query version.</p>
-- Required key: queryString
-- @return SearchIndexRequest structure as a key-value pair table
function M.SearchIndexRequest(args)
	assert(args, "You must provide an argument table when creating SearchIndexRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["queryString"] = args["queryString"],
		["nextToken"] = args["nextToken"],
		["indexName"] = args["indexName"],
		["maxResults"] = args["maxResults"],
		["queryVersion"] = args["queryVersion"],
	}
	asserts.AssertSearchIndexRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingGroupsRequest = { ["namePrefixFilter"] = true, ["parentGroup"] = true, ["nextToken"] = true, ["recursive"] = true, ["maxResults"] = true, nil }

function asserts.AssertListThingGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingGroupsRequest to be of type 'table'")
	if struct["namePrefixFilter"] then asserts.AssertThingGroupName(struct["namePrefixFilter"]) end
	if struct["parentGroup"] then asserts.AssertThingGroupName(struct["parentGroup"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["recursive"] then asserts.AssertRecursiveWithoutDefault(struct["recursive"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingGroupsRequest[k], "ListThingGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingGroupsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * namePrefixFilter [ThingGroupName] <p>A filter that limits the results to those with the specified name prefix.</p>
-- * parentGroup [ThingGroupName] <p>A filter that limits the results to those with the specified parent group.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * recursive [RecursiveWithoutDefault] <p>If true, return child groups as well.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return at one time.</p>
-- @return ListThingGroupsRequest structure as a key-value pair table
function M.ListThingGroupsRequest(args)
	assert(args, "You must provide an argument table when creating ListThingGroupsRequest")
    local query_args = { 
        ["namePrefixFilter"] = args["namePrefixFilter"],
        ["parentGroup"] = args["parentGroup"],
        ["nextToken"] = args["nextToken"],
        ["recursive"] = args["recursive"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["namePrefixFilter"] = args["namePrefixFilter"],
		["parentGroup"] = args["parentGroup"],
		["nextToken"] = args["nextToken"],
		["recursive"] = args["recursive"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListThingGroupsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartOnDemandAuditTaskRequest = { ["targetCheckNames"] = true, nil }

function asserts.AssertStartOnDemandAuditTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartOnDemandAuditTaskRequest to be of type 'table'")
	assert(struct["targetCheckNames"], "Expected key targetCheckNames to exist in table")
	if struct["targetCheckNames"] then asserts.AssertTargetAuditCheckNames(struct["targetCheckNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartOnDemandAuditTaskRequest[k], "StartOnDemandAuditTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartOnDemandAuditTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * targetCheckNames [TargetAuditCheckNames] <p>Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
-- Required key: targetCheckNames
-- @return StartOnDemandAuditTaskRequest structure as a key-value pair table
function M.StartOnDemandAuditTaskRequest(args)
	assert(args, "You must provide an argument table when creating StartOnDemandAuditTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["targetCheckNames"] = args["targetCheckNames"],
	}
	asserts.AssertStartOnDemandAuditTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListIndicesRequest = { ["nextToken"] = true, ["maxResults"] = true, nil }

function asserts.AssertListIndicesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListIndicesRequest to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertQueryMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListIndicesRequest[k], "ListIndicesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListIndicesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * maxResults [QueryMaxResults] <p>The maximum number of results to return at one time.</p>
-- @return ListIndicesRequest structure as a key-value pair table
function M.ListIndicesRequest(args)
	assert(args, "You must provide an argument table when creating ListIndicesRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListIndicesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Allowed = { ["policies"] = true, nil }

function asserts.AssertAllowed(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Allowed to be of type 'table'")
	if struct["policies"] then asserts.AssertPolicies(struct["policies"]) end
	for k,_ in pairs(struct) do
		assert(keys.Allowed[k], "Allowed contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Allowed
-- <p>Contains information that allowed the authorization.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policies [Policies] <p>A list of policies that allowed the authentication.</p>
-- @return Allowed structure as a key-value pair table
function M.Allowed(args)
	assert(args, "You must provide an argument table when creating Allowed")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policies"] = args["policies"],
	}
	asserts.AssertAllowed(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SecurityProfileIdentifier = { ["name"] = true, ["arn"] = true, nil }

function asserts.AssertSecurityProfileIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityProfileIdentifier to be of type 'table'")
	assert(struct["name"], "Expected key name to exist in table")
	assert(struct["arn"], "Expected key arn to exist in table")
	if struct["name"] then asserts.AssertSecurityProfileName(struct["name"]) end
	if struct["arn"] then asserts.AssertSecurityProfileArn(struct["arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityProfileIdentifier[k], "SecurityProfileIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityProfileIdentifier
-- <p>Identifying information for a Device Defender security profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * name [SecurityProfileName] <p>The name you have given to the security profile.</p>
-- * arn [SecurityProfileArn] <p>The ARN of the security profile.</p>
-- Required key: name
-- Required key: arn
-- @return SecurityProfileIdentifier structure as a key-value pair table
function M.SecurityProfileIdentifier(args)
	assert(args, "You must provide an argument table when creating SecurityProfileIdentifier")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["name"] = args["name"],
		["arn"] = args["arn"],
	}
	asserts.AssertSecurityProfileIdentifier(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterCertificateResponse = { ["certificateArn"] = true, ["certificateId"] = true, nil }

function asserts.AssertRegisterCertificateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterCertificateResponse to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterCertificateResponse[k], "RegisterCertificateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterCertificateResponse
-- <p>The output from the RegisterCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The certificate ARN.</p>
-- * certificateId [CertificateId] <p>The certificate identifier.</p>
-- @return RegisterCertificateResponse structure as a key-value pair table
function M.RegisterCertificateResponse(args)
	assert(args, "You must provide an argument table when creating RegisterCertificateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertRegisterCertificateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ClearDefaultAuthorizerResponse = { nil }

function asserts.AssertClearDefaultAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClearDefaultAuthorizerResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.ClearDefaultAuthorizerResponse[k], "ClearDefaultAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClearDefaultAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return ClearDefaultAuthorizerResponse structure as a key-value pair table
function M.ClearDefaultAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating ClearDefaultAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertClearDefaultAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteV2LoggingLevelRequest = { ["targetType"] = true, ["targetName"] = true, nil }

function asserts.AssertDeleteV2LoggingLevelRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteV2LoggingLevelRequest to be of type 'table'")
	assert(struct["targetType"], "Expected key targetType to exist in table")
	assert(struct["targetName"], "Expected key targetName to exist in table")
	if struct["targetType"] then asserts.AssertLogTargetType(struct["targetType"]) end
	if struct["targetName"] then asserts.AssertLogTargetName(struct["targetName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteV2LoggingLevelRequest[k], "DeleteV2LoggingLevelRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteV2LoggingLevelRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * targetType [LogTargetType] <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
-- * targetName [LogTargetName] <p>The name of the resource for which you are configuring logging.</p>
-- Required key: targetType
-- Required key: targetName
-- @return DeleteV2LoggingLevelRequest structure as a key-value pair table
function M.DeleteV2LoggingLevelRequest(args)
	assert(args, "You must provide an argument table when creating DeleteV2LoggingLevelRequest")
    local query_args = { 
        ["targetType"] = args["targetType"],
        ["targetName"] = args["targetName"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["targetType"] = args["targetType"],
		["targetName"] = args["targetName"],
	}
	asserts.AssertDeleteV2LoggingLevelRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingRegistrationTaskResponse = { ["status"] = true, ["templateBody"] = true, ["lastModifiedDate"] = true, ["roleArn"] = true, ["inputFileKey"] = true, ["inputFileBucket"] = true, ["failureCount"] = true, ["taskId"] = true, ["percentageProgress"] = true, ["message"] = true, ["creationDate"] = true, ["successCount"] = true, nil }

function asserts.AssertDescribeThingRegistrationTaskResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingRegistrationTaskResponse to be of type 'table'")
	if struct["status"] then asserts.AssertStatus(struct["status"]) end
	if struct["templateBody"] then asserts.AssertTemplateBody(struct["templateBody"]) end
	if struct["lastModifiedDate"] then asserts.AssertLastModifiedDate(struct["lastModifiedDate"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["inputFileKey"] then asserts.AssertRegistryS3KeyName(struct["inputFileKey"]) end
	if struct["inputFileBucket"] then asserts.AssertRegistryS3BucketName(struct["inputFileBucket"]) end
	if struct["failureCount"] then asserts.AssertCount(struct["failureCount"]) end
	if struct["taskId"] then asserts.AssertTaskId(struct["taskId"]) end
	if struct["percentageProgress"] then asserts.AssertPercentage(struct["percentageProgress"]) end
	if struct["message"] then asserts.AssertErrorMessage(struct["message"]) end
	if struct["creationDate"] then asserts.AssertCreationDate(struct["creationDate"]) end
	if struct["successCount"] then asserts.AssertCount(struct["successCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingRegistrationTaskResponse[k], "DescribeThingRegistrationTaskResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingRegistrationTaskResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [Status] <p>The status of the bulk thing provisioning task.</p>
-- * templateBody [TemplateBody] <p>The task's template.</p>
-- * lastModifiedDate [LastModifiedDate] <p>The date when the task was last modified.</p>
-- * roleArn [RoleArn] <p>The role ARN that grants access to the input file bucket.</p>
-- * inputFileKey [RegistryS3KeyName] <p>The input file key.</p>
-- * inputFileBucket [RegistryS3BucketName] <p>The S3 bucket that contains the input file.</p>
-- * failureCount [Count] <p>The number of things that failed to be provisioned.</p>
-- * taskId [TaskId] <p>The task ID.</p>
-- * percentageProgress [Percentage] <p>The progress of the bulk provisioning task expressed as a percentage.</p>
-- * message [ErrorMessage] <p>The message.</p>
-- * creationDate [CreationDate] <p>The task creation date.</p>
-- * successCount [Count] <p>The number of things successfully provisioned.</p>
-- @return DescribeThingRegistrationTaskResponse structure as a key-value pair table
function M.DescribeThingRegistrationTaskResponse(args)
	assert(args, "You must provide an argument table when creating DescribeThingRegistrationTaskResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["templateBody"] = args["templateBody"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["roleArn"] = args["roleArn"],
		["inputFileKey"] = args["inputFileKey"],
		["inputFileBucket"] = args["inputFileBucket"],
		["failureCount"] = args["failureCount"],
		["taskId"] = args["taskId"],
		["percentageProgress"] = args["percentageProgress"],
		["message"] = args["message"],
		["creationDate"] = args["creationDate"],
		["successCount"] = args["successCount"],
	}
	asserts.AssertDescribeThingRegistrationTaskResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GroupNameAndArn = { ["groupName"] = true, ["groupArn"] = true, nil }

function asserts.AssertGroupNameAndArn(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GroupNameAndArn to be of type 'table'")
	if struct["groupName"] then asserts.AssertThingGroupName(struct["groupName"]) end
	if struct["groupArn"] then asserts.AssertThingGroupArn(struct["groupArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.GroupNameAndArn[k], "GroupNameAndArn contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GroupNameAndArn
-- <p>The name and ARN of a group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * groupName [ThingGroupName] <p>The group name.</p>
-- * groupArn [ThingGroupArn] <p>The group ARN.</p>
-- @return GroupNameAndArn structure as a key-value pair table
function M.GroupNameAndArn(args)
	assert(args, "You must provide an argument table when creating GroupNameAndArn")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["groupName"] = args["groupName"],
		["groupArn"] = args["groupArn"],
	}
	asserts.AssertGroupNameAndArn(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingIndexingConfiguration = { ["thingIndexingMode"] = true, nil }

function asserts.AssertThingIndexingConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingIndexingConfiguration to be of type 'table'")
	assert(struct["thingIndexingMode"], "Expected key thingIndexingMode to exist in table")
	if struct["thingIndexingMode"] then asserts.AssertThingIndexingMode(struct["thingIndexingMode"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingIndexingConfiguration[k], "ThingIndexingConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingIndexingConfiguration
-- <p>Thing indexing configuration.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingIndexingMode [ThingIndexingMode] <p>Thing indexing mode. Valid values are: </p> <ul> <li> <p>REGISTRY – Your thing index will contain only registry data.</p> </li> <li> <p>REGISTRY_AND_SHADOW - Your thing index will contain registry and shadow data.</p> </li> <li> <p>OFF - Thing indexing is disabled.</p> </li> </ul>
-- Required key: thingIndexingMode
-- @return ThingIndexingConfiguration structure as a key-value pair table
function M.ThingIndexingConfiguration(args)
	assert(args, "You must provide an argument table when creating ThingIndexingConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingIndexingMode"] = args["thingIndexingMode"],
	}
	asserts.AssertThingIndexingConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelAuditTaskRequest = { ["taskId"] = true, nil }

function asserts.AssertCancelAuditTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelAuditTaskRequest to be of type 'table'")
	assert(struct["taskId"], "Expected key taskId to exist in table")
	if struct["taskId"] then asserts.AssertAuditTaskId(struct["taskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelAuditTaskRequest[k], "CancelAuditTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelAuditTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskId [AuditTaskId] <p>The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".</p>
-- Required key: taskId
-- @return CancelAuditTaskRequest structure as a key-value pair table
function M.CancelAuditTaskRequest(args)
	assert(args, "You must provide an argument table when creating CancelAuditTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{taskId}"] = args["taskId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["taskId"] = args["taskId"],
	}
	asserts.AssertCancelAuditTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateThingGroupsForThingResponse = { nil }

function asserts.AssertUpdateThingGroupsForThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateThingGroupsForThingResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.UpdateThingGroupsForThingResponse[k], "UpdateThingGroupsForThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateThingGroupsForThingResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return UpdateThingGroupsForThingResponse structure as a key-value pair table
function M.UpdateThingGroupsForThingResponse(args)
	assert(args, "You must provide an argument table when creating UpdateThingGroupsForThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertUpdateThingGroupsForThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateRoleAliasResponse = { ["roleAlias"] = true, ["roleAliasArn"] = true, nil }

function asserts.AssertCreateRoleAliasResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRoleAliasResponse to be of type 'table'")
	if struct["roleAlias"] then asserts.AssertRoleAlias(struct["roleAlias"]) end
	if struct["roleAliasArn"] then asserts.AssertRoleAliasArn(struct["roleAliasArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRoleAliasResponse[k], "CreateRoleAliasResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRoleAliasResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleAlias [RoleAlias] <p>The role alias.</p>
-- * roleAliasArn [RoleAliasArn] <p>The role alias ARN.</p>
-- @return CreateRoleAliasResponse structure as a key-value pair table
function M.CreateRoleAliasResponse(args)
	assert(args, "You must provide an argument table when creating CreateRoleAliasResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleAlias"] = args["roleAlias"],
		["roleAliasArn"] = args["roleAliasArn"],
	}
	asserts.AssertCreateRoleAliasResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSecurityProfileRequest = { ["behaviors"] = true, ["alertTargets"] = true, ["securityProfileName"] = true, ["securityProfileDescription"] = true, nil }

function asserts.AssertCreateSecurityProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityProfileRequest to be of type 'table'")
	assert(struct["securityProfileName"], "Expected key securityProfileName to exist in table")
	assert(struct["behaviors"], "Expected key behaviors to exist in table")
	if struct["behaviors"] then asserts.AssertBehaviors(struct["behaviors"]) end
	if struct["alertTargets"] then asserts.AssertAlertTargets(struct["alertTargets"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["securityProfileDescription"] then asserts.AssertSecurityProfileDescription(struct["securityProfileDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityProfileRequest[k], "CreateSecurityProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * behaviors [Behaviors] <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
-- * alertTargets [AlertTargets] <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.</p>
-- * securityProfileName [SecurityProfileName] <p>The name you are giving to the security profile.</p>
-- * securityProfileDescription [SecurityProfileDescription] <p>A description of the security profile.</p>
-- Required key: securityProfileName
-- Required key: behaviors
-- @return CreateSecurityProfileRequest structure as a key-value pair table
function M.CreateSecurityProfileRequest(args)
	assert(args, "You must provide an argument table when creating CreateSecurityProfileRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{securityProfileName}"] = args["securityProfileName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["behaviors"] = args["behaviors"],
		["alertTargets"] = args["alertTargets"],
		["securityProfileName"] = args["securityProfileName"],
		["securityProfileDescription"] = args["securityProfileDescription"],
	}
	asserts.AssertCreateSecurityProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeletePolicyRequest = { ["policyName"] = true, nil }

function asserts.AssertDeletePolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeletePolicyRequest[k], "DeletePolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePolicyRequest
-- <p>The input for the DeletePolicy operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The name of the policy to delete.</p>
-- Required key: policyName
-- @return DeletePolicyRequest structure as a key-value pair table
function M.DeletePolicyRequest(args)
	assert(args, "You must provide an argument table when creating DeletePolicyRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
	}
	asserts.AssertDeletePolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PolicyVersionIdentifier = { ["policyName"] = true, ["policyVersionId"] = true, nil }

function asserts.AssertPolicyVersionIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PolicyVersionIdentifier to be of type 'table'")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyVersionId"] then asserts.AssertPolicyVersionId(struct["policyVersionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PolicyVersionIdentifier[k], "PolicyVersionIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PolicyVersionIdentifier
-- <p>Information about the version of the policy associated with the resource.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The name of the policy.</p>
-- * policyVersionId [PolicyVersionId] <p>The ID of the version of the policy associated with the resource.</p>
-- @return PolicyVersionIdentifier structure as a key-value pair table
function M.PolicyVersionIdentifier(args)
	assert(args, "You must provide an argument table when creating PolicyVersionIdentifier")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyVersionId"] = args["policyVersionId"],
	}
	asserts.AssertPolicyVersionIdentifier(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateStreamResponse = { ["streamVersion"] = true, ["streamArn"] = true, ["description"] = true, ["streamId"] = true, nil }

function asserts.AssertUpdateStreamResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateStreamResponse to be of type 'table'")
	if struct["streamVersion"] then asserts.AssertStreamVersion(struct["streamVersion"]) end
	if struct["streamArn"] then asserts.AssertStreamArn(struct["streamArn"]) end
	if struct["description"] then asserts.AssertStreamDescription(struct["description"]) end
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateStreamResponse[k], "UpdateStreamResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateStreamResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * streamVersion [StreamVersion] <p>The stream version.</p>
-- * streamArn [StreamArn] <p>The stream ARN.</p>
-- * description [StreamDescription] <p>A description of the stream.</p>
-- * streamId [StreamId] <p>The stream ID.</p>
-- @return UpdateStreamResponse structure as a key-value pair table
function M.UpdateStreamResponse(args)
	assert(args, "You must provide an argument table when creating UpdateStreamResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["streamVersion"] = args["streamVersion"],
		["streamArn"] = args["streamArn"],
		["description"] = args["description"],
		["streamId"] = args["streamId"],
	}
	asserts.AssertUpdateStreamResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListJobExecutionsForJobResponse = { ["nextToken"] = true, ["executionSummaries"] = true, nil }

function asserts.AssertListJobExecutionsForJobResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListJobExecutionsForJobResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["executionSummaries"] then asserts.AssertJobExecutionSummaryForJobList(struct["executionSummaries"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListJobExecutionsForJobResponse[k], "ListJobExecutionsForJobResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListJobExecutionsForJobResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
-- * executionSummaries [JobExecutionSummaryForJobList] <p>A list of job execution summaries.</p>
-- @return ListJobExecutionsForJobResponse structure as a key-value pair table
function M.ListJobExecutionsForJobResponse(args)
	assert(args, "You must provide an argument table when creating ListJobExecutionsForJobResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["executionSummaries"] = args["executionSummaries"],
	}
	asserts.AssertListJobExecutionsForJobResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateThingTypeRequest = { ["thingTypeName"] = true, ["thingTypeProperties"] = true, nil }

function asserts.AssertCreateThingTypeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateThingTypeRequest to be of type 'table'")
	assert(struct["thingTypeName"], "Expected key thingTypeName to exist in table")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["thingTypeProperties"] then asserts.AssertThingTypeProperties(struct["thingTypeProperties"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateThingTypeRequest[k], "CreateThingTypeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateThingTypeRequest
-- <p>The input for the CreateThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- * thingTypeProperties [ThingTypeProperties] <p>The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.</p>
-- Required key: thingTypeName
-- @return CreateThingTypeRequest structure as a key-value pair table
function M.CreateThingTypeRequest(args)
	assert(args, "You must provide an argument table when creating CreateThingTypeRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingTypeName}"] = args["thingTypeName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["thingTypeProperties"] = args["thingTypeProperties"],
	}
	asserts.AssertCreateThingTypeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingsRequest = { ["thingTypeName"] = true, ["nextToken"] = true, ["attributeName"] = true, ["attributeValue"] = true, ["maxResults"] = true, nil }

function asserts.AssertListThingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingsRequest to be of type 'table'")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["attributeName"] then asserts.AssertAttributeName(struct["attributeName"]) end
	if struct["attributeValue"] then asserts.AssertAttributeValue(struct["attributeValue"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingsRequest[k], "ListThingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingsRequest
-- <p>The input for the ListThings operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type used to search for things.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * attributeName [AttributeName] <p>The attribute name used to search for things.</p>
-- * attributeValue [AttributeValue] <p>The attribute value used to search for things.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return in this operation.</p>
-- @return ListThingsRequest structure as a key-value pair table
function M.ListThingsRequest(args)
	assert(args, "You must provide an argument table when creating ListThingsRequest")
    local query_args = { 
        ["thingTypeName"] = args["thingTypeName"],
        ["nextToken"] = args["nextToken"],
        ["attributeName"] = args["attributeName"],
        ["attributeValue"] = args["attributeValue"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["nextToken"] = args["nextToken"],
		["attributeName"] = args["attributeName"],
		["attributeValue"] = args["attributeValue"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListThingsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListScheduledAuditsRequest = { ["nextToken"] = true, ["maxResults"] = true, nil }

function asserts.AssertListScheduledAuditsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListScheduledAuditsRequest to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListScheduledAuditsRequest[k], "ListScheduledAuditsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListScheduledAuditsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time. The default is 25.</p>
-- @return ListScheduledAuditsRequest structure as a key-value pair table
function M.ListScheduledAuditsRequest(args)
	assert(args, "You must provide an argument table when creating ListScheduledAuditsRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListScheduledAuditsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAuthorizersRequest = { ["marker"] = true, ["ascendingOrder"] = true, ["status"] = true, ["pageSize"] = true, nil }

function asserts.AssertListAuthorizersRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAuthorizersRequest to be of type 'table'")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["status"] then asserts.AssertAuthorizerStatus(struct["status"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAuthorizersRequest[k], "ListAuthorizersRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAuthorizersRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>A marker used to get the next set of results.</p>
-- * ascendingOrder [AscendingOrder] <p>Return the list of authorizers in ascending alphabetical order.</p>
-- * status [AuthorizerStatus] <p>The status of the list authorizers request.</p>
-- * pageSize [PageSize] <p>The maximum number of results to return at one time.</p>
-- @return ListAuthorizersRequest structure as a key-value pair table
function M.ListAuthorizersRequest(args)
	assert(args, "You must provide an argument table when creating ListAuthorizersRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["status"] = args["status"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["ascendingOrder"] = args["ascendingOrder"],
		["status"] = args["status"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListAuthorizersRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Stream = { ["fileId"] = true, ["streamId"] = true, nil }

function asserts.AssertStream(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Stream to be of type 'table'")
	if struct["fileId"] then asserts.AssertFileId(struct["fileId"]) end
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Stream[k], "Stream contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Stream
-- <p>Describes a group of files that can be streamed.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * fileId [FileId] <p>The ID of a file associated with a stream.</p>
-- * streamId [StreamId] <p>The stream ID.</p>
-- @return Stream structure as a key-value pair table
function M.Stream(args)
	assert(args, "You must provide an argument table when creating Stream")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["fileId"] = args["fileId"],
		["streamId"] = args["streamId"],
	}
	asserts.AssertStream(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CodeSigning = { ["customCodeSigning"] = true, ["awsSignerJobId"] = true, ["startSigningJobParameter"] = true, nil }

function asserts.AssertCodeSigning(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CodeSigning to be of type 'table'")
	if struct["customCodeSigning"] then asserts.AssertCustomCodeSigning(struct["customCodeSigning"]) end
	if struct["awsSignerJobId"] then asserts.AssertSigningJobId(struct["awsSignerJobId"]) end
	if struct["startSigningJobParameter"] then asserts.AssertStartSigningJobParameter(struct["startSigningJobParameter"]) end
	for k,_ in pairs(struct) do
		assert(keys.CodeSigning[k], "CodeSigning contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CodeSigning
-- <p>Describes the method to use when code signing a file.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * customCodeSigning [CustomCodeSigning] <p>A custom method for code signing a file.</p>
-- * awsSignerJobId [SigningJobId] <p>The ID of the AWSSignerJob which was created to sign the file.</p>
-- * startSigningJobParameter [StartSigningJobParameter] <p>Describes the code-signing job.</p>
-- @return CodeSigning structure as a key-value pair table
function M.CodeSigning(args)
	assert(args, "You must provide an argument table when creating CodeSigning")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["customCodeSigning"] = args["customCodeSigning"],
		["awsSignerJobId"] = args["awsSignerJobId"],
		["startSigningJobParameter"] = args["startSigningJobParameter"],
	}
	asserts.AssertCodeSigning(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Certificate = { ["certificateArn"] = true, ["status"] = true, ["creationDate"] = true, ["certificateId"] = true, nil }

function asserts.AssertCertificate(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Certificate to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["status"] then asserts.AssertCertificateStatus(struct["status"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Certificate[k], "Certificate contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Certificate
-- <p>Information about a certificate.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The ARN of the certificate.</p>
-- * status [CertificateStatus] <p>The status of the certificate.</p> <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
-- * creationDate [DateType] <p>The date and time the certificate was created.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- @return Certificate structure as a key-value pair table
function M.Certificate(args)
	assert(args, "You must provide an argument table when creating Certificate")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["status"] = args["status"],
		["creationDate"] = args["creationDate"],
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertCertificate(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateSecurityProfileResponse = { ["behaviors"] = true, ["securityProfileName"] = true, ["lastModifiedDate"] = true, ["securityProfileDescription"] = true, ["alertTargets"] = true, ["version"] = true, ["securityProfileArn"] = true, ["creationDate"] = true, nil }

function asserts.AssertUpdateSecurityProfileResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateSecurityProfileResponse to be of type 'table'")
	if struct["behaviors"] then asserts.AssertBehaviors(struct["behaviors"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["lastModifiedDate"] then asserts.AssertTimestamp(struct["lastModifiedDate"]) end
	if struct["securityProfileDescription"] then asserts.AssertSecurityProfileDescription(struct["securityProfileDescription"]) end
	if struct["alertTargets"] then asserts.AssertAlertTargets(struct["alertTargets"]) end
	if struct["version"] then asserts.AssertVersion(struct["version"]) end
	if struct["securityProfileArn"] then asserts.AssertSecurityProfileArn(struct["securityProfileArn"]) end
	if struct["creationDate"] then asserts.AssertTimestamp(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateSecurityProfileResponse[k], "UpdateSecurityProfileResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateSecurityProfileResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * behaviors [Behaviors] <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
-- * securityProfileName [SecurityProfileName] <p>The name of the security profile that was updated.</p>
-- * lastModifiedDate [Timestamp] <p>The time the security profile was last modified.</p>
-- * securityProfileDescription [SecurityProfileDescription] <p>The description of the security profile.</p>
-- * alertTargets [AlertTargets] <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
-- * version [Version] <p>The updated version of the security profile.</p>
-- * securityProfileArn [SecurityProfileArn] <p>The ARN of the security profile that was updated.</p>
-- * creationDate [Timestamp] <p>The time the security profile was created.</p>
-- @return UpdateSecurityProfileResponse structure as a key-value pair table
function M.UpdateSecurityProfileResponse(args)
	assert(args, "You must provide an argument table when creating UpdateSecurityProfileResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["behaviors"] = args["behaviors"],
		["securityProfileName"] = args["securityProfileName"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["securityProfileDescription"] = args["securityProfileDescription"],
		["alertTargets"] = args["alertTargets"],
		["version"] = args["version"],
		["securityProfileArn"] = args["securityProfileArn"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertUpdateSecurityProfileResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttributePayload = { ["attributes"] = true, ["merge"] = true, nil }

function asserts.AssertAttributePayload(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributePayload to be of type 'table'")
	if struct["attributes"] then asserts.AssertAttributes(struct["attributes"]) end
	if struct["merge"] then asserts.AssertFlag(struct["merge"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttributePayload[k], "AttributePayload contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributePayload
-- <p>The attribute payload.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * attributes [Attributes] <p>A JSON string containing up to three key-value pair in JSON format. For example:</p> <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
-- * merge [Flag] <p>Specifies whether the list of attributes provided in the <code>AttributePayload</code> is merged with the attributes stored in the registry, instead of overwriting them.</p> <p>To remove an attribute, call <code>UpdateThing</code> with an empty attribute value.</p> <note> <p>The <code>merge</code> attribute is only valid when calling <code>UpdateThing</code>.</p> </note>
-- @return AttributePayload structure as a key-value pair table
function M.AttributePayload(args)
	assert(args, "You must provide an argument table when creating AttributePayload")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["attributes"] = args["attributes"],
		["merge"] = args["merge"],
	}
	asserts.AssertAttributePayload(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AcceptCertificateTransferRequest = { ["certificateId"] = true, ["setAsActive"] = true, nil }

function asserts.AssertAcceptCertificateTransferRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptCertificateTransferRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["setAsActive"] then asserts.AssertSetAsActive(struct["setAsActive"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptCertificateTransferRequest[k], "AcceptCertificateTransferRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptCertificateTransferRequest
-- <p>The input for the AcceptCertificateTransfer operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- * setAsActive [SetAsActive] <p>Specifies whether the certificate is active.</p>
-- Required key: certificateId
-- @return AcceptCertificateTransferRequest structure as a key-value pair table
function M.AcceptCertificateTransferRequest(args)
	assert(args, "You must provide an argument table when creating AcceptCertificateTransferRequest")
    local query_args = { 
        ["setAsActive"] = args["setAsActive"],
    }
    local uri_args = { 
        ["{certificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateId"] = args["certificateId"],
		["setAsActive"] = args["setAsActive"],
	}
	asserts.AssertAcceptCertificateTransferRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSecurityProfileResponse = { ["behaviors"] = true, ["securityProfileName"] = true, ["lastModifiedDate"] = true, ["securityProfileDescription"] = true, ["alertTargets"] = true, ["version"] = true, ["securityProfileArn"] = true, ["creationDate"] = true, nil }

function asserts.AssertDescribeSecurityProfileResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityProfileResponse to be of type 'table'")
	if struct["behaviors"] then asserts.AssertBehaviors(struct["behaviors"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["lastModifiedDate"] then asserts.AssertTimestamp(struct["lastModifiedDate"]) end
	if struct["securityProfileDescription"] then asserts.AssertSecurityProfileDescription(struct["securityProfileDescription"]) end
	if struct["alertTargets"] then asserts.AssertAlertTargets(struct["alertTargets"]) end
	if struct["version"] then asserts.AssertVersion(struct["version"]) end
	if struct["securityProfileArn"] then asserts.AssertSecurityProfileArn(struct["securityProfileArn"]) end
	if struct["creationDate"] then asserts.AssertTimestamp(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityProfileResponse[k], "DescribeSecurityProfileResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityProfileResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * behaviors [Behaviors] <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
-- * securityProfileName [SecurityProfileName] <p>The name of the security profile.</p>
-- * lastModifiedDate [Timestamp] <p>The time the security profile was last modified.</p>
-- * securityProfileDescription [SecurityProfileDescription] <p>A description of the security profile (associated with the security profile when it was created or updated).</p>
-- * alertTargets [AlertTargets] <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
-- * version [Version] <p>The version of the security profile. A new version is generated whenever the security profile is updated.</p>
-- * securityProfileArn [SecurityProfileArn] <p>The ARN of the security profile.</p>
-- * creationDate [Timestamp] <p>The time the security profile was created.</p>
-- @return DescribeSecurityProfileResponse structure as a key-value pair table
function M.DescribeSecurityProfileResponse(args)
	assert(args, "You must provide an argument table when creating DescribeSecurityProfileResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["behaviors"] = args["behaviors"],
		["securityProfileName"] = args["securityProfileName"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["securityProfileDescription"] = args["securityProfileDescription"],
		["alertTargets"] = args["alertTargets"],
		["version"] = args["version"],
		["securityProfileArn"] = args["securityProfileArn"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertDescribeSecurityProfileResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SqsAction = { ["queueUrl"] = true, ["roleArn"] = true, ["useBase64"] = true, nil }

function asserts.AssertSqsAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SqsAction to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["queueUrl"], "Expected key queueUrl to exist in table")
	if struct["queueUrl"] then asserts.AssertQueueUrl(struct["queueUrl"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["useBase64"] then asserts.AssertUseBase64(struct["useBase64"]) end
	for k,_ in pairs(struct) do
		assert(keys.SqsAction[k], "SqsAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SqsAction
-- <p>Describes an action to publish data to an Amazon SQS queue.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * queueUrl [QueueUrl] <p>The URL of the Amazon SQS queue.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access.</p>
-- * useBase64 [UseBase64] <p>Specifies whether to use Base64 encoding.</p>
-- Required key: roleArn
-- Required key: queueUrl
-- @return SqsAction structure as a key-value pair table
function M.SqsAction(args)
	assert(args, "You must provide an argument table when creating SqsAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["queueUrl"] = args["queueUrl"],
		["roleArn"] = args["roleArn"],
		["useBase64"] = args["useBase64"],
	}
	asserts.AssertSqsAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TopicRulePayload = { ["description"] = true, ["actions"] = true, ["sql"] = true, ["awsIotSqlVersion"] = true, ["ruleDisabled"] = true, ["errorAction"] = true, nil }

function asserts.AssertTopicRulePayload(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TopicRulePayload to be of type 'table'")
	assert(struct["sql"], "Expected key sql to exist in table")
	assert(struct["actions"], "Expected key actions to exist in table")
	if struct["description"] then asserts.AssertDescription(struct["description"]) end
	if struct["actions"] then asserts.AssertActionList(struct["actions"]) end
	if struct["sql"] then asserts.AssertSQL(struct["sql"]) end
	if struct["awsIotSqlVersion"] then asserts.AssertAwsIotSqlVersion(struct["awsIotSqlVersion"]) end
	if struct["ruleDisabled"] then asserts.AssertIsDisabled(struct["ruleDisabled"]) end
	if struct["errorAction"] then asserts.AssertAction(struct["errorAction"]) end
	for k,_ in pairs(struct) do
		assert(keys.TopicRulePayload[k], "TopicRulePayload contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TopicRulePayload
-- <p>Describes a rule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * description [Description] <p>The description of the rule.</p>
-- * actions [ActionList] <p>The actions associated with the rule.</p>
-- * sql [SQL] <p>The SQL statement used to query the topic. For more information, see <a href="http://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference">AWS IoT SQL Reference</a> in the <i>AWS IoT Developer Guide</i>.</p>
-- * awsIotSqlVersion [AwsIotSqlVersion] <p>The version of the SQL rules engine to use when evaluating the rule.</p>
-- * ruleDisabled [IsDisabled] <p>Specifies whether the rule is disabled.</p>
-- * errorAction [Action] <p>The action to take when an error occurs.</p>
-- Required key: sql
-- Required key: actions
-- @return TopicRulePayload structure as a key-value pair table
function M.TopicRulePayload(args)
	assert(args, "You must provide an argument table when creating TopicRulePayload")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["description"] = args["description"],
		["actions"] = args["actions"],
		["sql"] = args["sql"],
		["awsIotSqlVersion"] = args["awsIotSqlVersion"],
		["ruleDisabled"] = args["ruleDisabled"],
		["errorAction"] = args["errorAction"],
	}
	asserts.AssertTopicRulePayload(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeJobRequest = { ["jobId"] = true, nil }

function asserts.AssertDescribeJobRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeJobRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeJobRequest[k], "DescribeJobRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeJobRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- Required key: jobId
-- @return DescribeJobRequest structure as a key-value pair table
function M.DescribeJobRequest(args)
	assert(args, "You must provide an argument table when creating DescribeJobRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["jobId"] = args["jobId"],
	}
	asserts.AssertDescribeJobRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuditFinding = { ["relatedResources"] = true, ["severity"] = true, ["nonCompliantResource"] = true, ["reasonForNonCompliance"] = true, ["reasonForNonComplianceCode"] = true, ["checkName"] = true, ["taskId"] = true, ["taskStartTime"] = true, ["findingTime"] = true, nil }

function asserts.AssertAuditFinding(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuditFinding to be of type 'table'")
	if struct["relatedResources"] then asserts.AssertRelatedResources(struct["relatedResources"]) end
	if struct["severity"] then asserts.AssertAuditFindingSeverity(struct["severity"]) end
	if struct["nonCompliantResource"] then asserts.AssertNonCompliantResource(struct["nonCompliantResource"]) end
	if struct["reasonForNonCompliance"] then asserts.AssertReasonForNonCompliance(struct["reasonForNonCompliance"]) end
	if struct["reasonForNonComplianceCode"] then asserts.AssertReasonForNonComplianceCode(struct["reasonForNonComplianceCode"]) end
	if struct["checkName"] then asserts.AssertAuditCheckName(struct["checkName"]) end
	if struct["taskId"] then asserts.AssertAuditTaskId(struct["taskId"]) end
	if struct["taskStartTime"] then asserts.AssertTimestamp(struct["taskStartTime"]) end
	if struct["findingTime"] then asserts.AssertTimestamp(struct["findingTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuditFinding[k], "AuditFinding contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuditFinding
-- <p>The findings (results) of the audit.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * relatedResources [RelatedResources] <p>The list of related resources.</p>
-- * severity [AuditFindingSeverity] <p>The severity of the result (finding).</p>
-- * nonCompliantResource [NonCompliantResource] <p>The resource that was found to be non-compliant with the audit check.</p>
-- * reasonForNonCompliance [ReasonForNonCompliance] <p>The reason the resource was non-compliant.</p>
-- * reasonForNonComplianceCode [ReasonForNonComplianceCode] <p>A code which indicates the reason that the resource was non-compliant.</p>
-- * checkName [AuditCheckName] <p>The audit check that generated this result.</p>
-- * taskId [AuditTaskId] <p>The ID of the audit that generated this result (finding)</p>
-- * taskStartTime [Timestamp] <p>The time the audit started.</p>
-- * findingTime [Timestamp] <p>The time the result (finding) was discovered.</p>
-- @return AuditFinding structure as a key-value pair table
function M.AuditFinding(args)
	assert(args, "You must provide an argument table when creating AuditFinding")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["relatedResources"] = args["relatedResources"],
		["severity"] = args["severity"],
		["nonCompliantResource"] = args["nonCompliantResource"],
		["reasonForNonCompliance"] = args["reasonForNonCompliance"],
		["reasonForNonComplianceCode"] = args["reasonForNonComplianceCode"],
		["checkName"] = args["checkName"],
		["taskId"] = args["taskId"],
		["taskStartTime"] = args["taskStartTime"],
		["findingTime"] = args["findingTime"],
	}
	asserts.AssertAuditFinding(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEventConfigurationsRequest = { nil }

function asserts.AssertDescribeEventConfigurationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEventConfigurationsRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DescribeEventConfigurationsRequest[k], "DescribeEventConfigurationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEventConfigurationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DescribeEventConfigurationsRequest structure as a key-value pair table
function M.DescribeEventConfigurationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeEventConfigurationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDescribeEventConfigurationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuthInfo = { ["actionType"] = true, ["resources"] = true, nil }

function asserts.AssertAuthInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthInfo to be of type 'table'")
	if struct["actionType"] then asserts.AssertActionType(struct["actionType"]) end
	if struct["resources"] then asserts.AssertResources(struct["resources"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthInfo[k], "AuthInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthInfo
-- <p>A collection of authorization information.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * actionType [ActionType] <p>The type of action for which the principal is being authorized.</p>
-- * resources [Resources] <p>The resources for which the principal is being authorized to perform the specified action.</p>
-- @return AuthInfo structure as a key-value pair table
function M.AuthInfo(args)
	assert(args, "You must provide an argument table when creating AuthInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["actionType"] = args["actionType"],
		["resources"] = args["resources"],
	}
	asserts.AssertAuthInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachPolicyRequest = { ["policyName"] = true, ["target"] = true, nil }

function asserts.AssertAttachPolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachPolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["target"], "Expected key target to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["target"] then asserts.AssertPolicyTarget(struct["target"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachPolicyRequest[k], "AttachPolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachPolicyRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The name of the policy to attach.</p>
-- * target [PolicyTarget] <p>The identity to which the policy is attached.</p>
-- Required key: policyName
-- Required key: target
-- @return AttachPolicyRequest structure as a key-value pair table
function M.AttachPolicyRequest(args)
	assert(args, "You must provide an argument table when creating AttachPolicyRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["target"] = args["target"],
	}
	asserts.AssertAttachPolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AwsJobExecutionsRolloutConfig = { ["maximumPerMinute"] = true, nil }

function asserts.AssertAwsJobExecutionsRolloutConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AwsJobExecutionsRolloutConfig to be of type 'table'")
	if struct["maximumPerMinute"] then asserts.AssertMaximumPerMinute(struct["maximumPerMinute"]) end
	for k,_ in pairs(struct) do
		assert(keys.AwsJobExecutionsRolloutConfig[k], "AwsJobExecutionsRolloutConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AwsJobExecutionsRolloutConfig
-- <p>Configuration for the rollout of OTA updates.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * maximumPerMinute [MaximumPerMinute] <p>The maximum number of OTA update job executions started per minute.</p>
-- @return AwsJobExecutionsRolloutConfig structure as a key-value pair table
function M.AwsJobExecutionsRolloutConfig(args)
	assert(args, "You must provide an argument table when creating AwsJobExecutionsRolloutConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["maximumPerMinute"] = args["maximumPerMinute"],
	}
	asserts.AssertAwsJobExecutionsRolloutConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobExecutionStatusDetails = { ["detailsMap"] = true, nil }

function asserts.AssertJobExecutionStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobExecutionStatusDetails to be of type 'table'")
	if struct["detailsMap"] then asserts.AssertDetailsMap(struct["detailsMap"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobExecutionStatusDetails[k], "JobExecutionStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobExecutionStatusDetails
-- <p>Details of the job execution status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * detailsMap [DetailsMap] <p>The job execution status.</p>
-- @return JobExecutionStatusDetails structure as a key-value pair table
function M.JobExecutionStatusDetails(args)
	assert(args, "You must provide an argument table when creating JobExecutionStatusDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["detailsMap"] = args["detailsMap"],
	}
	asserts.AssertJobExecutionStatusDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTargetsForSecurityProfileRequest = { ["nextToken"] = true, ["securityProfileName"] = true, ["maxResults"] = true, nil }

function asserts.AssertListTargetsForSecurityProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTargetsForSecurityProfileRequest to be of type 'table'")
	assert(struct["securityProfileName"], "Expected key securityProfileName to exist in table")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTargetsForSecurityProfileRequest[k], "ListTargetsForSecurityProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTargetsForSecurityProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- * securityProfileName [SecurityProfileName] <p>The security profile.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time.</p>
-- Required key: securityProfileName
-- @return ListTargetsForSecurityProfileRequest structure as a key-value pair table
function M.ListTargetsForSecurityProfileRequest(args)
	assert(args, "You must provide an argument table when creating ListTargetsForSecurityProfileRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
        ["{securityProfileName}"] = args["securityProfileName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["securityProfileName"] = args["securityProfileName"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListTargetsForSecurityProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingRegistrationTaskReportsResponse = { ["resourceLinks"] = true, ["nextToken"] = true, ["reportType"] = true, nil }

function asserts.AssertListThingRegistrationTaskReportsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingRegistrationTaskReportsResponse to be of type 'table'")
	if struct["resourceLinks"] then asserts.AssertS3FileUrlList(struct["resourceLinks"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["reportType"] then asserts.AssertReportType(struct["reportType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingRegistrationTaskReportsResponse[k], "ListThingRegistrationTaskReportsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingRegistrationTaskReportsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * resourceLinks [S3FileUrlList] <p>Links to the task resources.</p>
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * reportType [ReportType] <p>The type of task report.</p>
-- @return ListThingRegistrationTaskReportsResponse structure as a key-value pair table
function M.ListThingRegistrationTaskReportsResponse(args)
	assert(args, "You must provide an argument table when creating ListThingRegistrationTaskReportsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["resourceLinks"] = args["resourceLinks"],
		["nextToken"] = args["nextToken"],
		["reportType"] = args["reportType"],
	}
	asserts.AssertListThingRegistrationTaskReportsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCertificateRequest = { ["certificateId"] = true, nil }

function asserts.AssertDescribeCertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCertificateRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCertificateRequest[k], "DescribeCertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCertificateRequest
-- <p>The input for the DescribeCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- Required key: certificateId
-- @return DescribeCertificateRequest structure as a key-value pair table
function M.DescribeCertificateRequest(args)
	assert(args, "You must provide an argument table when creating DescribeCertificateRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{certificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertDescribeCertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingRegistrationTaskRequest = { ["taskId"] = true, nil }

function asserts.AssertDescribeThingRegistrationTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingRegistrationTaskRequest to be of type 'table'")
	assert(struct["taskId"], "Expected key taskId to exist in table")
	if struct["taskId"] then asserts.AssertTaskId(struct["taskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingRegistrationTaskRequest[k], "DescribeThingRegistrationTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingRegistrationTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskId [TaskId] <p>The task ID.</p>
-- Required key: taskId
-- @return DescribeThingRegistrationTaskRequest structure as a key-value pair table
function M.DescribeThingRegistrationTaskRequest(args)
	assert(args, "You must provide an argument table when creating DescribeThingRegistrationTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{taskId}"] = args["taskId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["taskId"] = args["taskId"],
	}
	asserts.AssertDescribeThingRegistrationTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TestAuthorizationResponse = { ["authResults"] = true, nil }

function asserts.AssertTestAuthorizationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TestAuthorizationResponse to be of type 'table'")
	if struct["authResults"] then asserts.AssertAuthResults(struct["authResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.TestAuthorizationResponse[k], "TestAuthorizationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TestAuthorizationResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authResults [AuthResults] <p>The authentication results.</p>
-- @return TestAuthorizationResponse structure as a key-value pair table
function M.TestAuthorizationResponse(args)
	assert(args, "You must provide an argument table when creating TestAuthorizationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authResults"] = args["authResults"],
	}
	asserts.AssertTestAuthorizationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ValidateSecurityProfileBehaviorsRequest = { ["behaviors"] = true, nil }

function asserts.AssertValidateSecurityProfileBehaviorsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ValidateSecurityProfileBehaviorsRequest to be of type 'table'")
	assert(struct["behaviors"], "Expected key behaviors to exist in table")
	if struct["behaviors"] then asserts.AssertBehaviors(struct["behaviors"]) end
	for k,_ in pairs(struct) do
		assert(keys.ValidateSecurityProfileBehaviorsRequest[k], "ValidateSecurityProfileBehaviorsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ValidateSecurityProfileBehaviorsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * behaviors [Behaviors] <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
-- Required key: behaviors
-- @return ValidateSecurityProfileBehaviorsRequest structure as a key-value pair table
function M.ValidateSecurityProfileBehaviorsRequest(args)
	assert(args, "You must provide an argument table when creating ValidateSecurityProfileBehaviorsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["behaviors"] = args["behaviors"],
	}
	asserts.AssertValidateSecurityProfileBehaviorsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetOTAUpdateRequest = { ["otaUpdateId"] = true, nil }

function asserts.AssertGetOTAUpdateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetOTAUpdateRequest to be of type 'table'")
	assert(struct["otaUpdateId"], "Expected key otaUpdateId to exist in table")
	if struct["otaUpdateId"] then asserts.AssertOTAUpdateId(struct["otaUpdateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetOTAUpdateRequest[k], "GetOTAUpdateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetOTAUpdateRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * otaUpdateId [OTAUpdateId] <p>The OTA update ID.</p>
-- Required key: otaUpdateId
-- @return GetOTAUpdateRequest structure as a key-value pair table
function M.GetOTAUpdateRequest(args)
	assert(args, "You must provide an argument table when creating GetOTAUpdateRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{otaUpdateId}"] = args["otaUpdateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["otaUpdateId"] = args["otaUpdateId"],
	}
	asserts.AssertGetOTAUpdateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCACertificateResponse = { ["registrationConfig"] = true, ["certificateDescription"] = true, nil }

function asserts.AssertDescribeCACertificateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCACertificateResponse to be of type 'table'")
	if struct["registrationConfig"] then asserts.AssertRegistrationConfig(struct["registrationConfig"]) end
	if struct["certificateDescription"] then asserts.AssertCACertificateDescription(struct["certificateDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCACertificateResponse[k], "DescribeCACertificateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCACertificateResponse
-- <p>The output from the DescribeCACertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * registrationConfig [RegistrationConfig] <p>Information about the registration configuration.</p>
-- * certificateDescription [CACertificateDescription] <p>The CA certificate description.</p>
-- @return DescribeCACertificateResponse structure as a key-value pair table
function M.DescribeCACertificateResponse(args)
	assert(args, "You must provide an argument table when creating DescribeCACertificateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["registrationConfig"] = args["registrationConfig"],
		["certificateDescription"] = args["certificateDescription"],
	}
	asserts.AssertDescribeCACertificateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FileLocation = { ["s3Location"] = true, ["stream"] = true, nil }

function asserts.AssertFileLocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FileLocation to be of type 'table'")
	if struct["s3Location"] then asserts.AssertS3Location(struct["s3Location"]) end
	if struct["stream"] then asserts.AssertStream(struct["stream"]) end
	for k,_ in pairs(struct) do
		assert(keys.FileLocation[k], "FileLocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FileLocation
-- <p>The location of the OTA update.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * s3Location [S3Location] <p>The location of the updated firmware in S3.</p>
-- * stream [Stream] <p>The stream that contains the OTA update.</p>
-- @return FileLocation structure as a key-value pair table
function M.FileLocation(args)
	assert(args, "You must provide an argument table when creating FileLocation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["s3Location"] = args["s3Location"],
		["stream"] = args["stream"],
	}
	asserts.AssertFileLocation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingsResponse = { ["things"] = true, ["nextToken"] = true, nil }

function asserts.AssertListThingsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingsResponse to be of type 'table'")
	if struct["things"] then asserts.AssertThingAttributeList(struct["things"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingsResponse[k], "ListThingsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingsResponse
-- <p>The output from the ListThings operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * things [ThingAttributeList] <p>The things.</p>
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- @return ListThingsResponse structure as a key-value pair table
function M.ListThingsResponse(args)
	assert(args, "You must provide an argument table when creating ListThingsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["things"] = args["things"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListThingsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachSecurityProfileResponse = { nil }

function asserts.AssertDetachSecurityProfileResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachSecurityProfileResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DetachSecurityProfileResponse[k], "DetachSecurityProfileResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachSecurityProfileResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DetachSecurityProfileResponse structure as a key-value pair table
function M.DetachSecurityProfileResponse(args)
	assert(args, "You must provide an argument table when creating DetachSecurityProfileResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDetachSecurityProfileResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeScheduledAuditRequest = { ["scheduledAuditName"] = true, nil }

function asserts.AssertDescribeScheduledAuditRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledAuditRequest to be of type 'table'")
	assert(struct["scheduledAuditName"], "Expected key scheduledAuditName to exist in table")
	if struct["scheduledAuditName"] then asserts.AssertScheduledAuditName(struct["scheduledAuditName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledAuditRequest[k], "DescribeScheduledAuditRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledAuditRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * scheduledAuditName [ScheduledAuditName] <p>The name of the scheduled audit whose information you want to get.</p>
-- Required key: scheduledAuditName
-- @return DescribeScheduledAuditRequest structure as a key-value pair table
function M.DescribeScheduledAuditRequest(args)
	assert(args, "You must provide an argument table when creating DescribeScheduledAuditRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{scheduledAuditName}"] = args["scheduledAuditName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["scheduledAuditName"] = args["scheduledAuditName"],
	}
	asserts.AssertDescribeScheduledAuditRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartThingRegistrationTaskResponse = { ["taskId"] = true, nil }

function asserts.AssertStartThingRegistrationTaskResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartThingRegistrationTaskResponse to be of type 'table'")
	if struct["taskId"] then asserts.AssertTaskId(struct["taskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartThingRegistrationTaskResponse[k], "StartThingRegistrationTaskResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartThingRegistrationTaskResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskId [TaskId] <p>The bulk thing provisioning task ID.</p>
-- @return StartThingRegistrationTaskResponse structure as a key-value pair table
function M.StartThingRegistrationTaskResponse(args)
	assert(args, "You must provide an argument table when creating StartThingRegistrationTaskResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["taskId"] = args["taskId"],
	}
	asserts.AssertStartThingRegistrationTaskResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAuditFindingsRequest = { ["endTime"] = true, ["taskId"] = true, ["maxResults"] = true, ["resourceIdentifier"] = true, ["checkName"] = true, ["startTime"] = true, ["nextToken"] = true, nil }

function asserts.AssertListAuditFindingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAuditFindingsRequest to be of type 'table'")
	if struct["endTime"] then asserts.AssertTimestamp(struct["endTime"]) end
	if struct["taskId"] then asserts.AssertAuditTaskId(struct["taskId"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	if struct["resourceIdentifier"] then asserts.AssertResourceIdentifier(struct["resourceIdentifier"]) end
	if struct["checkName"] then asserts.AssertAuditCheckName(struct["checkName"]) end
	if struct["startTime"] then asserts.AssertTimestamp(struct["startTime"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAuditFindingsRequest[k], "ListAuditFindingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAuditFindingsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * endTime [Timestamp] <p>A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
-- * taskId [AuditTaskId] <p>A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time. The default is 25.</p>
-- * resourceIdentifier [ResourceIdentifier] <p>Information identifying the non-compliant resource.</p>
-- * checkName [AuditCheckName] <p>A filter to limit results to the findings for the specified audit check.</p>
-- * startTime [Timestamp] <p>A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- @return ListAuditFindingsRequest structure as a key-value pair table
function M.ListAuditFindingsRequest(args)
	assert(args, "You must provide an argument table when creating ListAuditFindingsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["endTime"] = args["endTime"],
		["taskId"] = args["taskId"],
		["maxResults"] = args["maxResults"],
		["resourceIdentifier"] = args["resourceIdentifier"],
		["checkName"] = args["checkName"],
		["startTime"] = args["startTime"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListAuditFindingsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobExecution = { ["status"] = true, ["forceCanceled"] = true, ["queuedAt"] = true, ["approximateSecondsBeforeTimedOut"] = true, ["jobId"] = true, ["versionNumber"] = true, ["lastUpdatedAt"] = true, ["thingArn"] = true, ["startedAt"] = true, ["statusDetails"] = true, ["executionNumber"] = true, nil }

function asserts.AssertJobExecution(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobExecution to be of type 'table'")
	if struct["status"] then asserts.AssertJobExecutionStatus(struct["status"]) end
	if struct["forceCanceled"] then asserts.AssertForced(struct["forceCanceled"]) end
	if struct["queuedAt"] then asserts.AssertDateType(struct["queuedAt"]) end
	if struct["approximateSecondsBeforeTimedOut"] then asserts.AssertApproximateSecondsBeforeTimedOut(struct["approximateSecondsBeforeTimedOut"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	if struct["versionNumber"] then asserts.AssertVersionNumber(struct["versionNumber"]) end
	if struct["lastUpdatedAt"] then asserts.AssertDateType(struct["lastUpdatedAt"]) end
	if struct["thingArn"] then asserts.AssertThingArn(struct["thingArn"]) end
	if struct["startedAt"] then asserts.AssertDateType(struct["startedAt"]) end
	if struct["statusDetails"] then asserts.AssertJobExecutionStatusDetails(struct["statusDetails"]) end
	if struct["executionNumber"] then asserts.AssertExecutionNumber(struct["executionNumber"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobExecution[k], "JobExecution contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobExecution
-- <p>The job execution object represents the execution of a job on a particular device.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [JobExecutionStatus] <p>The status of the job execution (IN_PROGRESS, QUEUED, FAILED, SUCCEEDED, TIMED_OUT, CANCELED, or REJECTED).</p>
-- * forceCanceled [Forced] <p>Will be <code>true</code> if the job execution was canceled with the optional <code>force</code> parameter set to <code>true</code>.</p>
-- * queuedAt [DateType] <p>The time, in milliseconds since the epoch, when the job execution was queued.</p>
-- * approximateSecondsBeforeTimedOut [ApproximateSecondsBeforeTimedOut] <p>The estimated number of seconds that remain before the job execution status will be changed to <code>TIMED_OUT</code>.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to the job when it was created.</p>
-- * versionNumber [VersionNumber] <p>The version of the job execution. Job execution versions are incremented each time they are updated by a device.</p>
-- * lastUpdatedAt [DateType] <p>The time, in milliseconds since the epoch, when the job execution was last updated.</p>
-- * thingArn [ThingArn] <p>The ARN of the thing on which the job execution is running.</p>
-- * startedAt [DateType] <p>The time, in milliseconds since the epoch, when the job execution started.</p>
-- * statusDetails [JobExecutionStatusDetails] <p>A collection of name/value pairs that describe the status of the job execution.</p>
-- * executionNumber [ExecutionNumber] <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used in commands which return or update job execution information. </p>
-- @return JobExecution structure as a key-value pair table
function M.JobExecution(args)
	assert(args, "You must provide an argument table when creating JobExecution")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["forceCanceled"] = args["forceCanceled"],
		["queuedAt"] = args["queuedAt"],
		["approximateSecondsBeforeTimedOut"] = args["approximateSecondsBeforeTimedOut"],
		["jobId"] = args["jobId"],
		["versionNumber"] = args["versionNumber"],
		["lastUpdatedAt"] = args["lastUpdatedAt"],
		["thingArn"] = args["thingArn"],
		["startedAt"] = args["startedAt"],
		["statusDetails"] = args["statusDetails"],
		["executionNumber"] = args["executionNumber"],
	}
	asserts.AssertJobExecution(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAuthorizerResponse = { ["authorizerDescription"] = true, nil }

function asserts.AssertDescribeAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAuthorizerResponse to be of type 'table'")
	if struct["authorizerDescription"] then asserts.AssertAuthorizerDescription(struct["authorizerDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAuthorizerResponse[k], "DescribeAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerDescription [AuthorizerDescription] <p>The authorizer description.</p>
-- @return DescribeAuthorizerResponse structure as a key-value pair table
function M.DescribeAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating DescribeAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerDescription"] = args["authorizerDescription"],
	}
	asserts.AssertDescribeAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPolicyVersionsResponse = { ["policyVersions"] = true, nil }

function asserts.AssertListPolicyVersionsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPolicyVersionsResponse to be of type 'table'")
	if struct["policyVersions"] then asserts.AssertPolicyVersions(struct["policyVersions"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPolicyVersionsResponse[k], "ListPolicyVersionsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPolicyVersionsResponse
-- <p>The output from the ListPolicyVersions operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyVersions [PolicyVersions] <p>The policy versions.</p>
-- @return ListPolicyVersionsResponse structure as a key-value pair table
function M.ListPolicyVersionsResponse(args)
	assert(args, "You must provide an argument table when creating ListPolicyVersionsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyVersions"] = args["policyVersions"],
	}
	asserts.AssertListPolicyVersionsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Policy = { ["policyName"] = true, ["policyArn"] = true, nil }

function asserts.AssertPolicy(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Policy to be of type 'table'")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyArn"] then asserts.AssertPolicyArn(struct["policyArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.Policy[k], "Policy contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Policy
-- <p>Describes an AWS IoT policy.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * policyArn [PolicyArn] <p>The policy ARN.</p>
-- @return Policy structure as a key-value pair table
function M.Policy(args)
	assert(args, "You must provide an argument table when creating Policy")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyArn"] = args["policyArn"],
	}
	asserts.AssertPolicy(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetJobDocumentResponse = { ["document"] = true, nil }

function asserts.AssertGetJobDocumentResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetJobDocumentResponse to be of type 'table'")
	if struct["document"] then asserts.AssertJobDocument(struct["document"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetJobDocumentResponse[k], "GetJobDocumentResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetJobDocumentResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * document [JobDocument] <p>The job document content.</p>
-- @return GetJobDocumentResponse structure as a key-value pair table
function M.GetJobDocumentResponse(args)
	assert(args, "You must provide an argument table when creating GetJobDocumentResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["document"] = args["document"],
	}
	asserts.AssertGetJobDocumentResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetEffectivePoliciesRequest = { ["cognitoIdentityPoolId"] = true, ["thingName"] = true, ["principal"] = true, nil }

function asserts.AssertGetEffectivePoliciesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetEffectivePoliciesRequest to be of type 'table'")
	if struct["cognitoIdentityPoolId"] then asserts.AssertCognitoIdentityPoolId(struct["cognitoIdentityPoolId"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetEffectivePoliciesRequest[k], "GetEffectivePoliciesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetEffectivePoliciesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * cognitoIdentityPoolId [CognitoIdentityPoolId] <p>The Cognito identity pool ID.</p>
-- * thingName [ThingName] <p>The thing name.</p>
-- * principal [Principal] <p>The principal.</p>
-- @return GetEffectivePoliciesRequest structure as a key-value pair table
function M.GetEffectivePoliciesRequest(args)
	assert(args, "You must provide an argument table when creating GetEffectivePoliciesRequest")
    local query_args = { 
        ["thingName"] = args["thingName"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["cognitoIdentityPoolId"] = args["cognitoIdentityPoolId"],
		["thingName"] = args["thingName"],
		["principal"] = args["principal"],
	}
	asserts.AssertGetEffectivePoliciesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingsInThingGroupRequest = { ["thingGroupName"] = true, ["nextToken"] = true, ["recursive"] = true, ["maxResults"] = true, nil }

function asserts.AssertListThingsInThingGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingsInThingGroupRequest to be of type 'table'")
	assert(struct["thingGroupName"], "Expected key thingGroupName to exist in table")
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["recursive"] then asserts.AssertRecursive(struct["recursive"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingsInThingGroupRequest[k], "ListThingsInThingGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingsInThingGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupName [ThingGroupName] <p>The thing group name.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * recursive [Recursive] <p>When true, list things in this thing group and in all child groups as well.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return at one time.</p>
-- Required key: thingGroupName
-- @return ListThingsInThingGroupRequest structure as a key-value pair table
function M.ListThingsInThingGroupRequest(args)
	assert(args, "You must provide an argument table when creating ListThingsInThingGroupRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["recursive"] = args["recursive"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
        ["{thingGroupName}"] = args["thingGroupName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupName"] = args["thingGroupName"],
		["nextToken"] = args["nextToken"],
		["recursive"] = args["recursive"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListThingsInThingGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAccountAuditConfigurationRequest = { nil }

function asserts.AssertDescribeAccountAuditConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAuditConfigurationRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAuditConfigurationRequest[k], "DescribeAccountAuditConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAuditConfigurationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DescribeAccountAuditConfigurationRequest structure as a key-value pair table
function M.DescribeAccountAuditConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAccountAuditConfigurationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDescribeAccountAuditConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteRegistrationCodeResponse = { nil }

function asserts.AssertDeleteRegistrationCodeResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRegistrationCodeResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteRegistrationCodeResponse[k], "DeleteRegistrationCodeResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRegistrationCodeResponse
-- <p>The output for the DeleteRegistrationCode operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteRegistrationCodeResponse structure as a key-value pair table
function M.DeleteRegistrationCodeResponse(args)
	assert(args, "You must provide an argument table when creating DeleteRegistrationCodeResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteRegistrationCodeResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateEventConfigurationsRequest = { ["eventConfigurations"] = true, nil }

function asserts.AssertUpdateEventConfigurationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateEventConfigurationsRequest to be of type 'table'")
	if struct["eventConfigurations"] then asserts.AssertEventConfigurations(struct["eventConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateEventConfigurationsRequest[k], "UpdateEventConfigurationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateEventConfigurationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * eventConfigurations [EventConfigurations] <p>The new event configuration values.</p>
-- @return UpdateEventConfigurationsRequest structure as a key-value pair table
function M.UpdateEventConfigurationsRequest(args)
	assert(args, "You must provide an argument table when creating UpdateEventConfigurationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["eventConfigurations"] = args["eventConfigurations"],
	}
	asserts.AssertUpdateEventConfigurationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TimeoutConfig = { ["inProgressTimeoutInMinutes"] = true, nil }

function asserts.AssertTimeoutConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TimeoutConfig to be of type 'table'")
	if struct["inProgressTimeoutInMinutes"] then asserts.AssertInProgressTimeoutInMinutes(struct["inProgressTimeoutInMinutes"]) end
	for k,_ in pairs(struct) do
		assert(keys.TimeoutConfig[k], "TimeoutConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TimeoutConfig
-- <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * inProgressTimeoutInMinutes [InProgressTimeoutInMinutes] <p>Specifies the amount of time, in minutes, this device has to finish execution of this job. A timer is started, or restarted, whenever this job's execution status is specified as <code>IN_PROGRESS</code> with this field populated. If the job execution status is not set to a terminal state before the timer expires, or before another job execution status update is sent with this field populated, the status will be automatically set to <code>TIMED_OUT</code>. Note that setting/resetting this timer has no effect on the job execution timeout timer which may have been specified when the job was created (<code>CreateJobExecution</code> using the field <code>timeoutConfig</code>).</p>
-- @return TimeoutConfig structure as a key-value pair table
function M.TimeoutConfig(args)
	assert(args, "You must provide an argument table when creating TimeoutConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["inProgressTimeoutInMinutes"] = args["inProgressTimeoutInMinutes"],
	}
	asserts.AssertTimeoutConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeprecateThingTypeRequest = { ["thingTypeName"] = true, ["undoDeprecate"] = true, nil }

function asserts.AssertDeprecateThingTypeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeprecateThingTypeRequest to be of type 'table'")
	assert(struct["thingTypeName"], "Expected key thingTypeName to exist in table")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["undoDeprecate"] then asserts.AssertUndoDeprecate(struct["undoDeprecate"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeprecateThingTypeRequest[k], "DeprecateThingTypeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeprecateThingTypeRequest
-- <p>The input for the DeprecateThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type to deprecate.</p>
-- * undoDeprecate [UndoDeprecate] <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can associate it with things.</p>
-- Required key: thingTypeName
-- @return DeprecateThingTypeRequest structure as a key-value pair table
function M.DeprecateThingTypeRequest(args)
	assert(args, "You must provide an argument table when creating DeprecateThingTypeRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingTypeName}"] = args["thingTypeName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["undoDeprecate"] = args["undoDeprecate"],
	}
	asserts.AssertDeprecateThingTypeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListSecurityProfilesResponse = { ["securityProfileIdentifiers"] = true, ["nextToken"] = true, nil }

function asserts.AssertListSecurityProfilesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListSecurityProfilesResponse to be of type 'table'")
	if struct["securityProfileIdentifiers"] then asserts.AssertSecurityProfileIdentifiers(struct["securityProfileIdentifiers"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListSecurityProfilesResponse[k], "ListSecurityProfilesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListSecurityProfilesResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileIdentifiers [SecurityProfileIdentifiers] <p>A list of security profile identifiers (names and ARNs).</p>
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- @return ListSecurityProfilesResponse structure as a key-value pair table
function M.ListSecurityProfilesResponse(args)
	assert(args, "You must provide an argument table when creating ListSecurityProfilesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileIdentifiers"] = args["securityProfileIdentifiers"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListSecurityProfilesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TaskStatistics = { ["canceledChecks"] = true, ["totalChecks"] = true, ["waitingForDataCollectionChecks"] = true, ["compliantChecks"] = true, ["failedChecks"] = true, ["nonCompliantChecks"] = true, ["inProgressChecks"] = true, nil }

function asserts.AssertTaskStatistics(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TaskStatistics to be of type 'table'")
	if struct["canceledChecks"] then asserts.AssertCanceledChecksCount(struct["canceledChecks"]) end
	if struct["totalChecks"] then asserts.AssertTotalChecksCount(struct["totalChecks"]) end
	if struct["waitingForDataCollectionChecks"] then asserts.AssertWaitingForDataCollectionChecksCount(struct["waitingForDataCollectionChecks"]) end
	if struct["compliantChecks"] then asserts.AssertCompliantChecksCount(struct["compliantChecks"]) end
	if struct["failedChecks"] then asserts.AssertFailedChecksCount(struct["failedChecks"]) end
	if struct["nonCompliantChecks"] then asserts.AssertNonCompliantChecksCount(struct["nonCompliantChecks"]) end
	if struct["inProgressChecks"] then asserts.AssertInProgressChecksCount(struct["inProgressChecks"]) end
	for k,_ in pairs(struct) do
		assert(keys.TaskStatistics[k], "TaskStatistics contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TaskStatistics
-- <p>Statistics for the checks performed during the audit.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * canceledChecks [CanceledChecksCount] <p>The number of checks that did not run because the audit was canceled.</p>
-- * totalChecks [TotalChecksCount] <p>The number of checks in this audit.</p>
-- * waitingForDataCollectionChecks [WaitingForDataCollectionChecksCount] <p>The number of checks waiting for data collection.</p>
-- * compliantChecks [CompliantChecksCount] <p>The number of checks that found compliant resources.</p>
-- * failedChecks [FailedChecksCount] <p>The number of checks </p>
-- * nonCompliantChecks [NonCompliantChecksCount] <p>The number of checks that found non-compliant resources.</p>
-- * inProgressChecks [InProgressChecksCount] <p>The number of checks in progress.</p>
-- @return TaskStatistics structure as a key-value pair table
function M.TaskStatistics(args)
	assert(args, "You must provide an argument table when creating TaskStatistics")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["canceledChecks"] = args["canceledChecks"],
		["totalChecks"] = args["totalChecks"],
		["waitingForDataCollectionChecks"] = args["waitingForDataCollectionChecks"],
		["compliantChecks"] = args["compliantChecks"],
		["failedChecks"] = args["failedChecks"],
		["nonCompliantChecks"] = args["nonCompliantChecks"],
		["inProgressChecks"] = args["inProgressChecks"],
	}
	asserts.AssertTaskStatistics(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NonCompliantResource = { ["resourceType"] = true, ["additionalInfo"] = true, ["resourceIdentifier"] = true, nil }

function asserts.AssertNonCompliantResource(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NonCompliantResource to be of type 'table'")
	if struct["resourceType"] then asserts.AssertResourceType(struct["resourceType"]) end
	if struct["additionalInfo"] then asserts.AssertStringMap(struct["additionalInfo"]) end
	if struct["resourceIdentifier"] then asserts.AssertResourceIdentifier(struct["resourceIdentifier"]) end
	for k,_ in pairs(struct) do
		assert(keys.NonCompliantResource[k], "NonCompliantResource contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NonCompliantResource
-- <p>Information about the resource that was non-compliant with the audit check.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * resourceType [ResourceType] <p>The type of the non-compliant resource.</p>
-- * additionalInfo [StringMap] <p>Additional information about the non-compliant resource.</p>
-- * resourceIdentifier [ResourceIdentifier] <p>Information identifying the non-compliant resource.</p>
-- @return NonCompliantResource structure as a key-value pair table
function M.NonCompliantResource(args)
	assert(args, "You must provide an argument table when creating NonCompliantResource")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["resourceType"] = args["resourceType"],
		["additionalInfo"] = args["additionalInfo"],
		["resourceIdentifier"] = args["resourceIdentifier"],
	}
	asserts.AssertNonCompliantResource(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ElasticsearchAction = { ["index"] = true, ["roleArn"] = true, ["endpoint"] = true, ["type"] = true, ["id"] = true, nil }

function asserts.AssertElasticsearchAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ElasticsearchAction to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["endpoint"], "Expected key endpoint to exist in table")
	assert(struct["index"], "Expected key index to exist in table")
	assert(struct["type"], "Expected key type to exist in table")
	assert(struct["id"], "Expected key id to exist in table")
	if struct["index"] then asserts.AssertElasticsearchIndex(struct["index"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["endpoint"] then asserts.AssertElasticsearchEndpoint(struct["endpoint"]) end
	if struct["type"] then asserts.AssertElasticsearchType(struct["type"]) end
	if struct["id"] then asserts.AssertElasticsearchId(struct["id"]) end
	for k,_ in pairs(struct) do
		assert(keys.ElasticsearchAction[k], "ElasticsearchAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ElasticsearchAction
-- <p>Describes an action that writes data to an Amazon Elasticsearch Service domain.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * index [ElasticsearchIndex] <p>The Elasticsearch index where you want to store your data.</p>
-- * roleArn [AwsArn] <p>The IAM role ARN that has access to Elasticsearch.</p>
-- * endpoint [ElasticsearchEndpoint] <p>The endpoint of your Elasticsearch domain.</p>
-- * type [ElasticsearchType] <p>The type of document you are storing.</p>
-- * id [ElasticsearchId] <p>The unique identifier for the document you are storing.</p>
-- Required key: roleArn
-- Required key: endpoint
-- Required key: index
-- Required key: type
-- Required key: id
-- @return ElasticsearchAction structure as a key-value pair table
function M.ElasticsearchAction(args)
	assert(args, "You must provide an argument table when creating ElasticsearchAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["index"] = args["index"],
		["roleArn"] = args["roleArn"],
		["endpoint"] = args["endpoint"],
		["type"] = args["type"],
		["id"] = args["id"],
	}
	asserts.AssertElasticsearchAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.KeyPair = { ["PublicKey"] = true, ["PrivateKey"] = true, nil }

function asserts.AssertKeyPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPair to be of type 'table'")
	if struct["PublicKey"] then asserts.AssertPublicKey(struct["PublicKey"]) end
	if struct["PrivateKey"] then asserts.AssertPrivateKey(struct["PrivateKey"]) end
	for k,_ in pairs(struct) do
		assert(keys.KeyPair[k], "KeyPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPair
-- <p>Describes a key pair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicKey [PublicKey] <p>The public key.</p>
-- * PrivateKey [PrivateKey] <p>The private key.</p>
-- @return KeyPair structure as a key-value pair table
function M.KeyPair(args)
	assert(args, "You must provide an argument table when creating KeyPair")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicKey"] = args["PublicKey"],
		["PrivateKey"] = args["PrivateKey"],
	}
	asserts.AssertKeyPair(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAccountAuditConfigurationResponse = { nil }

function asserts.AssertUpdateAccountAuditConfigurationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAccountAuditConfigurationResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.UpdateAccountAuditConfigurationResponse[k], "UpdateAccountAuditConfigurationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAccountAuditConfigurationResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return UpdateAccountAuditConfigurationResponse structure as a key-value pair table
function M.UpdateAccountAuditConfigurationResponse(args)
	assert(args, "You must provide an argument table when creating UpdateAccountAuditConfigurationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertUpdateAccountAuditConfigurationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListOTAUpdatesResponse = { ["nextToken"] = true, ["otaUpdates"] = true, nil }

function asserts.AssertListOTAUpdatesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListOTAUpdatesResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["otaUpdates"] then asserts.AssertOTAUpdatesSummary(struct["otaUpdates"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListOTAUpdatesResponse[k], "ListOTAUpdatesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListOTAUpdatesResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token to use to get the next set of results.</p>
-- * otaUpdates [OTAUpdatesSummary] <p>A list of OTA update jobs.</p>
-- @return ListOTAUpdatesResponse structure as a key-value pair table
function M.ListOTAUpdatesResponse(args)
	assert(args, "You must provide an argument table when creating ListOTAUpdatesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["otaUpdates"] = args["otaUpdates"],
	}
	asserts.AssertListOTAUpdatesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingGroupDocument = { ["attributes"] = true, ["thingGroupName"] = true, ["parentGroupNames"] = true, ["thingGroupDescription"] = true, ["thingGroupId"] = true, nil }

function asserts.AssertThingGroupDocument(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingGroupDocument to be of type 'table'")
	if struct["attributes"] then asserts.AssertAttributes(struct["attributes"]) end
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["parentGroupNames"] then asserts.AssertThingGroupNameList(struct["parentGroupNames"]) end
	if struct["thingGroupDescription"] then asserts.AssertThingGroupDescription(struct["thingGroupDescription"]) end
	if struct["thingGroupId"] then asserts.AssertThingGroupId(struct["thingGroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingGroupDocument[k], "ThingGroupDocument contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingGroupDocument
-- <p>The thing group search index document.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * attributes [Attributes] <p>The thing group attributes.</p>
-- * thingGroupName [ThingGroupName] <p>The thing group name.</p>
-- * parentGroupNames [ThingGroupNameList] <p>Parent group names.</p>
-- * thingGroupDescription [ThingGroupDescription] <p>The thing group description.</p>
-- * thingGroupId [ThingGroupId] <p>The thing group ID.</p>
-- @return ThingGroupDocument structure as a key-value pair table
function M.ThingGroupDocument(args)
	assert(args, "You must provide an argument table when creating ThingGroupDocument")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["attributes"] = args["attributes"],
		["thingGroupName"] = args["thingGroupName"],
		["parentGroupNames"] = args["parentGroupNames"],
		["thingGroupDescription"] = args["thingGroupDescription"],
		["thingGroupId"] = args["thingGroupId"],
	}
	asserts.AssertThingGroupDocument(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.S3Location = { ["version"] = true, ["bucket"] = true, ["key"] = true, nil }

function asserts.AssertS3Location(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3Location to be of type 'table'")
	if struct["version"] then asserts.AssertS3Version(struct["version"]) end
	if struct["bucket"] then asserts.AssertS3Bucket(struct["bucket"]) end
	if struct["key"] then asserts.AssertS3Key(struct["key"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3Location[k], "S3Location contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3Location
-- <p>The S3 location.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * version [S3Version] <p>The S3 bucket version.</p>
-- * bucket [S3Bucket] <p>The S3 bucket.</p>
-- * key [S3Key] <p>The S3 key.</p>
-- @return S3Location structure as a key-value pair table
function M.S3Location(args)
	assert(args, "You must provide an argument table when creating S3Location")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["version"] = args["version"],
		["bucket"] = args["bucket"],
		["key"] = args["key"],
	}
	asserts.AssertS3Location(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCACertificateRequest = { ["certificateId"] = true, nil }

function asserts.AssertDescribeCACertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCACertificateRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCACertificateRequest[k], "DescribeCACertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCACertificateRequest
-- <p>The input for the DescribeCACertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateId [CertificateId] <p>The CA certificate identifier.</p>
-- Required key: certificateId
-- @return DescribeCACertificateRequest structure as a key-value pair table
function M.DescribeCACertificateRequest(args)
	assert(args, "You must provide an argument table when creating DescribeCACertificateRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{caCertificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertDescribeCACertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListSecurityProfilesRequest = { ["nextToken"] = true, ["maxResults"] = true, nil }

function asserts.AssertListSecurityProfilesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListSecurityProfilesRequest to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListSecurityProfilesRequest[k], "ListSecurityProfilesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListSecurityProfilesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time.</p>
-- @return ListSecurityProfilesRequest structure as a key-value pair table
function M.ListSecurityProfilesRequest(args)
	assert(args, "You must provide an argument table when creating ListSecurityProfilesRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListSecurityProfilesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PutItemInput = { ["tableName"] = true, nil }

function asserts.AssertPutItemInput(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PutItemInput to be of type 'table'")
	assert(struct["tableName"], "Expected key tableName to exist in table")
	if struct["tableName"] then asserts.AssertTableName(struct["tableName"]) end
	for k,_ in pairs(struct) do
		assert(keys.PutItemInput[k], "PutItemInput contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PutItemInput
-- <p>The input for the DynamoActionVS action that specifies the DynamoDB table to which the message data will be written.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * tableName [TableName] <p>The table where the message data will be written</p>
-- Required key: tableName
-- @return PutItemInput structure as a key-value pair table
function M.PutItemInput(args)
	assert(args, "You must provide an argument table when creating PutItemInput")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["tableName"] = args["tableName"],
	}
	asserts.AssertPutItemInput(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEventConfigurationsResponse = { ["lastModifiedDate"] = true, ["eventConfigurations"] = true, ["creationDate"] = true, nil }

function asserts.AssertDescribeEventConfigurationsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEventConfigurationsResponse to be of type 'table'")
	if struct["lastModifiedDate"] then asserts.AssertLastModifiedDate(struct["lastModifiedDate"]) end
	if struct["eventConfigurations"] then asserts.AssertEventConfigurations(struct["eventConfigurations"]) end
	if struct["creationDate"] then asserts.AssertCreationDate(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEventConfigurationsResponse[k], "DescribeEventConfigurationsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEventConfigurationsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * lastModifiedDate [LastModifiedDate] <p>The date the event configurations were last modified.</p>
-- * eventConfigurations [EventConfigurations] <p>The event configurations.</p>
-- * creationDate [CreationDate] <p>The creation date of the event configuration.</p>
-- @return DescribeEventConfigurationsResponse structure as a key-value pair table
function M.DescribeEventConfigurationsResponse(args)
	assert(args, "You must provide an argument table when creating DescribeEventConfigurationsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["lastModifiedDate"] = args["lastModifiedDate"],
		["eventConfigurations"] = args["eventConfigurations"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertDescribeEventConfigurationsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StreamSummary = { ["streamVersion"] = true, ["streamArn"] = true, ["description"] = true, ["streamId"] = true, nil }

function asserts.AssertStreamSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StreamSummary to be of type 'table'")
	if struct["streamVersion"] then asserts.AssertStreamVersion(struct["streamVersion"]) end
	if struct["streamArn"] then asserts.AssertStreamArn(struct["streamArn"]) end
	if struct["description"] then asserts.AssertStreamDescription(struct["description"]) end
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.StreamSummary[k], "StreamSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StreamSummary
-- <p>A summary of a stream.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * streamVersion [StreamVersion] <p>The stream version.</p>
-- * streamArn [StreamArn] <p>The stream ARN.</p>
-- * description [StreamDescription] <p>A description of the stream.</p>
-- * streamId [StreamId] <p>The stream ID.</p>
-- @return StreamSummary structure as a key-value pair table
function M.StreamSummary(args)
	assert(args, "You must provide an argument table when creating StreamSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["streamVersion"] = args["streamVersion"],
		["streamArn"] = args["streamArn"],
		["description"] = args["description"],
		["streamId"] = args["streamId"],
	}
	asserts.AssertStreamSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartThingRegistrationTaskRequest = { ["roleArn"] = true, ["inputFileBucket"] = true, ["templateBody"] = true, ["inputFileKey"] = true, nil }

function asserts.AssertStartThingRegistrationTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartThingRegistrationTaskRequest to be of type 'table'")
	assert(struct["templateBody"], "Expected key templateBody to exist in table")
	assert(struct["inputFileBucket"], "Expected key inputFileBucket to exist in table")
	assert(struct["inputFileKey"], "Expected key inputFileKey to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["inputFileBucket"] then asserts.AssertRegistryS3BucketName(struct["inputFileBucket"]) end
	if struct["templateBody"] then asserts.AssertTemplateBody(struct["templateBody"]) end
	if struct["inputFileKey"] then asserts.AssertRegistryS3KeyName(struct["inputFileKey"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartThingRegistrationTaskRequest[k], "StartThingRegistrationTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartThingRegistrationTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [RoleArn] <p>The IAM role ARN that grants permission the input file.</p>
-- * inputFileBucket [RegistryS3BucketName] <p>The S3 bucket that contains the input file.</p>
-- * templateBody [TemplateBody] <p>The provisioning template.</p>
-- * inputFileKey [RegistryS3KeyName] <p>The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).</p>
-- Required key: templateBody
-- Required key: inputFileBucket
-- Required key: inputFileKey
-- Required key: roleArn
-- @return StartThingRegistrationTaskRequest structure as a key-value pair table
function M.StartThingRegistrationTaskRequest(args)
	assert(args, "You must provide an argument table when creating StartThingRegistrationTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["inputFileBucket"] = args["inputFileBucket"],
		["templateBody"] = args["templateBody"],
		["inputFileKey"] = args["inputFileKey"],
	}
	asserts.AssertStartThingRegistrationTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAuditTaskResponse = { ["taskStatistics"] = true, ["auditDetails"] = true, ["taskType"] = true, ["taskStatus"] = true, ["scheduledAuditName"] = true, ["taskStartTime"] = true, nil }

function asserts.AssertDescribeAuditTaskResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAuditTaskResponse to be of type 'table'")
	if struct["taskStatistics"] then asserts.AssertTaskStatistics(struct["taskStatistics"]) end
	if struct["auditDetails"] then asserts.AssertAuditDetails(struct["auditDetails"]) end
	if struct["taskType"] then asserts.AssertAuditTaskType(struct["taskType"]) end
	if struct["taskStatus"] then asserts.AssertAuditTaskStatus(struct["taskStatus"]) end
	if struct["scheduledAuditName"] then asserts.AssertScheduledAuditName(struct["scheduledAuditName"]) end
	if struct["taskStartTime"] then asserts.AssertTimestamp(struct["taskStartTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAuditTaskResponse[k], "DescribeAuditTaskResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAuditTaskResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskStatistics [TaskStatistics] <p>Statistical information about the audit.</p>
-- * auditDetails [AuditDetails] <p>Detailed information about each check performed during this audit.</p>
-- * taskType [AuditTaskType] <p>The type of audit: "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
-- * taskStatus [AuditTaskStatus] <p>The status of the audit: one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
-- * scheduledAuditName [ScheduledAuditName] <p>The name of the scheduled audit (only if the audit was a scheduled audit).</p>
-- * taskStartTime [Timestamp] <p>The time the audit started.</p>
-- @return DescribeAuditTaskResponse structure as a key-value pair table
function M.DescribeAuditTaskResponse(args)
	assert(args, "You must provide an argument table when creating DescribeAuditTaskResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["taskStatistics"] = args["taskStatistics"],
		["auditDetails"] = args["auditDetails"],
		["taskType"] = args["taskType"],
		["taskStatus"] = args["taskStatus"],
		["scheduledAuditName"] = args["scheduledAuditName"],
		["taskStartTime"] = args["taskStartTime"],
	}
	asserts.AssertDescribeAuditTaskResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelJobRequest = { ["comment"] = true, ["force"] = true, ["jobId"] = true, nil }

function asserts.AssertCancelJobRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelJobRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	if struct["comment"] then asserts.AssertComment(struct["comment"]) end
	if struct["force"] then asserts.AssertForceFlag(struct["force"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelJobRequest[k], "CancelJobRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelJobRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * comment [Comment] <p>An optional comment string describing why the job was canceled.</p>
-- * force [ForceFlag] <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- Required key: jobId
-- @return CancelJobRequest structure as a key-value pair table
function M.CancelJobRequest(args)
	assert(args, "You must provide an argument table when creating CancelJobRequest")
    local query_args = { 
        ["force"] = args["force"],
    }
    local uri_args = { 
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["comment"] = args["comment"],
		["force"] = args["force"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertCancelJobRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobExecutionSummaryForJob = { ["thingArn"] = true, ["jobExecutionSummary"] = true, nil }

function asserts.AssertJobExecutionSummaryForJob(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobExecutionSummaryForJob to be of type 'table'")
	if struct["thingArn"] then asserts.AssertThingArn(struct["thingArn"]) end
	if struct["jobExecutionSummary"] then asserts.AssertJobExecutionSummary(struct["jobExecutionSummary"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobExecutionSummaryForJob[k], "JobExecutionSummaryForJob contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobExecutionSummaryForJob
-- <p>Contains a summary of information about job executions for a specific job.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingArn [ThingArn] <p>The ARN of the thing on which the job execution is running.</p>
-- * jobExecutionSummary [JobExecutionSummary] <p>Contains a subset of information about a job execution.</p>
-- @return JobExecutionSummaryForJob structure as a key-value pair table
function M.JobExecutionSummaryForJob(args)
	assert(args, "You must provide an argument table when creating JobExecutionSummaryForJob")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingArn"] = args["thingArn"],
		["jobExecutionSummary"] = args["jobExecutionSummary"],
	}
	asserts.AssertJobExecutionSummaryForJob(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateOTAUpdateRequest = { ["files"] = true, ["otaUpdateId"] = true, ["roleArn"] = true, ["targetSelection"] = true, ["awsJobExecutionsRolloutConfig"] = true, ["additionalParameters"] = true, ["targets"] = true, ["description"] = true, nil }

function asserts.AssertCreateOTAUpdateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateOTAUpdateRequest to be of type 'table'")
	assert(struct["otaUpdateId"], "Expected key otaUpdateId to exist in table")
	assert(struct["targets"], "Expected key targets to exist in table")
	assert(struct["files"], "Expected key files to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["files"] then asserts.AssertOTAUpdateFiles(struct["files"]) end
	if struct["otaUpdateId"] then asserts.AssertOTAUpdateId(struct["otaUpdateId"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["targetSelection"] then asserts.AssertTargetSelection(struct["targetSelection"]) end
	if struct["awsJobExecutionsRolloutConfig"] then asserts.AssertAwsJobExecutionsRolloutConfig(struct["awsJobExecutionsRolloutConfig"]) end
	if struct["additionalParameters"] then asserts.AssertAdditionalParameterMap(struct["additionalParameters"]) end
	if struct["targets"] then asserts.AssertTargets(struct["targets"]) end
	if struct["description"] then asserts.AssertOTAUpdateDescription(struct["description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateOTAUpdateRequest[k], "CreateOTAUpdateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateOTAUpdateRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * files [OTAUpdateFiles] <p>The files to be streamed by the OTA update.</p>
-- * otaUpdateId [OTAUpdateId] <p>The ID of the OTA update to be created.</p>
-- * roleArn [RoleArn] <p>The IAM role that allows access to the AWS IoT Jobs service.</p>
-- * targetSelection [TargetSelection] <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
-- * awsJobExecutionsRolloutConfig [AwsJobExecutionsRolloutConfig] <p>Configuration for the rollout of OTA updates.</p>
-- * additionalParameters [AdditionalParameterMap] <p>A list of additional OTA update parameters which are name-value pairs.</p>
-- * targets [Targets] <p>The targeted devices to receive OTA updates.</p>
-- * description [OTAUpdateDescription] <p>The description of the OTA update.</p>
-- Required key: otaUpdateId
-- Required key: targets
-- Required key: files
-- Required key: roleArn
-- @return CreateOTAUpdateRequest structure as a key-value pair table
function M.CreateOTAUpdateRequest(args)
	assert(args, "You must provide an argument table when creating CreateOTAUpdateRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{otaUpdateId}"] = args["otaUpdateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["files"] = args["files"],
		["otaUpdateId"] = args["otaUpdateId"],
		["roleArn"] = args["roleArn"],
		["targetSelection"] = args["targetSelection"],
		["awsJobExecutionsRolloutConfig"] = args["awsJobExecutionsRolloutConfig"],
		["additionalParameters"] = args["additionalParameters"],
		["targets"] = args["targets"],
		["description"] = args["description"],
	}
	asserts.AssertCreateOTAUpdateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CodeSigningCertificateChain = { ["inlineDocument"] = true, ["certificateName"] = true, nil }

function asserts.AssertCodeSigningCertificateChain(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CodeSigningCertificateChain to be of type 'table'")
	if struct["inlineDocument"] then asserts.AssertInlineDocument(struct["inlineDocument"]) end
	if struct["certificateName"] then asserts.AssertCertificateName(struct["certificateName"]) end
	for k,_ in pairs(struct) do
		assert(keys.CodeSigningCertificateChain[k], "CodeSigningCertificateChain contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CodeSigningCertificateChain
-- <p>Describes the certificate chain being used when code signing a file.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * inlineDocument [InlineDocument] <p>A base64 encoded binary representation of the code signing certificate chain.</p>
-- * certificateName [CertificateName] <p>The name of the certificate.</p>
-- @return CodeSigningCertificateChain structure as a key-value pair table
function M.CodeSigningCertificateChain(args)
	assert(args, "You must provide an argument table when creating CodeSigningCertificateChain")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["inlineDocument"] = args["inlineDocument"],
		["certificateName"] = args["certificateName"],
	}
	asserts.AssertCodeSigningCertificateChain(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingTypesResponse = { ["nextToken"] = true, ["thingTypes"] = true, nil }

function asserts.AssertListThingTypesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingTypesResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["thingTypes"] then asserts.AssertThingTypeList(struct["thingTypes"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingTypesResponse[k], "ListThingTypesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingTypesResponse
-- <p>The output for the ListThingTypes operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
-- * thingTypes [ThingTypeList] <p>The thing types.</p>
-- @return ListThingTypesResponse structure as a key-value pair table
function M.ListThingTypesResponse(args)
	assert(args, "You must provide an argument table when creating ListThingTypesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["thingTypes"] = args["thingTypes"],
	}
	asserts.AssertListThingTypesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDefaultAuthorizerRequest = { nil }

function asserts.AssertDescribeDefaultAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDefaultAuthorizerRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DescribeDefaultAuthorizerRequest[k], "DescribeDefaultAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDefaultAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DescribeDefaultAuthorizerRequest structure as a key-value pair table
function M.DescribeDefaultAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating DescribeDefaultAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDescribeDefaultAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPrincipalThingsResponse = { ["things"] = true, ["nextToken"] = true, nil }

function asserts.AssertListPrincipalThingsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPrincipalThingsResponse to be of type 'table'")
	if struct["things"] then asserts.AssertThingNameList(struct["things"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPrincipalThingsResponse[k], "ListPrincipalThingsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPrincipalThingsResponse
-- <p>The output from the ListPrincipalThings operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * things [ThingNameList] <p>The things.</p>
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- @return ListPrincipalThingsResponse structure as a key-value pair table
function M.ListPrincipalThingsResponse(args)
	assert(args, "You must provide an argument table when creating ListPrincipalThingsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["things"] = args["things"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListPrincipalThingsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteAccountAuditConfigurationResponse = { nil }

function asserts.AssertDeleteAccountAuditConfigurationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteAccountAuditConfigurationResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteAccountAuditConfigurationResponse[k], "DeleteAccountAuditConfigurationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteAccountAuditConfigurationResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteAccountAuditConfigurationResponse structure as a key-value pair table
function M.DeleteAccountAuditConfigurationResponse(args)
	assert(args, "You must provide an argument table when creating DeleteAccountAuditConfigurationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteAccountAuditConfigurationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingRequest = { ["thingName"] = true, nil }

function asserts.AssertDescribeThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingRequest[k], "DescribeThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingRequest
-- <p>The input for the DescribeThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingName [ThingName] <p>The name of the thing.</p>
-- Required key: thingName
-- @return DescribeThingRequest structure as a key-value pair table
function M.DescribeThingRequest(args)
	assert(args, "You must provide an argument table when creating DescribeThingRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingName"] = args["thingName"],
	}
	asserts.AssertDescribeThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ValidationError = { ["errorMessage"] = true, nil }

function asserts.AssertValidationError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ValidationError to be of type 'table'")
	if struct["errorMessage"] then asserts.AssertErrorMessage(struct["errorMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ValidationError[k], "ValidationError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ValidationError
-- <p>Information about an error found in a behavior specification.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * errorMessage [ErrorMessage] <p>The description of an error found in the behaviors.</p>
-- @return ValidationError structure as a key-value pair table
function M.ValidationError(args)
	assert(args, "You must provide an argument table when creating ValidationError")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["errorMessage"] = args["errorMessage"],
	}
	asserts.AssertValidationError(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeStreamResponse = { ["streamInfo"] = true, nil }

function asserts.AssertDescribeStreamResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStreamResponse to be of type 'table'")
	if struct["streamInfo"] then asserts.AssertStreamInfo(struct["streamInfo"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStreamResponse[k], "DescribeStreamResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStreamResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * streamInfo [StreamInfo] <p>Information about the stream.</p>
-- @return DescribeStreamResponse structure as a key-value pair table
function M.DescribeStreamResponse(args)
	assert(args, "You must provide an argument table when creating DescribeStreamResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["streamInfo"] = args["streamInfo"],
	}
	asserts.AssertDescribeStreamResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSecurityProfileRequest = { ["securityProfileName"] = true, nil }

function asserts.AssertDescribeSecurityProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityProfileRequest to be of type 'table'")
	assert(struct["securityProfileName"], "Expected key securityProfileName to exist in table")
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityProfileRequest[k], "DescribeSecurityProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileName [SecurityProfileName] <p>The name of the security profile whose information you want to get.</p>
-- Required key: securityProfileName
-- @return DescribeSecurityProfileRequest structure as a key-value pair table
function M.DescribeSecurityProfileRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSecurityProfileRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{securityProfileName}"] = args["securityProfileName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileName"] = args["securityProfileName"],
	}
	asserts.AssertDescribeSecurityProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingGroupMetadata = { ["creationDate"] = true, ["rootToParentThingGroups"] = true, ["parentGroupName"] = true, nil }

function asserts.AssertThingGroupMetadata(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingGroupMetadata to be of type 'table'")
	if struct["creationDate"] then asserts.AssertCreationDate(struct["creationDate"]) end
	if struct["rootToParentThingGroups"] then asserts.AssertThingGroupNameAndArnList(struct["rootToParentThingGroups"]) end
	if struct["parentGroupName"] then asserts.AssertThingGroupName(struct["parentGroupName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingGroupMetadata[k], "ThingGroupMetadata contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingGroupMetadata
-- <p>Thing group metadata.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * creationDate [CreationDate] <p>The UNIX timestamp of when the thing group was created.</p>
-- * rootToParentThingGroups [ThingGroupNameAndArnList] <p>The root parent thing group.</p>
-- * parentGroupName [ThingGroupName] <p>The parent thing group name.</p>
-- @return ThingGroupMetadata structure as a key-value pair table
function M.ThingGroupMetadata(args)
	assert(args, "You must provide an argument table when creating ThingGroupMetadata")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["creationDate"] = args["creationDate"],
		["rootToParentThingGroups"] = args["rootToParentThingGroups"],
		["parentGroupName"] = args["parentGroupName"],
	}
	asserts.AssertThingGroupMetadata(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingTypeDefinition = { ["thingTypeName"] = true, ["thingTypeProperties"] = true, ["thingTypeMetadata"] = true, ["thingTypeArn"] = true, nil }

function asserts.AssertThingTypeDefinition(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingTypeDefinition to be of type 'table'")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["thingTypeProperties"] then asserts.AssertThingTypeProperties(struct["thingTypeProperties"]) end
	if struct["thingTypeMetadata"] then asserts.AssertThingTypeMetadata(struct["thingTypeMetadata"]) end
	if struct["thingTypeArn"] then asserts.AssertThingTypeArn(struct["thingTypeArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingTypeDefinition[k], "ThingTypeDefinition contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingTypeDefinition
-- <p>The definition of the thing type, including thing type name and description.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- * thingTypeProperties [ThingTypeProperties] <p>The ThingTypeProperties for the thing type.</p>
-- * thingTypeMetadata [ThingTypeMetadata] <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.</p>
-- * thingTypeArn [ThingTypeArn] <p>The thing type ARN.</p>
-- @return ThingTypeDefinition structure as a key-value pair table
function M.ThingTypeDefinition(args)
	assert(args, "You must provide an argument table when creating ThingTypeDefinition")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["thingTypeProperties"] = args["thingTypeProperties"],
		["thingTypeMetadata"] = args["thingTypeMetadata"],
		["thingTypeArn"] = args["thingTypeArn"],
	}
	asserts.AssertThingTypeDefinition(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteJobExecutionRequest = { ["force"] = true, ["thingName"] = true, ["executionNumber"] = true, ["jobId"] = true, nil }

function asserts.AssertDeleteJobExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteJobExecutionRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	assert(struct["executionNumber"], "Expected key executionNumber to exist in table")
	if struct["force"] then asserts.AssertForceFlag(struct["force"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["executionNumber"] then asserts.AssertExecutionNumber(struct["executionNumber"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteJobExecutionRequest[k], "DeleteJobExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteJobExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * force [ForceFlag] <p>(Optional) When true, you can delete a job execution which is "IN_PROGRESS". Otherwise, you can only delete a job execution which is in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is "IN_PROGRESS", will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note>
-- * thingName [ThingName] <p>The name of the thing whose job execution will be deleted.</p>
-- * executionNumber [ExecutionNumber] <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
-- * jobId [JobId] <p>The ID of the job whose execution on a particular device will be deleted.</p>
-- Required key: jobId
-- Required key: thingName
-- Required key: executionNumber
-- @return DeleteJobExecutionRequest structure as a key-value pair table
function M.DeleteJobExecutionRequest(args)
	assert(args, "You must provide an argument table when creating DeleteJobExecutionRequest")
    local query_args = { 
        ["force"] = args["force"],
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
        ["{executionNumber}"] = args["executionNumber"],
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["force"] = args["force"],
		["thingName"] = args["thingName"],
		["executionNumber"] = args["executionNumber"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertDeleteJobExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListJobExecutionsForThingRequest = { ["status"] = true, ["nextToken"] = true, ["thingName"] = true, ["maxResults"] = true, nil }

function asserts.AssertListJobExecutionsForThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListJobExecutionsForThingRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["status"] then asserts.AssertJobExecutionStatus(struct["status"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["maxResults"] then asserts.AssertLaserMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListJobExecutionsForThingRequest[k], "ListJobExecutionsForThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListJobExecutionsForThingRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [JobExecutionStatus] <p>An optional filter that lets you search for jobs that have the specified status.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * thingName [ThingName] <p>The thing name.</p>
-- * maxResults [LaserMaxResults] <p>The maximum number of results to be returned per request.</p>
-- Required key: thingName
-- @return ListJobExecutionsForThingRequest structure as a key-value pair table
function M.ListJobExecutionsForThingRequest(args)
	assert(args, "You must provide an argument table when creating ListJobExecutionsForThingRequest")
    local query_args = { 
        ["status"] = args["status"],
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["nextToken"] = args["nextToken"],
		["thingName"] = args["thingName"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListJobExecutionsForThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteThingResponse = { nil }

function asserts.AssertDeleteThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteThingResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteThingResponse[k], "DeleteThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteThingResponse
-- <p>The output of the DeleteThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteThingResponse structure as a key-value pair table
function M.DeleteThingResponse(args)
	assert(args, "You must provide an argument table when creating DeleteThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RoleAliasDescription = { ["credentialDurationSeconds"] = true, ["lastModifiedDate"] = true, ["roleArn"] = true, ["roleAlias"] = true, ["owner"] = true, ["creationDate"] = true, ["roleAliasArn"] = true, nil }

function asserts.AssertRoleAliasDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RoleAliasDescription to be of type 'table'")
	if struct["credentialDurationSeconds"] then asserts.AssertCredentialDurationSeconds(struct["credentialDurationSeconds"]) end
	if struct["lastModifiedDate"] then asserts.AssertDateType(struct["lastModifiedDate"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["roleAlias"] then asserts.AssertRoleAlias(struct["roleAlias"]) end
	if struct["owner"] then asserts.AssertAwsAccountId(struct["owner"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	if struct["roleAliasArn"] then asserts.AssertRoleAliasArn(struct["roleAliasArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.RoleAliasDescription[k], "RoleAliasDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RoleAliasDescription
-- <p>Role alias description.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * credentialDurationSeconds [CredentialDurationSeconds] <p>The number of seconds for which the credential is valid.</p>
-- * lastModifiedDate [DateType] <p>The UNIX timestamp of when the role alias was last modified.</p>
-- * roleArn [RoleArn] <p>The role ARN.</p>
-- * roleAlias [RoleAlias] <p>The role alias.</p>
-- * owner [AwsAccountId] <p>The role alias owner.</p>
-- * creationDate [DateType] <p>The UNIX timestamp of when the role alias was created.</p>
-- * roleAliasArn [RoleAliasArn] <p>The ARN of the role alias.</p>
-- @return RoleAliasDescription structure as a key-value pair table
function M.RoleAliasDescription(args)
	assert(args, "You must provide an argument table when creating RoleAliasDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["credentialDurationSeconds"] = args["credentialDurationSeconds"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["roleArn"] = args["roleArn"],
		["roleAlias"] = args["roleAlias"],
		["owner"] = args["owner"],
		["creationDate"] = args["creationDate"],
		["roleAliasArn"] = args["roleAliasArn"],
	}
	asserts.AssertRoleAliasDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LogTarget = { ["targetType"] = true, ["targetName"] = true, nil }

function asserts.AssertLogTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LogTarget to be of type 'table'")
	assert(struct["targetType"], "Expected key targetType to exist in table")
	if struct["targetType"] then asserts.AssertLogTargetType(struct["targetType"]) end
	if struct["targetName"] then asserts.AssertLogTargetName(struct["targetName"]) end
	for k,_ in pairs(struct) do
		assert(keys.LogTarget[k], "LogTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LogTarget
-- <p>A log target.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * targetType [LogTargetType] <p>The target type.</p>
-- * targetName [LogTargetName] <p>The target name.</p>
-- Required key: targetType
-- @return LogTarget structure as a key-value pair table
function M.LogTarget(args)
	assert(args, "You must provide an argument table when creating LogTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["targetType"] = args["targetType"],
		["targetName"] = args["targetName"],
	}
	asserts.AssertLogTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateThingRequest = { ["thingTypeName"] = true, ["attributePayload"] = true, ["thingName"] = true, nil }

function asserts.AssertCreateThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateThingRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["attributePayload"] then asserts.AssertAttributePayload(struct["attributePayload"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateThingRequest[k], "CreateThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateThingRequest
-- <p>The input for the CreateThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type associated with the new thing.</p>
-- * attributePayload [AttributePayload] <p>The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:</p> <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
-- * thingName [ThingName] <p>The name of the thing to create.</p>
-- Required key: thingName
-- @return CreateThingRequest structure as a key-value pair table
function M.CreateThingRequest(args)
	assert(args, "You must provide an argument table when creating CreateThingRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["attributePayload"] = args["attributePayload"],
		["thingName"] = args["thingName"],
	}
	asserts.AssertCreateThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingTypeMetadata = { ["deprecated"] = true, ["creationDate"] = true, ["deprecationDate"] = true, nil }

function asserts.AssertThingTypeMetadata(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingTypeMetadata to be of type 'table'")
	if struct["deprecated"] then asserts.AssertBoolean(struct["deprecated"]) end
	if struct["creationDate"] then asserts.AssertCreationDate(struct["creationDate"]) end
	if struct["deprecationDate"] then asserts.AssertDeprecationDate(struct["deprecationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingTypeMetadata[k], "ThingTypeMetadata contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingTypeMetadata
-- <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when time was deprecated.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * deprecated [Boolean] <p>Whether the thing type is deprecated. If <b>true</b>, no new things could be associated with this type.</p>
-- * creationDate [CreationDate] <p>The date and time when the thing type was created.</p>
-- * deprecationDate [DeprecationDate] <p>The date and time when the thing type was deprecated.</p>
-- @return ThingTypeMetadata structure as a key-value pair table
function M.ThingTypeMetadata(args)
	assert(args, "You must provide an argument table when creating ThingTypeMetadata")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["deprecated"] = args["deprecated"],
		["creationDate"] = args["creationDate"],
		["deprecationDate"] = args["deprecationDate"],
	}
	asserts.AssertThingTypeMetadata(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListOutgoingCertificatesRequest = { ["marker"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, nil }

function asserts.AssertListOutgoingCertificatesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListOutgoingCertificatesRequest to be of type 'table'")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListOutgoingCertificatesRequest[k], "ListOutgoingCertificatesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListOutgoingCertificatesRequest
-- <p>The input to the ListOutgoingCertificates operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The marker for the next set of results.</p>
-- * ascendingOrder [AscendingOrder] <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
-- * pageSize [PageSize] <p>The result page size.</p>
-- @return ListOutgoingCertificatesRequest structure as a key-value pair table
function M.ListOutgoingCertificatesRequest(args)
	assert(args, "You must provide an argument table when creating ListOutgoingCertificatesRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListOutgoingCertificatesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeStreamRequest = { ["streamId"] = true, nil }

function asserts.AssertDescribeStreamRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStreamRequest to be of type 'table'")
	assert(struct["streamId"], "Expected key streamId to exist in table")
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStreamRequest[k], "DescribeStreamRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStreamRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * streamId [StreamId] <p>The stream ID.</p>
-- Required key: streamId
-- @return DescribeStreamRequest structure as a key-value pair table
function M.DescribeStreamRequest(args)
	assert(args, "You must provide an argument table when creating DescribeStreamRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{streamId}"] = args["streamId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["streamId"] = args["streamId"],
	}
	asserts.AssertDescribeStreamRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetIndexingConfigurationRequest = { nil }

function asserts.AssertGetIndexingConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetIndexingConfigurationRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.GetIndexingConfigurationRequest[k], "GetIndexingConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetIndexingConfigurationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return GetIndexingConfigurationRequest structure as a key-value pair table
function M.GetIndexingConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating GetIndexingConfigurationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertGetIndexingConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateJobResponse = { ["jobArn"] = true, ["description"] = true, ["jobId"] = true, nil }

function asserts.AssertCreateJobResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateJobResponse to be of type 'table'")
	if struct["jobArn"] then asserts.AssertJobArn(struct["jobArn"]) end
	if struct["description"] then asserts.AssertJobDescription(struct["description"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateJobResponse[k], "CreateJobResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateJobResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * jobArn [JobArn] <p>The job ARN.</p>
-- * description [JobDescription] <p>The job description.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job.</p>
-- @return CreateJobResponse structure as a key-value pair table
function M.CreateJobResponse(args)
	assert(args, "You must provide an argument table when creating CreateJobResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["jobArn"] = args["jobArn"],
		["description"] = args["description"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertCreateJobResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingRegistrationTaskReportsRequest = { ["nextToken"] = true, ["reportType"] = true, ["maxResults"] = true, ["taskId"] = true, nil }

function asserts.AssertListThingRegistrationTaskReportsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingRegistrationTaskReportsRequest to be of type 'table'")
	assert(struct["taskId"], "Expected key taskId to exist in table")
	assert(struct["reportType"], "Expected key reportType to exist in table")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["reportType"] then asserts.AssertReportType(struct["reportType"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	if struct["taskId"] then asserts.AssertTaskId(struct["taskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingRegistrationTaskReportsRequest[k], "ListThingRegistrationTaskReportsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingRegistrationTaskReportsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * reportType [ReportType] <p>The type of task report.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return per request.</p>
-- * taskId [TaskId] <p>The id of the task.</p>
-- Required key: taskId
-- Required key: reportType
-- @return ListThingRegistrationTaskReportsRequest structure as a key-value pair table
function M.ListThingRegistrationTaskReportsRequest(args)
	assert(args, "You must provide an argument table when creating ListThingRegistrationTaskReportsRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["reportType"] = args["reportType"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
        ["{taskId}"] = args["taskId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["reportType"] = args["reportType"],
		["maxResults"] = args["maxResults"],
		["taskId"] = args["taskId"],
	}
	asserts.AssertListThingRegistrationTaskReportsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobExecutionSummaryForThing = { ["jobExecutionSummary"] = true, ["jobId"] = true, nil }

function asserts.AssertJobExecutionSummaryForThing(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobExecutionSummaryForThing to be of type 'table'")
	if struct["jobExecutionSummary"] then asserts.AssertJobExecutionSummary(struct["jobExecutionSummary"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobExecutionSummaryForThing[k], "JobExecutionSummaryForThing contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobExecutionSummaryForThing
-- <p>The job execution summary for a thing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * jobExecutionSummary [JobExecutionSummary] <p>Contains a subset of information about a job execution.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- @return JobExecutionSummaryForThing structure as a key-value pair table
function M.JobExecutionSummaryForThing(args)
	assert(args, "You must provide an argument table when creating JobExecutionSummaryForThing")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["jobExecutionSummary"] = args["jobExecutionSummary"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertJobExecutionSummaryForThing(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateScheduledAuditRequest = { ["dayOfWeek"] = true, ["targetCheckNames"] = true, ["scheduledAuditName"] = true, ["frequency"] = true, ["dayOfMonth"] = true, nil }

function asserts.AssertCreateScheduledAuditRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateScheduledAuditRequest to be of type 'table'")
	assert(struct["frequency"], "Expected key frequency to exist in table")
	assert(struct["targetCheckNames"], "Expected key targetCheckNames to exist in table")
	assert(struct["scheduledAuditName"], "Expected key scheduledAuditName to exist in table")
	if struct["dayOfWeek"] then asserts.AssertDayOfWeek(struct["dayOfWeek"]) end
	if struct["targetCheckNames"] then asserts.AssertTargetAuditCheckNames(struct["targetCheckNames"]) end
	if struct["scheduledAuditName"] then asserts.AssertScheduledAuditName(struct["scheduledAuditName"]) end
	if struct["frequency"] then asserts.AssertAuditFrequency(struct["frequency"]) end
	if struct["dayOfMonth"] then asserts.AssertDayOfMonth(struct["dayOfMonth"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateScheduledAuditRequest[k], "CreateScheduledAuditRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateScheduledAuditRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * dayOfWeek [DayOfWeek] <p>The day of the week on which the scheduled audit takes place. Can be one of "SUN", "MON", "TUE", "WED", "THU", "FRI" or "SAT". This field is required if the "frequency" parameter is set to "WEEKLY" or "BIWEEKLY".</p>
-- * targetCheckNames [TargetAuditCheckNames] <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
-- * scheduledAuditName [ScheduledAuditName] <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
-- * frequency [AuditFrequency] <p>How often the scheduled audit takes place. Can be one of "DAILY", "WEEKLY", "BIWEEKLY" or "MONTHLY". The actual start time of each audit is determined by the system.</p>
-- * dayOfMonth [DayOfMonth] <p>The day of the month on which the scheduled audit takes place. Can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to "MONTHLY". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
-- Required key: frequency
-- Required key: targetCheckNames
-- Required key: scheduledAuditName
-- @return CreateScheduledAuditRequest structure as a key-value pair table
function M.CreateScheduledAuditRequest(args)
	assert(args, "You must provide an argument table when creating CreateScheduledAuditRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{scheduledAuditName}"] = args["scheduledAuditName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["dayOfWeek"] = args["dayOfWeek"],
		["targetCheckNames"] = args["targetCheckNames"],
		["scheduledAuditName"] = args["scheduledAuditName"],
		["frequency"] = args["frequency"],
		["dayOfMonth"] = args["dayOfMonth"],
	}
	asserts.AssertCreateScheduledAuditRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetV2LoggingOptionsRequest = { nil }

function asserts.AssertGetV2LoggingOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetV2LoggingOptionsRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.GetV2LoggingOptionsRequest[k], "GetV2LoggingOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetV2LoggingOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return GetV2LoggingOptionsRequest structure as a key-value pair table
function M.GetV2LoggingOptionsRequest(args)
	assert(args, "You must provide an argument table when creating GetV2LoggingOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertGetV2LoggingOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPolicyPrincipalsRequest = { ["marker"] = true, ["policyName"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, nil }

function asserts.AssertListPolicyPrincipalsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPolicyPrincipalsRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPolicyPrincipalsRequest[k], "ListPolicyPrincipalsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPolicyPrincipalsRequest
-- <p>The input for the ListPolicyPrincipals operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The marker for the next set of results.</p>
-- * policyName [PolicyName] <p>The policy name.</p>
-- * ascendingOrder [AscendingOrder] <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
-- * pageSize [PageSize] <p>The result page size.</p>
-- Required key: policyName
-- @return ListPolicyPrincipalsRequest structure as a key-value pair table
function M.ListPolicyPrincipalsRequest(args)
	assert(args, "You must provide an argument table when creating ListPolicyPrincipalsRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
        ["x-amzn-iot-policy"] = args["policyName"],
    }
	local all_args = { 
		["marker"] = args["marker"],
		["policyName"] = args["policyName"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListPolicyPrincipalsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAuditTasksRequest = { ["endTime"] = true, ["maxResults"] = true, ["taskStatus"] = true, ["startTime"] = true, ["taskType"] = true, ["nextToken"] = true, nil }

function asserts.AssertListAuditTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAuditTasksRequest to be of type 'table'")
	assert(struct["startTime"], "Expected key startTime to exist in table")
	assert(struct["endTime"], "Expected key endTime to exist in table")
	if struct["endTime"] then asserts.AssertTimestamp(struct["endTime"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	if struct["taskStatus"] then asserts.AssertAuditTaskStatus(struct["taskStatus"]) end
	if struct["startTime"] then asserts.AssertTimestamp(struct["startTime"]) end
	if struct["taskType"] then asserts.AssertAuditTaskType(struct["taskType"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAuditTasksRequest[k], "ListAuditTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAuditTasksRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * endTime [Timestamp] <p>The end of the time period.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time. The default is 25.</p>
-- * taskStatus [AuditTaskStatus] <p>A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED" or "CANCELED".</p>
-- * startTime [Timestamp] <p>The beginning of the time period. Note that audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".</p>
-- * taskType [AuditTaskType] <p>A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- Required key: startTime
-- Required key: endTime
-- @return ListAuditTasksRequest structure as a key-value pair table
function M.ListAuditTasksRequest(args)
	assert(args, "You must provide an argument table when creating ListAuditTasksRequest")
    local query_args = { 
        ["endTime"] = args["endTime"],
        ["maxResults"] = args["maxResults"],
        ["taskStatus"] = args["taskStatus"],
        ["startTime"] = args["startTime"],
        ["taskType"] = args["taskType"],
        ["nextToken"] = args["nextToken"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["endTime"] = args["endTime"],
		["maxResults"] = args["maxResults"],
		["taskStatus"] = args["taskStatus"],
		["startTime"] = args["startTime"],
		["taskType"] = args["taskType"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListAuditTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Job = { ["status"] = true, ["comment"] = true, ["jobArn"] = true, ["description"] = true, ["completedAt"] = true, ["forceCanceled"] = true, ["jobProcessDetails"] = true, ["presignedUrlConfig"] = true, ["jobId"] = true, ["lastUpdatedAt"] = true, ["targetSelection"] = true, ["timeoutConfig"] = true, ["jobExecutionsRolloutConfig"] = true, ["targets"] = true, ["createdAt"] = true, nil }

function asserts.AssertJob(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Job to be of type 'table'")
	if struct["status"] then asserts.AssertJobStatus(struct["status"]) end
	if struct["comment"] then asserts.AssertComment(struct["comment"]) end
	if struct["jobArn"] then asserts.AssertJobArn(struct["jobArn"]) end
	if struct["description"] then asserts.AssertJobDescription(struct["description"]) end
	if struct["completedAt"] then asserts.AssertDateType(struct["completedAt"]) end
	if struct["forceCanceled"] then asserts.AssertForced(struct["forceCanceled"]) end
	if struct["jobProcessDetails"] then asserts.AssertJobProcessDetails(struct["jobProcessDetails"]) end
	if struct["presignedUrlConfig"] then asserts.AssertPresignedUrlConfig(struct["presignedUrlConfig"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	if struct["lastUpdatedAt"] then asserts.AssertDateType(struct["lastUpdatedAt"]) end
	if struct["targetSelection"] then asserts.AssertTargetSelection(struct["targetSelection"]) end
	if struct["timeoutConfig"] then asserts.AssertTimeoutConfig(struct["timeoutConfig"]) end
	if struct["jobExecutionsRolloutConfig"] then asserts.AssertJobExecutionsRolloutConfig(struct["jobExecutionsRolloutConfig"]) end
	if struct["targets"] then asserts.AssertJobTargets(struct["targets"]) end
	if struct["createdAt"] then asserts.AssertDateType(struct["createdAt"]) end
	for k,_ in pairs(struct) do
		assert(keys.Job[k], "Job contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Job
-- <p>The <code>Job</code> object contains details about a job.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [JobStatus] <p>The status of the job, one of <code>IN_PROGRESS</code>, <code>CANCELED</code>, <code>DELETION_IN_PROGRESS</code> or <code>COMPLETED</code>. </p>
-- * comment [Comment] <p>If the job was updated, describes the reason for the update.</p>
-- * jobArn [JobArn] <p>An ARN identifying the job with format "arn:aws:iot:region:account:job/jobId".</p>
-- * description [JobDescription] <p>A short text description of the job.</p>
-- * completedAt [DateType] <p>The time, in milliseconds since the epoch, when the job was completed.</p>
-- * forceCanceled [Forced] <p>Will be <code>true</code> if the job was canceled with the optional <code>force</code> parameter set to <code>true</code>.</p>
-- * jobProcessDetails [JobProcessDetails] <p>Details about the job process.</p>
-- * presignedUrlConfig [PresignedUrlConfig] <p>Configuration for pre-signed S3 URLs.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- * lastUpdatedAt [DateType] <p>The time, in milliseconds since the epoch, when the job was last updated.</p>
-- * targetSelection [TargetSelection] <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a device when the thing representing the device is added to a target group, even after the job was completed by all things originally in the group. </p>
-- * timeoutConfig [TimeoutConfig] <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
-- * jobExecutionsRolloutConfig [JobExecutionsRolloutConfig] <p>Allows you to create a staged rollout of a job.</p>
-- * targets [JobTargets] <p>A list of IoT things and thing groups to which the job should be sent.</p>
-- * createdAt [DateType] <p>The time, in milliseconds since the epoch, when the job was created.</p>
-- @return Job structure as a key-value pair table
function M.Job(args)
	assert(args, "You must provide an argument table when creating Job")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["comment"] = args["comment"],
		["jobArn"] = args["jobArn"],
		["description"] = args["description"],
		["completedAt"] = args["completedAt"],
		["forceCanceled"] = args["forceCanceled"],
		["jobProcessDetails"] = args["jobProcessDetails"],
		["presignedUrlConfig"] = args["presignedUrlConfig"],
		["jobId"] = args["jobId"],
		["lastUpdatedAt"] = args["lastUpdatedAt"],
		["targetSelection"] = args["targetSelection"],
		["timeoutConfig"] = args["timeoutConfig"],
		["jobExecutionsRolloutConfig"] = args["jobExecutionsRolloutConfig"],
		["targets"] = args["targets"],
		["createdAt"] = args["createdAt"],
	}
	asserts.AssertJob(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateIndexingConfigurationResponse = { nil }

function asserts.AssertUpdateIndexingConfigurationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateIndexingConfigurationResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.UpdateIndexingConfigurationResponse[k], "UpdateIndexingConfigurationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateIndexingConfigurationResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return UpdateIndexingConfigurationResponse structure as a key-value pair table
function M.UpdateIndexingConfigurationResponse(args)
	assert(args, "You must provide an argument table when creating UpdateIndexingConfigurationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertUpdateIndexingConfigurationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachThingPrincipalResponse = { nil }

function asserts.AssertAttachThingPrincipalResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachThingPrincipalResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.AttachThingPrincipalResponse[k], "AttachThingPrincipalResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachThingPrincipalResponse
-- <p>The output from the AttachThingPrincipal operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return AttachThingPrincipalResponse structure as a key-value pair table
function M.AttachThingPrincipalResponse(args)
	assert(args, "You must provide an argument table when creating AttachThingPrincipalResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertAttachThingPrincipalResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeRoleAliasResponse = { ["roleAliasDescription"] = true, nil }

function asserts.AssertDescribeRoleAliasResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRoleAliasResponse to be of type 'table'")
	if struct["roleAliasDescription"] then asserts.AssertRoleAliasDescription(struct["roleAliasDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRoleAliasResponse[k], "DescribeRoleAliasResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRoleAliasResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleAliasDescription [RoleAliasDescription] <p>The role alias description.</p>
-- @return DescribeRoleAliasResponse structure as a key-value pair table
function M.DescribeRoleAliasResponse(args)
	assert(args, "You must provide an argument table when creating DescribeRoleAliasResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleAliasDescription"] = args["roleAliasDescription"],
	}
	asserts.AssertDescribeRoleAliasResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetLoggingOptionsRequest = { nil }

function asserts.AssertGetLoggingOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetLoggingOptionsRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.GetLoggingOptionsRequest[k], "GetLoggingOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetLoggingOptionsRequest
-- <p>The input for the GetLoggingOptions operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return GetLoggingOptionsRequest structure as a key-value pair table
function M.GetLoggingOptionsRequest(args)
	assert(args, "You must provide an argument table when creating GetLoggingOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertGetLoggingOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RelatedResource = { ["resourceType"] = true, ["additionalInfo"] = true, ["resourceIdentifier"] = true, nil }

function asserts.AssertRelatedResource(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RelatedResource to be of type 'table'")
	if struct["resourceType"] then asserts.AssertResourceType(struct["resourceType"]) end
	if struct["additionalInfo"] then asserts.AssertStringMap(struct["additionalInfo"]) end
	if struct["resourceIdentifier"] then asserts.AssertResourceIdentifier(struct["resourceIdentifier"]) end
	for k,_ in pairs(struct) do
		assert(keys.RelatedResource[k], "RelatedResource contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RelatedResource
-- <p>Information about a related resource.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * resourceType [ResourceType] <p>The type of resource.</p>
-- * additionalInfo [StringMap] <p>Additional information about the resource.</p>
-- * resourceIdentifier [ResourceIdentifier] <p>Information identifying the resource.</p>
-- @return RelatedResource structure as a key-value pair table
function M.RelatedResource(args)
	assert(args, "You must provide an argument table when creating RelatedResource")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["resourceType"] = args["resourceType"],
		["additionalInfo"] = args["additionalInfo"],
		["resourceIdentifier"] = args["resourceIdentifier"],
	}
	asserts.AssertRelatedResource(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateCertificateFromCsrResponse = { ["certificateArn"] = true, ["certificateId"] = true, ["certificatePem"] = true, nil }

function asserts.AssertCreateCertificateFromCsrResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCertificateFromCsrResponse to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["certificatePem"] then asserts.AssertCertificatePem(struct["certificatePem"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCertificateFromCsrResponse[k], "CreateCertificateFromCsrResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCertificateFromCsrResponse
-- <p>The output from the CreateCertificateFromCsr operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate. Certificate management operations only take a certificateId.</p>
-- * certificatePem [CertificatePem] <p>The certificate data, in PEM format.</p>
-- @return CreateCertificateFromCsrResponse structure as a key-value pair table
function M.CreateCertificateFromCsrResponse(args)
	assert(args, "You must provide an argument table when creating CreateCertificateFromCsrResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["certificateId"] = args["certificateId"],
		["certificatePem"] = args["certificatePem"],
	}
	asserts.AssertCreateCertificateFromCsrResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingGroupResponse = { ["thingGroupName"] = true, ["thingGroupArn"] = true, ["version"] = true, ["thingGroupMetadata"] = true, ["thingGroupProperties"] = true, ["thingGroupId"] = true, nil }

function asserts.AssertDescribeThingGroupResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingGroupResponse to be of type 'table'")
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["thingGroupArn"] then asserts.AssertThingGroupArn(struct["thingGroupArn"]) end
	if struct["version"] then asserts.AssertVersion(struct["version"]) end
	if struct["thingGroupMetadata"] then asserts.AssertThingGroupMetadata(struct["thingGroupMetadata"]) end
	if struct["thingGroupProperties"] then asserts.AssertThingGroupProperties(struct["thingGroupProperties"]) end
	if struct["thingGroupId"] then asserts.AssertThingGroupId(struct["thingGroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingGroupResponse[k], "DescribeThingGroupResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingGroupResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupName [ThingGroupName] <p>The name of the thing group.</p>
-- * thingGroupArn [ThingGroupArn] <p>The thing group ARN.</p>
-- * version [Version] <p>The version of the thing group.</p>
-- * thingGroupMetadata [ThingGroupMetadata] <p>Thing group metadata.</p>
-- * thingGroupProperties [ThingGroupProperties] <p>The thing group properties.</p>
-- * thingGroupId [ThingGroupId] <p>The thing group ID.</p>
-- @return DescribeThingGroupResponse structure as a key-value pair table
function M.DescribeThingGroupResponse(args)
	assert(args, "You must provide an argument table when creating DescribeThingGroupResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupName"] = args["thingGroupName"],
		["thingGroupArn"] = args["thingGroupArn"],
		["version"] = args["version"],
		["thingGroupMetadata"] = args["thingGroupMetadata"],
		["thingGroupProperties"] = args["thingGroupProperties"],
		["thingGroupId"] = args["thingGroupId"],
	}
	asserts.AssertDescribeThingGroupResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateOTAUpdateResponse = { ["otaUpdateArn"] = true, ["awsIotJobId"] = true, ["otaUpdateStatus"] = true, ["otaUpdateId"] = true, ["awsIotJobArn"] = true, nil }

function asserts.AssertCreateOTAUpdateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateOTAUpdateResponse to be of type 'table'")
	if struct["otaUpdateArn"] then asserts.AssertOTAUpdateArn(struct["otaUpdateArn"]) end
	if struct["awsIotJobId"] then asserts.AssertAwsIotJobId(struct["awsIotJobId"]) end
	if struct["otaUpdateStatus"] then asserts.AssertOTAUpdateStatus(struct["otaUpdateStatus"]) end
	if struct["otaUpdateId"] then asserts.AssertOTAUpdateId(struct["otaUpdateId"]) end
	if struct["awsIotJobArn"] then asserts.AssertAwsIotJobArn(struct["awsIotJobArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateOTAUpdateResponse[k], "CreateOTAUpdateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateOTAUpdateResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * otaUpdateArn [OTAUpdateArn] <p>The OTA update ARN.</p>
-- * awsIotJobId [AwsIotJobId] <p>The AWS IoT job ID associated with the OTA update.</p>
-- * otaUpdateStatus [OTAUpdateStatus] <p>The OTA update status.</p>
-- * otaUpdateId [OTAUpdateId] <p>The OTA update ID.</p>
-- * awsIotJobArn [AwsIotJobArn] <p>The AWS IoT job ARN associated with the OTA update.</p>
-- @return CreateOTAUpdateResponse structure as a key-value pair table
function M.CreateOTAUpdateResponse(args)
	assert(args, "You must provide an argument table when creating CreateOTAUpdateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["otaUpdateArn"] = args["otaUpdateArn"],
		["awsIotJobId"] = args["awsIotJobId"],
		["otaUpdateStatus"] = args["otaUpdateStatus"],
		["otaUpdateId"] = args["otaUpdateId"],
		["awsIotJobArn"] = args["awsIotJobArn"],
	}
	asserts.AssertCreateOTAUpdateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateIndexingConfigurationRequest = { ["thingIndexingConfiguration"] = true, ["thingGroupIndexingConfiguration"] = true, nil }

function asserts.AssertUpdateIndexingConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateIndexingConfigurationRequest to be of type 'table'")
	if struct["thingIndexingConfiguration"] then asserts.AssertThingIndexingConfiguration(struct["thingIndexingConfiguration"]) end
	if struct["thingGroupIndexingConfiguration"] then asserts.AssertThingGroupIndexingConfiguration(struct["thingGroupIndexingConfiguration"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateIndexingConfigurationRequest[k], "UpdateIndexingConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateIndexingConfigurationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingIndexingConfiguration [ThingIndexingConfiguration] <p>Thing indexing configuration.</p>
-- * thingGroupIndexingConfiguration [ThingGroupIndexingConfiguration] <p>Thing group indexing configuration.</p>
-- @return UpdateIndexingConfigurationRequest structure as a key-value pair table
function M.UpdateIndexingConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating UpdateIndexingConfigurationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingIndexingConfiguration"] = args["thingIndexingConfiguration"],
		["thingGroupIndexingConfiguration"] = args["thingGroupIndexingConfiguration"],
	}
	asserts.AssertUpdateIndexingConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CertificateValidity = { ["notAfter"] = true, ["notBefore"] = true, nil }

function asserts.AssertCertificateValidity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CertificateValidity to be of type 'table'")
	if struct["notAfter"] then asserts.AssertDateType(struct["notAfter"]) end
	if struct["notBefore"] then asserts.AssertDateType(struct["notBefore"]) end
	for k,_ in pairs(struct) do
		assert(keys.CertificateValidity[k], "CertificateValidity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CertificateValidity
-- <p>When the certificate is valid.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * notAfter [DateType] <p>The certificate is not valid after this date.</p>
-- * notBefore [DateType] <p>The certificate is not valid before this date.</p>
-- @return CertificateValidity structure as a key-value pair table
function M.CertificateValidity(args)
	assert(args, "You must provide an argument table when creating CertificateValidity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["notAfter"] = args["notAfter"],
		["notBefore"] = args["notBefore"],
	}
	asserts.AssertCertificateValidity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteJobRequest = { ["force"] = true, ["jobId"] = true, nil }

function asserts.AssertDeleteJobRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteJobRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	if struct["force"] then asserts.AssertForceFlag(struct["force"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteJobRequest[k], "DeleteJobRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteJobRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * force [ForceFlag] <p>(Optional) When true, you can delete a job which is "IN_PROGRESS". Otherwise, you can only delete a job which is in a terminal state ("COMPLETED" or "CANCELED") or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note>
-- * jobId [JobId] <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
-- Required key: jobId
-- @return DeleteJobRequest structure as a key-value pair table
function M.DeleteJobRequest(args)
	assert(args, "You must provide an argument table when creating DeleteJobRequest")
    local query_args = { 
        ["force"] = args["force"],
    }
    local uri_args = { 
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["force"] = args["force"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertDeleteJobRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreatePolicyVersionResponse = { ["policyDocument"] = true, ["policyVersionId"] = true, ["policyArn"] = true, ["isDefaultVersion"] = true, nil }

function asserts.AssertCreatePolicyVersionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePolicyVersionResponse to be of type 'table'")
	if struct["policyDocument"] then asserts.AssertPolicyDocument(struct["policyDocument"]) end
	if struct["policyVersionId"] then asserts.AssertPolicyVersionId(struct["policyVersionId"]) end
	if struct["policyArn"] then asserts.AssertPolicyArn(struct["policyArn"]) end
	if struct["isDefaultVersion"] then asserts.AssertIsDefaultVersion(struct["isDefaultVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePolicyVersionResponse[k], "CreatePolicyVersionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePolicyVersionResponse
-- <p>The output of the CreatePolicyVersion operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyDocument [PolicyDocument] <p>The JSON document that describes the policy.</p>
-- * policyVersionId [PolicyVersionId] <p>The policy version ID.</p>
-- * policyArn [PolicyArn] <p>The policy ARN.</p>
-- * isDefaultVersion [IsDefaultVersion] <p>Specifies whether the policy version is the default.</p>
-- @return CreatePolicyVersionResponse structure as a key-value pair table
function M.CreatePolicyVersionResponse(args)
	assert(args, "You must provide an argument table when creating CreatePolicyVersionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyDocument"] = args["policyDocument"],
		["policyVersionId"] = args["policyVersionId"],
		["policyArn"] = args["policyArn"],
		["isDefaultVersion"] = args["isDefaultVersion"],
	}
	asserts.AssertCreatePolicyVersionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetRegistrationCodeRequest = { nil }

function asserts.AssertGetRegistrationCodeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetRegistrationCodeRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.GetRegistrationCodeRequest[k], "GetRegistrationCodeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetRegistrationCodeRequest
-- <p>The input to the GetRegistrationCode operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return GetRegistrationCodeRequest structure as a key-value pair table
function M.GetRegistrationCodeRequest(args)
	assert(args, "You must provide an argument table when creating GetRegistrationCodeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertGetRegistrationCodeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.OTAUpdateInfo = { ["otaUpdateArn"] = true, ["errorInfo"] = true, ["otaUpdateFiles"] = true, ["otaUpdateId"] = true, ["lastModifiedDate"] = true, ["awsIotJobId"] = true, ["awsIotJobArn"] = true, ["additionalParameters"] = true, ["targetSelection"] = true, ["awsJobExecutionsRolloutConfig"] = true, ["otaUpdateStatus"] = true, ["creationDate"] = true, ["targets"] = true, ["description"] = true, nil }

function asserts.AssertOTAUpdateInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected OTAUpdateInfo to be of type 'table'")
	if struct["otaUpdateArn"] then asserts.AssertOTAUpdateArn(struct["otaUpdateArn"]) end
	if struct["errorInfo"] then asserts.AssertErrorInfo(struct["errorInfo"]) end
	if struct["otaUpdateFiles"] then asserts.AssertOTAUpdateFiles(struct["otaUpdateFiles"]) end
	if struct["otaUpdateId"] then asserts.AssertOTAUpdateId(struct["otaUpdateId"]) end
	if struct["lastModifiedDate"] then asserts.AssertDateType(struct["lastModifiedDate"]) end
	if struct["awsIotJobId"] then asserts.AssertAwsIotJobId(struct["awsIotJobId"]) end
	if struct["awsIotJobArn"] then asserts.AssertAwsIotJobArn(struct["awsIotJobArn"]) end
	if struct["additionalParameters"] then asserts.AssertAdditionalParameterMap(struct["additionalParameters"]) end
	if struct["targetSelection"] then asserts.AssertTargetSelection(struct["targetSelection"]) end
	if struct["awsJobExecutionsRolloutConfig"] then asserts.AssertAwsJobExecutionsRolloutConfig(struct["awsJobExecutionsRolloutConfig"]) end
	if struct["otaUpdateStatus"] then asserts.AssertOTAUpdateStatus(struct["otaUpdateStatus"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	if struct["targets"] then asserts.AssertTargets(struct["targets"]) end
	if struct["description"] then asserts.AssertOTAUpdateDescription(struct["description"]) end
	for k,_ in pairs(struct) do
		assert(keys.OTAUpdateInfo[k], "OTAUpdateInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type OTAUpdateInfo
-- <p>Information about an OTA update.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * otaUpdateArn [OTAUpdateArn] <p>The OTA update ARN.</p>
-- * errorInfo [ErrorInfo] <p>Error information associated with the OTA update.</p>
-- * otaUpdateFiles [OTAUpdateFiles] <p>A list of files associated with the OTA update.</p>
-- * otaUpdateId [OTAUpdateId] <p>The OTA update ID.</p>
-- * lastModifiedDate [DateType] <p>The date when the OTA update was last updated.</p>
-- * awsIotJobId [AwsIotJobId] <p>The AWS IoT job ID associated with the OTA update.</p>
-- * awsIotJobArn [AwsIotJobArn] <p>The AWS IoT job ARN associated with the OTA update.</p>
-- * additionalParameters [AdditionalParameterMap] <p>A collection of name/value pairs</p>
-- * targetSelection [TargetSelection] <p>Specifies whether the OTA update will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the OTA update (SNAPSHOT). If continuous, the OTA update may also be run on a thing when a change is detected in a target. For example, an OTA update will run on a thing when the thing is added to a target group, even after the OTA update was completed by all things originally in the group. </p>
-- * awsJobExecutionsRolloutConfig [AwsJobExecutionsRolloutConfig] <p>Configuration for the rollout of OTA updates.</p>
-- * otaUpdateStatus [OTAUpdateStatus] <p>The status of the OTA update.</p>
-- * creationDate [DateType] <p>The date when the OTA update was created.</p>
-- * targets [Targets] <p>The targets of the OTA update.</p>
-- * description [OTAUpdateDescription] <p>A description of the OTA update.</p>
-- @return OTAUpdateInfo structure as a key-value pair table
function M.OTAUpdateInfo(args)
	assert(args, "You must provide an argument table when creating OTAUpdateInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["otaUpdateArn"] = args["otaUpdateArn"],
		["errorInfo"] = args["errorInfo"],
		["otaUpdateFiles"] = args["otaUpdateFiles"],
		["otaUpdateId"] = args["otaUpdateId"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["awsIotJobId"] = args["awsIotJobId"],
		["awsIotJobArn"] = args["awsIotJobArn"],
		["additionalParameters"] = args["additionalParameters"],
		["targetSelection"] = args["targetSelection"],
		["awsJobExecutionsRolloutConfig"] = args["awsJobExecutionsRolloutConfig"],
		["otaUpdateStatus"] = args["otaUpdateStatus"],
		["creationDate"] = args["creationDate"],
		["targets"] = args["targets"],
		["description"] = args["description"],
	}
	asserts.AssertOTAUpdateInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteStreamResponse = { nil }

function asserts.AssertDeleteStreamResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteStreamResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteStreamResponse[k], "DeleteStreamResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteStreamResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteStreamResponse structure as a key-value pair table
function M.DeleteStreamResponse(args)
	assert(args, "You must provide an argument table when creating DeleteStreamResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteStreamResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachPolicyRequest = { ["policyName"] = true, ["target"] = true, nil }

function asserts.AssertDetachPolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachPolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["target"], "Expected key target to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["target"] then asserts.AssertPolicyTarget(struct["target"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachPolicyRequest[k], "DetachPolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachPolicyRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy to detach.</p>
-- * target [PolicyTarget] <p>The target from which the policy will be detached.</p>
-- Required key: policyName
-- Required key: target
-- @return DetachPolicyRequest structure as a key-value pair table
function M.DetachPolicyRequest(args)
	assert(args, "You must provide an argument table when creating DetachPolicyRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["target"] = args["target"],
	}
	asserts.AssertDetachPolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SalesforceAction = { ["url"] = true, ["token"] = true, nil }

function asserts.AssertSalesforceAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SalesforceAction to be of type 'table'")
	assert(struct["token"], "Expected key token to exist in table")
	assert(struct["url"], "Expected key url to exist in table")
	if struct["url"] then asserts.AssertSalesforceEndpoint(struct["url"]) end
	if struct["token"] then asserts.AssertSalesforceToken(struct["token"]) end
	for k,_ in pairs(struct) do
		assert(keys.SalesforceAction[k], "SalesforceAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SalesforceAction
-- <p>Describes an action to write a message to a Salesforce IoT Cloud Input Stream.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * url [SalesforceEndpoint] <p>The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available from the Salesforce IoT Cloud platform after creation of the Input Stream.</p>
-- * token [SalesforceToken] <p>The token used to authenticate access to the Salesforce IoT Cloud Input Stream. The token is available from the Salesforce IoT Cloud platform after creation of the Input Stream.</p>
-- Required key: token
-- Required key: url
-- @return SalesforceAction structure as a key-value pair table
function M.SalesforceAction(args)
	assert(args, "You must provide an argument table when creating SalesforceAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["url"] = args["url"],
		["token"] = args["token"],
	}
	asserts.AssertSalesforceAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCertificateResponse = { ["certificateDescription"] = true, nil }

function asserts.AssertDescribeCertificateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCertificateResponse to be of type 'table'")
	if struct["certificateDescription"] then asserts.AssertCertificateDescription(struct["certificateDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCertificateResponse[k], "DescribeCertificateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCertificateResponse
-- <p>The output of the DescribeCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateDescription [CertificateDescription] <p>The description of the certificate.</p>
-- @return DescribeCertificateResponse structure as a key-value pair table
function M.DescribeCertificateResponse(args)
	assert(args, "You must provide an argument table when creating DescribeCertificateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateDescription"] = args["certificateDescription"],
	}
	asserts.AssertDescribeCertificateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateThingResponse = { nil }

function asserts.AssertUpdateThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateThingResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.UpdateThingResponse[k], "UpdateThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateThingResponse
-- <p>The output from the UpdateThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return UpdateThingResponse structure as a key-value pair table
function M.UpdateThingResponse(args)
	assert(args, "You must provide an argument table when creating UpdateThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertUpdateThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteAuthorizerRequest = { ["authorizerName"] = true, nil }

function asserts.AssertDeleteAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteAuthorizerRequest to be of type 'table'")
	assert(struct["authorizerName"], "Expected key authorizerName to exist in table")
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteAuthorizerRequest[k], "DeleteAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerName [AuthorizerName] <p>The name of the authorizer to delete.</p>
-- Required key: authorizerName
-- @return DeleteAuthorizerRequest structure as a key-value pair table
function M.DeleteAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating DeleteAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{authorizerName}"] = args["authorizerName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerName"] = args["authorizerName"],
	}
	asserts.AssertDeleteAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateThingGroupRequest = { ["thingGroupName"] = true, ["thingGroupProperties"] = true, ["parentGroupName"] = true, nil }

function asserts.AssertCreateThingGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateThingGroupRequest to be of type 'table'")
	assert(struct["thingGroupName"], "Expected key thingGroupName to exist in table")
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["thingGroupProperties"] then asserts.AssertThingGroupProperties(struct["thingGroupProperties"]) end
	if struct["parentGroupName"] then asserts.AssertThingGroupName(struct["parentGroupName"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateThingGroupRequest[k], "CreateThingGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateThingGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupName [ThingGroupName] <p>The thing group name to create.</p>
-- * thingGroupProperties [ThingGroupProperties] <p>The thing group properties.</p>
-- * parentGroupName [ThingGroupName] <p>The name of the parent thing group.</p>
-- Required key: thingGroupName
-- @return CreateThingGroupRequest structure as a key-value pair table
function M.CreateThingGroupRequest(args)
	assert(args, "You must provide an argument table when creating CreateThingGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingGroupName}"] = args["thingGroupName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupName"] = args["thingGroupName"],
		["thingGroupProperties"] = args["thingGroupProperties"],
		["parentGroupName"] = args["parentGroupName"],
	}
	asserts.AssertCreateThingGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ExplicitDeny = { ["policies"] = true, nil }

function asserts.AssertExplicitDeny(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExplicitDeny to be of type 'table'")
	if struct["policies"] then asserts.AssertPolicies(struct["policies"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExplicitDeny[k], "ExplicitDeny contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExplicitDeny
-- <p>Information that explicitly denies authorization.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policies [Policies] <p>The policies that denied the authorization.</p>
-- @return ExplicitDeny structure as a key-value pair table
function M.ExplicitDeny(args)
	assert(args, "You must provide an argument table when creating ExplicitDeny")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policies"] = args["policies"],
	}
	asserts.AssertExplicitDeny(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceTopicRuleRequest = { ["topicRulePayload"] = true, ["ruleName"] = true, nil }

function asserts.AssertReplaceTopicRuleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceTopicRuleRequest to be of type 'table'")
	assert(struct["ruleName"], "Expected key ruleName to exist in table")
	assert(struct["topicRulePayload"], "Expected key topicRulePayload to exist in table")
	if struct["topicRulePayload"] then asserts.AssertTopicRulePayload(struct["topicRulePayload"]) end
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceTopicRuleRequest[k], "ReplaceTopicRuleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceTopicRuleRequest
-- <p>The input for the ReplaceTopicRule operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * topicRulePayload [TopicRulePayload] <p>The rule payload.</p>
-- * ruleName [RuleName] <p>The name of the rule.</p>
-- Required key: ruleName
-- Required key: topicRulePayload
-- @return ReplaceTopicRuleRequest structure as a key-value pair table
function M.ReplaceTopicRuleRequest(args)
	assert(args, "You must provide an argument table when creating ReplaceTopicRuleRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{ruleName}"] = args["ruleName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["topicRulePayload"] = args["topicRulePayload"],
		["ruleName"] = args["ruleName"],
	}
	asserts.AssertReplaceTopicRuleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuditTaskMetadata = { ["taskType"] = true, ["taskId"] = true, ["taskStatus"] = true, nil }

function asserts.AssertAuditTaskMetadata(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuditTaskMetadata to be of type 'table'")
	if struct["taskType"] then asserts.AssertAuditTaskType(struct["taskType"]) end
	if struct["taskId"] then asserts.AssertAuditTaskId(struct["taskId"]) end
	if struct["taskStatus"] then asserts.AssertAuditTaskStatus(struct["taskStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuditTaskMetadata[k], "AuditTaskMetadata contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuditTaskMetadata
-- <p>The audits that were performed.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskType [AuditTaskType] <p>The type of this audit: one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
-- * taskId [AuditTaskId] <p>The ID of this audit.</p>
-- * taskStatus [AuditTaskStatus] <p>The status of this audit: one of "IN_PROGRESS", "COMPLETED", "FAILED" or "CANCELED".</p>
-- @return AuditTaskMetadata structure as a key-value pair table
function M.AuditTaskMetadata(args)
	assert(args, "You must provide an argument table when creating AuditTaskMetadata")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["taskType"] = args["taskType"],
		["taskId"] = args["taskId"],
		["taskStatus"] = args["taskStatus"],
	}
	asserts.AssertAuditTaskMetadata(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteThingTypeRequest = { ["thingTypeName"] = true, nil }

function asserts.AssertDeleteThingTypeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteThingTypeRequest to be of type 'table'")
	assert(struct["thingTypeName"], "Expected key thingTypeName to exist in table")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteThingTypeRequest[k], "DeleteThingTypeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteThingTypeRequest
-- <p>The input for the DeleteThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- Required key: thingTypeName
-- @return DeleteThingTypeRequest structure as a key-value pair table
function M.DeleteThingTypeRequest(args)
	assert(args, "You must provide an argument table when creating DeleteThingTypeRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingTypeName}"] = args["thingTypeName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
	}
	asserts.AssertDeleteThingTypeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SetDefaultAuthorizerResponse = { ["authorizerName"] = true, ["authorizerArn"] = true, nil }

function asserts.AssertSetDefaultAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SetDefaultAuthorizerResponse to be of type 'table'")
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	if struct["authorizerArn"] then asserts.AssertAuthorizerArn(struct["authorizerArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.SetDefaultAuthorizerResponse[k], "SetDefaultAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SetDefaultAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerName [AuthorizerName] <p>The authorizer name.</p>
-- * authorizerArn [AuthorizerArn] <p>The authorizer ARN.</p>
-- @return SetDefaultAuthorizerResponse structure as a key-value pair table
function M.SetDefaultAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating SetDefaultAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerName"] = args["authorizerName"],
		["authorizerArn"] = args["authorizerArn"],
	}
	asserts.AssertSetDefaultAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetLoggingOptionsResponse = { ["logLevel"] = true, ["roleArn"] = true, nil }

function asserts.AssertGetLoggingOptionsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetLoggingOptionsResponse to be of type 'table'")
	if struct["logLevel"] then asserts.AssertLogLevel(struct["logLevel"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetLoggingOptionsResponse[k], "GetLoggingOptionsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetLoggingOptionsResponse
-- <p>The output from the GetLoggingOptions operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * logLevel [LogLevel] <p>The logging level.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access.</p>
-- @return GetLoggingOptionsResponse structure as a key-value pair table
function M.GetLoggingOptionsResponse(args)
	assert(args, "You must provide an argument table when creating GetLoggingOptionsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["logLevel"] = args["logLevel"],
		["roleArn"] = args["roleArn"],
	}
	asserts.AssertGetLoggingOptionsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListRoleAliasesResponse = { ["nextMarker"] = true, ["roleAliases"] = true, nil }

function asserts.AssertListRoleAliasesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListRoleAliasesResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["roleAliases"] then asserts.AssertRoleAliases(struct["roleAliases"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListRoleAliasesResponse[k], "ListRoleAliasesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListRoleAliasesResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>A marker used to get the next set of results.</p>
-- * roleAliases [RoleAliases] <p>The role aliases.</p>
-- @return ListRoleAliasesResponse structure as a key-value pair table
function M.ListRoleAliasesResponse(args)
	assert(args, "You must provide an argument table when creating ListRoleAliasesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["roleAliases"] = args["roleAliases"],
	}
	asserts.AssertListRoleAliasesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SetLoggingOptionsRequest = { ["loggingOptionsPayload"] = true, nil }

function asserts.AssertSetLoggingOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SetLoggingOptionsRequest to be of type 'table'")
	assert(struct["loggingOptionsPayload"], "Expected key loggingOptionsPayload to exist in table")
	if struct["loggingOptionsPayload"] then asserts.AssertLoggingOptionsPayload(struct["loggingOptionsPayload"]) end
	for k,_ in pairs(struct) do
		assert(keys.SetLoggingOptionsRequest[k], "SetLoggingOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SetLoggingOptionsRequest
-- <p>The input for the SetLoggingOptions operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * loggingOptionsPayload [LoggingOptionsPayload] <p>The logging options payload.</p>
-- Required key: loggingOptionsPayload
-- @return SetLoggingOptionsRequest structure as a key-value pair table
function M.SetLoggingOptionsRequest(args)
	assert(args, "You must provide an argument table when creating SetLoggingOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["loggingOptionsPayload"] = args["loggingOptionsPayload"],
	}
	asserts.AssertSetLoggingOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteTopicRuleRequest = { ["ruleName"] = true, nil }

function asserts.AssertDeleteTopicRuleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteTopicRuleRequest to be of type 'table'")
	assert(struct["ruleName"], "Expected key ruleName to exist in table")
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteTopicRuleRequest[k], "DeleteTopicRuleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteTopicRuleRequest
-- <p>The input for the DeleteTopicRule operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ruleName [RuleName] <p>The name of the rule.</p>
-- Required key: ruleName
-- @return DeleteTopicRuleRequest structure as a key-value pair table
function M.DeleteTopicRuleRequest(args)
	assert(args, "You must provide an argument table when creating DeleteTopicRuleRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{ruleName}"] = args["ruleName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["ruleName"] = args["ruleName"],
	}
	asserts.AssertDeleteTopicRuleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeletePolicyVersionRequest = { ["policyName"] = true, ["policyVersionId"] = true, nil }

function asserts.AssertDeletePolicyVersionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePolicyVersionRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["policyVersionId"], "Expected key policyVersionId to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyVersionId"] then asserts.AssertPolicyVersionId(struct["policyVersionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeletePolicyVersionRequest[k], "DeletePolicyVersionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePolicyVersionRequest
-- <p>The input for the DeletePolicyVersion operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The name of the policy.</p>
-- * policyVersionId [PolicyVersionId] <p>The policy version ID.</p>
-- Required key: policyName
-- Required key: policyVersionId
-- @return DeletePolicyVersionRequest structure as a key-value pair table
function M.DeletePolicyVersionRequest(args)
	assert(args, "You must provide an argument table when creating DeletePolicyVersionRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
        ["{policyVersionId}"] = args["policyVersionId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyVersionId"] = args["policyVersionId"],
	}
	asserts.AssertDeletePolicyVersionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTargetsForSecurityProfileResponse = { ["nextToken"] = true, ["securityProfileTargets"] = true, nil }

function asserts.AssertListTargetsForSecurityProfileResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTargetsForSecurityProfileResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["securityProfileTargets"] then asserts.AssertSecurityProfileTargets(struct["securityProfileTargets"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTargetsForSecurityProfileResponse[k], "ListTargetsForSecurityProfileResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTargetsForSecurityProfileResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- * securityProfileTargets [SecurityProfileTargets] <p>The thing groups to which the security profile is attached.</p>
-- @return ListTargetsForSecurityProfileResponse structure as a key-value pair table
function M.ListTargetsForSecurityProfileResponse(args)
	assert(args, "You must provide an argument table when creating ListTargetsForSecurityProfileResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["securityProfileTargets"] = args["securityProfileTargets"],
	}
	asserts.AssertListTargetsForSecurityProfileResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListSecurityProfilesForTargetRequest = { ["securityProfileTargetArn"] = true, ["nextToken"] = true, ["recursive"] = true, ["maxResults"] = true, nil }

function asserts.AssertListSecurityProfilesForTargetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListSecurityProfilesForTargetRequest to be of type 'table'")
	assert(struct["securityProfileTargetArn"], "Expected key securityProfileTargetArn to exist in table")
	if struct["securityProfileTargetArn"] then asserts.AssertSecurityProfileTargetArn(struct["securityProfileTargetArn"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["recursive"] then asserts.AssertRecursive(struct["recursive"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListSecurityProfilesForTargetRequest[k], "ListSecurityProfilesForTargetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListSecurityProfilesForTargetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileTargetArn [SecurityProfileTargetArn] <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- * recursive [Recursive] <p>If true, return child groups as well.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time.</p>
-- Required key: securityProfileTargetArn
-- @return ListSecurityProfilesForTargetRequest structure as a key-value pair table
function M.ListSecurityProfilesForTargetRequest(args)
	assert(args, "You must provide an argument table when creating ListSecurityProfilesForTargetRequest")
    local query_args = { 
        ["securityProfileTargetArn"] = args["securityProfileTargetArn"],
        ["nextToken"] = args["nextToken"],
        ["recursive"] = args["recursive"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileTargetArn"] = args["securityProfileTargetArn"],
		["nextToken"] = args["nextToken"],
		["recursive"] = args["recursive"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListSecurityProfilesForTargetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteCertificateRequest = { ["forceDelete"] = true, ["certificateId"] = true, nil }

function asserts.AssertDeleteCertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteCertificateRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["forceDelete"] then asserts.AssertForceDelete(struct["forceDelete"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteCertificateRequest[k], "DeleteCertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteCertificateRequest
-- <p>The input for the DeleteCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * forceDelete [ForceDelete] <p>Forces a certificate request to be deleted.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- Required key: certificateId
-- @return DeleteCertificateRequest structure as a key-value pair table
function M.DeleteCertificateRequest(args)
	assert(args, "You must provide an argument table when creating DeleteCertificateRequest")
    local query_args = { 
        ["forceDelete"] = args["forceDelete"],
    }
    local uri_args = { 
        ["{certificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["forceDelete"] = args["forceDelete"],
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertDeleteCertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelJobExecutionRequest = { ["force"] = true, ["expectedVersion"] = true, ["thingName"] = true, ["statusDetails"] = true, ["jobId"] = true, nil }

function asserts.AssertCancelJobExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelJobExecutionRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["force"] then asserts.AssertForceFlag(struct["force"]) end
	if struct["expectedVersion"] then asserts.AssertExpectedVersion(struct["expectedVersion"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["statusDetails"] then asserts.AssertDetailsMap(struct["statusDetails"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelJobExecutionRequest[k], "CancelJobExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelJobExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * force [ForceFlag] <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
-- * expectedVersion [ExpectedVersion] <p>(Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)</p>
-- * thingName [ThingName] <p>The name of the thing whose execution of the job will be canceled.</p>
-- * statusDetails [DetailsMap] <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
-- * jobId [JobId] <p>The ID of the job to be canceled.</p>
-- Required key: jobId
-- Required key: thingName
-- @return CancelJobExecutionRequest structure as a key-value pair table
function M.CancelJobExecutionRequest(args)
	assert(args, "You must provide an argument table when creating CancelJobExecutionRequest")
    local query_args = { 
        ["force"] = args["force"],
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["force"] = args["force"],
		["expectedVersion"] = args["expectedVersion"],
		["thingName"] = args["thingName"],
		["statusDetails"] = args["statusDetails"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertCancelJobExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.OutgoingCertificate = { ["certificateArn"] = true, ["certificateId"] = true, ["transferDate"] = true, ["transferredTo"] = true, ["transferMessage"] = true, ["creationDate"] = true, nil }

function asserts.AssertOutgoingCertificate(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected OutgoingCertificate to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["transferDate"] then asserts.AssertDateType(struct["transferDate"]) end
	if struct["transferredTo"] then asserts.AssertAwsAccountId(struct["transferredTo"]) end
	if struct["transferMessage"] then asserts.AssertMessage(struct["transferMessage"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.OutgoingCertificate[k], "OutgoingCertificate contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type OutgoingCertificate
-- <p>A certificate that has been transferred but not yet accepted.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The certificate ARN.</p>
-- * certificateId [CertificateId] <p>The certificate ID.</p>
-- * transferDate [DateType] <p>The date the transfer was initiated.</p>
-- * transferredTo [AwsAccountId] <p>The AWS account to which the transfer was made.</p>
-- * transferMessage [Message] <p>The transfer message.</p>
-- * creationDate [DateType] <p>The certificate creation date.</p>
-- @return OutgoingCertificate structure as a key-value pair table
function M.OutgoingCertificate(args)
	assert(args, "You must provide an argument table when creating OutgoingCertificate")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["certificateId"] = args["certificateId"],
		["transferDate"] = args["transferDate"],
		["transferredTo"] = args["transferredTo"],
		["transferMessage"] = args["transferMessage"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertOutgoingCertificate(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterThingResponse = { ["certificatePem"] = true, ["resourceArns"] = true, nil }

function asserts.AssertRegisterThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterThingResponse to be of type 'table'")
	if struct["certificatePem"] then asserts.AssertCertificatePem(struct["certificatePem"]) end
	if struct["resourceArns"] then asserts.AssertResourceArns(struct["resourceArns"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterThingResponse[k], "RegisterThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterThingResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificatePem [CertificatePem] <p>.</p>
-- * resourceArns [ResourceArns] <p>ARNs for the generated resources.</p>
-- @return RegisterThingResponse structure as a key-value pair table
function M.RegisterThingResponse(args)
	assert(args, "You must provide an argument table when creating RegisterThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificatePem"] = args["certificatePem"],
		["resourceArns"] = args["resourceArns"],
	}
	asserts.AssertRegisterThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPolicyRequest = { ["policyName"] = true, nil }

function asserts.AssertGetPolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPolicyRequest[k], "GetPolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPolicyRequest
-- <p>The input for the GetPolicy operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The name of the policy.</p>
-- Required key: policyName
-- @return GetPolicyRequest structure as a key-value pair table
function M.GetPolicyRequest(args)
	assert(args, "You must provide an argument table when creating GetPolicyRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
	}
	asserts.AssertGetPolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteAccountAuditConfigurationRequest = { ["deleteScheduledAudits"] = true, nil }

function asserts.AssertDeleteAccountAuditConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteAccountAuditConfigurationRequest to be of type 'table'")
	if struct["deleteScheduledAudits"] then asserts.AssertDeleteScheduledAudits(struct["deleteScheduledAudits"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteAccountAuditConfigurationRequest[k], "DeleteAccountAuditConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteAccountAuditConfigurationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * deleteScheduledAudits [DeleteScheduledAudits] <p>If true, all scheduled audits are deleted.</p>
-- @return DeleteAccountAuditConfigurationRequest structure as a key-value pair table
function M.DeleteAccountAuditConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating DeleteAccountAuditConfigurationRequest")
    local query_args = { 
        ["deleteScheduledAudits"] = args["deleteScheduledAudits"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["deleteScheduledAudits"] = args["deleteScheduledAudits"],
	}
	asserts.AssertDeleteAccountAuditConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteThingGroupRequest = { ["thingGroupName"] = true, ["expectedVersion"] = true, nil }

function asserts.AssertDeleteThingGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteThingGroupRequest to be of type 'table'")
	assert(struct["thingGroupName"], "Expected key thingGroupName to exist in table")
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["expectedVersion"] then asserts.AssertOptionalVersion(struct["expectedVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteThingGroupRequest[k], "DeleteThingGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteThingGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupName [ThingGroupName] <p>The name of the thing group to delete.</p>
-- * expectedVersion [OptionalVersion] <p>The expected version of the thing group to delete.</p>
-- Required key: thingGroupName
-- @return DeleteThingGroupRequest structure as a key-value pair table
function M.DeleteThingGroupRequest(args)
	assert(args, "You must provide an argument table when creating DeleteThingGroupRequest")
    local query_args = { 
        ["expectedVersion"] = args["expectedVersion"],
    }
    local uri_args = { 
        ["{thingGroupName}"] = args["thingGroupName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupName"] = args["thingGroupName"],
		["expectedVersion"] = args["expectedVersion"],
	}
	asserts.AssertDeleteThingGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartOnDemandAuditTaskResponse = { ["taskId"] = true, nil }

function asserts.AssertStartOnDemandAuditTaskResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartOnDemandAuditTaskResponse to be of type 'table'")
	if struct["taskId"] then asserts.AssertAuditTaskId(struct["taskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartOnDemandAuditTaskResponse[k], "StartOnDemandAuditTaskResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartOnDemandAuditTaskResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskId [AuditTaskId] <p>The ID of the on-demand audit you started.</p>
-- @return StartOnDemandAuditTaskResponse structure as a key-value pair table
function M.StartOnDemandAuditTaskResponse(args)
	assert(args, "You must provide an argument table when creating StartOnDemandAuditTaskResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["taskId"] = args["taskId"],
	}
	asserts.AssertStartOnDemandAuditTaskResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingTypeRequest = { ["thingTypeName"] = true, nil }

function asserts.AssertDescribeThingTypeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingTypeRequest to be of type 'table'")
	assert(struct["thingTypeName"], "Expected key thingTypeName to exist in table")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingTypeRequest[k], "DescribeThingTypeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingTypeRequest
-- <p>The input for the DescribeThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- Required key: thingTypeName
-- @return DescribeThingTypeRequest structure as a key-value pair table
function M.DescribeThingTypeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeThingTypeRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingTypeName}"] = args["thingTypeName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
	}
	asserts.AssertDescribeThingTypeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.S3Destination = { ["prefix"] = true, ["bucket"] = true, nil }

function asserts.AssertS3Destination(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3Destination to be of type 'table'")
	if struct["prefix"] then asserts.AssertPrefix(struct["prefix"]) end
	if struct["bucket"] then asserts.AssertS3Bucket(struct["bucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3Destination[k], "S3Destination contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3Destination
-- <p>Describes the location of updated firmware in S3.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * prefix [Prefix] <p>The S3 prefix.</p>
-- * bucket [S3Bucket] <p>The S3 bucket that contains the updated firmware.</p>
-- @return S3Destination structure as a key-value pair table
function M.S3Destination(args)
	assert(args, "You must provide an argument table when creating S3Destination")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["prefix"] = args["prefix"],
		["bucket"] = args["bucket"],
	}
	asserts.AssertS3Destination(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateStreamResponse = { ["streamVersion"] = true, ["streamArn"] = true, ["description"] = true, ["streamId"] = true, nil }

function asserts.AssertCreateStreamResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateStreamResponse to be of type 'table'")
	if struct["streamVersion"] then asserts.AssertStreamVersion(struct["streamVersion"]) end
	if struct["streamArn"] then asserts.AssertStreamArn(struct["streamArn"]) end
	if struct["description"] then asserts.AssertStreamDescription(struct["description"]) end
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateStreamResponse[k], "CreateStreamResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateStreamResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * streamVersion [StreamVersion] <p>The version of the stream.</p>
-- * streamArn [StreamArn] <p>The stream ARN.</p>
-- * description [StreamDescription] <p>A description of the stream.</p>
-- * streamId [StreamId] <p>The stream ID.</p>
-- @return CreateStreamResponse structure as a key-value pair table
function M.CreateStreamResponse(args)
	assert(args, "You must provide an argument table when creating CreateStreamResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["streamVersion"] = args["streamVersion"],
		["streamArn"] = args["streamArn"],
		["description"] = args["description"],
		["streamId"] = args["streamId"],
	}
	asserts.AssertCreateStreamResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeRoleAliasRequest = { ["roleAlias"] = true, nil }

function asserts.AssertDescribeRoleAliasRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRoleAliasRequest to be of type 'table'")
	assert(struct["roleAlias"], "Expected key roleAlias to exist in table")
	if struct["roleAlias"] then asserts.AssertRoleAlias(struct["roleAlias"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRoleAliasRequest[k], "DescribeRoleAliasRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRoleAliasRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleAlias [RoleAlias] <p>The role alias to describe.</p>
-- Required key: roleAlias
-- @return DescribeRoleAliasRequest structure as a key-value pair table
function M.DescribeRoleAliasRequest(args)
	assert(args, "You must provide an argument table when creating DescribeRoleAliasRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{roleAlias}"] = args["roleAlias"],
    }
    local header_args = { 
    }
	local all_args = { 
		["roleAlias"] = args["roleAlias"],
	}
	asserts.AssertDescribeRoleAliasRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPrincipalThingsRequest = { ["nextToken"] = true, ["maxResults"] = true, ["principal"] = true, nil }

function asserts.AssertListPrincipalThingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPrincipalThingsRequest to be of type 'table'")
	assert(struct["principal"], "Expected key principal to exist in table")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPrincipalThingsRequest[k], "ListPrincipalThingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPrincipalThingsRequest
-- <p>The input for the ListPrincipalThings operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return in this operation.</p>
-- * principal [Principal] <p>The principal.</p>
-- Required key: principal
-- @return ListPrincipalThingsRequest structure as a key-value pair table
function M.ListPrincipalThingsRequest(args)
	assert(args, "You must provide an argument table when creating ListPrincipalThingsRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
        ["x-amzn-principal"] = args["principal"],
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
		["principal"] = args["principal"],
	}
	asserts.AssertListPrincipalThingsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachThingPrincipalRequest = { ["thingName"] = true, ["principal"] = true, nil }

function asserts.AssertDetachThingPrincipalRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachThingPrincipalRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	assert(struct["principal"], "Expected key principal to exist in table")
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachThingPrincipalRequest[k], "DetachThingPrincipalRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachThingPrincipalRequest
-- <p>The input for the DetachThingPrincipal operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingName [ThingName] <p>The name of the thing.</p>
-- * principal [Principal] <p>If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.</p>
-- Required key: thingName
-- Required key: principal
-- @return DetachThingPrincipalRequest structure as a key-value pair table
function M.DetachThingPrincipalRequest(args)
	assert(args, "You must provide an argument table when creating DetachThingPrincipalRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
        ["x-amzn-principal"] = args["principal"],
    }
	local all_args = { 
		["thingName"] = args["thingName"],
		["principal"] = args["principal"],
	}
	asserts.AssertDetachThingPrincipalRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PresignedUrlConfig = { ["expiresInSec"] = true, ["roleArn"] = true, nil }

function asserts.AssertPresignedUrlConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PresignedUrlConfig to be of type 'table'")
	if struct["expiresInSec"] then asserts.AssertExpiresInSec(struct["expiresInSec"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.PresignedUrlConfig[k], "PresignedUrlConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PresignedUrlConfig
-- <p>Configuration for pre-signed S3 URLs.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * expiresInSec [ExpiresInSec] <p>How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.</p>
-- * roleArn [RoleArn] <p>The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.</p>
-- @return PresignedUrlConfig structure as a key-value pair table
function M.PresignedUrlConfig(args)
	assert(args, "You must provide an argument table when creating PresignedUrlConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["expiresInSec"] = args["expiresInSec"],
		["roleArn"] = args["roleArn"],
	}
	asserts.AssertPresignedUrlConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateTargetsWithJobResponse = { ["jobArn"] = true, ["description"] = true, ["jobId"] = true, nil }

function asserts.AssertAssociateTargetsWithJobResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateTargetsWithJobResponse to be of type 'table'")
	if struct["jobArn"] then asserts.AssertJobArn(struct["jobArn"]) end
	if struct["description"] then asserts.AssertJobDescription(struct["description"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateTargetsWithJobResponse[k], "AssociateTargetsWithJobResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateTargetsWithJobResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * jobArn [JobArn] <p>An ARN identifying the job.</p>
-- * description [JobDescription] <p>A short text description of the job.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- @return AssociateTargetsWithJobResponse structure as a key-value pair table
function M.AssociateTargetsWithJobResponse(args)
	assert(args, "You must provide an argument table when creating AssociateTargetsWithJobResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["jobArn"] = args["jobArn"],
		["description"] = args["description"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertAssociateTargetsWithJobResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIndexResponse = { ["indexStatus"] = true, ["indexName"] = true, ["schema"] = true, nil }

function asserts.AssertDescribeIndexResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIndexResponse to be of type 'table'")
	if struct["indexStatus"] then asserts.AssertIndexStatus(struct["indexStatus"]) end
	if struct["indexName"] then asserts.AssertIndexName(struct["indexName"]) end
	if struct["schema"] then asserts.AssertIndexSchema(struct["schema"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIndexResponse[k], "DescribeIndexResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIndexResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * indexStatus [IndexStatus] <p>The index status.</p>
-- * indexName [IndexName] <p>The index name.</p>
-- * schema [IndexSchema] <p>Contains a value that specifies the type of indexing performed. Valid values are:</p> <ol> <li> <p>REGISTRY – Your thing index will contain only registry data.</p> </li> <li> <p>REGISTRY_AND_SHADOW - Your thing index will contain registry and shadow data.</p> </li> </ol>
-- @return DescribeIndexResponse structure as a key-value pair table
function M.DescribeIndexResponse(args)
	assert(args, "You must provide an argument table when creating DescribeIndexResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["indexStatus"] = args["indexStatus"],
		["indexName"] = args["indexName"],
		["schema"] = args["schema"],
	}
	asserts.AssertDescribeIndexResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTargetsForPolicyRequest = { ["marker"] = true, ["policyName"] = true, ["pageSize"] = true, nil }

function asserts.AssertListTargetsForPolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTargetsForPolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTargetsForPolicyRequest[k], "ListTargetsForPolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTargetsForPolicyRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>A marker used to get the next set of results.</p>
-- * policyName [PolicyName] <p>The policy name.</p>
-- * pageSize [PageSize] <p>The maximum number of results to return at one time.</p>
-- Required key: policyName
-- @return ListTargetsForPolicyRequest structure as a key-value pair table
function M.ListTargetsForPolicyRequest(args)
	assert(args, "You must provide an argument table when creating ListTargetsForPolicyRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["policyName"] = args["policyName"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListTargetsForPolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateRoleAliasRequest = { ["roleArn"] = true, ["credentialDurationSeconds"] = true, ["roleAlias"] = true, nil }

function asserts.AssertUpdateRoleAliasRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateRoleAliasRequest to be of type 'table'")
	assert(struct["roleAlias"], "Expected key roleAlias to exist in table")
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["credentialDurationSeconds"] then asserts.AssertCredentialDurationSeconds(struct["credentialDurationSeconds"]) end
	if struct["roleAlias"] then asserts.AssertRoleAlias(struct["roleAlias"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateRoleAliasRequest[k], "UpdateRoleAliasRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateRoleAliasRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [RoleArn] <p>The role ARN.</p>
-- * credentialDurationSeconds [CredentialDurationSeconds] <p>The number of seconds the credential will be valid.</p>
-- * roleAlias [RoleAlias] <p>The role alias to update.</p>
-- Required key: roleAlias
-- @return UpdateRoleAliasRequest structure as a key-value pair table
function M.UpdateRoleAliasRequest(args)
	assert(args, "You must provide an argument table when creating UpdateRoleAliasRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{roleAlias}"] = args["roleAlias"],
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["credentialDurationSeconds"] = args["credentialDurationSeconds"],
		["roleAlias"] = args["roleAlias"],
	}
	asserts.AssertUpdateRoleAliasRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisableTopicRuleRequest = { ["ruleName"] = true, nil }

function asserts.AssertDisableTopicRuleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableTopicRuleRequest to be of type 'table'")
	assert(struct["ruleName"], "Expected key ruleName to exist in table")
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableTopicRuleRequest[k], "DisableTopicRuleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableTopicRuleRequest
-- <p>The input for the DisableTopicRuleRequest operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ruleName [RuleName] <p>The name of the rule to disable.</p>
-- Required key: ruleName
-- @return DisableTopicRuleRequest structure as a key-value pair table
function M.DisableTopicRuleRequest(args)
	assert(args, "You must provide an argument table when creating DisableTopicRuleRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{ruleName}"] = args["ruleName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["ruleName"] = args["ruleName"],
	}
	asserts.AssertDisableTopicRuleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingGroupIndexingConfiguration = { ["thingGroupIndexingMode"] = true, nil }

function asserts.AssertThingGroupIndexingConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingGroupIndexingConfiguration to be of type 'table'")
	assert(struct["thingGroupIndexingMode"], "Expected key thingGroupIndexingMode to exist in table")
	if struct["thingGroupIndexingMode"] then asserts.AssertThingGroupIndexingMode(struct["thingGroupIndexingMode"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingGroupIndexingConfiguration[k], "ThingGroupIndexingConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingGroupIndexingConfiguration
-- <p>Thing group indexing configuration.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupIndexingMode [ThingGroupIndexingMode] <p>Thing group indexing mode.</p>
-- Required key: thingGroupIndexingMode
-- @return ThingGroupIndexingConfiguration structure as a key-value pair table
function M.ThingGroupIndexingConfiguration(args)
	assert(args, "You must provide an argument table when creating ThingGroupIndexingConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupIndexingMode"] = args["thingGroupIndexingMode"],
	}
	asserts.AssertThingGroupIndexingConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateTopicRuleRequest = { ["topicRulePayload"] = true, ["ruleName"] = true, nil }

function asserts.AssertCreateTopicRuleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateTopicRuleRequest to be of type 'table'")
	assert(struct["ruleName"], "Expected key ruleName to exist in table")
	assert(struct["topicRulePayload"], "Expected key topicRulePayload to exist in table")
	if struct["topicRulePayload"] then asserts.AssertTopicRulePayload(struct["topicRulePayload"]) end
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateTopicRuleRequest[k], "CreateTopicRuleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateTopicRuleRequest
-- <p>The input for the CreateTopicRule operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * topicRulePayload [TopicRulePayload] <p>The rule payload.</p>
-- * ruleName [RuleName] <p>The name of the rule.</p>
-- Required key: ruleName
-- Required key: topicRulePayload
-- @return CreateTopicRuleRequest structure as a key-value pair table
function M.CreateTopicRuleRequest(args)
	assert(args, "You must provide an argument table when creating CreateTopicRuleRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{ruleName}"] = args["ruleName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["topicRulePayload"] = args["topicRulePayload"],
		["ruleName"] = args["ruleName"],
	}
	asserts.AssertCreateTopicRuleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeJobExecutionRequest = { ["thingName"] = true, ["executionNumber"] = true, ["jobId"] = true, nil }

function asserts.AssertDescribeJobExecutionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeJobExecutionRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["executionNumber"] then asserts.AssertExecutionNumber(struct["executionNumber"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeJobExecutionRequest[k], "DescribeJobExecutionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeJobExecutionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingName [ThingName] <p>The name of the thing on which the job execution is running.</p>
-- * executionNumber [ExecutionNumber] <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- Required key: jobId
-- Required key: thingName
-- @return DescribeJobExecutionRequest structure as a key-value pair table
function M.DescribeJobExecutionRequest(args)
	assert(args, "You must provide an argument table when creating DescribeJobExecutionRequest")
    local query_args = { 
        ["executionNumber"] = args["executionNumber"],
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingName"] = args["thingName"],
		["executionNumber"] = args["executionNumber"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertDescribeJobExecutionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SecurityProfileTargetMapping = { ["securityProfileIdentifier"] = true, ["target"] = true, nil }

function asserts.AssertSecurityProfileTargetMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityProfileTargetMapping to be of type 'table'")
	if struct["securityProfileIdentifier"] then asserts.AssertSecurityProfileIdentifier(struct["securityProfileIdentifier"]) end
	if struct["target"] then asserts.AssertSecurityProfileTarget(struct["target"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityProfileTargetMapping[k], "SecurityProfileTargetMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityProfileTargetMapping
-- <p>Information about a security profile and the target associated with it.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileIdentifier [SecurityProfileIdentifier] <p>Information that identifies the security profile.</p>
-- * target [SecurityProfileTarget] <p>Information about the target (thing group) associated with the security profile.</p>
-- @return SecurityProfileTargetMapping structure as a key-value pair table
function M.SecurityProfileTargetMapping(args)
	assert(args, "You must provide an argument table when creating SecurityProfileTargetMapping")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileIdentifier"] = args["securityProfileIdentifier"],
		["target"] = args["target"],
	}
	asserts.AssertSecurityProfileTargetMapping(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TestAuthorizationRequest = { ["policyNamesToAdd"] = true, ["clientId"] = true, ["policyNamesToSkip"] = true, ["authInfos"] = true, ["cognitoIdentityPoolId"] = true, ["principal"] = true, nil }

function asserts.AssertTestAuthorizationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TestAuthorizationRequest to be of type 'table'")
	assert(struct["authInfos"], "Expected key authInfos to exist in table")
	if struct["policyNamesToAdd"] then asserts.AssertPolicyNames(struct["policyNamesToAdd"]) end
	if struct["clientId"] then asserts.AssertClientId(struct["clientId"]) end
	if struct["policyNamesToSkip"] then asserts.AssertPolicyNames(struct["policyNamesToSkip"]) end
	if struct["authInfos"] then asserts.AssertAuthInfos(struct["authInfos"]) end
	if struct["cognitoIdentityPoolId"] then asserts.AssertCognitoIdentityPoolId(struct["cognitoIdentityPoolId"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.TestAuthorizationRequest[k], "TestAuthorizationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TestAuthorizationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyNamesToAdd [PolicyNames] <p>When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.</p>
-- * clientId [ClientId] <p>The MQTT client ID.</p>
-- * policyNamesToSkip [PolicyNames] <p>When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.</p>
-- * authInfos [AuthInfos] <p>A list of authorization info objects. Simulating authorization will create a response for each <code>authInfo</code> object in the list.</p>
-- * cognitoIdentityPoolId [CognitoIdentityPoolId] <p>The Cognito identity pool ID.</p>
-- * principal [Principal] <p>The principal.</p>
-- Required key: authInfos
-- @return TestAuthorizationRequest structure as a key-value pair table
function M.TestAuthorizationRequest(args)
	assert(args, "You must provide an argument table when creating TestAuthorizationRequest")
    local query_args = { 
        ["clientId"] = args["clientId"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyNamesToAdd"] = args["policyNamesToAdd"],
		["clientId"] = args["clientId"],
		["policyNamesToSkip"] = args["policyNamesToSkip"],
		["authInfos"] = args["authInfos"],
		["cognitoIdentityPoolId"] = args["cognitoIdentityPoolId"],
		["principal"] = args["principal"],
	}
	asserts.AssertTestAuthorizationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListJobExecutionsForThingResponse = { ["nextToken"] = true, ["executionSummaries"] = true, nil }

function asserts.AssertListJobExecutionsForThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListJobExecutionsForThingResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["executionSummaries"] then asserts.AssertJobExecutionSummaryForThingList(struct["executionSummaries"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListJobExecutionsForThingResponse[k], "ListJobExecutionsForThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListJobExecutionsForThingResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
-- * executionSummaries [JobExecutionSummaryForThingList] <p>A list of job execution summaries.</p>
-- @return ListJobExecutionsForThingResponse structure as a key-value pair table
function M.ListJobExecutionsForThingResponse(args)
	assert(args, "You must provide an argument table when creating ListJobExecutionsForThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["executionSummaries"] = args["executionSummaries"],
	}
	asserts.AssertListJobExecutionsForThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CertificateDescription = { ["certificateArn"] = true, ["status"] = true, ["previousOwnedBy"] = true, ["certificateId"] = true, ["generationId"] = true, ["lastModifiedDate"] = true, ["validity"] = true, ["certificatePem"] = true, ["transferData"] = true, ["ownedBy"] = true, ["customerVersion"] = true, ["caCertificateId"] = true, ["creationDate"] = true, nil }

function asserts.AssertCertificateDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CertificateDescription to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["status"] then asserts.AssertCertificateStatus(struct["status"]) end
	if struct["previousOwnedBy"] then asserts.AssertAwsAccountId(struct["previousOwnedBy"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["generationId"] then asserts.AssertGenerationId(struct["generationId"]) end
	if struct["lastModifiedDate"] then asserts.AssertDateType(struct["lastModifiedDate"]) end
	if struct["validity"] then asserts.AssertCertificateValidity(struct["validity"]) end
	if struct["certificatePem"] then asserts.AssertCertificatePem(struct["certificatePem"]) end
	if struct["transferData"] then asserts.AssertTransferData(struct["transferData"]) end
	if struct["ownedBy"] then asserts.AssertAwsAccountId(struct["ownedBy"]) end
	if struct["customerVersion"] then asserts.AssertCustomerVersion(struct["customerVersion"]) end
	if struct["caCertificateId"] then asserts.AssertCertificateId(struct["caCertificateId"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.CertificateDescription[k], "CertificateDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CertificateDescription
-- <p>Describes a certificate.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The ARN of the certificate.</p>
-- * status [CertificateStatus] <p>The status of the certificate.</p>
-- * previousOwnedBy [AwsAccountId] <p>The ID of the AWS account of the previous owner of the certificate.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate.</p>
-- * generationId [GenerationId] <p>The generation ID of the certificate.</p>
-- * lastModifiedDate [DateType] <p>The date and time the certificate was last modified.</p>
-- * validity [CertificateValidity] <p>When the certificate is valid.</p>
-- * certificatePem [CertificatePem] <p>The certificate data, in PEM format.</p>
-- * transferData [TransferData] <p>The transfer data.</p>
-- * ownedBy [AwsAccountId] <p>The ID of the AWS account that owns the certificate.</p>
-- * customerVersion [CustomerVersion] <p>The customer version of the certificate.</p>
-- * caCertificateId [CertificateId] <p>The certificate ID of the CA certificate used to sign this certificate.</p>
-- * creationDate [DateType] <p>The date and time the certificate was created.</p>
-- @return CertificateDescription structure as a key-value pair table
function M.CertificateDescription(args)
	assert(args, "You must provide an argument table when creating CertificateDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["status"] = args["status"],
		["previousOwnedBy"] = args["previousOwnedBy"],
		["certificateId"] = args["certificateId"],
		["generationId"] = args["generationId"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["validity"] = args["validity"],
		["certificatePem"] = args["certificatePem"],
		["transferData"] = args["transferData"],
		["ownedBy"] = args["ownedBy"],
		["customerVersion"] = args["customerVersion"],
		["caCertificateId"] = args["caCertificateId"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertCertificateDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListViolationEventsResponse = { ["nextToken"] = true, ["violationEvents"] = true, nil }

function asserts.AssertListViolationEventsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListViolationEventsResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["violationEvents"] then asserts.AssertViolationEvents(struct["violationEvents"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListViolationEventsResponse[k], "ListViolationEventsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListViolationEventsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- * violationEvents [ViolationEvents] <p>The security profile violation alerts issued for this account during the given time frame, potentially filtered by security profile, behavior violated, or thing (device) violating.</p>
-- @return ListViolationEventsResponse structure as a key-value pair table
function M.ListViolationEventsResponse(args)
	assert(args, "You must provide an argument table when creating ListViolationEventsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["violationEvents"] = args["violationEvents"],
	}
	asserts.AssertListViolationEventsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteAuthorizerResponse = { nil }

function asserts.AssertDeleteAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteAuthorizerResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteAuthorizerResponse[k], "DeleteAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteAuthorizerResponse structure as a key-value pair table
function M.DeleteAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating DeleteAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ClearDefaultAuthorizerRequest = { nil }

function asserts.AssertClearDefaultAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClearDefaultAuthorizerRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.ClearDefaultAuthorizerRequest[k], "ClearDefaultAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClearDefaultAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return ClearDefaultAuthorizerRequest structure as a key-value pair table
function M.ClearDefaultAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating ClearDefaultAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertClearDefaultAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAuditTaskRequest = { ["taskId"] = true, nil }

function asserts.AssertDescribeAuditTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAuditTaskRequest to be of type 'table'")
	assert(struct["taskId"], "Expected key taskId to exist in table")
	if struct["taskId"] then asserts.AssertAuditTaskId(struct["taskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAuditTaskRequest[k], "DescribeAuditTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAuditTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskId [AuditTaskId] <p>The ID of the audit whose information you want to get.</p>
-- Required key: taskId
-- @return DescribeAuditTaskRequest structure as a key-value pair table
function M.DescribeAuditTaskRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAuditTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{taskId}"] = args["taskId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["taskId"] = args["taskId"],
	}
	asserts.AssertDescribeAuditTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachSecurityProfileRequest = { ["securityProfileTargetArn"] = true, ["securityProfileName"] = true, nil }

function asserts.AssertAttachSecurityProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachSecurityProfileRequest to be of type 'table'")
	assert(struct["securityProfileName"], "Expected key securityProfileName to exist in table")
	assert(struct["securityProfileTargetArn"], "Expected key securityProfileTargetArn to exist in table")
	if struct["securityProfileTargetArn"] then asserts.AssertSecurityProfileTargetArn(struct["securityProfileTargetArn"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachSecurityProfileRequest[k], "AttachSecurityProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachSecurityProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileTargetArn [SecurityProfileTargetArn] <p>The ARN of the target (thing group) to which the security profile is attached.</p>
-- * securityProfileName [SecurityProfileName] <p>The security profile that is attached.</p>
-- Required key: securityProfileName
-- Required key: securityProfileTargetArn
-- @return AttachSecurityProfileRequest structure as a key-value pair table
function M.AttachSecurityProfileRequest(args)
	assert(args, "You must provide an argument table when creating AttachSecurityProfileRequest")
    local query_args = { 
        ["securityProfileTargetArn"] = args["securityProfileTargetArn"],
    }
    local uri_args = { 
        ["{securityProfileName}"] = args["securityProfileName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileTargetArn"] = args["securityProfileTargetArn"],
		["securityProfileName"] = args["securityProfileName"],
	}
	asserts.AssertAttachSecurityProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DynamoDBAction = { ["rangeKeyType"] = true, ["payloadField"] = true, ["hashKeyType"] = true, ["hashKeyField"] = true, ["roleArn"] = true, ["tableName"] = true, ["hashKeyValue"] = true, ["rangeKeyValue"] = true, ["operation"] = true, ["rangeKeyField"] = true, nil }

function asserts.AssertDynamoDBAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DynamoDBAction to be of type 'table'")
	assert(struct["tableName"], "Expected key tableName to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["hashKeyField"], "Expected key hashKeyField to exist in table")
	assert(struct["hashKeyValue"], "Expected key hashKeyValue to exist in table")
	if struct["rangeKeyType"] then asserts.AssertDynamoKeyType(struct["rangeKeyType"]) end
	if struct["payloadField"] then asserts.AssertPayloadField(struct["payloadField"]) end
	if struct["hashKeyType"] then asserts.AssertDynamoKeyType(struct["hashKeyType"]) end
	if struct["hashKeyField"] then asserts.AssertHashKeyField(struct["hashKeyField"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["tableName"] then asserts.AssertTableName(struct["tableName"]) end
	if struct["hashKeyValue"] then asserts.AssertHashKeyValue(struct["hashKeyValue"]) end
	if struct["rangeKeyValue"] then asserts.AssertRangeKeyValue(struct["rangeKeyValue"]) end
	if struct["operation"] then asserts.AssertDynamoOperation(struct["operation"]) end
	if struct["rangeKeyField"] then asserts.AssertRangeKeyField(struct["rangeKeyField"]) end
	for k,_ in pairs(struct) do
		assert(keys.DynamoDBAction[k], "DynamoDBAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DynamoDBAction
-- <p>Describes an action to write to a DynamoDB table.</p> <p>The <code>tableName</code>, <code>hashKeyField</code>, and <code>rangeKeyField</code> values must match the values used when you created the table.</p> <p>The <code>hashKeyValue</code> and <code>rangeKeyvalue</code> fields use a substitution template syntax. These templates provide data at runtime. The syntax is as follows: ${<i>sql-expression</i>}.</p> <p>You can specify any valid expression in a WHERE or SELECT clause, including JSON properties, comparisons, calculations, and functions. For example, the following field uses the third level of the topic:</p> <p> <code>"hashKeyValue": "${topic(3)}"</code> </p> <p>The following field uses the timestamp:</p> <p> <code>"rangeKeyValue": "${timestamp()}"</code> </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * rangeKeyType [DynamoKeyType] <p>The range key type. Valid values are "STRING" or "NUMBER"</p>
-- * payloadField [PayloadField] <p>The action payload. This name can be customized.</p>
-- * hashKeyType [DynamoKeyType] <p>The hash key type. Valid values are "STRING" or "NUMBER"</p>
-- * hashKeyField [HashKeyField] <p>The hash key name.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
-- * tableName [TableName] <p>The name of the DynamoDB table.</p>
-- * hashKeyValue [HashKeyValue] <p>The hash key value.</p>
-- * rangeKeyValue [RangeKeyValue] <p>The range key value.</p>
-- * operation [DynamoOperation] <p>The type of operation to be performed. This follows the substitution template, so it can be <code>${operation}</code>, but the substitution must result in one of the following: <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p>
-- * rangeKeyField [RangeKeyField] <p>The range key name.</p>
-- Required key: tableName
-- Required key: roleArn
-- Required key: hashKeyField
-- Required key: hashKeyValue
-- @return DynamoDBAction structure as a key-value pair table
function M.DynamoDBAction(args)
	assert(args, "You must provide an argument table when creating DynamoDBAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["rangeKeyType"] = args["rangeKeyType"],
		["payloadField"] = args["payloadField"],
		["hashKeyType"] = args["hashKeyType"],
		["hashKeyField"] = args["hashKeyField"],
		["roleArn"] = args["roleArn"],
		["tableName"] = args["tableName"],
		["hashKeyValue"] = args["hashKeyValue"],
		["rangeKeyValue"] = args["rangeKeyValue"],
		["operation"] = args["operation"],
		["rangeKeyField"] = args["rangeKeyField"],
	}
	asserts.AssertDynamoDBAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDefaultAuthorizerResponse = { ["authorizerDescription"] = true, nil }

function asserts.AssertDescribeDefaultAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDefaultAuthorizerResponse to be of type 'table'")
	if struct["authorizerDescription"] then asserts.AssertAuthorizerDescription(struct["authorizerDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDefaultAuthorizerResponse[k], "DescribeDefaultAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDefaultAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerDescription [AuthorizerDescription] <p>The default authorizer's description.</p>
-- @return DescribeDefaultAuthorizerResponse structure as a key-value pair table
function M.DescribeDefaultAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating DescribeDefaultAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerDescription"] = args["authorizerDescription"],
	}
	asserts.AssertDescribeDefaultAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ActiveViolation = { ["securityProfileName"] = true, ["lastViolationTime"] = true, ["violationId"] = true, ["lastViolationValue"] = true, ["thingName"] = true, ["behavior"] = true, ["violationStartTime"] = true, nil }

function asserts.AssertActiveViolation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ActiveViolation to be of type 'table'")
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["lastViolationTime"] then asserts.AssertTimestamp(struct["lastViolationTime"]) end
	if struct["violationId"] then asserts.AssertViolationId(struct["violationId"]) end
	if struct["lastViolationValue"] then asserts.AssertMetricValue(struct["lastViolationValue"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["behavior"] then asserts.AssertBehavior(struct["behavior"]) end
	if struct["violationStartTime"] then asserts.AssertTimestamp(struct["violationStartTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ActiveViolation[k], "ActiveViolation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ActiveViolation
-- <p>Information about an active Device Defender security profile behavior violation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileName [SecurityProfileName] <p>The security profile whose behavior is in violation.</p>
-- * lastViolationTime [Timestamp] <p>The time the most recent violation occurred.</p>
-- * violationId [ViolationId] <p>The ID of the active violation.</p>
-- * lastViolationValue [MetricValue] <p>The value of the metric (the measurement) which caused the most recent violation.</p>
-- * thingName [ThingName] <p>The name of the thing responsible for the active violation.</p>
-- * behavior [Behavior] <p>The behavior which is being violated.</p>
-- * violationStartTime [Timestamp] <p>The time the violation started.</p>
-- @return ActiveViolation structure as a key-value pair table
function M.ActiveViolation(args)
	assert(args, "You must provide an argument table when creating ActiveViolation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileName"] = args["securityProfileName"],
		["lastViolationTime"] = args["lastViolationTime"],
		["violationId"] = args["violationId"],
		["lastViolationValue"] = args["lastViolationValue"],
		["thingName"] = args["thingName"],
		["behavior"] = args["behavior"],
		["violationStartTime"] = args["violationStartTime"],
	}
	asserts.AssertActiveViolation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuditCheckDetails = { ["totalResourcesCount"] = true, ["nonCompliantResourcesCount"] = true, ["errorCode"] = true, ["checkRunStatus"] = true, ["message"] = true, ["checkCompliant"] = true, nil }

function asserts.AssertAuditCheckDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuditCheckDetails to be of type 'table'")
	if struct["totalResourcesCount"] then asserts.AssertTotalResourcesCount(struct["totalResourcesCount"]) end
	if struct["nonCompliantResourcesCount"] then asserts.AssertNonCompliantResourcesCount(struct["nonCompliantResourcesCount"]) end
	if struct["errorCode"] then asserts.AssertErrorCode(struct["errorCode"]) end
	if struct["checkRunStatus"] then asserts.AssertAuditCheckRunStatus(struct["checkRunStatus"]) end
	if struct["message"] then asserts.AssertErrorMessage(struct["message"]) end
	if struct["checkCompliant"] then asserts.AssertCheckCompliant(struct["checkCompliant"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuditCheckDetails[k], "AuditCheckDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuditCheckDetails
-- <p>Information about the audit check.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * totalResourcesCount [TotalResourcesCount] <p>The number of resources on which the check was performed.</p>
-- * nonCompliantResourcesCount [NonCompliantResourcesCount] <p>The number of resources that the check found non-compliant.</p>
-- * errorCode [ErrorCode] <p>The code of any error encountered when performing this check during this audit. One of "INSUFFICIENT_PERMISSIONS", or "AUDIT_CHECK_DISABLED".</p>
-- * checkRunStatus [AuditCheckRunStatus] <p>The completion status of this check, one of "IN_PROGRESS", "WAITING_FOR_DATA_COLLECTION", "CANCELED", "COMPLETED_COMPLIANT", "COMPLETED_NON_COMPLIANT", or "FAILED".</p>
-- * message [ErrorMessage] <p>The message associated with any error encountered when performing this check during this audit.</p>
-- * checkCompliant [CheckCompliant] <p>True if the check completed and found all resources compliant.</p>
-- @return AuditCheckDetails structure as a key-value pair table
function M.AuditCheckDetails(args)
	assert(args, "You must provide an argument table when creating AuditCheckDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["totalResourcesCount"] = args["totalResourcesCount"],
		["nonCompliantResourcesCount"] = args["nonCompliantResourcesCount"],
		["errorCode"] = args["errorCode"],
		["checkRunStatus"] = args["checkRunStatus"],
		["message"] = args["message"],
		["checkCompliant"] = args["checkCompliant"],
	}
	asserts.AssertAuditCheckDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StreamFile = { ["s3Location"] = true, ["fileId"] = true, nil }

function asserts.AssertStreamFile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StreamFile to be of type 'table'")
	if struct["s3Location"] then asserts.AssertS3Location(struct["s3Location"]) end
	if struct["fileId"] then asserts.AssertFileId(struct["fileId"]) end
	for k,_ in pairs(struct) do
		assert(keys.StreamFile[k], "StreamFile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StreamFile
-- <p>Represents a file to stream.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * s3Location [S3Location] <p>The location of the file in S3.</p>
-- * fileId [FileId] <p>The file ID.</p>
-- @return StreamFile structure as a key-value pair table
function M.StreamFile(args)
	assert(args, "You must provide an argument table when creating StreamFile")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["s3Location"] = args["s3Location"],
		["fileId"] = args["fileId"],
	}
	asserts.AssertStreamFile(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteCACertificateResponse = { nil }

function asserts.AssertDeleteCACertificateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteCACertificateResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteCACertificateResponse[k], "DeleteCACertificateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteCACertificateResponse
-- <p>The output for the DeleteCACertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteCACertificateResponse structure as a key-value pair table
function M.DeleteCACertificateResponse(args)
	assert(args, "You must provide an argument table when creating DeleteCACertificateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteCACertificateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEndpointResponse = { ["endpointAddress"] = true, nil }

function asserts.AssertDescribeEndpointResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEndpointResponse to be of type 'table'")
	if struct["endpointAddress"] then asserts.AssertEndpointAddress(struct["endpointAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEndpointResponse[k], "DescribeEndpointResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEndpointResponse
-- <p>The output from the DescribeEndpoint operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * endpointAddress [EndpointAddress] <p>The endpoint. The format of the endpoint is as follows: <i>identifier</i>.iot.<i>region</i>.amazonaws.com.</p>
-- @return DescribeEndpointResponse structure as a key-value pair table
function M.DescribeEndpointResponse(args)
	assert(args, "You must provide an argument table when creating DescribeEndpointResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["endpointAddress"] = args["endpointAddress"],
	}
	asserts.AssertDescribeEndpointResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetRegistrationCodeResponse = { ["registrationCode"] = true, nil }

function asserts.AssertGetRegistrationCodeResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetRegistrationCodeResponse to be of type 'table'")
	if struct["registrationCode"] then asserts.AssertRegistrationCode(struct["registrationCode"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetRegistrationCodeResponse[k], "GetRegistrationCodeResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetRegistrationCodeResponse
-- <p>The output from the GetRegistrationCode operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * registrationCode [RegistrationCode] <p>The CA certificate registration code.</p>
-- @return GetRegistrationCodeResponse structure as a key-value pair table
function M.GetRegistrationCodeResponse(args)
	assert(args, "You must provide an argument table when creating GetRegistrationCodeResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["registrationCode"] = args["registrationCode"],
	}
	asserts.AssertGetRegistrationCodeResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListJobsResponse = { ["nextToken"] = true, ["jobs"] = true, nil }

function asserts.AssertListJobsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListJobsResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["jobs"] then asserts.AssertJobSummaryList(struct["jobs"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListJobsResponse[k], "ListJobsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListJobsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
-- * jobs [JobSummaryList] <p>A list of jobs.</p>
-- @return ListJobsResponse structure as a key-value pair table
function M.ListJobsResponse(args)
	assert(args, "You must provide an argument table when creating ListJobsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["jobs"] = args["jobs"],
	}
	asserts.AssertListJobsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingsInThingGroupResponse = { ["things"] = true, ["nextToken"] = true, nil }

function asserts.AssertListThingsInThingGroupResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingsInThingGroupResponse to be of type 'table'")
	if struct["things"] then asserts.AssertThingNameList(struct["things"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingsInThingGroupResponse[k], "ListThingsInThingGroupResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingsInThingGroupResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * things [ThingNameList] <p>The things in the specified thing group.</p>
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- @return ListThingsInThingGroupResponse structure as a key-value pair table
function M.ListThingsInThingGroupResponse(args)
	assert(args, "You must provide an argument table when creating ListThingsInThingGroupResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["things"] = args["things"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListThingsInThingGroupResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPolicyVersionsRequest = { ["policyName"] = true, nil }

function asserts.AssertListPolicyVersionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPolicyVersionsRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPolicyVersionsRequest[k], "ListPolicyVersionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPolicyVersionsRequest
-- <p>The input for the ListPolicyVersions operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- Required key: policyName
-- @return ListPolicyVersionsRequest structure as a key-value pair table
function M.ListPolicyVersionsRequest(args)
	assert(args, "You must provide an argument table when creating ListPolicyVersionsRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
	}
	asserts.AssertListPolicyVersionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteScheduledAuditRequest = { ["scheduledAuditName"] = true, nil }

function asserts.AssertDeleteScheduledAuditRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteScheduledAuditRequest to be of type 'table'")
	assert(struct["scheduledAuditName"], "Expected key scheduledAuditName to exist in table")
	if struct["scheduledAuditName"] then asserts.AssertScheduledAuditName(struct["scheduledAuditName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteScheduledAuditRequest[k], "DeleteScheduledAuditRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteScheduledAuditRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * scheduledAuditName [ScheduledAuditName] <p>The name of the scheduled audit you want to delete.</p>
-- Required key: scheduledAuditName
-- @return DeleteScheduledAuditRequest structure as a key-value pair table
function M.DeleteScheduledAuditRequest(args)
	assert(args, "You must provide an argument table when creating DeleteScheduledAuditRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{scheduledAuditName}"] = args["scheduledAuditName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["scheduledAuditName"] = args["scheduledAuditName"],
	}
	asserts.AssertDeleteScheduledAuditRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCertificatesRequest = { ["marker"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, nil }

function asserts.AssertListCertificatesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCertificatesRequest to be of type 'table'")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCertificatesRequest[k], "ListCertificatesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCertificatesRequest
-- <p>The input for the ListCertificates operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The marker for the next set of results.</p>
-- * ascendingOrder [AscendingOrder] <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
-- * pageSize [PageSize] <p>The result page size.</p>
-- @return ListCertificatesRequest structure as a key-value pair table
function M.ListCertificatesRequest(args)
	assert(args, "You must provide an argument table when creating ListCertificatesRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListCertificatesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAuthorizerRequest = { ["authorizerName"] = true, nil }

function asserts.AssertDescribeAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAuthorizerRequest to be of type 'table'")
	assert(struct["authorizerName"], "Expected key authorizerName to exist in table")
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAuthorizerRequest[k], "DescribeAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerName [AuthorizerName] <p>The name of the authorizer to describe.</p>
-- Required key: authorizerName
-- @return DescribeAuthorizerRequest structure as a key-value pair table
function M.DescribeAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{authorizerName}"] = args["authorizerName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerName"] = args["authorizerName"],
	}
	asserts.AssertDescribeAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingPrincipalsResponse = { ["principals"] = true, nil }

function asserts.AssertListThingPrincipalsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingPrincipalsResponse to be of type 'table'")
	if struct["principals"] then asserts.AssertPrincipals(struct["principals"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingPrincipalsResponse[k], "ListThingPrincipalsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingPrincipalsResponse
-- <p>The output from the ListThingPrincipals operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * principals [Principals] <p>The principals associated with the thing.</p>
-- @return ListThingPrincipalsResponse structure as a key-value pair table
function M.ListThingPrincipalsResponse(args)
	assert(args, "You must provide an argument table when creating ListThingPrincipalsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["principals"] = args["principals"],
	}
	asserts.AssertListThingPrincipalsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetJobDocumentRequest = { ["jobId"] = true, nil }

function asserts.AssertGetJobDocumentRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetJobDocumentRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetJobDocumentRequest[k], "GetJobDocumentRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetJobDocumentRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- Required key: jobId
-- @return GetJobDocumentRequest structure as a key-value pair table
function M.GetJobDocumentRequest(args)
	assert(args, "You must provide an argument table when creating GetJobDocumentRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["jobId"] = args["jobId"],
	}
	asserts.AssertGetJobDocumentRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SetDefaultAuthorizerRequest = { ["authorizerName"] = true, nil }

function asserts.AssertSetDefaultAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SetDefaultAuthorizerRequest to be of type 'table'")
	assert(struct["authorizerName"], "Expected key authorizerName to exist in table")
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	for k,_ in pairs(struct) do
		assert(keys.SetDefaultAuthorizerRequest[k], "SetDefaultAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SetDefaultAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerName [AuthorizerName] <p>The authorizer name.</p>
-- Required key: authorizerName
-- @return SetDefaultAuthorizerRequest structure as a key-value pair table
function M.SetDefaultAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating SetDefaultAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerName"] = args["authorizerName"],
	}
	asserts.AssertSetDefaultAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.OTAUpdateFile = { ["attributes"] = true, ["fileLocation"] = true, ["fileVersion"] = true, ["codeSigning"] = true, ["fileName"] = true, nil }

function asserts.AssertOTAUpdateFile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected OTAUpdateFile to be of type 'table'")
	if struct["attributes"] then asserts.AssertAttributesMap(struct["attributes"]) end
	if struct["fileLocation"] then asserts.AssertFileLocation(struct["fileLocation"]) end
	if struct["fileVersion"] then asserts.AssertOTAUpdateFileVersion(struct["fileVersion"]) end
	if struct["codeSigning"] then asserts.AssertCodeSigning(struct["codeSigning"]) end
	if struct["fileName"] then asserts.AssertFileName(struct["fileName"]) end
	for k,_ in pairs(struct) do
		assert(keys.OTAUpdateFile[k], "OTAUpdateFile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type OTAUpdateFile
-- <p>Describes a file to be associated with an OTA update.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * attributes [AttributesMap] <p>A list of name/attribute pairs.</p>
-- * fileLocation [FileLocation] <p>The location of the updated firmware.</p>
-- * fileVersion [OTAUpdateFileVersion] <p>The file version.</p>
-- * codeSigning [CodeSigning] <p>The code signing method of the file.</p>
-- * fileName [FileName] <p>The name of the file.</p>
-- @return OTAUpdateFile structure as a key-value pair table
function M.OTAUpdateFile(args)
	assert(args, "You must provide an argument table when creating OTAUpdateFile")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["attributes"] = args["attributes"],
		["fileLocation"] = args["fileLocation"],
		["fileVersion"] = args["fileVersion"],
		["codeSigning"] = args["codeSigning"],
		["fileName"] = args["fileName"],
	}
	asserts.AssertOTAUpdateFile(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachSecurityProfileResponse = { nil }

function asserts.AssertAttachSecurityProfileResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachSecurityProfileResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.AttachSecurityProfileResponse[k], "AttachSecurityProfileResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachSecurityProfileResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return AttachSecurityProfileResponse structure as a key-value pair table
function M.AttachSecurityProfileResponse(args)
	assert(args, "You must provide an argument table when creating AttachSecurityProfileResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertAttachSecurityProfileResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteThingGroupResponse = { nil }

function asserts.AssertDeleteThingGroupResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteThingGroupResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteThingGroupResponse[k], "DeleteThingGroupResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteThingGroupResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteThingGroupResponse structure as a key-value pair table
function M.DeleteThingGroupResponse(args)
	assert(args, "You must provide an argument table when creating DeleteThingGroupResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteThingGroupResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterThingRequest = { ["parameters"] = true, ["templateBody"] = true, nil }

function asserts.AssertRegisterThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterThingRequest to be of type 'table'")
	assert(struct["templateBody"], "Expected key templateBody to exist in table")
	if struct["parameters"] then asserts.AssertParameters(struct["parameters"]) end
	if struct["templateBody"] then asserts.AssertTemplateBody(struct["templateBody"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterThingRequest[k], "RegisterThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterThingRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * parameters [Parameters] <p>The parameters for provisioning a thing. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html">Programmatic Provisioning</a> for more information.</p>
-- * templateBody [TemplateBody] <p>The provisioning template. See <a href="http://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html">Programmatic Provisioning</a> for more information.</p>
-- Required key: templateBody
-- @return RegisterThingRequest structure as a key-value pair table
function M.RegisterThingRequest(args)
	assert(args, "You must provide an argument table when creating RegisterThingRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["parameters"] = args["parameters"],
		["templateBody"] = args["templateBody"],
	}
	asserts.AssertRegisterThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPoliciesResponse = { ["nextMarker"] = true, ["policies"] = true, nil }

function asserts.AssertListPoliciesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPoliciesResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["policies"] then asserts.AssertPolicies(struct["policies"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPoliciesResponse[k], "ListPoliciesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPoliciesResponse
-- <p>The output from the ListPolicies operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>The marker for the next set of results, or null if there are no additional results.</p>
-- * policies [Policies] <p>The descriptions of the policies.</p>
-- @return ListPoliciesResponse structure as a key-value pair table
function M.ListPoliciesResponse(args)
	assert(args, "You must provide an argument table when creating ListPoliciesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["policies"] = args["policies"],
	}
	asserts.AssertListPoliciesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteCACertificateRequest = { ["certificateId"] = true, nil }

function asserts.AssertDeleteCACertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteCACertificateRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteCACertificateRequest[k], "DeleteCACertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteCACertificateRequest
-- <p>Input for the DeleteCACertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateId [CertificateId] <p>The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)</p>
-- Required key: certificateId
-- @return DeleteCACertificateRequest structure as a key-value pair table
function M.DeleteCACertificateRequest(args)
	assert(args, "You must provide an argument table when creating DeleteCACertificateRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{caCertificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertDeleteCACertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ValidateSecurityProfileBehaviorsResponse = { ["validationErrors"] = true, ["valid"] = true, nil }

function asserts.AssertValidateSecurityProfileBehaviorsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ValidateSecurityProfileBehaviorsResponse to be of type 'table'")
	if struct["validationErrors"] then asserts.AssertValidationErrors(struct["validationErrors"]) end
	if struct["valid"] then asserts.AssertValid(struct["valid"]) end
	for k,_ in pairs(struct) do
		assert(keys.ValidateSecurityProfileBehaviorsResponse[k], "ValidateSecurityProfileBehaviorsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ValidateSecurityProfileBehaviorsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * validationErrors [ValidationErrors] <p>The list of any errors found in the behaviors.</p>
-- * valid [Valid] <p>True if the behaviors were valid.</p>
-- @return ValidateSecurityProfileBehaviorsResponse structure as a key-value pair table
function M.ValidateSecurityProfileBehaviorsResponse(args)
	assert(args, "You must provide an argument table when creating ValidateSecurityProfileBehaviorsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["validationErrors"] = args["validationErrors"],
		["valid"] = args["valid"],
	}
	asserts.AssertValidateSecurityProfileBehaviorsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateThingTypeResponse = { ["thingTypeName"] = true, ["thingTypeId"] = true, ["thingTypeArn"] = true, nil }

function asserts.AssertCreateThingTypeResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateThingTypeResponse to be of type 'table'")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["thingTypeId"] then asserts.AssertThingTypeId(struct["thingTypeId"]) end
	if struct["thingTypeArn"] then asserts.AssertThingTypeArn(struct["thingTypeArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateThingTypeResponse[k], "CreateThingTypeResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateThingTypeResponse
-- <p>The output of the CreateThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- * thingTypeId [ThingTypeId] <p>The thing type ID.</p>
-- * thingTypeArn [ThingTypeArn] <p>The Amazon Resource Name (ARN) of the thing type.</p>
-- @return CreateThingTypeResponse structure as a key-value pair table
function M.CreateThingTypeResponse(args)
	assert(args, "You must provide an argument table when creating CreateThingTypeResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["thingTypeId"] = args["thingTypeId"],
		["thingTypeArn"] = args["thingTypeArn"],
	}
	asserts.AssertCreateThingTypeResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreatePolicyVersionRequest = { ["policyName"] = true, ["policyDocument"] = true, ["setAsDefault"] = true, nil }

function asserts.AssertCreatePolicyVersionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePolicyVersionRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["policyDocument"], "Expected key policyDocument to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyDocument"] then asserts.AssertPolicyDocument(struct["policyDocument"]) end
	if struct["setAsDefault"] then asserts.AssertSetAsDefault(struct["setAsDefault"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePolicyVersionRequest[k], "CreatePolicyVersionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePolicyVersionRequest
-- <p>The input for the CreatePolicyVersion operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * policyDocument [PolicyDocument] <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.</p>
-- * setAsDefault [SetAsDefault] <p>Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
-- Required key: policyName
-- Required key: policyDocument
-- @return CreatePolicyVersionRequest structure as a key-value pair table
function M.CreatePolicyVersionRequest(args)
	assert(args, "You must provide an argument table when creating CreatePolicyVersionRequest")
    local query_args = { 
        ["setAsDefault"] = args["setAsDefault"],
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyDocument"] = args["policyDocument"],
		["setAsDefault"] = args["setAsDefault"],
	}
	asserts.AssertCreatePolicyVersionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingGroupRequest = { ["thingGroupName"] = true, nil }

function asserts.AssertDescribeThingGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingGroupRequest to be of type 'table'")
	assert(struct["thingGroupName"], "Expected key thingGroupName to exist in table")
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingGroupRequest[k], "DescribeThingGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupName [ThingGroupName] <p>The name of the thing group.</p>
-- Required key: thingGroupName
-- @return DescribeThingGroupRequest structure as a key-value pair table
function M.DescribeThingGroupRequest(args)
	assert(args, "You must provide an argument table when creating DescribeThingGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingGroupName}"] = args["thingGroupName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupName"] = args["thingGroupName"],
	}
	asserts.AssertDescribeThingGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSecurityProfileResponse = { ["securityProfileArn"] = true, ["securityProfileName"] = true, nil }

function asserts.AssertCreateSecurityProfileResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityProfileResponse to be of type 'table'")
	if struct["securityProfileArn"] then asserts.AssertSecurityProfileArn(struct["securityProfileArn"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityProfileResponse[k], "CreateSecurityProfileResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityProfileResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileArn [SecurityProfileArn] <p>The ARN of the security profile.</p>
-- * securityProfileName [SecurityProfileName] <p>The name you gave to the security profile.</p>
-- @return CreateSecurityProfileResponse structure as a key-value pair table
function M.CreateSecurityProfileResponse(args)
	assert(args, "You must provide an argument table when creating CreateSecurityProfileResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileArn"] = args["securityProfileArn"],
		["securityProfileName"] = args["securityProfileName"],
	}
	asserts.AssertCreateSecurityProfileResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AlertTarget = { ["alertTargetArn"] = true, ["roleArn"] = true, nil }

function asserts.AssertAlertTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AlertTarget to be of type 'table'")
	assert(struct["alertTargetArn"], "Expected key alertTargetArn to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["alertTargetArn"] then asserts.AssertAlertTargetArn(struct["alertTargetArn"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.AlertTarget[k], "AlertTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AlertTarget
-- <p>A structure containing the alert target ARN and the role ARN.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * alertTargetArn [AlertTargetArn] <p>The ARN of the notification target to which alerts are sent.</p>
-- * roleArn [RoleArn] <p>The ARN of the role that grants permission to send alerts to the notification target.</p>
-- Required key: alertTargetArn
-- Required key: roleArn
-- @return AlertTarget structure as a key-value pair table
function M.AlertTarget(args)
	assert(args, "You must provide an argument table when creating AlertTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["alertTargetArn"] = args["alertTargetArn"],
		["roleArn"] = args["roleArn"],
	}
	asserts.AssertAlertTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EffectivePolicy = { ["policyName"] = true, ["policyDocument"] = true, ["policyArn"] = true, nil }

function asserts.AssertEffectivePolicy(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EffectivePolicy to be of type 'table'")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyDocument"] then asserts.AssertPolicyDocument(struct["policyDocument"]) end
	if struct["policyArn"] then asserts.AssertPolicyArn(struct["policyArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.EffectivePolicy[k], "EffectivePolicy contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EffectivePolicy
-- <p>The policy that has the effect on the authorization results.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * policyDocument [PolicyDocument] <p>The IAM policy document.</p>
-- * policyArn [PolicyArn] <p>The policy ARN.</p>
-- @return EffectivePolicy structure as a key-value pair table
function M.EffectivePolicy(args)
	assert(args, "You must provide an argument table when creating EffectivePolicy")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyDocument"] = args["policyDocument"],
		["policyArn"] = args["policyArn"],
	}
	asserts.AssertEffectivePolicy(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelAuditTaskResponse = { nil }

function asserts.AssertCancelAuditTaskResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelAuditTaskResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.CancelAuditTaskResponse[k], "CancelAuditTaskResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelAuditTaskResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return CancelAuditTaskResponse structure as a key-value pair table
function M.CancelAuditTaskResponse(args)
	assert(args, "You must provide an argument table when creating CancelAuditTaskResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertCancelAuditTaskResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PolicyVersion = { ["versionId"] = true, ["createDate"] = true, ["isDefaultVersion"] = true, nil }

function asserts.AssertPolicyVersion(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PolicyVersion to be of type 'table'")
	if struct["versionId"] then asserts.AssertPolicyVersionId(struct["versionId"]) end
	if struct["createDate"] then asserts.AssertDateType(struct["createDate"]) end
	if struct["isDefaultVersion"] then asserts.AssertIsDefaultVersion(struct["isDefaultVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.PolicyVersion[k], "PolicyVersion contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PolicyVersion
-- <p>Describes a policy version.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * versionId [PolicyVersionId] <p>The policy version ID.</p>
-- * createDate [DateType] <p>The date and time the policy was created.</p>
-- * isDefaultVersion [IsDefaultVersion] <p>Specifies whether the policy version is the default.</p>
-- @return PolicyVersion structure as a key-value pair table
function M.PolicyVersion(args)
	assert(args, "You must provide an argument table when creating PolicyVersion")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["versionId"] = args["versionId"],
		["createDate"] = args["createDate"],
		["isDefaultVersion"] = args["isDefaultVersion"],
	}
	asserts.AssertPolicyVersion(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SigningProfileParameter = { ["certificateArn"] = true, ["platform"] = true, ["certificatePathOnDevice"] = true, nil }

function asserts.AssertSigningProfileParameter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SigningProfileParameter to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["platform"] then asserts.AssertPlatform(struct["platform"]) end
	if struct["certificatePathOnDevice"] then asserts.AssertCertificatePathOnDevice(struct["certificatePathOnDevice"]) end
	for k,_ in pairs(struct) do
		assert(keys.SigningProfileParameter[k], "SigningProfileParameter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SigningProfileParameter
-- <p>Describes the code-signing profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>Certificate ARN.</p>
-- * platform [Platform] <p>The hardware platform of your device.</p>
-- * certificatePathOnDevice [CertificatePathOnDevice] <p>The location of the code-signing certificate on your device.</p>
-- @return SigningProfileParameter structure as a key-value pair table
function M.SigningProfileParameter(args)
	assert(args, "You must provide an argument table when creating SigningProfileParameter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["platform"] = args["platform"],
		["certificatePathOnDevice"] = args["certificatePathOnDevice"],
	}
	asserts.AssertSigningProfileParameter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.OTAUpdateSummary = { ["otaUpdateArn"] = true, ["creationDate"] = true, ["otaUpdateId"] = true, nil }

function asserts.AssertOTAUpdateSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected OTAUpdateSummary to be of type 'table'")
	if struct["otaUpdateArn"] then asserts.AssertOTAUpdateArn(struct["otaUpdateArn"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	if struct["otaUpdateId"] then asserts.AssertOTAUpdateId(struct["otaUpdateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.OTAUpdateSummary[k], "OTAUpdateSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type OTAUpdateSummary
-- <p>An OTA update summary.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * otaUpdateArn [OTAUpdateArn] <p>The OTA update ARN.</p>
-- * creationDate [DateType] <p>The date when the OTA update was created.</p>
-- * otaUpdateId [OTAUpdateId] <p>The OTA update ID.</p>
-- @return OTAUpdateSummary structure as a key-value pair table
function M.OTAUpdateSummary(args)
	assert(args, "You must provide an argument table when creating OTAUpdateSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["otaUpdateArn"] = args["otaUpdateArn"],
		["creationDate"] = args["creationDate"],
		["otaUpdateId"] = args["otaUpdateId"],
	}
	asserts.AssertOTAUpdateSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachSecurityProfileRequest = { ["securityProfileTargetArn"] = true, ["securityProfileName"] = true, nil }

function asserts.AssertDetachSecurityProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachSecurityProfileRequest to be of type 'table'")
	assert(struct["securityProfileName"], "Expected key securityProfileName to exist in table")
	assert(struct["securityProfileTargetArn"], "Expected key securityProfileTargetArn to exist in table")
	if struct["securityProfileTargetArn"] then asserts.AssertSecurityProfileTargetArn(struct["securityProfileTargetArn"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachSecurityProfileRequest[k], "DetachSecurityProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachSecurityProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * securityProfileTargetArn [SecurityProfileTargetArn] <p>The ARN of the thing group from which the security profile is detached.</p>
-- * securityProfileName [SecurityProfileName] <p>The security profile that is detached.</p>
-- Required key: securityProfileName
-- Required key: securityProfileTargetArn
-- @return DetachSecurityProfileRequest structure as a key-value pair table
function M.DetachSecurityProfileRequest(args)
	assert(args, "You must provide an argument table when creating DetachSecurityProfileRequest")
    local query_args = { 
        ["securityProfileTargetArn"] = args["securityProfileTargetArn"],
    }
    local uri_args = { 
        ["{securityProfileName}"] = args["securityProfileName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["securityProfileTargetArn"] = args["securityProfileTargetArn"],
		["securityProfileName"] = args["securityProfileName"],
	}
	asserts.AssertDetachSecurityProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListV2LoggingLevelsRequest = { ["targetType"] = true, ["nextToken"] = true, ["maxResults"] = true, nil }

function asserts.AssertListV2LoggingLevelsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListV2LoggingLevelsRequest to be of type 'table'")
	if struct["targetType"] then asserts.AssertLogTargetType(struct["targetType"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertSkyfallMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListV2LoggingLevelsRequest[k], "ListV2LoggingLevelsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListV2LoggingLevelsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * targetType [LogTargetType] <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * maxResults [SkyfallMaxResults] <p>The maximum number of results to return at one time.</p>
-- @return ListV2LoggingLevelsRequest structure as a key-value pair table
function M.ListV2LoggingLevelsRequest(args)
	assert(args, "You must provide an argument table when creating ListV2LoggingLevelsRequest")
    local query_args = { 
        ["targetType"] = args["targetType"],
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["targetType"] = args["targetType"],
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListV2LoggingLevelsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SecurityProfileTarget = { ["arn"] = true, nil }

function asserts.AssertSecurityProfileTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityProfileTarget to be of type 'table'")
	assert(struct["arn"], "Expected key arn to exist in table")
	if struct["arn"] then asserts.AssertSecurityProfileTargetArn(struct["arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityProfileTarget[k], "SecurityProfileTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityProfileTarget
-- <p>A target to which an alert is sent when a security profile behavior is violated.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * arn [SecurityProfileTargetArn] <p>The ARN of the security profile.</p>
-- Required key: arn
-- @return SecurityProfileTarget structure as a key-value pair table
function M.SecurityProfileTarget(args)
	assert(args, "You must provide an argument table when creating SecurityProfileTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["arn"] = args["arn"],
	}
	asserts.AssertSecurityProfileTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LoggingOptionsPayload = { ["logLevel"] = true, ["roleArn"] = true, nil }

function asserts.AssertLoggingOptionsPayload(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LoggingOptionsPayload to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["logLevel"] then asserts.AssertLogLevel(struct["logLevel"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.LoggingOptionsPayload[k], "LoggingOptionsPayload contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LoggingOptionsPayload
-- <p>Describes the logging options payload.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * logLevel [LogLevel] <p>The log level.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access.</p>
-- Required key: roleArn
-- @return LoggingOptionsPayload structure as a key-value pair table
function M.LoggingOptionsPayload(args)
	assert(args, "You must provide an argument table when creating LoggingOptionsPayload")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["logLevel"] = args["logLevel"],
		["roleArn"] = args["roleArn"],
	}
	asserts.AssertLoggingOptionsPayload(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPolicyVersionRequest = { ["policyName"] = true, ["policyVersionId"] = true, nil }

function asserts.AssertGetPolicyVersionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPolicyVersionRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["policyVersionId"], "Expected key policyVersionId to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyVersionId"] then asserts.AssertPolicyVersionId(struct["policyVersionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPolicyVersionRequest[k], "GetPolicyVersionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPolicyVersionRequest
-- <p>The input for the GetPolicyVersion operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The name of the policy.</p>
-- * policyVersionId [PolicyVersionId] <p>The policy version ID.</p>
-- Required key: policyName
-- Required key: policyVersionId
-- @return GetPolicyVersionRequest structure as a key-value pair table
function M.GetPolicyVersionRequest(args)
	assert(args, "You must provide an argument table when creating GetPolicyVersionRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
        ["{policyVersionId}"] = args["policyVersionId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyVersionId"] = args["policyVersionId"],
	}
	asserts.AssertGetPolicyVersionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImplicitDeny = { ["policies"] = true, nil }

function asserts.AssertImplicitDeny(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImplicitDeny to be of type 'table'")
	if struct["policies"] then asserts.AssertPolicies(struct["policies"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImplicitDeny[k], "ImplicitDeny contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImplicitDeny
-- <p>Information that implicitly denies authorization. When policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policies [Policies] <p>Policies that don't contain a matching allow or deny statement for the specified action on the specified resource. </p>
-- @return ImplicitDeny structure as a key-value pair table
function M.ImplicitDeny(args)
	assert(args, "You must provide an argument table when creating ImplicitDeny")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policies"] = args["policies"],
	}
	asserts.AssertImplicitDeny(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AddThingToThingGroupResponse = { nil }

function asserts.AssertAddThingToThingGroupResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AddThingToThingGroupResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.AddThingToThingGroupResponse[k], "AddThingToThingGroupResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AddThingToThingGroupResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return AddThingToThingGroupResponse structure as a key-value pair table
function M.AddThingToThingGroupResponse(args)
	assert(args, "You must provide an argument table when creating AddThingToThingGroupResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertAddThingToThingGroupResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SearchIndexResponse = { ["things"] = true, ["nextToken"] = true, ["thingGroups"] = true, nil }

function asserts.AssertSearchIndexResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SearchIndexResponse to be of type 'table'")
	if struct["things"] then asserts.AssertThingDocumentList(struct["things"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["thingGroups"] then asserts.AssertThingGroupDocumentList(struct["thingGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.SearchIndexResponse[k], "SearchIndexResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SearchIndexResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * things [ThingDocumentList] <p>The things that match the search query.</p>
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * thingGroups [ThingGroupDocumentList] <p>The thing groups that match the search query.</p>
-- @return SearchIndexResponse structure as a key-value pair table
function M.SearchIndexResponse(args)
	assert(args, "You must provide an argument table when creating SearchIndexResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["things"] = args["things"],
		["nextToken"] = args["nextToken"],
		["thingGroups"] = args["thingGroups"],
	}
	asserts.AssertSearchIndexResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListActiveViolationsResponse = { ["activeViolations"] = true, ["nextToken"] = true, nil }

function asserts.AssertListActiveViolationsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListActiveViolationsResponse to be of type 'table'")
	if struct["activeViolations"] then asserts.AssertActiveViolations(struct["activeViolations"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListActiveViolationsResponse[k], "ListActiveViolationsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListActiveViolationsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * activeViolations [ActiveViolations] <p>The list of active violations.</p>
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- @return ListActiveViolationsResponse structure as a key-value pair table
function M.ListActiveViolationsResponse(args)
	assert(args, "You must provide an argument table when creating ListActiveViolationsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["activeViolations"] = args["activeViolations"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListActiveViolationsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeJobResponse = { ["documentSource"] = true, ["job"] = true, nil }

function asserts.AssertDescribeJobResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeJobResponse to be of type 'table'")
	if struct["documentSource"] then asserts.AssertJobDocumentSource(struct["documentSource"]) end
	if struct["job"] then asserts.AssertJob(struct["job"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeJobResponse[k], "DescribeJobResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeJobResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * documentSource [JobDocumentSource] <p>An S3 link to the job document.</p>
-- * job [Job] <p>Information about the job.</p>
-- @return DescribeJobResponse structure as a key-value pair table
function M.DescribeJobResponse(args)
	assert(args, "You must provide an argument table when creating DescribeJobResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["documentSource"] = args["documentSource"],
		["job"] = args["job"],
	}
	asserts.AssertDescribeJobResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TestInvokeAuthorizerResponse = { ["refreshAfterInSeconds"] = true, ["policyDocuments"] = true, ["disconnectAfterInSeconds"] = true, ["principalId"] = true, ["isAuthenticated"] = true, nil }

function asserts.AssertTestInvokeAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TestInvokeAuthorizerResponse to be of type 'table'")
	if struct["refreshAfterInSeconds"] then asserts.AssertSeconds(struct["refreshAfterInSeconds"]) end
	if struct["policyDocuments"] then asserts.AssertPolicyDocuments(struct["policyDocuments"]) end
	if struct["disconnectAfterInSeconds"] then asserts.AssertSeconds(struct["disconnectAfterInSeconds"]) end
	if struct["principalId"] then asserts.AssertPrincipalId(struct["principalId"]) end
	if struct["isAuthenticated"] then asserts.AssertIsAuthenticated(struct["isAuthenticated"]) end
	for k,_ in pairs(struct) do
		assert(keys.TestInvokeAuthorizerResponse[k], "TestInvokeAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TestInvokeAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * refreshAfterInSeconds [Seconds] <p>The number of seconds after which the temporary credentials are refreshed.</p>
-- * policyDocuments [PolicyDocuments] <p>IAM policy documents.</p>
-- * disconnectAfterInSeconds [Seconds] <p>The number of seconds after which the connection is terminated.</p>
-- * principalId [PrincipalId] <p>The principal ID.</p>
-- * isAuthenticated [IsAuthenticated] <p>True if the token is authenticated, otherwise false.</p>
-- @return TestInvokeAuthorizerResponse structure as a key-value pair table
function M.TestInvokeAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating TestInvokeAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["refreshAfterInSeconds"] = args["refreshAfterInSeconds"],
		["policyDocuments"] = args["policyDocuments"],
		["disconnectAfterInSeconds"] = args["disconnectAfterInSeconds"],
		["principalId"] = args["principalId"],
		["isAuthenticated"] = args["isAuthenticated"],
	}
	asserts.AssertTestInvokeAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobExecutionsRolloutConfig = { ["maximumPerMinute"] = true, nil }

function asserts.AssertJobExecutionsRolloutConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobExecutionsRolloutConfig to be of type 'table'")
	if struct["maximumPerMinute"] then asserts.AssertMaxJobExecutionsPerMin(struct["maximumPerMinute"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobExecutionsRolloutConfig[k], "JobExecutionsRolloutConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobExecutionsRolloutConfig
-- <p>Allows you to create a staged rollout of a job.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * maximumPerMinute [MaxJobExecutionsPerMin] <p>The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.</p>
-- @return JobExecutionsRolloutConfig structure as a key-value pair table
function M.JobExecutionsRolloutConfig(args)
	assert(args, "You must provide an argument table when creating JobExecutionsRolloutConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["maximumPerMinute"] = args["maximumPerMinute"],
	}
	asserts.AssertJobExecutionsRolloutConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetTopicRuleResponse = { ["ruleArn"] = true, ["rule"] = true, nil }

function asserts.AssertGetTopicRuleResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetTopicRuleResponse to be of type 'table'")
	if struct["ruleArn"] then asserts.AssertRuleArn(struct["ruleArn"]) end
	if struct["rule"] then asserts.AssertTopicRule(struct["rule"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetTopicRuleResponse[k], "GetTopicRuleResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetTopicRuleResponse
-- <p>The output from the GetTopicRule operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ruleArn [RuleArn] <p>The rule ARN.</p>
-- * rule [TopicRule] <p>The rule.</p>
-- @return GetTopicRuleResponse structure as a key-value pair table
function M.GetTopicRuleResponse(args)
	assert(args, "You must provide an argument table when creating GetTopicRuleResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ruleArn"] = args["ruleArn"],
		["rule"] = args["rule"],
	}
	asserts.AssertGetTopicRuleResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetIndexingConfigurationResponse = { ["thingIndexingConfiguration"] = true, ["thingGroupIndexingConfiguration"] = true, nil }

function asserts.AssertGetIndexingConfigurationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetIndexingConfigurationResponse to be of type 'table'")
	if struct["thingIndexingConfiguration"] then asserts.AssertThingIndexingConfiguration(struct["thingIndexingConfiguration"]) end
	if struct["thingGroupIndexingConfiguration"] then asserts.AssertThingGroupIndexingConfiguration(struct["thingGroupIndexingConfiguration"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetIndexingConfigurationResponse[k], "GetIndexingConfigurationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetIndexingConfigurationResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingIndexingConfiguration [ThingIndexingConfiguration] <p>Thing indexing configuration.</p>
-- * thingGroupIndexingConfiguration [ThingGroupIndexingConfiguration] <p>The index configuration.</p>
-- @return GetIndexingConfigurationResponse structure as a key-value pair table
function M.GetIndexingConfigurationResponse(args)
	assert(args, "You must provide an argument table when creating GetIndexingConfigurationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingIndexingConfiguration"] = args["thingIndexingConfiguration"],
		["thingGroupIndexingConfiguration"] = args["thingGroupIndexingConfiguration"],
	}
	asserts.AssertGetIndexingConfigurationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RejectCertificateTransferRequest = { ["rejectReason"] = true, ["certificateId"] = true, nil }

function asserts.AssertRejectCertificateTransferRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectCertificateTransferRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["rejectReason"] then asserts.AssertMessage(struct["rejectReason"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectCertificateTransferRequest[k], "RejectCertificateTransferRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectCertificateTransferRequest
-- <p>The input for the RejectCertificateTransfer operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * rejectReason [Message] <p>The reason the certificate transfer was rejected.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- Required key: certificateId
-- @return RejectCertificateTransferRequest structure as a key-value pair table
function M.RejectCertificateTransferRequest(args)
	assert(args, "You must provide an argument table when creating RejectCertificateTransferRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{certificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["rejectReason"] = args["rejectReason"],
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertRejectCertificateTransferRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCACertificatesRequest = { ["marker"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, nil }

function asserts.AssertListCACertificatesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCACertificatesRequest to be of type 'table'")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCACertificatesRequest[k], "ListCACertificatesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCACertificatesRequest
-- <p>Input for the ListCACertificates operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The marker for the next set of results.</p>
-- * ascendingOrder [AscendingOrder] <p>Determines the order of the results.</p>
-- * pageSize [PageSize] <p>The result page size.</p>
-- @return ListCACertificatesRequest structure as a key-value pair table
function M.ListCACertificatesRequest(args)
	assert(args, "You must provide an argument table when creating ListCACertificatesRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListCACertificatesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingGroupsForThingResponse = { ["nextToken"] = true, ["thingGroups"] = true, nil }

function asserts.AssertListThingGroupsForThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingGroupsForThingResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["thingGroups"] then asserts.AssertThingGroupNameAndArnList(struct["thingGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingGroupsForThingResponse[k], "ListThingGroupsForThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingGroupsForThingResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * thingGroups [ThingGroupNameAndArnList] <p>The thing groups.</p>
-- @return ListThingGroupsForThingResponse structure as a key-value pair table
function M.ListThingGroupsForThingResponse(args)
	assert(args, "You must provide an argument table when creating ListThingGroupsForThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["thingGroups"] = args["thingGroups"],
	}
	asserts.AssertListThingGroupsForThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListSecurityProfilesForTargetResponse = { ["nextToken"] = true, ["securityProfileTargetMappings"] = true, nil }

function asserts.AssertListSecurityProfilesForTargetResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListSecurityProfilesForTargetResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["securityProfileTargetMappings"] then asserts.AssertSecurityProfileTargetMappings(struct["securityProfileTargetMappings"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListSecurityProfilesForTargetResponse[k], "ListSecurityProfilesForTargetResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListSecurityProfilesForTargetResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- * securityProfileTargetMappings [SecurityProfileTargetMappings] <p>A list of security profiles and their associated targets.</p>
-- @return ListSecurityProfilesForTargetResponse structure as a key-value pair table
function M.ListSecurityProfilesForTargetResponse(args)
	assert(args, "You must provide an argument table when creating ListSecurityProfilesForTargetResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["securityProfileTargetMappings"] = args["securityProfileTargetMappings"],
	}
	asserts.AssertListSecurityProfilesForTargetResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TopicRuleListItem = { ["topicPattern"] = true, ["ruleArn"] = true, ["ruleDisabled"] = true, ["createdAt"] = true, ["ruleName"] = true, nil }

function asserts.AssertTopicRuleListItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TopicRuleListItem to be of type 'table'")
	if struct["topicPattern"] then asserts.AssertTopicPattern(struct["topicPattern"]) end
	if struct["ruleArn"] then asserts.AssertRuleArn(struct["ruleArn"]) end
	if struct["ruleDisabled"] then asserts.AssertIsDisabled(struct["ruleDisabled"]) end
	if struct["createdAt"] then asserts.AssertCreatedAtDate(struct["createdAt"]) end
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.TopicRuleListItem[k], "TopicRuleListItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TopicRuleListItem
-- <p>Describes a rule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * topicPattern [TopicPattern] <p>The pattern for the topic names that apply.</p>
-- * ruleArn [RuleArn] <p>The rule ARN.</p>
-- * ruleDisabled [IsDisabled] <p>Specifies whether the rule is disabled.</p>
-- * createdAt [CreatedAtDate] <p>The date and time the rule was created.</p>
-- * ruleName [RuleName] <p>The name of the rule.</p>
-- @return TopicRuleListItem structure as a key-value pair table
function M.TopicRuleListItem(args)
	assert(args, "You must provide an argument table when creating TopicRuleListItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["topicPattern"] = args["topicPattern"],
		["ruleArn"] = args["ruleArn"],
		["ruleDisabled"] = args["ruleDisabled"],
		["createdAt"] = args["createdAt"],
		["ruleName"] = args["ruleName"],
	}
	asserts.AssertTopicRuleListItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListActiveViolationsRequest = { ["nextToken"] = true, ["securityProfileName"] = true, ["thingName"] = true, ["maxResults"] = true, nil }

function asserts.AssertListActiveViolationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListActiveViolationsRequest to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListActiveViolationsRequest[k], "ListActiveViolationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListActiveViolationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- * securityProfileName [SecurityProfileName] <p>The name of the Device Defender security profile for which violations are listed.</p>
-- * thingName [ThingName] <p>The name of the thing whose active violations are listed.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time.</p>
-- @return ListActiveViolationsRequest structure as a key-value pair table
function M.ListActiveViolationsRequest(args)
	assert(args, "You must provide an argument table when creating ListActiveViolationsRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["securityProfileName"] = args["securityProfileName"],
        ["thingName"] = args["thingName"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["securityProfileName"] = args["securityProfileName"],
		["thingName"] = args["thingName"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListActiveViolationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobSummary = { ["status"] = true, ["jobArn"] = true, ["completedAt"] = true, ["jobId"] = true, ["lastUpdatedAt"] = true, ["targetSelection"] = true, ["thingGroupId"] = true, ["createdAt"] = true, nil }

function asserts.AssertJobSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobSummary to be of type 'table'")
	if struct["status"] then asserts.AssertJobStatus(struct["status"]) end
	if struct["jobArn"] then asserts.AssertJobArn(struct["jobArn"]) end
	if struct["completedAt"] then asserts.AssertDateType(struct["completedAt"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	if struct["lastUpdatedAt"] then asserts.AssertDateType(struct["lastUpdatedAt"]) end
	if struct["targetSelection"] then asserts.AssertTargetSelection(struct["targetSelection"]) end
	if struct["thingGroupId"] then asserts.AssertThingGroupId(struct["thingGroupId"]) end
	if struct["createdAt"] then asserts.AssertDateType(struct["createdAt"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobSummary[k], "JobSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobSummary
-- <p>The job summary.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [JobStatus] <p>The job summary status.</p>
-- * jobArn [JobArn] <p>The job ARN.</p>
-- * completedAt [DateType] <p>The time, in milliseconds since the epoch, when the job completed.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- * lastUpdatedAt [DateType] <p>The time, in milliseconds since the epoch, when the job was last updated.</p>
-- * targetSelection [TargetSelection] <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p>
-- * thingGroupId [ThingGroupId] <p>The ID of the thing group.</p>
-- * createdAt [DateType] <p>The time, in milliseconds since the epoch, when the job was created.</p>
-- @return JobSummary structure as a key-value pair table
function M.JobSummary(args)
	assert(args, "You must provide an argument table when creating JobSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["jobArn"] = args["jobArn"],
		["completedAt"] = args["completedAt"],
		["jobId"] = args["jobId"],
		["lastUpdatedAt"] = args["lastUpdatedAt"],
		["targetSelection"] = args["targetSelection"],
		["thingGroupId"] = args["thingGroupId"],
		["createdAt"] = args["createdAt"],
	}
	asserts.AssertJobSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetEffectivePoliciesResponse = { ["effectivePolicies"] = true, nil }

function asserts.AssertGetEffectivePoliciesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetEffectivePoliciesResponse to be of type 'table'")
	if struct["effectivePolicies"] then asserts.AssertEffectivePolicies(struct["effectivePolicies"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetEffectivePoliciesResponse[k], "GetEffectivePoliciesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetEffectivePoliciesResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * effectivePolicies [EffectivePolicies] <p>The effective policies.</p>
-- @return GetEffectivePoliciesResponse structure as a key-value pair table
function M.GetEffectivePoliciesResponse(args)
	assert(args, "You must provide an argument table when creating GetEffectivePoliciesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["effectivePolicies"] = args["effectivePolicies"],
	}
	asserts.AssertGetEffectivePoliciesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTopicRulesResponse = { ["rules"] = true, ["nextToken"] = true, nil }

function asserts.AssertListTopicRulesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTopicRulesResponse to be of type 'table'")
	if struct["rules"] then asserts.AssertTopicRuleList(struct["rules"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTopicRulesResponse[k], "ListTopicRulesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTopicRulesResponse
-- <p>The output from the ListTopicRules operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * rules [TopicRuleList] <p>The rules.</p>
-- * nextToken [NextToken] <p>A token used to retrieve the next value.</p>
-- @return ListTopicRulesResponse structure as a key-value pair table
function M.ListTopicRulesResponse(args)
	assert(args, "You must provide an argument table when creating ListTopicRulesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["rules"] = args["rules"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListTopicRulesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingTypeProperties = { ["searchableAttributes"] = true, ["thingTypeDescription"] = true, nil }

function asserts.AssertThingTypeProperties(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingTypeProperties to be of type 'table'")
	if struct["searchableAttributes"] then asserts.AssertSearchableAttributes(struct["searchableAttributes"]) end
	if struct["thingTypeDescription"] then asserts.AssertThingTypeDescription(struct["thingTypeDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingTypeProperties[k], "ThingTypeProperties contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingTypeProperties
-- <p>The ThingTypeProperties contains information about the thing type including: a thing type description, and a list of searchable thing attribute names.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * searchableAttributes [SearchableAttributes] <p>A list of searchable thing attribute names.</p>
-- * thingTypeDescription [ThingTypeDescription] <p>The description of the thing type.</p>
-- @return ThingTypeProperties structure as a key-value pair table
function M.ThingTypeProperties(args)
	assert(args, "You must provide an argument table when creating ThingTypeProperties")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["searchableAttributes"] = args["searchableAttributes"],
		["thingTypeDescription"] = args["thingTypeDescription"],
	}
	asserts.AssertThingTypeProperties(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateThingResponse = { ["thingArn"] = true, ["thingId"] = true, ["thingName"] = true, nil }

function asserts.AssertCreateThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateThingResponse to be of type 'table'")
	if struct["thingArn"] then asserts.AssertThingArn(struct["thingArn"]) end
	if struct["thingId"] then asserts.AssertThingId(struct["thingId"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateThingResponse[k], "CreateThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateThingResponse
-- <p>The output of the CreateThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingArn [ThingArn] <p>The ARN of the new thing.</p>
-- * thingId [ThingId] <p>The thing ID.</p>
-- * thingName [ThingName] <p>The name of the new thing.</p>
-- @return CreateThingResponse structure as a key-value pair table
function M.CreateThingResponse(args)
	assert(args, "You must provide an argument table when creating CreateThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingArn"] = args["thingArn"],
		["thingId"] = args["thingId"],
		["thingName"] = args["thingName"],
	}
	asserts.AssertCreateThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CloudwatchMetricAction = { ["metricUnit"] = true, ["roleArn"] = true, ["metricTimestamp"] = true, ["metricNamespace"] = true, ["metricValue"] = true, ["metricName"] = true, nil }

function asserts.AssertCloudwatchMetricAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CloudwatchMetricAction to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["metricNamespace"], "Expected key metricNamespace to exist in table")
	assert(struct["metricName"], "Expected key metricName to exist in table")
	assert(struct["metricValue"], "Expected key metricValue to exist in table")
	assert(struct["metricUnit"], "Expected key metricUnit to exist in table")
	if struct["metricUnit"] then asserts.AssertString(struct["metricUnit"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["metricTimestamp"] then asserts.AssertString(struct["metricTimestamp"]) end
	if struct["metricNamespace"] then asserts.AssertString(struct["metricNamespace"]) end
	if struct["metricValue"] then asserts.AssertString(struct["metricValue"]) end
	if struct["metricName"] then asserts.AssertString(struct["metricName"]) end
	for k,_ in pairs(struct) do
		assert(keys.CloudwatchMetricAction[k], "CloudwatchMetricAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CloudwatchMetricAction
-- <p>Describes an action that captures a CloudWatch metric.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * metricUnit [String] <p>The <a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit">metric unit</a> supported by CloudWatch.</p>
-- * roleArn [AwsArn] <p>The IAM role that allows access to the CloudWatch metric.</p>
-- * metricTimestamp [String] <p>An optional <a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp">Unix timestamp</a>.</p>
-- * metricNamespace [String] <p>The CloudWatch metric namespace name.</p>
-- * metricValue [String] <p>The CloudWatch metric value.</p>
-- * metricName [String] <p>The CloudWatch metric name.</p>
-- Required key: roleArn
-- Required key: metricNamespace
-- Required key: metricName
-- Required key: metricValue
-- Required key: metricUnit
-- @return CloudwatchMetricAction structure as a key-value pair table
function M.CloudwatchMetricAction(args)
	assert(args, "You must provide an argument table when creating CloudwatchMetricAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["metricUnit"] = args["metricUnit"],
		["roleArn"] = args["roleArn"],
		["metricTimestamp"] = args["metricTimestamp"],
		["metricNamespace"] = args["metricNamespace"],
		["metricValue"] = args["metricValue"],
		["metricName"] = args["metricName"],
	}
	asserts.AssertCloudwatchMetricAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteSecurityProfileRequest = { ["expectedVersion"] = true, ["securityProfileName"] = true, nil }

function asserts.AssertDeleteSecurityProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSecurityProfileRequest to be of type 'table'")
	assert(struct["securityProfileName"], "Expected key securityProfileName to exist in table")
	if struct["expectedVersion"] then asserts.AssertOptionalVersion(struct["expectedVersion"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSecurityProfileRequest[k], "DeleteSecurityProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSecurityProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * expectedVersion [OptionalVersion] <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different than the actual version, a <code>VersionConflictException</code> is thrown.</p>
-- * securityProfileName [SecurityProfileName] <p>The name of the security profile to be deleted.</p>
-- Required key: securityProfileName
-- @return DeleteSecurityProfileRequest structure as a key-value pair table
function M.DeleteSecurityProfileRequest(args)
	assert(args, "You must provide an argument table when creating DeleteSecurityProfileRequest")
    local query_args = { 
        ["expectedVersion"] = args["expectedVersion"],
    }
    local uri_args = { 
        ["{securityProfileName}"] = args["securityProfileName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["expectedVersion"] = args["expectedVersion"],
		["securityProfileName"] = args["securityProfileName"],
	}
	asserts.AssertDeleteSecurityProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Action = { ["dynamoDBv2"] = true, ["salesforce"] = true, ["kinesis"] = true, ["sqs"] = true, ["republish"] = true, ["dynamoDB"] = true, ["s3"] = true, ["cloudwatchAlarm"] = true, ["sns"] = true, ["stepFunctions"] = true, ["elasticsearch"] = true, ["cloudwatchMetric"] = true, ["firehose"] = true, ["iotAnalytics"] = true, ["lambda"] = true, nil }

function asserts.AssertAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Action to be of type 'table'")
	if struct["dynamoDBv2"] then asserts.AssertDynamoDBv2Action(struct["dynamoDBv2"]) end
	if struct["salesforce"] then asserts.AssertSalesforceAction(struct["salesforce"]) end
	if struct["kinesis"] then asserts.AssertKinesisAction(struct["kinesis"]) end
	if struct["sqs"] then asserts.AssertSqsAction(struct["sqs"]) end
	if struct["republish"] then asserts.AssertRepublishAction(struct["republish"]) end
	if struct["dynamoDB"] then asserts.AssertDynamoDBAction(struct["dynamoDB"]) end
	if struct["s3"] then asserts.AssertS3Action(struct["s3"]) end
	if struct["cloudwatchAlarm"] then asserts.AssertCloudwatchAlarmAction(struct["cloudwatchAlarm"]) end
	if struct["sns"] then asserts.AssertSnsAction(struct["sns"]) end
	if struct["stepFunctions"] then asserts.AssertStepFunctionsAction(struct["stepFunctions"]) end
	if struct["elasticsearch"] then asserts.AssertElasticsearchAction(struct["elasticsearch"]) end
	if struct["cloudwatchMetric"] then asserts.AssertCloudwatchMetricAction(struct["cloudwatchMetric"]) end
	if struct["firehose"] then asserts.AssertFirehoseAction(struct["firehose"]) end
	if struct["iotAnalytics"] then asserts.AssertIotAnalyticsAction(struct["iotAnalytics"]) end
	if struct["lambda"] then asserts.AssertLambdaAction(struct["lambda"]) end
	for k,_ in pairs(struct) do
		assert(keys.Action[k], "Action contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Action
-- <p>Describes the actions associated with a rule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * dynamoDBv2 [DynamoDBv2Action] <p>Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.</p>
-- * salesforce [SalesforceAction] <p>Send a message to a Salesforce IoT Cloud Input Stream.</p>
-- * kinesis [KinesisAction] <p>Write data to an Amazon Kinesis stream.</p>
-- * sqs [SqsAction] <p>Publish to an Amazon SQS queue.</p>
-- * republish [RepublishAction] <p>Publish to another MQTT topic.</p>
-- * dynamoDB [DynamoDBAction] <p>Write to a DynamoDB table.</p>
-- * s3 [S3Action] <p>Write to an Amazon S3 bucket.</p>
-- * cloudwatchAlarm [CloudwatchAlarmAction] <p>Change the state of a CloudWatch alarm.</p>
-- * sns [SnsAction] <p>Publish to an Amazon SNS topic.</p>
-- * stepFunctions [StepFunctionsAction] <p>Starts execution of a Step Functions state machine.</p>
-- * elasticsearch [ElasticsearchAction] <p>Write data to an Amazon Elasticsearch Service domain.</p>
-- * cloudwatchMetric [CloudwatchMetricAction] <p>Capture a CloudWatch metric.</p>
-- * firehose [FirehoseAction] <p>Write to an Amazon Kinesis Firehose stream.</p>
-- * iotAnalytics [IotAnalyticsAction] <p>Sends message data to an AWS IoT Analytics channel.</p>
-- * lambda [LambdaAction] <p>Invoke a Lambda function.</p>
-- @return Action structure as a key-value pair table
function M.Action(args)
	assert(args, "You must provide an argument table when creating Action")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["dynamoDBv2"] = args["dynamoDBv2"],
		["salesforce"] = args["salesforce"],
		["kinesis"] = args["kinesis"],
		["sqs"] = args["sqs"],
		["republish"] = args["republish"],
		["dynamoDB"] = args["dynamoDB"],
		["s3"] = args["s3"],
		["cloudwatchAlarm"] = args["cloudwatchAlarm"],
		["sns"] = args["sns"],
		["stepFunctions"] = args["stepFunctions"],
		["elasticsearch"] = args["elasticsearch"],
		["cloudwatchMetric"] = args["cloudwatchMetric"],
		["firehose"] = args["firehose"],
		["iotAnalytics"] = args["iotAnalytics"],
		["lambda"] = args["lambda"],
	}
	asserts.AssertAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StepFunctionsAction = { ["executionNamePrefix"] = true, ["roleArn"] = true, ["stateMachineName"] = true, nil }

function asserts.AssertStepFunctionsAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StepFunctionsAction to be of type 'table'")
	assert(struct["stateMachineName"], "Expected key stateMachineName to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["executionNamePrefix"] then asserts.AssertExecutionNamePrefix(struct["executionNamePrefix"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["stateMachineName"] then asserts.AssertStateMachineName(struct["stateMachineName"]) end
	for k,_ in pairs(struct) do
		assert(keys.StepFunctionsAction[k], "StepFunctionsAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StepFunctionsAction
-- <p>Starts execution of a Step Functions state machine.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * executionNamePrefix [ExecutionNamePrefix] <p>(Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.</p>
-- * roleArn [AwsArn] <p>The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").</p>
-- * stateMachineName [StateMachineName] <p>The name of the Step Functions state machine whose execution will be started.</p>
-- Required key: stateMachineName
-- Required key: roleArn
-- @return StepFunctionsAction structure as a key-value pair table
function M.StepFunctionsAction(args)
	assert(args, "You must provide an argument table when creating StepFunctionsAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["executionNamePrefix"] = args["executionNamePrefix"],
		["roleArn"] = args["roleArn"],
		["stateMachineName"] = args["stateMachineName"],
	}
	asserts.AssertStepFunctionsAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPoliciesRequest = { ["marker"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, nil }

function asserts.AssertListPoliciesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPoliciesRequest to be of type 'table'")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPoliciesRequest[k], "ListPoliciesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPoliciesRequest
-- <p>The input for the ListPolicies operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The marker for the next set of results.</p>
-- * ascendingOrder [AscendingOrder] <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
-- * pageSize [PageSize] <p>The result page size.</p>
-- @return ListPoliciesRequest structure as a key-value pair table
function M.ListPoliciesRequest(args)
	assert(args, "You must provide an argument table when creating ListPoliciesRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListPoliciesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateStreamRequest = { ["files"] = true, ["roleArn"] = true, ["description"] = true, ["streamId"] = true, nil }

function asserts.AssertUpdateStreamRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateStreamRequest to be of type 'table'")
	assert(struct["streamId"], "Expected key streamId to exist in table")
	if struct["files"] then asserts.AssertStreamFiles(struct["files"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["description"] then asserts.AssertStreamDescription(struct["description"]) end
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateStreamRequest[k], "UpdateStreamRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateStreamRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * files [StreamFiles] <p>The files associated with the stream.</p>
-- * roleArn [RoleArn] <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
-- * description [StreamDescription] <p>The description of the stream.</p>
-- * streamId [StreamId] <p>The stream ID.</p>
-- Required key: streamId
-- @return UpdateStreamRequest structure as a key-value pair table
function M.UpdateStreamRequest(args)
	assert(args, "You must provide an argument table when creating UpdateStreamRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{streamId}"] = args["streamId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["files"] = args["files"],
		["roleArn"] = args["roleArn"],
		["description"] = args["description"],
		["streamId"] = args["streamId"],
	}
	asserts.AssertUpdateStreamRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEndpointRequest = { ["endpointType"] = true, nil }

function asserts.AssertDescribeEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEndpointRequest to be of type 'table'")
	if struct["endpointType"] then asserts.AssertEndpointType(struct["endpointType"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEndpointRequest[k], "DescribeEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEndpointRequest
-- <p>The input for the DescribeEndpoint operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * endpointType [EndpointType] <p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul>
-- @return DescribeEndpointRequest structure as a key-value pair table
function M.DescribeEndpointRequest(args)
	assert(args, "You must provide an argument table when creating DescribeEndpointRequest")
    local query_args = { 
        ["endpointType"] = args["endpointType"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["endpointType"] = args["endpointType"],
	}
	asserts.AssertDescribeEndpointRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreatePolicyRequest = { ["policyName"] = true, ["policyDocument"] = true, nil }

function asserts.AssertCreatePolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["policyDocument"], "Expected key policyDocument to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyDocument"] then asserts.AssertPolicyDocument(struct["policyDocument"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePolicyRequest[k], "CreatePolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePolicyRequest
-- <p>The input for the CreatePolicy operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * policyDocument [PolicyDocument] <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.</p>
-- Required key: policyName
-- Required key: policyDocument
-- @return CreatePolicyRequest structure as a key-value pair table
function M.CreatePolicyRequest(args)
	assert(args, "You must provide an argument table when creating CreatePolicyRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyDocument"] = args["policyDocument"],
	}
	asserts.AssertCreatePolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingGroupsResponse = { ["nextToken"] = true, ["thingGroups"] = true, nil }

function asserts.AssertListThingGroupsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingGroupsResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["thingGroups"] then asserts.AssertThingGroupNameAndArnList(struct["thingGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingGroupsResponse[k], "ListThingGroupsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingGroupsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * thingGroups [ThingGroupNameAndArnList] <p>The thing groups.</p>
-- @return ListThingGroupsResponse structure as a key-value pair table
function M.ListThingGroupsResponse(args)
	assert(args, "You must provide an argument table when creating ListThingGroupsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["thingGroups"] = args["thingGroups"],
	}
	asserts.AssertListThingGroupsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingRegistrationTasksResponse = { ["nextToken"] = true, ["taskIds"] = true, nil }

function asserts.AssertListThingRegistrationTasksResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingRegistrationTasksResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["taskIds"] then asserts.AssertTaskIdList(struct["taskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingRegistrationTasksResponse[k], "ListThingRegistrationTasksResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingRegistrationTasksResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * taskIds [TaskIdList] <p>A list of bulk thing provisioning task IDs.</p>
-- @return ListThingRegistrationTasksResponse structure as a key-value pair table
function M.ListThingRegistrationTasksResponse(args)
	assert(args, "You must provide an argument table when creating ListThingRegistrationTasksResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["taskIds"] = args["taskIds"],
	}
	asserts.AssertListThingRegistrationTasksResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAuthorizerRequest = { ["status"] = true, ["tokenKeyName"] = true, ["tokenSigningPublicKeys"] = true, ["authorizerName"] = true, ["authorizerFunctionArn"] = true, nil }

function asserts.AssertUpdateAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAuthorizerRequest to be of type 'table'")
	assert(struct["authorizerName"], "Expected key authorizerName to exist in table")
	if struct["status"] then asserts.AssertAuthorizerStatus(struct["status"]) end
	if struct["tokenKeyName"] then asserts.AssertTokenKeyName(struct["tokenKeyName"]) end
	if struct["tokenSigningPublicKeys"] then asserts.AssertPublicKeyMap(struct["tokenSigningPublicKeys"]) end
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	if struct["authorizerFunctionArn"] then asserts.AssertAuthorizerFunctionArn(struct["authorizerFunctionArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateAuthorizerRequest[k], "UpdateAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [AuthorizerStatus] <p>The status of the update authorizer request.</p>
-- * tokenKeyName [TokenKeyName] <p>The key used to extract the token from the HTTP headers. </p>
-- * tokenSigningPublicKeys [PublicKeyMap] <p>The public keys used to verify the token signature.</p>
-- * authorizerName [AuthorizerName] <p>The authorizer name.</p>
-- * authorizerFunctionArn [AuthorizerFunctionArn] <p>The ARN of the authorizer's Lambda function.</p>
-- Required key: authorizerName
-- @return UpdateAuthorizerRequest structure as a key-value pair table
function M.UpdateAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating UpdateAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{authorizerName}"] = args["authorizerName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["tokenKeyName"] = args["tokenKeyName"],
		["tokenSigningPublicKeys"] = args["tokenSigningPublicKeys"],
		["authorizerName"] = args["authorizerName"],
		["authorizerFunctionArn"] = args["authorizerFunctionArn"],
	}
	asserts.AssertUpdateAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CACertificate = { ["certificateArn"] = true, ["status"] = true, ["creationDate"] = true, ["certificateId"] = true, nil }

function asserts.AssertCACertificate(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CACertificate to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["status"] then asserts.AssertCACertificateStatus(struct["status"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CACertificate[k], "CACertificate contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CACertificate
-- <p>A CA certificate.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The ARN of the CA certificate.</p>
-- * status [CACertificateStatus] <p>The status of the CA certificate.</p> <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
-- * creationDate [DateType] <p>The date the CA certificate was created.</p>
-- * certificateId [CertificateId] <p>The ID of the CA certificate.</p>
-- @return CACertificate structure as a key-value pair table
function M.CACertificate(args)
	assert(args, "You must provide an argument table when creating CACertificate")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["status"] = args["status"],
		["creationDate"] = args["creationDate"],
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertCACertificate(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingTypesRequest = { ["thingTypeName"] = true, ["nextToken"] = true, ["maxResults"] = true, nil }

function asserts.AssertListThingTypesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingTypesRequest to be of type 'table'")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingTypesRequest[k], "ListThingTypesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingTypesRequest
-- <p>The input for the ListThingTypes operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return in this operation.</p>
-- @return ListThingTypesRequest structure as a key-value pair table
function M.ListThingTypesRequest(args)
	assert(args, "You must provide an argument table when creating ListThingTypesRequest")
    local query_args = { 
        ["thingTypeName"] = args["thingTypeName"],
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListThingTypesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateCACertificateRequest = { ["removeAutoRegistration"] = true, ["newStatus"] = true, ["certificateId"] = true, ["newAutoRegistrationStatus"] = true, ["registrationConfig"] = true, nil }

function asserts.AssertUpdateCACertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateCACertificateRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["removeAutoRegistration"] then asserts.AssertRemoveAutoRegistration(struct["removeAutoRegistration"]) end
	if struct["newStatus"] then asserts.AssertCACertificateStatus(struct["newStatus"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["newAutoRegistrationStatus"] then asserts.AssertAutoRegistrationStatus(struct["newAutoRegistrationStatus"]) end
	if struct["registrationConfig"] then asserts.AssertRegistrationConfig(struct["registrationConfig"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateCACertificateRequest[k], "UpdateCACertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateCACertificateRequest
-- <p>The input to the UpdateCACertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * removeAutoRegistration [RemoveAutoRegistration] <p>If true, remove auto registration.</p>
-- * newStatus [CACertificateStatus] <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
-- * certificateId [CertificateId] <p>The CA certificate identifier.</p>
-- * newAutoRegistrationStatus [AutoRegistrationStatus] <p>The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".</p>
-- * registrationConfig [RegistrationConfig] <p>Information about the registration configuration.</p>
-- Required key: certificateId
-- @return UpdateCACertificateRequest structure as a key-value pair table
function M.UpdateCACertificateRequest(args)
	assert(args, "You must provide an argument table when creating UpdateCACertificateRequest")
    local query_args = { 
        ["newStatus"] = args["newStatus"],
        ["newAutoRegistrationStatus"] = args["newAutoRegistrationStatus"],
    }
    local uri_args = { 
        ["{caCertificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["removeAutoRegistration"] = args["removeAutoRegistration"],
		["newStatus"] = args["newStatus"],
		["certificateId"] = args["certificateId"],
		["newAutoRegistrationStatus"] = args["newAutoRegistrationStatus"],
		["registrationConfig"] = args["registrationConfig"],
	}
	asserts.AssertUpdateCACertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateRoleAliasResponse = { ["roleAlias"] = true, ["roleAliasArn"] = true, nil }

function asserts.AssertUpdateRoleAliasResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateRoleAliasResponse to be of type 'table'")
	if struct["roleAlias"] then asserts.AssertRoleAlias(struct["roleAlias"]) end
	if struct["roleAliasArn"] then asserts.AssertRoleAliasArn(struct["roleAliasArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateRoleAliasResponse[k], "UpdateRoleAliasResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateRoleAliasResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleAlias [RoleAlias] <p>The role alias.</p>
-- * roleAliasArn [RoleAliasArn] <p>The role alias ARN.</p>
-- @return UpdateRoleAliasResponse structure as a key-value pair table
function M.UpdateRoleAliasResponse(args)
	assert(args, "You must provide an argument table when creating UpdateRoleAliasResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleAlias"] = args["roleAlias"],
		["roleAliasArn"] = args["roleAliasArn"],
	}
	asserts.AssertUpdateRoleAliasResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CloudwatchAlarmAction = { ["stateReason"] = true, ["roleArn"] = true, ["alarmName"] = true, ["stateValue"] = true, nil }

function asserts.AssertCloudwatchAlarmAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CloudwatchAlarmAction to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["alarmName"], "Expected key alarmName to exist in table")
	assert(struct["stateReason"], "Expected key stateReason to exist in table")
	assert(struct["stateValue"], "Expected key stateValue to exist in table")
	if struct["stateReason"] then asserts.AssertStateReason(struct["stateReason"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["alarmName"] then asserts.AssertAlarmName(struct["alarmName"]) end
	if struct["stateValue"] then asserts.AssertStateValue(struct["stateValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.CloudwatchAlarmAction[k], "CloudwatchAlarmAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CloudwatchAlarmAction
-- <p>Describes an action that updates a CloudWatch alarm.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * stateReason [StateReason] <p>The reason for the alarm change.</p>
-- * roleArn [AwsArn] <p>The IAM role that allows access to the CloudWatch alarm.</p>
-- * alarmName [AlarmName] <p>The CloudWatch alarm name.</p>
-- * stateValue [StateValue] <p>The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.</p>
-- Required key: roleArn
-- Required key: alarmName
-- Required key: stateReason
-- Required key: stateValue
-- @return CloudwatchAlarmAction structure as a key-value pair table
function M.CloudwatchAlarmAction(args)
	assert(args, "You must provide an argument table when creating CloudwatchAlarmAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["stateReason"] = args["stateReason"],
		["roleArn"] = args["roleArn"],
		["alarmName"] = args["alarmName"],
		["stateValue"] = args["stateValue"],
	}
	asserts.AssertCloudwatchAlarmAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateStreamRequest = { ["files"] = true, ["roleArn"] = true, ["description"] = true, ["streamId"] = true, nil }

function asserts.AssertCreateStreamRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateStreamRequest to be of type 'table'")
	assert(struct["streamId"], "Expected key streamId to exist in table")
	assert(struct["files"], "Expected key files to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["files"] then asserts.AssertStreamFiles(struct["files"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["description"] then asserts.AssertStreamDescription(struct["description"]) end
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateStreamRequest[k], "CreateStreamRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateStreamRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * files [StreamFiles] <p>The files to stream.</p>
-- * roleArn [RoleArn] <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
-- * description [StreamDescription] <p>A description of the stream.</p>
-- * streamId [StreamId] <p>The stream ID.</p>
-- Required key: streamId
-- Required key: files
-- Required key: roleArn
-- @return CreateStreamRequest structure as a key-value pair table
function M.CreateStreamRequest(args)
	assert(args, "You must provide an argument table when creating CreateStreamRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{streamId}"] = args["streamId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["files"] = args["files"],
		["roleArn"] = args["roleArn"],
		["description"] = args["description"],
		["streamId"] = args["streamId"],
	}
	asserts.AssertCreateStreamRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteOTAUpdateRequest = { ["forceDeleteAWSJob"] = true, ["otaUpdateId"] = true, ["deleteStream"] = true, nil }

function asserts.AssertDeleteOTAUpdateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteOTAUpdateRequest to be of type 'table'")
	assert(struct["otaUpdateId"], "Expected key otaUpdateId to exist in table")
	if struct["forceDeleteAWSJob"] then asserts.AssertForceDeleteAWSJob(struct["forceDeleteAWSJob"]) end
	if struct["otaUpdateId"] then asserts.AssertOTAUpdateId(struct["otaUpdateId"]) end
	if struct["deleteStream"] then asserts.AssertDeleteStream(struct["deleteStream"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteOTAUpdateRequest[k], "DeleteOTAUpdateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteOTAUpdateRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * forceDeleteAWSJob [ForceDeleteAWSJob] <p>Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.</p>
-- * otaUpdateId [OTAUpdateId] <p>The OTA update ID to delete.</p>
-- * deleteStream [DeleteStream] <p>Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.</p>
-- Required key: otaUpdateId
-- @return DeleteOTAUpdateRequest structure as a key-value pair table
function M.DeleteOTAUpdateRequest(args)
	assert(args, "You must provide an argument table when creating DeleteOTAUpdateRequest")
    local query_args = { 
        ["forceDeleteAWSJob"] = args["forceDeleteAWSJob"],
        ["deleteStream"] = args["deleteStream"],
    }
    local uri_args = { 
        ["{otaUpdateId}"] = args["otaUpdateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["forceDeleteAWSJob"] = args["forceDeleteAWSJob"],
		["otaUpdateId"] = args["otaUpdateId"],
		["deleteStream"] = args["deleteStream"],
	}
	asserts.AssertDeleteOTAUpdateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StopThingRegistrationTaskResponse = { nil }

function asserts.AssertStopThingRegistrationTaskResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopThingRegistrationTaskResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.StopThingRegistrationTaskResponse[k], "StopThingRegistrationTaskResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopThingRegistrationTaskResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return StopThingRegistrationTaskResponse structure as a key-value pair table
function M.StopThingRegistrationTaskResponse(args)
	assert(args, "You must provide an argument table when creating StopThingRegistrationTaskResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertStopThingRegistrationTaskResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingResponse = { ["defaultClientId"] = true, ["thingTypeName"] = true, ["thingArn"] = true, ["version"] = true, ["thingName"] = true, ["attributes"] = true, ["thingId"] = true, nil }

function asserts.AssertDescribeThingResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingResponse to be of type 'table'")
	if struct["defaultClientId"] then asserts.AssertClientId(struct["defaultClientId"]) end
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["thingArn"] then asserts.AssertThingArn(struct["thingArn"]) end
	if struct["version"] then asserts.AssertVersion(struct["version"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["attributes"] then asserts.AssertAttributes(struct["attributes"]) end
	if struct["thingId"] then asserts.AssertThingId(struct["thingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingResponse[k], "DescribeThingResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingResponse
-- <p>The output from the DescribeThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * defaultClientId [ClientId] <p>The default client ID.</p>
-- * thingTypeName [ThingTypeName] <p>The thing type name.</p>
-- * thingArn [ThingArn] <p>The ARN of the thing to describe.</p>
-- * version [Version] <p>The current version of the thing record in the registry.</p> <note> <p>To avoid unintentional changes to the information in the registry, you can pass the version information in the <code>expectedVersion</code> parameter of the <code>UpdateThing</code> and <code>DeleteThing</code> calls.</p> </note>
-- * thingName [ThingName] <p>The name of the thing.</p>
-- * attributes [Attributes] <p>The thing attributes.</p>
-- * thingId [ThingId] <p>The ID of the thing to describe.</p>
-- @return DescribeThingResponse structure as a key-value pair table
function M.DescribeThingResponse(args)
	assert(args, "You must provide an argument table when creating DescribeThingResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["defaultClientId"] = args["defaultClientId"],
		["thingTypeName"] = args["thingTypeName"],
		["thingArn"] = args["thingArn"],
		["version"] = args["version"],
		["thingName"] = args["thingName"],
		["attributes"] = args["attributes"],
		["thingId"] = args["thingId"],
	}
	asserts.AssertDescribeThingResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListStreamsRequest = { ["ascendingOrder"] = true, ["nextToken"] = true, ["maxResults"] = true, nil }

function asserts.AssertListStreamsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListStreamsRequest to be of type 'table'")
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListStreamsRequest[k], "ListStreamsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListStreamsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ascendingOrder [AscendingOrder] <p>Set to true to return the list of streams in ascending order.</p>
-- * nextToken [NextToken] <p>A token used to get the next set of results.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at a time.</p>
-- @return ListStreamsRequest structure as a key-value pair table
function M.ListStreamsRequest(args)
	assert(args, "You must provide an argument table when creating ListStreamsRequest")
    local query_args = { 
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ascendingOrder"] = args["ascendingOrder"],
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListStreamsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAccountAuditConfigurationRequest = { ["roleArn"] = true, ["auditNotificationTargetConfigurations"] = true, ["auditCheckConfigurations"] = true, nil }

function asserts.AssertUpdateAccountAuditConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAccountAuditConfigurationRequest to be of type 'table'")
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["auditNotificationTargetConfigurations"] then asserts.AssertAuditNotificationTargetConfigurations(struct["auditNotificationTargetConfigurations"]) end
	if struct["auditCheckConfigurations"] then asserts.AssertAuditCheckConfigurations(struct["auditCheckConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateAccountAuditConfigurationRequest[k], "UpdateAccountAuditConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAccountAuditConfigurationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [RoleArn] <p>The ARN of the role that grants permission to AWS IoT to access information about your devices, policies, certificates and other items as necessary when performing an audit.</p>
-- * auditNotificationTargetConfigurations [AuditNotificationTargetConfigurations] <p>Information about the targets to which audit notifications are sent.</p>
-- * auditCheckConfigurations [AuditCheckConfigurations] <p>Specifies which audit checks are enabled and disabled for this account. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are currently enabled.</p> <p>Note that some data collection may begin immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted.</p> <p>You cannot disable a check if it is used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself.</p> <p>On the first call to <code>UpdateAccountAuditConfiguration</code> this parameter is required and must specify at least one enabled check.</p>
-- @return UpdateAccountAuditConfigurationRequest structure as a key-value pair table
function M.UpdateAccountAuditConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating UpdateAccountAuditConfigurationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["auditNotificationTargetConfigurations"] = args["auditNotificationTargetConfigurations"],
		["auditCheckConfigurations"] = args["auditCheckConfigurations"],
	}
	asserts.AssertUpdateAccountAuditConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuthorizerDescription = { ["status"] = true, ["lastModifiedDate"] = true, ["authorizerName"] = true, ["tokenKeyName"] = true, ["authorizerArn"] = true, ["tokenSigningPublicKeys"] = true, ["creationDate"] = true, ["authorizerFunctionArn"] = true, nil }

function asserts.AssertAuthorizerDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizerDescription to be of type 'table'")
	if struct["status"] then asserts.AssertAuthorizerStatus(struct["status"]) end
	if struct["lastModifiedDate"] then asserts.AssertDateType(struct["lastModifiedDate"]) end
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	if struct["tokenKeyName"] then asserts.AssertTokenKeyName(struct["tokenKeyName"]) end
	if struct["authorizerArn"] then asserts.AssertAuthorizerArn(struct["authorizerArn"]) end
	if struct["tokenSigningPublicKeys"] then asserts.AssertPublicKeyMap(struct["tokenSigningPublicKeys"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	if struct["authorizerFunctionArn"] then asserts.AssertAuthorizerFunctionArn(struct["authorizerFunctionArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizerDescription[k], "AuthorizerDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizerDescription
-- <p>The authorizer description.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [AuthorizerStatus] <p>The status of the authorizer.</p>
-- * lastModifiedDate [DateType] <p>The UNIX timestamp of when the authorizer was last updated.</p>
-- * authorizerName [AuthorizerName] <p>The authorizer name.</p>
-- * tokenKeyName [TokenKeyName] <p>The key used to extract the token from the HTTP headers.</p>
-- * authorizerArn [AuthorizerArn] <p>The authorizer ARN.</p>
-- * tokenSigningPublicKeys [PublicKeyMap] <p>The public keys used to validate the token signature returned by your custom authentication service.</p>
-- * creationDate [DateType] <p>The UNIX timestamp of when the authorizer was created.</p>
-- * authorizerFunctionArn [AuthorizerFunctionArn] <p>The authorizer's Lambda function ARN.</p>
-- @return AuthorizerDescription structure as a key-value pair table
function M.AuthorizerDescription(args)
	assert(args, "You must provide an argument table when creating AuthorizerDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["authorizerName"] = args["authorizerName"],
		["tokenKeyName"] = args["tokenKeyName"],
		["authorizerArn"] = args["authorizerArn"],
		["tokenSigningPublicKeys"] = args["tokenSigningPublicKeys"],
		["creationDate"] = args["creationDate"],
		["authorizerFunctionArn"] = args["authorizerFunctionArn"],
	}
	asserts.AssertAuthorizerDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateCertificateFromCsrRequest = { ["certificateSigningRequest"] = true, ["setAsActive"] = true, nil }

function asserts.AssertCreateCertificateFromCsrRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCertificateFromCsrRequest to be of type 'table'")
	assert(struct["certificateSigningRequest"], "Expected key certificateSigningRequest to exist in table")
	if struct["certificateSigningRequest"] then asserts.AssertCertificateSigningRequest(struct["certificateSigningRequest"]) end
	if struct["setAsActive"] then asserts.AssertSetAsActive(struct["setAsActive"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCertificateFromCsrRequest[k], "CreateCertificateFromCsrRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCertificateFromCsrRequest
-- <p>The input for the CreateCertificateFromCsr operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateSigningRequest [CertificateSigningRequest] <p>The certificate signing request (CSR).</p>
-- * setAsActive [SetAsActive] <p>Specifies whether the certificate is active.</p>
-- Required key: certificateSigningRequest
-- @return CreateCertificateFromCsrRequest structure as a key-value pair table
function M.CreateCertificateFromCsrRequest(args)
	assert(args, "You must provide an argument table when creating CreateCertificateFromCsrRequest")
    local query_args = { 
        ["setAsActive"] = args["setAsActive"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateSigningRequest"] = args["certificateSigningRequest"],
		["setAsActive"] = args["setAsActive"],
	}
	asserts.AssertCreateCertificateFromCsrRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateEventConfigurationsResponse = { nil }

function asserts.AssertUpdateEventConfigurationsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateEventConfigurationsResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.UpdateEventConfigurationsResponse[k], "UpdateEventConfigurationsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateEventConfigurationsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return UpdateEventConfigurationsResponse structure as a key-value pair table
function M.UpdateEventConfigurationsResponse(args)
	assert(args, "You must provide an argument table when creating UpdateEventConfigurationsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertUpdateEventConfigurationsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateScheduledAuditRequest = { ["dayOfWeek"] = true, ["targetCheckNames"] = true, ["scheduledAuditName"] = true, ["frequency"] = true, ["dayOfMonth"] = true, nil }

function asserts.AssertUpdateScheduledAuditRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateScheduledAuditRequest to be of type 'table'")
	assert(struct["scheduledAuditName"], "Expected key scheduledAuditName to exist in table")
	if struct["dayOfWeek"] then asserts.AssertDayOfWeek(struct["dayOfWeek"]) end
	if struct["targetCheckNames"] then asserts.AssertTargetAuditCheckNames(struct["targetCheckNames"]) end
	if struct["scheduledAuditName"] then asserts.AssertScheduledAuditName(struct["scheduledAuditName"]) end
	if struct["frequency"] then asserts.AssertAuditFrequency(struct["frequency"]) end
	if struct["dayOfMonth"] then asserts.AssertDayOfMonth(struct["dayOfMonth"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateScheduledAuditRequest[k], "UpdateScheduledAuditRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateScheduledAuditRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * dayOfWeek [DayOfWeek] <p>The day of the week on which the scheduled audit takes place. Can be one of "SUN", "MON", "TUE", "WED", "THU", "FRI" or "SAT". This field is required if the "frequency" parameter is set to "WEEKLY" or "BIWEEKLY".</p>
-- * targetCheckNames [TargetAuditCheckNames] <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
-- * scheduledAuditName [ScheduledAuditName] <p>The name of the scheduled audit. (Max. 128 chars)</p>
-- * frequency [AuditFrequency] <p>How often the scheduled audit takes place. Can be one of "DAILY", "WEEKLY", "BIWEEKLY" or "MONTHLY". The actual start time of each audit is determined by the system.</p>
-- * dayOfMonth [DayOfMonth] <p>The day of the month on which the scheduled audit takes place. Can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to "MONTHLY". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
-- Required key: scheduledAuditName
-- @return UpdateScheduledAuditRequest structure as a key-value pair table
function M.UpdateScheduledAuditRequest(args)
	assert(args, "You must provide an argument table when creating UpdateScheduledAuditRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{scheduledAuditName}"] = args["scheduledAuditName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["dayOfWeek"] = args["dayOfWeek"],
		["targetCheckNames"] = args["targetCheckNames"],
		["scheduledAuditName"] = args["scheduledAuditName"],
		["frequency"] = args["frequency"],
		["dayOfMonth"] = args["dayOfMonth"],
	}
	asserts.AssertUpdateScheduledAuditRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteOTAUpdateResponse = { nil }

function asserts.AssertDeleteOTAUpdateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteOTAUpdateResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteOTAUpdateResponse[k], "DeleteOTAUpdateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteOTAUpdateResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteOTAUpdateResponse structure as a key-value pair table
function M.DeleteOTAUpdateResponse(args)
	assert(args, "You must provide an argument table when creating DeleteOTAUpdateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteOTAUpdateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetOTAUpdateResponse = { ["otaUpdateInfo"] = true, nil }

function asserts.AssertGetOTAUpdateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetOTAUpdateResponse to be of type 'table'")
	if struct["otaUpdateInfo"] then asserts.AssertOTAUpdateInfo(struct["otaUpdateInfo"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetOTAUpdateResponse[k], "GetOTAUpdateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetOTAUpdateResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * otaUpdateInfo [OTAUpdateInfo] <p>The OTA update info.</p>
-- @return GetOTAUpdateResponse structure as a key-value pair table
function M.GetOTAUpdateResponse(args)
	assert(args, "You must provide an argument table when creating GetOTAUpdateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["otaUpdateInfo"] = args["otaUpdateInfo"],
	}
	asserts.AssertGetOTAUpdateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RemoveThingFromThingGroupResponse = { nil }

function asserts.AssertRemoveThingFromThingGroupResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RemoveThingFromThingGroupResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.RemoveThingFromThingGroupResponse[k], "RemoveThingFromThingGroupResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RemoveThingFromThingGroupResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return RemoveThingFromThingGroupResponse structure as a key-value pair table
function M.RemoveThingFromThingGroupResponse(args)
	assert(args, "You must provide an argument table when creating RemoveThingFromThingGroupResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertRemoveThingFromThingGroupResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ErrorInfo = { ["message"] = true, ["code"] = true, nil }

function asserts.AssertErrorInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ErrorInfo to be of type 'table'")
	if struct["message"] then asserts.AssertOTAUpdateErrorMessage(struct["message"]) end
	if struct["code"] then asserts.AssertCode(struct["code"]) end
	for k,_ in pairs(struct) do
		assert(keys.ErrorInfo[k], "ErrorInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ErrorInfo
-- <p>Error information.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * message [OTAUpdateErrorMessage] <p>The error message.</p>
-- * code [Code] <p>The error code.</p>
-- @return ErrorInfo structure as a key-value pair table
function M.ErrorInfo(args)
	assert(args, "You must provide an argument table when creating ErrorInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["message"] = args["message"],
		["code"] = args["code"],
	}
	asserts.AssertErrorInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListOTAUpdatesRequest = { ["nextToken"] = true, ["otaUpdateStatus"] = true, ["maxResults"] = true, nil }

function asserts.AssertListOTAUpdatesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListOTAUpdatesRequest to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["otaUpdateStatus"] then asserts.AssertOTAUpdateStatus(struct["otaUpdateStatus"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListOTAUpdatesRequest[k], "ListOTAUpdatesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListOTAUpdatesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token used to retrieve the next set of results.</p>
-- * otaUpdateStatus [OTAUpdateStatus] <p>The OTA update job status.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time.</p>
-- @return ListOTAUpdatesRequest structure as a key-value pair table
function M.ListOTAUpdatesRequest(args)
	assert(args, "You must provide an argument table when creating ListOTAUpdatesRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["otaUpdateStatus"] = args["otaUpdateStatus"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["otaUpdateStatus"] = args["otaUpdateStatus"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListOTAUpdatesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Destination = { ["s3Destination"] = true, nil }

function asserts.AssertDestination(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Destination to be of type 'table'")
	if struct["s3Destination"] then asserts.AssertS3Destination(struct["s3Destination"]) end
	for k,_ in pairs(struct) do
		assert(keys.Destination[k], "Destination contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Destination
-- <p>Describes the location of the updated firmware.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * s3Destination [S3Destination] <p>Describes the location in S3 of the updated firmware.</p>
-- @return Destination structure as a key-value pair table
function M.Destination(args)
	assert(args, "You must provide an argument table when creating Destination")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["s3Destination"] = args["s3Destination"],
	}
	asserts.AssertDestination(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RemoveThingFromThingGroupRequest = { ["thingArn"] = true, ["thingGroupName"] = true, ["thingGroupArn"] = true, ["thingName"] = true, nil }

function asserts.AssertRemoveThingFromThingGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RemoveThingFromThingGroupRequest to be of type 'table'")
	if struct["thingArn"] then asserts.AssertThingArn(struct["thingArn"]) end
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["thingGroupArn"] then asserts.AssertThingGroupArn(struct["thingGroupArn"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.RemoveThingFromThingGroupRequest[k], "RemoveThingFromThingGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RemoveThingFromThingGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingArn [ThingArn] <p>The ARN of the thing to remove from the group.</p>
-- * thingGroupName [ThingGroupName] <p>The group name.</p>
-- * thingGroupArn [ThingGroupArn] <p>The group ARN.</p>
-- * thingName [ThingName] <p>The name of the thing to remove from the group.</p>
-- @return RemoveThingFromThingGroupRequest structure as a key-value pair table
function M.RemoveThingFromThingGroupRequest(args)
	assert(args, "You must provide an argument table when creating RemoveThingFromThingGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingArn"] = args["thingArn"],
		["thingGroupName"] = args["thingGroupName"],
		["thingGroupArn"] = args["thingGroupArn"],
		["thingName"] = args["thingName"],
	}
	asserts.AssertRemoveThingFromThingGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeScheduledAuditResponse = { ["dayOfWeek"] = true, ["targetCheckNames"] = true, ["scheduledAuditArn"] = true, ["scheduledAuditName"] = true, ["frequency"] = true, ["dayOfMonth"] = true, nil }

function asserts.AssertDescribeScheduledAuditResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledAuditResponse to be of type 'table'")
	if struct["dayOfWeek"] then asserts.AssertDayOfWeek(struct["dayOfWeek"]) end
	if struct["targetCheckNames"] then asserts.AssertTargetAuditCheckNames(struct["targetCheckNames"]) end
	if struct["scheduledAuditArn"] then asserts.AssertScheduledAuditArn(struct["scheduledAuditArn"]) end
	if struct["scheduledAuditName"] then asserts.AssertScheduledAuditName(struct["scheduledAuditName"]) end
	if struct["frequency"] then asserts.AssertAuditFrequency(struct["frequency"]) end
	if struct["dayOfMonth"] then asserts.AssertDayOfMonth(struct["dayOfMonth"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledAuditResponse[k], "DescribeScheduledAuditResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledAuditResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * dayOfWeek [DayOfWeek] <p>The day of the week on which the scheduled audit takes place. One of "SUN", "MON", "TUE", "WED", "THU", "FRI" or "SAT".</p>
-- * targetCheckNames [TargetAuditCheckNames] <p>Which checks are performed during the scheduled audit. (Note that checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
-- * scheduledAuditArn [ScheduledAuditArn] <p>The ARN of the scheduled audit.</p>
-- * scheduledAuditName [ScheduledAuditName] <p>The name of the scheduled audit.</p>
-- * frequency [AuditFrequency] <p>How often the scheduled audit takes place. One of "DAILY", "WEEKLY", "BIWEEKLY" or "MONTHLY". The actual start time of each audit is determined by the system.</p>
-- * dayOfMonth [DayOfMonth] <p>The day of the month on which the scheduled audit takes place. Will be "1" through "31" or "LAST". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
-- @return DescribeScheduledAuditResponse structure as a key-value pair table
function M.DescribeScheduledAuditResponse(args)
	assert(args, "You must provide an argument table when creating DescribeScheduledAuditResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["dayOfWeek"] = args["dayOfWeek"],
		["targetCheckNames"] = args["targetCheckNames"],
		["scheduledAuditArn"] = args["scheduledAuditArn"],
		["scheduledAuditName"] = args["scheduledAuditName"],
		["frequency"] = args["frequency"],
		["dayOfMonth"] = args["dayOfMonth"],
	}
	asserts.AssertDescribeScheduledAuditResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAuditFindingsResponse = { ["nextToken"] = true, ["findings"] = true, nil }

function asserts.AssertListAuditFindingsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAuditFindingsResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["findings"] then asserts.AssertAuditFindings(struct["findings"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAuditFindingsResponse[k], "ListAuditFindingsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAuditFindingsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- * findings [AuditFindings] <p>The findings (results) of the audit.</p>
-- @return ListAuditFindingsResponse structure as a key-value pair table
function M.ListAuditFindingsResponse(args)
	assert(args, "You must provide an argument table when creating ListAuditFindingsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["findings"] = args["findings"],
	}
	asserts.AssertListAuditFindingsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TransferCertificateResponse = { ["transferredCertificateArn"] = true, nil }

function asserts.AssertTransferCertificateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TransferCertificateResponse to be of type 'table'")
	if struct["transferredCertificateArn"] then asserts.AssertCertificateArn(struct["transferredCertificateArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.TransferCertificateResponse[k], "TransferCertificateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TransferCertificateResponse
-- <p>The output from the TransferCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * transferredCertificateArn [CertificateArn] <p>The ARN of the certificate.</p>
-- @return TransferCertificateResponse structure as a key-value pair table
function M.TransferCertificateResponse(args)
	assert(args, "You must provide an argument table when creating TransferCertificateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["transferredCertificateArn"] = args["transferredCertificateArn"],
	}
	asserts.AssertTransferCertificateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListRoleAliasesRequest = { ["marker"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, nil }

function asserts.AssertListRoleAliasesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListRoleAliasesRequest to be of type 'table'")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListRoleAliasesRequest[k], "ListRoleAliasesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListRoleAliasesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>A marker used to get the next set of results.</p>
-- * ascendingOrder [AscendingOrder] <p>Return the list of role aliases in ascending alphabetical order.</p>
-- * pageSize [PageSize] <p>The maximum number of results to return at one time.</p>
-- @return ListRoleAliasesRequest structure as a key-value pair table
function M.ListRoleAliasesRequest(args)
	assert(args, "You must provide an argument table when creating ListRoleAliasesRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListRoleAliasesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListJobExecutionsForJobRequest = { ["status"] = true, ["nextToken"] = true, ["maxResults"] = true, ["jobId"] = true, nil }

function asserts.AssertListJobExecutionsForJobRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListJobExecutionsForJobRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	if struct["status"] then asserts.AssertJobExecutionStatus(struct["status"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertLaserMaxResults(struct["maxResults"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListJobExecutionsForJobRequest[k], "ListJobExecutionsForJobRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListJobExecutionsForJobRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [JobExecutionStatus] <p>The status of the job.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * maxResults [LaserMaxResults] <p>The maximum number of results to be returned per request.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- Required key: jobId
-- @return ListJobExecutionsForJobRequest structure as a key-value pair table
function M.ListJobExecutionsForJobRequest(args)
	assert(args, "You must provide an argument table when creating ListJobExecutionsForJobRequest")
    local query_args = { 
        ["status"] = args["status"],
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertListJobExecutionsForJobRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateAuthorizerResponse = { ["authorizerName"] = true, ["authorizerArn"] = true, nil }

function asserts.AssertUpdateAuthorizerResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateAuthorizerResponse to be of type 'table'")
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	if struct["authorizerArn"] then asserts.AssertAuthorizerArn(struct["authorizerArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateAuthorizerResponse[k], "UpdateAuthorizerResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateAuthorizerResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerName [AuthorizerName] <p>The authorizer name.</p>
-- * authorizerArn [AuthorizerArn] <p>The authorizer ARN.</p>
-- @return UpdateAuthorizerResponse structure as a key-value pair table
function M.UpdateAuthorizerResponse(args)
	assert(args, "You must provide an argument table when creating UpdateAuthorizerResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerName"] = args["authorizerName"],
		["authorizerArn"] = args["authorizerArn"],
	}
	asserts.AssertUpdateAuthorizerResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuditNotificationTarget = { ["targetArn"] = true, ["roleArn"] = true, ["enabled"] = true, nil }

function asserts.AssertAuditNotificationTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuditNotificationTarget to be of type 'table'")
	if struct["targetArn"] then asserts.AssertTargetArn(struct["targetArn"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["enabled"] then asserts.AssertEnabled(struct["enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuditNotificationTarget[k], "AuditNotificationTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuditNotificationTarget
-- <p>Information about the targets to which audit notifications are sent.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * targetArn [TargetArn] <p>The ARN of the target (SNS topic) to which audit notifications are sent.</p>
-- * roleArn [RoleArn] <p>The ARN of the role that grants permission to send notifications to the target.</p>
-- * enabled [Enabled] <p>True if notifications to the target are enabled.</p>
-- @return AuditNotificationTarget structure as a key-value pair table
function M.AuditNotificationTarget(args)
	assert(args, "You must provide an argument table when creating AuditNotificationTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["targetArn"] = args["targetArn"],
		["roleArn"] = args["roleArn"],
		["enabled"] = args["enabled"],
	}
	asserts.AssertAuditNotificationTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteRegistrationCodeRequest = { nil }

function asserts.AssertDeleteRegistrationCodeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRegistrationCodeRequest to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteRegistrationCodeRequest[k], "DeleteRegistrationCodeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRegistrationCodeRequest
-- <p>The input for the DeleteRegistrationCode operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteRegistrationCodeRequest structure as a key-value pair table
function M.DeleteRegistrationCodeRequest(args)
	assert(args, "You must provide an argument table when creating DeleteRegistrationCodeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteRegistrationCodeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateScheduledAuditResponse = { ["scheduledAuditArn"] = true, nil }

function asserts.AssertCreateScheduledAuditResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateScheduledAuditResponse to be of type 'table'")
	if struct["scheduledAuditArn"] then asserts.AssertScheduledAuditArn(struct["scheduledAuditArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateScheduledAuditResponse[k], "CreateScheduledAuditResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateScheduledAuditResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * scheduledAuditArn [ScheduledAuditArn] <p>The ARN of the scheduled audit.</p>
-- @return CreateScheduledAuditResponse structure as a key-value pair table
function M.CreateScheduledAuditResponse(args)
	assert(args, "You must provide an argument table when creating CreateScheduledAuditResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["scheduledAuditArn"] = args["scheduledAuditArn"],
	}
	asserts.AssertCreateScheduledAuditResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingAttribute = { ["thingTypeName"] = true, ["thingArn"] = true, ["version"] = true, ["thingName"] = true, ["attributes"] = true, nil }

function asserts.AssertThingAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingAttribute to be of type 'table'")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["thingArn"] then asserts.AssertThingArn(struct["thingArn"]) end
	if struct["version"] then asserts.AssertVersion(struct["version"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["attributes"] then asserts.AssertAttributes(struct["attributes"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingAttribute[k], "ThingAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingAttribute
-- <p>The properties of the thing, including thing name, thing type name, and a list of thing attributes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type, if the thing has been associated with a type.</p>
-- * thingArn [ThingArn] <p>The thing ARN.</p>
-- * version [Version] <p>The version of the thing record in the registry.</p>
-- * thingName [ThingName] <p>The name of the thing.</p>
-- * attributes [Attributes] <p>A list of thing attributes which are name-value pairs.</p>
-- @return ThingAttribute structure as a key-value pair table
function M.ThingAttribute(args)
	assert(args, "You must provide an argument table when creating ThingAttribute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["thingArn"] = args["thingArn"],
		["version"] = args["version"],
		["thingName"] = args["thingName"],
		["attributes"] = args["attributes"],
	}
	asserts.AssertThingAttribute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIndexRequest = { ["indexName"] = true, nil }

function asserts.AssertDescribeIndexRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIndexRequest to be of type 'table'")
	assert(struct["indexName"], "Expected key indexName to exist in table")
	if struct["indexName"] then asserts.AssertIndexName(struct["indexName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIndexRequest[k], "DescribeIndexRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIndexRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * indexName [IndexName] <p>The index name.</p>
-- Required key: indexName
-- @return DescribeIndexRequest structure as a key-value pair table
function M.DescribeIndexRequest(args)
	assert(args, "You must provide an argument table when creating DescribeIndexRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{indexName}"] = args["indexName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["indexName"] = args["indexName"],
	}
	asserts.AssertDescribeIndexRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteRoleAliasRequest = { ["roleAlias"] = true, nil }

function asserts.AssertDeleteRoleAliasRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRoleAliasRequest to be of type 'table'")
	assert(struct["roleAlias"], "Expected key roleAlias to exist in table")
	if struct["roleAlias"] then asserts.AssertRoleAlias(struct["roleAlias"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteRoleAliasRequest[k], "DeleteRoleAliasRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRoleAliasRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleAlias [RoleAlias] <p>The role alias to delete.</p>
-- Required key: roleAlias
-- @return DeleteRoleAliasRequest structure as a key-value pair table
function M.DeleteRoleAliasRequest(args)
	assert(args, "You must provide an argument table when creating DeleteRoleAliasRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{roleAlias}"] = args["roleAlias"],
    }
    local header_args = { 
    }
	local all_args = { 
		["roleAlias"] = args["roleAlias"],
	}
	asserts.AssertDeleteRoleAliasRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteScheduledAuditResponse = { nil }

function asserts.AssertDeleteScheduledAuditResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteScheduledAuditResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteScheduledAuditResponse[k], "DeleteScheduledAuditResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteScheduledAuditResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteScheduledAuditResponse structure as a key-value pair table
function M.DeleteScheduledAuditResponse(args)
	assert(args, "You must provide an argument table when creating DeleteScheduledAuditResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteScheduledAuditResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListIndicesResponse = { ["nextToken"] = true, ["indexNames"] = true, nil }

function asserts.AssertListIndicesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListIndicesResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["indexNames"] then asserts.AssertIndexNamesList(struct["indexNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListIndicesResponse[k], "ListIndicesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListIndicesResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * indexNames [IndexNamesList] <p>The index names.</p>
-- @return ListIndicesResponse structure as a key-value pair table
function M.ListIndicesResponse(args)
	assert(args, "You must provide an argument table when creating ListIndicesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["indexNames"] = args["indexNames"],
	}
	asserts.AssertListIndicesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateCertificateRequest = { ["newStatus"] = true, ["certificateId"] = true, nil }

function asserts.AssertUpdateCertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateCertificateRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	assert(struct["newStatus"], "Expected key newStatus to exist in table")
	if struct["newStatus"] then asserts.AssertCertificateStatus(struct["newStatus"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateCertificateRequest[k], "UpdateCertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateCertificateRequest
-- <p>The input for the UpdateCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * newStatus [CertificateStatus] <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- Required key: certificateId
-- Required key: newStatus
-- @return UpdateCertificateRequest structure as a key-value pair table
function M.UpdateCertificateRequest(args)
	assert(args, "You must provide an argument table when creating UpdateCertificateRequest")
    local query_args = { 
        ["newStatus"] = args["newStatus"],
    }
    local uri_args = { 
        ["{certificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["newStatus"] = args["newStatus"],
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertUpdateCertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPrincipalPoliciesResponse = { ["nextMarker"] = true, ["policies"] = true, nil }

function asserts.AssertListPrincipalPoliciesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPrincipalPoliciesResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["policies"] then asserts.AssertPolicies(struct["policies"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPrincipalPoliciesResponse[k], "ListPrincipalPoliciesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPrincipalPoliciesResponse
-- <p>The output from the ListPrincipalPolicies operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>The marker for the next set of results, or null if there are no additional results.</p>
-- * policies [Policies] <p>The policies.</p>
-- @return ListPrincipalPoliciesResponse structure as a key-value pair table
function M.ListPrincipalPoliciesResponse(args)
	assert(args, "You must provide an argument table when creating ListPrincipalPoliciesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["policies"] = args["policies"],
	}
	asserts.AssertListPrincipalPoliciesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelJobResponse = { ["jobArn"] = true, ["description"] = true, ["jobId"] = true, nil }

function asserts.AssertCancelJobResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelJobResponse to be of type 'table'")
	if struct["jobArn"] then asserts.AssertJobArn(struct["jobArn"]) end
	if struct["description"] then asserts.AssertJobDescription(struct["description"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelJobResponse[k], "CancelJobResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelJobResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * jobArn [JobArn] <p>The job ARN.</p>
-- * description [JobDescription] <p>A short text description of the job.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- @return CancelJobResponse structure as a key-value pair table
function M.CancelJobResponse(args)
	assert(args, "You must provide an argument table when creating CancelJobResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["jobArn"] = args["jobArn"],
		["description"] = args["description"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertCancelJobResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuthorizerSummary = { ["authorizerName"] = true, ["authorizerArn"] = true, nil }

function asserts.AssertAuthorizerSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizerSummary to be of type 'table'")
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	if struct["authorizerArn"] then asserts.AssertAuthorizerArn(struct["authorizerArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizerSummary[k], "AuthorizerSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizerSummary
-- <p>The authorizer summary.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * authorizerName [AuthorizerName] <p>The authorizer name.</p>
-- * authorizerArn [AuthorizerArn] <p>The authorizer ARN.</p>
-- @return AuthorizerSummary structure as a key-value pair table
function M.AuthorizerSummary(args)
	assert(args, "You must provide an argument table when creating AuthorizerSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["authorizerName"] = args["authorizerName"],
		["authorizerArn"] = args["authorizerArn"],
	}
	asserts.AssertAuthorizerSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Denied = { ["implicitDeny"] = true, ["explicitDeny"] = true, nil }

function asserts.AssertDenied(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Denied to be of type 'table'")
	if struct["implicitDeny"] then asserts.AssertImplicitDeny(struct["implicitDeny"]) end
	if struct["explicitDeny"] then asserts.AssertExplicitDeny(struct["explicitDeny"]) end
	for k,_ in pairs(struct) do
		assert(keys.Denied[k], "Denied contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Denied
-- <p>Contains information that denied the authorization.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * implicitDeny [ImplicitDeny] <p>Information that implicitly denies the authorization. When a policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.</p>
-- * explicitDeny [ExplicitDeny] <p>Information that explicitly denies the authorization. </p>
-- @return Denied structure as a key-value pair table
function M.Denied(args)
	assert(args, "You must provide an argument table when creating Denied")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["implicitDeny"] = args["implicitDeny"],
		["explicitDeny"] = args["explicitDeny"],
	}
	asserts.AssertDenied(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetTopicRuleRequest = { ["ruleName"] = true, nil }

function asserts.AssertGetTopicRuleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetTopicRuleRequest to be of type 'table'")
	assert(struct["ruleName"], "Expected key ruleName to exist in table")
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetTopicRuleRequest[k], "GetTopicRuleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetTopicRuleRequest
-- <p>The input for the GetTopicRule operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ruleName [RuleName] <p>The name of the rule.</p>
-- Required key: ruleName
-- @return GetTopicRuleRequest structure as a key-value pair table
function M.GetTopicRuleRequest(args)
	assert(args, "You must provide an argument table when creating GetTopicRuleRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{ruleName}"] = args["ruleName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["ruleName"] = args["ruleName"],
	}
	asserts.AssertGetTopicRuleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateThingGroupResponse = { ["version"] = true, nil }

function asserts.AssertUpdateThingGroupResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateThingGroupResponse to be of type 'table'")
	if struct["version"] then asserts.AssertVersion(struct["version"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateThingGroupResponse[k], "UpdateThingGroupResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateThingGroupResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * version [Version] <p>The version of the updated thing group.</p>
-- @return UpdateThingGroupResponse structure as a key-value pair table
function M.UpdateThingGroupResponse(args)
	assert(args, "You must provide an argument table when creating UpdateThingGroupResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["version"] = args["version"],
	}
	asserts.AssertUpdateThingGroupResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TransferData = { ["transferMessage"] = true, ["rejectDate"] = true, ["acceptDate"] = true, ["transferDate"] = true, ["rejectReason"] = true, nil }

function asserts.AssertTransferData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TransferData to be of type 'table'")
	if struct["transferMessage"] then asserts.AssertMessage(struct["transferMessage"]) end
	if struct["rejectDate"] then asserts.AssertDateType(struct["rejectDate"]) end
	if struct["acceptDate"] then asserts.AssertDateType(struct["acceptDate"]) end
	if struct["transferDate"] then asserts.AssertDateType(struct["transferDate"]) end
	if struct["rejectReason"] then asserts.AssertMessage(struct["rejectReason"]) end
	for k,_ in pairs(struct) do
		assert(keys.TransferData[k], "TransferData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TransferData
-- <p>Data used to transfer a certificate to an AWS account.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * transferMessage [Message] <p>The transfer message.</p>
-- * rejectDate [DateType] <p>The date the transfer was rejected.</p>
-- * acceptDate [DateType] <p>The date the transfer was accepted.</p>
-- * transferDate [DateType] <p>The date the transfer took place.</p>
-- * rejectReason [Message] <p>The reason why the transfer was rejected.</p>
-- @return TransferData structure as a key-value pair table
function M.TransferData(args)
	assert(args, "You must provide an argument table when creating TransferData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["transferMessage"] = args["transferMessage"],
		["rejectDate"] = args["rejectDate"],
		["acceptDate"] = args["acceptDate"],
		["transferDate"] = args["transferDate"],
		["rejectReason"] = args["rejectReason"],
	}
	asserts.AssertTransferData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StreamInfo = { ["files"] = true, ["description"] = true, ["roleArn"] = true, ["lastUpdatedAt"] = true, ["streamArn"] = true, ["streamId"] = true, ["streamVersion"] = true, ["createdAt"] = true, nil }

function asserts.AssertStreamInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StreamInfo to be of type 'table'")
	if struct["files"] then asserts.AssertStreamFiles(struct["files"]) end
	if struct["description"] then asserts.AssertStreamDescription(struct["description"]) end
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["lastUpdatedAt"] then asserts.AssertDateType(struct["lastUpdatedAt"]) end
	if struct["streamArn"] then asserts.AssertStreamArn(struct["streamArn"]) end
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	if struct["streamVersion"] then asserts.AssertStreamVersion(struct["streamVersion"]) end
	if struct["createdAt"] then asserts.AssertDateType(struct["createdAt"]) end
	for k,_ in pairs(struct) do
		assert(keys.StreamInfo[k], "StreamInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StreamInfo
-- <p>Information about a stream.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * files [StreamFiles] <p>The files to stream.</p>
-- * description [StreamDescription] <p>The description of the stream.</p>
-- * roleArn [RoleArn] <p>An IAM role AWS IoT assumes to access your S3 files.</p>
-- * lastUpdatedAt [DateType] <p>The date when the stream was last updated.</p>
-- * streamArn [StreamArn] <p>The stream ARN.</p>
-- * streamId [StreamId] <p>The stream ID.</p>
-- * streamVersion [StreamVersion] <p>The stream version.</p>
-- * createdAt [DateType] <p>The date when the stream was created.</p>
-- @return StreamInfo structure as a key-value pair table
function M.StreamInfo(args)
	assert(args, "You must provide an argument table when creating StreamInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["files"] = args["files"],
		["description"] = args["description"],
		["roleArn"] = args["roleArn"],
		["lastUpdatedAt"] = args["lastUpdatedAt"],
		["streamArn"] = args["streamArn"],
		["streamId"] = args["streamId"],
		["streamVersion"] = args["streamVersion"],
		["createdAt"] = args["createdAt"],
	}
	asserts.AssertStreamInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteThingRequest = { ["expectedVersion"] = true, ["thingName"] = true, nil }

function asserts.AssertDeleteThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteThingRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["expectedVersion"] then asserts.AssertOptionalVersion(struct["expectedVersion"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteThingRequest[k], "DeleteThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteThingRequest
-- <p>The input for the DeleteThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * expectedVersion [OptionalVersion] <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
-- * thingName [ThingName] <p>The name of the thing to delete.</p>
-- Required key: thingName
-- @return DeleteThingRequest structure as a key-value pair table
function M.DeleteThingRequest(args)
	assert(args, "You must provide an argument table when creating DeleteThingRequest")
    local query_args = { 
        ["expectedVersion"] = args["expectedVersion"],
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["expectedVersion"] = args["expectedVersion"],
		["thingName"] = args["thingName"],
	}
	asserts.AssertDeleteThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SetDefaultPolicyVersionRequest = { ["policyName"] = true, ["policyVersionId"] = true, nil }

function asserts.AssertSetDefaultPolicyVersionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SetDefaultPolicyVersionRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["policyVersionId"], "Expected key policyVersionId to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyVersionId"] then asserts.AssertPolicyVersionId(struct["policyVersionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SetDefaultPolicyVersionRequest[k], "SetDefaultPolicyVersionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SetDefaultPolicyVersionRequest
-- <p>The input for the SetDefaultPolicyVersion operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * policyVersionId [PolicyVersionId] <p>The policy version ID.</p>
-- Required key: policyName
-- Required key: policyVersionId
-- @return SetDefaultPolicyVersionRequest structure as a key-value pair table
function M.SetDefaultPolicyVersionRequest(args)
	assert(args, "You must provide an argument table when creating SetDefaultPolicyVersionRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
        ["{policyVersionId}"] = args["policyVersionId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyVersionId"] = args["policyVersionId"],
	}
	asserts.AssertSetDefaultPolicyVersionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TestInvokeAuthorizerRequest = { ["tokenSignature"] = true, ["token"] = true, ["authorizerName"] = true, nil }

function asserts.AssertTestInvokeAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TestInvokeAuthorizerRequest to be of type 'table'")
	assert(struct["authorizerName"], "Expected key authorizerName to exist in table")
	assert(struct["token"], "Expected key token to exist in table")
	assert(struct["tokenSignature"], "Expected key tokenSignature to exist in table")
	if struct["tokenSignature"] then asserts.AssertTokenSignature(struct["tokenSignature"]) end
	if struct["token"] then asserts.AssertToken(struct["token"]) end
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	for k,_ in pairs(struct) do
		assert(keys.TestInvokeAuthorizerRequest[k], "TestInvokeAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TestInvokeAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * tokenSignature [TokenSignature] <p>The signature made with the token and your custom authentication service's private key.</p>
-- * token [Token] <p>The token returned by your custom authentication service.</p>
-- * authorizerName [AuthorizerName] <p>The custom authorizer name.</p>
-- Required key: authorizerName
-- Required key: token
-- Required key: tokenSignature
-- @return TestInvokeAuthorizerRequest structure as a key-value pair table
function M.TestInvokeAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating TestInvokeAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{authorizerName}"] = args["authorizerName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["tokenSignature"] = args["tokenSignature"],
		["token"] = args["token"],
		["authorizerName"] = args["authorizerName"],
	}
	asserts.AssertTestInvokeAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateThingGroupRequest = { ["thingGroupName"] = true, ["expectedVersion"] = true, ["thingGroupProperties"] = true, nil }

function asserts.AssertUpdateThingGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateThingGroupRequest to be of type 'table'")
	assert(struct["thingGroupName"], "Expected key thingGroupName to exist in table")
	assert(struct["thingGroupProperties"], "Expected key thingGroupProperties to exist in table")
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["expectedVersion"] then asserts.AssertOptionalVersion(struct["expectedVersion"]) end
	if struct["thingGroupProperties"] then asserts.AssertThingGroupProperties(struct["thingGroupProperties"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateThingGroupRequest[k], "UpdateThingGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateThingGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupName [ThingGroupName] <p>The thing group to update.</p>
-- * expectedVersion [OptionalVersion] <p>The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.</p>
-- * thingGroupProperties [ThingGroupProperties] <p>The thing group properties.</p>
-- Required key: thingGroupName
-- Required key: thingGroupProperties
-- @return UpdateThingGroupRequest structure as a key-value pair table
function M.UpdateThingGroupRequest(args)
	assert(args, "You must provide an argument table when creating UpdateThingGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingGroupName}"] = args["thingGroupName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupName"] = args["thingGroupName"],
		["expectedVersion"] = args["expectedVersion"],
		["thingGroupProperties"] = args["thingGroupProperties"],
	}
	asserts.AssertUpdateThingGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingRegistrationTasksRequest = { ["status"] = true, ["nextToken"] = true, ["maxResults"] = true, nil }

function asserts.AssertListThingRegistrationTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingRegistrationTasksRequest to be of type 'table'")
	if struct["status"] then asserts.AssertStatus(struct["status"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingRegistrationTasksRequest[k], "ListThingRegistrationTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingRegistrationTasksRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [Status] <p>The status of the bulk thing provisioning task.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return at one time.</p>
-- @return ListThingRegistrationTasksRequest structure as a key-value pair table
function M.ListThingRegistrationTasksRequest(args)
	assert(args, "You must provide an argument table when creating ListThingRegistrationTasksRequest")
    local query_args = { 
        ["status"] = args["status"],
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["nextToken"] = args["nextToken"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListThingRegistrationTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreatePolicyResponse = { ["policyName"] = true, ["policyDocument"] = true, ["policyVersionId"] = true, ["policyArn"] = true, nil }

function asserts.AssertCreatePolicyResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePolicyResponse to be of type 'table'")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["policyDocument"] then asserts.AssertPolicyDocument(struct["policyDocument"]) end
	if struct["policyVersionId"] then asserts.AssertPolicyVersionId(struct["policyVersionId"]) end
	if struct["policyArn"] then asserts.AssertPolicyArn(struct["policyArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePolicyResponse[k], "CreatePolicyResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePolicyResponse
-- <p>The output from the CreatePolicy operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * policyDocument [PolicyDocument] <p>The JSON document that describes the policy.</p>
-- * policyVersionId [PolicyVersionId] <p>The policy version ID.</p>
-- * policyArn [PolicyArn] <p>The policy ARN.</p>
-- @return CreatePolicyResponse structure as a key-value pair table
function M.CreatePolicyResponse(args)
	assert(args, "You must provide an argument table when creating CreatePolicyResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["policyDocument"] = args["policyDocument"],
		["policyVersionId"] = args["policyVersionId"],
		["policyArn"] = args["policyArn"],
	}
	asserts.AssertCreatePolicyResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateKeysAndCertificateRequest = { ["setAsActive"] = true, nil }

function asserts.AssertCreateKeysAndCertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateKeysAndCertificateRequest to be of type 'table'")
	if struct["setAsActive"] then asserts.AssertSetAsActive(struct["setAsActive"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateKeysAndCertificateRequest[k], "CreateKeysAndCertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateKeysAndCertificateRequest
-- <p>The input for the CreateKeysAndCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * setAsActive [SetAsActive] <p>Specifies whether the certificate is active.</p>
-- @return CreateKeysAndCertificateRequest structure as a key-value pair table
function M.CreateKeysAndCertificateRequest(args)
	assert(args, "You must provide an argument table when creating CreateKeysAndCertificateRequest")
    local query_args = { 
        ["setAsActive"] = args["setAsActive"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["setAsActive"] = args["setAsActive"],
	}
	asserts.AssertCreateKeysAndCertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuditCheckConfiguration = { ["enabled"] = true, nil }

function asserts.AssertAuditCheckConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuditCheckConfiguration to be of type 'table'")
	if struct["enabled"] then asserts.AssertEnabled(struct["enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuditCheckConfiguration[k], "AuditCheckConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuditCheckConfiguration
-- <p>Which audit checks are enabled and disabled for this account.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * enabled [Enabled] <p>True if this audit check is enabled for this account.</p>
-- @return AuditCheckConfiguration structure as a key-value pair table
function M.AuditCheckConfiguration(args)
	assert(args, "You must provide an argument table when creating AuditCheckConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["enabled"] = args["enabled"],
	}
	asserts.AssertAuditCheckConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateScheduledAuditResponse = { ["scheduledAuditArn"] = true, nil }

function asserts.AssertUpdateScheduledAuditResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateScheduledAuditResponse to be of type 'table'")
	if struct["scheduledAuditArn"] then asserts.AssertScheduledAuditArn(struct["scheduledAuditArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateScheduledAuditResponse[k], "UpdateScheduledAuditResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateScheduledAuditResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * scheduledAuditArn [ScheduledAuditArn] <p>The ARN of the scheduled audit.</p>
-- @return UpdateScheduledAuditResponse structure as a key-value pair table
function M.UpdateScheduledAuditResponse(args)
	assert(args, "You must provide an argument table when creating UpdateScheduledAuditResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["scheduledAuditArn"] = args["scheduledAuditArn"],
	}
	asserts.AssertUpdateScheduledAuditResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachPrincipalPolicyRequest = { ["policyName"] = true, ["principal"] = true, nil }

function asserts.AssertAttachPrincipalPolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachPrincipalPolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["principal"], "Expected key principal to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachPrincipalPolicyRequest[k], "AttachPrincipalPolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachPrincipalPolicyRequest
-- <p>The input for the AttachPrincipalPolicy operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * principal [Principal] <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
-- Required key: policyName
-- Required key: principal
-- @return AttachPrincipalPolicyRequest structure as a key-value pair table
function M.AttachPrincipalPolicyRequest(args)
	assert(args, "You must provide an argument table when creating AttachPrincipalPolicyRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
        ["x-amzn-iot-principal"] = args["principal"],
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["principal"] = args["principal"],
	}
	asserts.AssertAttachPrincipalPolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Configuration = { ["Enabled"] = true, nil }

function asserts.AssertConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Configuration to be of type 'table'")
	if struct["Enabled"] then asserts.AssertEnabled(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.Configuration[k], "Configuration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Configuration
-- <p>Configuration.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Enabled] <p>True to enable the configuration.</p>
-- @return Configuration structure as a key-value pair table
function M.Configuration(args)
	assert(args, "You must provide an argument table when creating Configuration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TransferCertificateRequest = { ["transferMessage"] = true, ["certificateId"] = true, ["targetAwsAccount"] = true, nil }

function asserts.AssertTransferCertificateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TransferCertificateRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	assert(struct["targetAwsAccount"], "Expected key targetAwsAccount to exist in table")
	if struct["transferMessage"] then asserts.AssertMessage(struct["transferMessage"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["targetAwsAccount"] then asserts.AssertAwsAccountId(struct["targetAwsAccount"]) end
	for k,_ in pairs(struct) do
		assert(keys.TransferCertificateRequest[k], "TransferCertificateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TransferCertificateRequest
-- <p>The input for the TransferCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * transferMessage [Message] <p>The transfer message.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- * targetAwsAccount [AwsAccountId] <p>The AWS account.</p>
-- Required key: certificateId
-- Required key: targetAwsAccount
-- @return TransferCertificateRequest structure as a key-value pair table
function M.TransferCertificateRequest(args)
	assert(args, "You must provide an argument table when creating TransferCertificateRequest")
    local query_args = { 
        ["targetAwsAccount"] = args["targetAwsAccount"],
    }
    local uri_args = { 
        ["{certificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["transferMessage"] = args["transferMessage"],
		["certificateId"] = args["certificateId"],
		["targetAwsAccount"] = args["targetAwsAccount"],
	}
	asserts.AssertTransferCertificateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListTopicRulesRequest = { ["topic"] = true, ["nextToken"] = true, ["ruleDisabled"] = true, ["maxResults"] = true, nil }

function asserts.AssertListTopicRulesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListTopicRulesRequest to be of type 'table'")
	if struct["topic"] then asserts.AssertTopic(struct["topic"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["ruleDisabled"] then asserts.AssertIsDisabled(struct["ruleDisabled"]) end
	if struct["maxResults"] then asserts.AssertGEMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListTopicRulesRequest[k], "ListTopicRulesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListTopicRulesRequest
-- <p>The input for the ListTopicRules operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * topic [Topic] <p>The topic.</p>
-- * nextToken [NextToken] <p>A token used to retrieve the next value.</p>
-- * ruleDisabled [IsDisabled] <p>Specifies whether the rule is disabled.</p>
-- * maxResults [GEMaxResults] <p>The maximum number of results to return.</p>
-- @return ListTopicRulesRequest structure as a key-value pair table
function M.ListTopicRulesRequest(args)
	assert(args, "You must provide an argument table when creating ListTopicRulesRequest")
    local query_args = { 
        ["topic"] = args["topic"],
        ["nextToken"] = args["nextToken"],
        ["ruleDisabled"] = args["ruleDisabled"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["topic"] = args["topic"],
		["nextToken"] = args["nextToken"],
		["ruleDisabled"] = args["ruleDisabled"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListTopicRulesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobProcessDetails = { ["numberOfQueuedThings"] = true, ["numberOfInProgressThings"] = true, ["processingTargets"] = true, ["numberOfSucceededThings"] = true, ["numberOfTimedOutThings"] = true, ["numberOfCanceledThings"] = true, ["numberOfFailedThings"] = true, ["numberOfRemovedThings"] = true, ["numberOfRejectedThings"] = true, nil }

function asserts.AssertJobProcessDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobProcessDetails to be of type 'table'")
	if struct["numberOfQueuedThings"] then asserts.AssertQueuedThings(struct["numberOfQueuedThings"]) end
	if struct["numberOfInProgressThings"] then asserts.AssertInProgressThings(struct["numberOfInProgressThings"]) end
	if struct["processingTargets"] then asserts.AssertProcessingTargetNameList(struct["processingTargets"]) end
	if struct["numberOfSucceededThings"] then asserts.AssertSucceededThings(struct["numberOfSucceededThings"]) end
	if struct["numberOfTimedOutThings"] then asserts.AssertTimedOutThings(struct["numberOfTimedOutThings"]) end
	if struct["numberOfCanceledThings"] then asserts.AssertCanceledThings(struct["numberOfCanceledThings"]) end
	if struct["numberOfFailedThings"] then asserts.AssertFailedThings(struct["numberOfFailedThings"]) end
	if struct["numberOfRemovedThings"] then asserts.AssertRemovedThings(struct["numberOfRemovedThings"]) end
	if struct["numberOfRejectedThings"] then asserts.AssertRejectedThings(struct["numberOfRejectedThings"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobProcessDetails[k], "JobProcessDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobProcessDetails
-- <p>The job process details.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * numberOfQueuedThings [QueuedThings] <p>The number of things that are awaiting execution of the job.</p>
-- * numberOfInProgressThings [InProgressThings] <p>The number of things currently executing the job.</p>
-- * processingTargets [ProcessingTargetNameList] <p>The target devices to which the job execution is being rolled out. This value will be null after the job execution has finished rolling out to all the target devices.</p>
-- * numberOfSucceededThings [SucceededThings] <p>The number of things which successfully completed the job.</p>
-- * numberOfTimedOutThings [TimedOutThings] <p>The number of things whose job execution status is <code>TIMED_OUT</code>.</p>
-- * numberOfCanceledThings [CanceledThings] <p>The number of things that cancelled the job.</p>
-- * numberOfFailedThings [FailedThings] <p>The number of things that failed executing the job.</p>
-- * numberOfRemovedThings [RemovedThings] <p>The number of things that are no longer scheduled to execute the job because they have been deleted or have been removed from the group that was a target of the job.</p>
-- * numberOfRejectedThings [RejectedThings] <p>The number of things that rejected the job.</p>
-- @return JobProcessDetails structure as a key-value pair table
function M.JobProcessDetails(args)
	assert(args, "You must provide an argument table when creating JobProcessDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["numberOfQueuedThings"] = args["numberOfQueuedThings"],
		["numberOfInProgressThings"] = args["numberOfInProgressThings"],
		["processingTargets"] = args["processingTargets"],
		["numberOfSucceededThings"] = args["numberOfSucceededThings"],
		["numberOfTimedOutThings"] = args["numberOfTimedOutThings"],
		["numberOfCanceledThings"] = args["numberOfCanceledThings"],
		["numberOfFailedThings"] = args["numberOfFailedThings"],
		["numberOfRemovedThings"] = args["numberOfRemovedThings"],
		["numberOfRejectedThings"] = args["numberOfRejectedThings"],
	}
	asserts.AssertJobProcessDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResourceIdentifier = { ["policyVersionIdentifier"] = true, ["account"] = true, ["clientId"] = true, ["deviceCertificateId"] = true, ["cognitoIdentityPoolId"] = true, ["caCertificateId"] = true, nil }

function asserts.AssertResourceIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResourceIdentifier to be of type 'table'")
	if struct["policyVersionIdentifier"] then asserts.AssertPolicyVersionIdentifier(struct["policyVersionIdentifier"]) end
	if struct["account"] then asserts.AssertAwsAccountId(struct["account"]) end
	if struct["clientId"] then asserts.AssertClientId(struct["clientId"]) end
	if struct["deviceCertificateId"] then asserts.AssertCertificateId(struct["deviceCertificateId"]) end
	if struct["cognitoIdentityPoolId"] then asserts.AssertCognitoIdentityPoolId(struct["cognitoIdentityPoolId"]) end
	if struct["caCertificateId"] then asserts.AssertCertificateId(struct["caCertificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResourceIdentifier[k], "ResourceIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResourceIdentifier
-- <p>Information identifying the non-compliant resource.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyVersionIdentifier [PolicyVersionIdentifier] <p>The version of the policy associated with the resource.</p>
-- * account [AwsAccountId] <p>The account with which the resource is associated.</p>
-- * clientId [ClientId] <p>The client ID.</p>
-- * deviceCertificateId [CertificateId] <p>The ID of the certificate attached to the resource.</p>
-- * cognitoIdentityPoolId [CognitoIdentityPoolId] <p>The ID of the Cognito Identity Pool.</p>
-- * caCertificateId [CertificateId] <p>The ID of the CA certificate used to authorize the certificate.</p>
-- @return ResourceIdentifier structure as a key-value pair table
function M.ResourceIdentifier(args)
	assert(args, "You must provide an argument table when creating ResourceIdentifier")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyVersionIdentifier"] = args["policyVersionIdentifier"],
		["account"] = args["account"],
		["clientId"] = args["clientId"],
		["deviceCertificateId"] = args["deviceCertificateId"],
		["cognitoIdentityPoolId"] = args["cognitoIdentityPoolId"],
		["caCertificateId"] = args["caCertificateId"],
	}
	asserts.AssertResourceIdentifier(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Behavior = { ["metric"] = true, ["name"] = true, ["criteria"] = true, nil }

function asserts.AssertBehavior(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Behavior to be of type 'table'")
	assert(struct["name"], "Expected key name to exist in table")
	if struct["metric"] then asserts.AssertBehaviorMetric(struct["metric"]) end
	if struct["name"] then asserts.AssertBehaviorName(struct["name"]) end
	if struct["criteria"] then asserts.AssertBehaviorCriteria(struct["criteria"]) end
	for k,_ in pairs(struct) do
		assert(keys.Behavior[k], "Behavior contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Behavior
-- <p>A Device Defender security profile behavior.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * metric [BehaviorMetric] <p>What is measured by the behavior.</p>
-- * name [BehaviorName] <p>The name you have given to the behavior.</p>
-- * criteria [BehaviorCriteria] <p>The criteria that determine if a device is behaving normally in regard to the <code>metric</code>.</p>
-- Required key: name
-- @return Behavior structure as a key-value pair table
function M.Behavior(args)
	assert(args, "You must provide an argument table when creating Behavior")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["metric"] = args["metric"],
		["name"] = args["name"],
		["criteria"] = args["criteria"],
	}
	asserts.AssertBehavior(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SetV2LoggingLevelRequest = { ["logTarget"] = true, ["logLevel"] = true, nil }

function asserts.AssertSetV2LoggingLevelRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SetV2LoggingLevelRequest to be of type 'table'")
	assert(struct["logTarget"], "Expected key logTarget to exist in table")
	assert(struct["logLevel"], "Expected key logLevel to exist in table")
	if struct["logTarget"] then asserts.AssertLogTarget(struct["logTarget"]) end
	if struct["logLevel"] then asserts.AssertLogLevel(struct["logLevel"]) end
	for k,_ in pairs(struct) do
		assert(keys.SetV2LoggingLevelRequest[k], "SetV2LoggingLevelRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SetV2LoggingLevelRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * logTarget [LogTarget] <p>The log target.</p>
-- * logLevel [LogLevel] <p>The log level.</p>
-- Required key: logTarget
-- Required key: logLevel
-- @return SetV2LoggingLevelRequest structure as a key-value pair table
function M.SetV2LoggingLevelRequest(args)
	assert(args, "You must provide an argument table when creating SetV2LoggingLevelRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["logTarget"] = args["logTarget"],
		["logLevel"] = args["logLevel"],
	}
	asserts.AssertSetV2LoggingLevelRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingPrincipalsRequest = { ["thingName"] = true, nil }

function asserts.AssertListThingPrincipalsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingPrincipalsRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingPrincipalsRequest[k], "ListThingPrincipalsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingPrincipalsRequest
-- <p>The input for the ListThingPrincipal operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingName [ThingName] <p>The name of the thing.</p>
-- Required key: thingName
-- @return ListThingPrincipalsRequest structure as a key-value pair table
function M.ListThingPrincipalsRequest(args)
	assert(args, "You must provide an argument table when creating ListThingPrincipalsRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingName"] = args["thingName"],
	}
	asserts.AssertListThingPrincipalsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAccountAuditConfigurationResponse = { ["roleArn"] = true, ["auditNotificationTargetConfigurations"] = true, ["auditCheckConfigurations"] = true, nil }

function asserts.AssertDescribeAccountAuditConfigurationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAuditConfigurationResponse to be of type 'table'")
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["auditNotificationTargetConfigurations"] then asserts.AssertAuditNotificationTargetConfigurations(struct["auditNotificationTargetConfigurations"]) end
	if struct["auditCheckConfigurations"] then asserts.AssertAuditCheckConfigurations(struct["auditCheckConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAuditConfigurationResponse[k], "DescribeAccountAuditConfigurationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAuditConfigurationResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [RoleArn] <p>The ARN of the role that grants permission to AWS IoT to access information about your devices, policies, certificates and other items as necessary when performing an audit.</p> <p>On the first call to <code>UpdateAccountAuditConfiguration</code> this parameter is required.</p>
-- * auditNotificationTargetConfigurations [AuditNotificationTargetConfigurations] <p>Information about the targets to which audit notifications are sent for this account.</p>
-- * auditCheckConfigurations [AuditCheckConfigurations] <p>Which audit checks are enabled and disabled for this account.</p>
-- @return DescribeAccountAuditConfigurationResponse structure as a key-value pair table
function M.DescribeAccountAuditConfigurationResponse(args)
	assert(args, "You must provide an argument table when creating DescribeAccountAuditConfigurationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["auditNotificationTargetConfigurations"] = args["auditNotificationTargetConfigurations"],
		["auditCheckConfigurations"] = args["auditCheckConfigurations"],
	}
	asserts.AssertDescribeAccountAuditConfigurationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DynamoDBv2Action = { ["putItem"] = true, ["roleArn"] = true, nil }

function asserts.AssertDynamoDBv2Action(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DynamoDBv2Action to be of type 'table'")
	if struct["putItem"] then asserts.AssertPutItemInput(struct["putItem"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.DynamoDBv2Action[k], "DynamoDBv2Action contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DynamoDBv2Action
-- <p>Describes an action to write to a DynamoDB table.</p> <p>This DynamoDB action writes each attribute in the message payload into it's own column in the DynamoDB table.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * putItem [PutItemInput] <p>Specifies the DynamoDB table to which the message data will be written. For example:</p> <p> <code>{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }</code> </p> <p>Each attribute in the message payload will be written to a separate column in the DynamoDB database.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
-- @return DynamoDBv2Action structure as a key-value pair table
function M.DynamoDBv2Action(args)
	assert(args, "You must provide an argument table when creating DynamoDBv2Action")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["putItem"] = args["putItem"],
		["roleArn"] = args["roleArn"],
	}
	asserts.AssertDynamoDBv2Action(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachThingPrincipalRequest = { ["thingName"] = true, ["principal"] = true, nil }

function asserts.AssertAttachThingPrincipalRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachThingPrincipalRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	assert(struct["principal"], "Expected key principal to exist in table")
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachThingPrincipalRequest[k], "AttachThingPrincipalRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachThingPrincipalRequest
-- <p>The input for the AttachThingPrincipal operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingName [ThingName] <p>The name of the thing.</p>
-- * principal [Principal] <p>The principal, such as a certificate or other credential.</p>
-- Required key: thingName
-- Required key: principal
-- @return AttachThingPrincipalRequest structure as a key-value pair table
function M.AttachThingPrincipalRequest(args)
	assert(args, "You must provide an argument table when creating AttachThingPrincipalRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
        ["x-amzn-principal"] = args["principal"],
    }
	local all_args = { 
		["thingName"] = args["thingName"],
		["principal"] = args["principal"],
	}
	asserts.AssertAttachThingPrincipalRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CACertificateDescription = { ["certificateArn"] = true, ["status"] = true, ["autoRegistrationStatus"] = true, ["certificateId"] = true, ["generationId"] = true, ["lastModifiedDate"] = true, ["validity"] = true, ["certificatePem"] = true, ["ownedBy"] = true, ["customerVersion"] = true, ["creationDate"] = true, nil }

function asserts.AssertCACertificateDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CACertificateDescription to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["status"] then asserts.AssertCACertificateStatus(struct["status"]) end
	if struct["autoRegistrationStatus"] then asserts.AssertAutoRegistrationStatus(struct["autoRegistrationStatus"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["generationId"] then asserts.AssertGenerationId(struct["generationId"]) end
	if struct["lastModifiedDate"] then asserts.AssertDateType(struct["lastModifiedDate"]) end
	if struct["validity"] then asserts.AssertCertificateValidity(struct["validity"]) end
	if struct["certificatePem"] then asserts.AssertCertificatePem(struct["certificatePem"]) end
	if struct["ownedBy"] then asserts.AssertAwsAccountId(struct["ownedBy"]) end
	if struct["customerVersion"] then asserts.AssertCustomerVersion(struct["customerVersion"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.CACertificateDescription[k], "CACertificateDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CACertificateDescription
-- <p>Describes a CA certificate.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The CA certificate ARN.</p>
-- * status [CACertificateStatus] <p>The status of a CA certificate.</p>
-- * autoRegistrationStatus [AutoRegistrationStatus] <p>Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"</p>
-- * certificateId [CertificateId] <p>The CA certificate ID.</p>
-- * generationId [GenerationId] <p>The generation ID of the CA certificate.</p>
-- * lastModifiedDate [DateType] <p>The date the CA certificate was last modified.</p>
-- * validity [CertificateValidity] <p>When the CA certificate is valid.</p>
-- * certificatePem [CertificatePem] <p>The CA certificate data, in PEM format.</p>
-- * ownedBy [AwsAccountId] <p>The owner of the CA certificate.</p>
-- * customerVersion [CustomerVersion] <p>The customer version of the CA certificate.</p>
-- * creationDate [DateType] <p>The date the CA certificate was created.</p>
-- @return CACertificateDescription structure as a key-value pair table
function M.CACertificateDescription(args)
	assert(args, "You must provide an argument table when creating CACertificateDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["status"] = args["status"],
		["autoRegistrationStatus"] = args["autoRegistrationStatus"],
		["certificateId"] = args["certificateId"],
		["generationId"] = args["generationId"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["validity"] = args["validity"],
		["certificatePem"] = args["certificatePem"],
		["ownedBy"] = args["ownedBy"],
		["customerVersion"] = args["customerVersion"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertCACertificateDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListThingGroupsForThingRequest = { ["nextToken"] = true, ["thingName"] = true, ["maxResults"] = true, nil }

function asserts.AssertListThingGroupsForThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListThingGroupsForThingRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["maxResults"] then asserts.AssertRegistryMaxResults(struct["maxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListThingGroupsForThingRequest[k], "ListThingGroupsForThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListThingGroupsForThingRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- * thingName [ThingName] <p>The thing name.</p>
-- * maxResults [RegistryMaxResults] <p>The maximum number of results to return at one time.</p>
-- Required key: thingName
-- @return ListThingGroupsForThingRequest structure as a key-value pair table
function M.ListThingGroupsForThingRequest(args)
	assert(args, "You must provide an argument table when creating ListThingGroupsForThingRequest")
    local query_args = { 
        ["nextToken"] = args["nextToken"],
        ["maxResults"] = args["maxResults"],
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["thingName"] = args["thingName"],
		["maxResults"] = args["maxResults"],
	}
	asserts.AssertListThingGroupsForThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListStreamsResponse = { ["nextToken"] = true, ["streams"] = true, nil }

function asserts.AssertListStreamsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListStreamsResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["streams"] then asserts.AssertStreamsSummary(struct["streams"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListStreamsResponse[k], "ListStreamsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListStreamsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token used to get the next set of results.</p>
-- * streams [StreamsSummary] <p>A list of streams.</p>
-- @return ListStreamsResponse structure as a key-value pair table
function M.ListStreamsResponse(args)
	assert(args, "You must provide an argument table when creating ListStreamsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["streams"] = args["streams"],
	}
	asserts.AssertListStreamsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CustomCodeSigning = { ["hashAlgorithm"] = true, ["signatureAlgorithm"] = true, ["certificateChain"] = true, ["signature"] = true, nil }

function asserts.AssertCustomCodeSigning(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CustomCodeSigning to be of type 'table'")
	if struct["hashAlgorithm"] then asserts.AssertHashAlgorithm(struct["hashAlgorithm"]) end
	if struct["signatureAlgorithm"] then asserts.AssertSignatureAlgorithm(struct["signatureAlgorithm"]) end
	if struct["certificateChain"] then asserts.AssertCodeSigningCertificateChain(struct["certificateChain"]) end
	if struct["signature"] then asserts.AssertCodeSigningSignature(struct["signature"]) end
	for k,_ in pairs(struct) do
		assert(keys.CustomCodeSigning[k], "CustomCodeSigning contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CustomCodeSigning
-- <p>Describes a custom method used to code sign a file.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * hashAlgorithm [HashAlgorithm] <p>The hash algorithm used to code sign the file.</p>
-- * signatureAlgorithm [SignatureAlgorithm] <p>The signature algorithm used to code sign the file.</p>
-- * certificateChain [CodeSigningCertificateChain] <p>The certificate chain.</p>
-- * signature [CodeSigningSignature] <p>The signature for the file.</p>
-- @return CustomCodeSigning structure as a key-value pair table
function M.CustomCodeSigning(args)
	assert(args, "You must provide an argument table when creating CustomCodeSigning")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["hashAlgorithm"] = args["hashAlgorithm"],
		["signatureAlgorithm"] = args["signatureAlgorithm"],
		["certificateChain"] = args["certificateChain"],
		["signature"] = args["signature"],
	}
	asserts.AssertCustomCodeSigning(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AddThingToThingGroupRequest = { ["thingArn"] = true, ["thingGroupName"] = true, ["thingGroupArn"] = true, ["thingName"] = true, nil }

function asserts.AssertAddThingToThingGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AddThingToThingGroupRequest to be of type 'table'")
	if struct["thingArn"] then asserts.AssertThingArn(struct["thingArn"]) end
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["thingGroupArn"] then asserts.AssertThingGroupArn(struct["thingGroupArn"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.AddThingToThingGroupRequest[k], "AddThingToThingGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AddThingToThingGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingArn [ThingArn] <p>The ARN of the thing to add to a group.</p>
-- * thingGroupName [ThingGroupName] <p>The name of the group to which you are adding a thing.</p>
-- * thingGroupArn [ThingGroupArn] <p>The ARN of the group to which you are adding a thing.</p>
-- * thingName [ThingName] <p>The name of the thing to add to a group.</p>
-- @return AddThingToThingGroupRequest structure as a key-value pair table
function M.AddThingToThingGroupRequest(args)
	assert(args, "You must provide an argument table when creating AddThingToThingGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingArn"] = args["thingArn"],
		["thingGroupName"] = args["thingGroupName"],
		["thingGroupArn"] = args["thingGroupArn"],
		["thingName"] = args["thingName"],
	}
	asserts.AssertAddThingToThingGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetV2LoggingOptionsResponse = { ["roleArn"] = true, ["defaultLogLevel"] = true, ["disableAllLogs"] = true, nil }

function asserts.AssertGetV2LoggingOptionsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetV2LoggingOptionsResponse to be of type 'table'")
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["defaultLogLevel"] then asserts.AssertLogLevel(struct["defaultLogLevel"]) end
	if struct["disableAllLogs"] then asserts.AssertDisableAllLogs(struct["disableAllLogs"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetV2LoggingOptionsResponse[k], "GetV2LoggingOptionsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetV2LoggingOptionsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [AwsArn] <p>The IAM role ARN AWS IoT uses to write to your CloudWatch logs.</p>
-- * defaultLogLevel [LogLevel] <p>The default log level.</p>
-- * disableAllLogs [DisableAllLogs] <p>Disables all logs.</p>
-- @return GetV2LoggingOptionsResponse structure as a key-value pair table
function M.GetV2LoggingOptionsResponse(args)
	assert(args, "You must provide an argument table when creating GetV2LoggingOptionsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["defaultLogLevel"] = args["defaultLogLevel"],
		["disableAllLogs"] = args["disableAllLogs"],
	}
	asserts.AssertGetV2LoggingOptionsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MetricValue = { ["count"] = true, ["cidrs"] = true, ["ports"] = true, nil }

function asserts.AssertMetricValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MetricValue to be of type 'table'")
	if struct["count"] then asserts.AssertUnsignedLong(struct["count"]) end
	if struct["cidrs"] then asserts.AssertCidrs(struct["cidrs"]) end
	if struct["ports"] then asserts.AssertPorts(struct["ports"]) end
	for k,_ in pairs(struct) do
		assert(keys.MetricValue[k], "MetricValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MetricValue
-- <p>The value to be compared with the <code>metric</code>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * count [UnsignedLong] <p>If the <code>comparisonOperator</code> calls for a numeric value, use this to specify that numeric value to be compared with the <code>metric</code>.</p>
-- * cidrs [Cidrs] <p>If the <code>comparisonOperator</code> calls for a set of CIDRs, use this to specify that set to be compared with the <code>metric</code>.</p>
-- * ports [Ports] <p>If the <code>comparisonOperator</code> calls for a set of ports, use this to specify that set to be compared with the <code>metric</code>.</p>
-- @return MetricValue structure as a key-value pair table
function M.MetricValue(args)
	assert(args, "You must provide an argument table when creating MetricValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["count"] = args["count"],
		["cidrs"] = args["cidrs"],
		["ports"] = args["ports"],
	}
	asserts.AssertMetricValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPolicyPrincipalsResponse = { ["nextMarker"] = true, ["principals"] = true, nil }

function asserts.AssertListPolicyPrincipalsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPolicyPrincipalsResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["principals"] then asserts.AssertPrincipals(struct["principals"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPolicyPrincipalsResponse[k], "ListPolicyPrincipalsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPolicyPrincipalsResponse
-- <p>The output from the ListPolicyPrincipals operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>The marker for the next set of results, or null if there are no additional results.</p>
-- * principals [Principals] <p>The descriptions of the principals.</p>
-- @return ListPolicyPrincipalsResponse structure as a key-value pair table
function M.ListPolicyPrincipalsResponse(args)
	assert(args, "You must provide an argument table when creating ListPolicyPrincipalsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["principals"] = args["principals"],
	}
	asserts.AssertListPolicyPrincipalsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FirehoseAction = { ["roleArn"] = true, ["deliveryStreamName"] = true, ["separator"] = true, nil }

function asserts.AssertFirehoseAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FirehoseAction to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["deliveryStreamName"], "Expected key deliveryStreamName to exist in table")
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["deliveryStreamName"] then asserts.AssertDeliveryStreamName(struct["deliveryStreamName"]) end
	if struct["separator"] then asserts.AssertFirehoseSeparator(struct["separator"]) end
	for k,_ in pairs(struct) do
		assert(keys.FirehoseAction[k], "FirehoseAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FirehoseAction
-- <p>Describes an action that writes data to an Amazon Kinesis Firehose stream.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [AwsArn] <p>The IAM role that grants access to the Amazon Kinesis Firehose stream.</p>
-- * deliveryStreamName [DeliveryStreamName] <p>The delivery stream name.</p>
-- * separator [FirehoseSeparator] <p>A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).</p>
-- Required key: roleArn
-- Required key: deliveryStreamName
-- @return FirehoseAction structure as a key-value pair table
function M.FirehoseAction(args)
	assert(args, "You must provide an argument table when creating FirehoseAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["deliveryStreamName"] = args["deliveryStreamName"],
		["separator"] = args["separator"],
	}
	asserts.AssertFirehoseAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAttachedPoliciesResponse = { ["nextMarker"] = true, ["policies"] = true, nil }

function asserts.AssertListAttachedPoliciesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAttachedPoliciesResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["policies"] then asserts.AssertPolicies(struct["policies"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAttachedPoliciesResponse[k], "ListAttachedPoliciesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAttachedPoliciesResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>The token to retrieve the next set of results, or ``null`` if there are no more results.</p>
-- * policies [Policies] <p>The policies.</p>
-- @return ListAttachedPoliciesResponse structure as a key-value pair table
function M.ListAttachedPoliciesResponse(args)
	assert(args, "You must provide an argument table when creating ListAttachedPoliciesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["policies"] = args["policies"],
	}
	asserts.AssertListAttachedPoliciesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingDocument = { ["thingTypeName"] = true, ["thingGroupNames"] = true, ["thingName"] = true, ["attributes"] = true, ["shadow"] = true, ["thingId"] = true, nil }

function asserts.AssertThingDocument(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingDocument to be of type 'table'")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["thingGroupNames"] then asserts.AssertThingGroupNameList(struct["thingGroupNames"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["attributes"] then asserts.AssertAttributes(struct["attributes"]) end
	if struct["shadow"] then asserts.AssertJsonDocument(struct["shadow"]) end
	if struct["thingId"] then asserts.AssertThingId(struct["thingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingDocument[k], "ThingDocument contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingDocument
-- <p>The thing search index document.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The thing type name.</p>
-- * thingGroupNames [ThingGroupNameList] <p>Thing group names.</p>
-- * thingName [ThingName] <p>The thing name.</p>
-- * attributes [Attributes] <p>The attributes.</p>
-- * shadow [JsonDocument] <p>The shadow.</p>
-- * thingId [ThingId] <p>The thing ID.</p>
-- @return ThingDocument structure as a key-value pair table
function M.ThingDocument(args)
	assert(args, "You must provide an argument table when creating ThingDocument")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["thingGroupNames"] = args["thingGroupNames"],
		["thingName"] = args["thingName"],
		["attributes"] = args["attributes"],
		["shadow"] = args["shadow"],
		["thingId"] = args["thingId"],
	}
	asserts.AssertThingDocument(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegistrationConfig = { ["roleArn"] = true, ["templateBody"] = true, nil }

function asserts.AssertRegistrationConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegistrationConfig to be of type 'table'")
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["templateBody"] then asserts.AssertTemplateBody(struct["templateBody"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegistrationConfig[k], "RegistrationConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegistrationConfig
-- <p>The registration configuration.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [RoleArn] <p>The ARN of the role.</p>
-- * templateBody [TemplateBody] <p>The template body.</p>
-- @return RegistrationConfig structure as a key-value pair table
function M.RegistrationConfig(args)
	assert(args, "You must provide an argument table when creating RegistrationConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["templateBody"] = args["templateBody"],
	}
	asserts.AssertRegistrationConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteThingTypeResponse = { nil }

function asserts.AssertDeleteThingTypeResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteThingTypeResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteThingTypeResponse[k], "DeleteThingTypeResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteThingTypeResponse
-- <p>The output for the DeleteThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteThingTypeResponse structure as a key-value pair table
function M.DeleteThingTypeResponse(args)
	assert(args, "You must provide an argument table when creating DeleteThingTypeResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteThingTypeResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TopicRule = { ["description"] = true, ["ruleName"] = true, ["actions"] = true, ["createdAt"] = true, ["sql"] = true, ["awsIotSqlVersion"] = true, ["ruleDisabled"] = true, ["errorAction"] = true, nil }

function asserts.AssertTopicRule(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TopicRule to be of type 'table'")
	if struct["description"] then asserts.AssertDescription(struct["description"]) end
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	if struct["actions"] then asserts.AssertActionList(struct["actions"]) end
	if struct["createdAt"] then asserts.AssertCreatedAtDate(struct["createdAt"]) end
	if struct["sql"] then asserts.AssertSQL(struct["sql"]) end
	if struct["awsIotSqlVersion"] then asserts.AssertAwsIotSqlVersion(struct["awsIotSqlVersion"]) end
	if struct["ruleDisabled"] then asserts.AssertIsDisabled(struct["ruleDisabled"]) end
	if struct["errorAction"] then asserts.AssertAction(struct["errorAction"]) end
	for k,_ in pairs(struct) do
		assert(keys.TopicRule[k], "TopicRule contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TopicRule
-- <p>Describes a rule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * description [Description] <p>The description of the rule.</p>
-- * ruleName [RuleName] <p>The name of the rule.</p>
-- * actions [ActionList] <p>The actions associated with the rule.</p>
-- * createdAt [CreatedAtDate] <p>The date and time the rule was created.</p>
-- * sql [SQL] <p>The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.</p>
-- * awsIotSqlVersion [AwsIotSqlVersion] <p>The version of the SQL rules engine to use when evaluating the rule.</p>
-- * ruleDisabled [IsDisabled] <p>Specifies whether the rule is disabled.</p>
-- * errorAction [Action] <p>The action to perform when an error occurs.</p>
-- @return TopicRule structure as a key-value pair table
function M.TopicRule(args)
	assert(args, "You must provide an argument table when creating TopicRule")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["description"] = args["description"],
		["ruleName"] = args["ruleName"],
		["actions"] = args["actions"],
		["createdAt"] = args["createdAt"],
		["sql"] = args["sql"],
		["awsIotSqlVersion"] = args["awsIotSqlVersion"],
		["ruleDisabled"] = args["ruleDisabled"],
		["errorAction"] = args["errorAction"],
	}
	asserts.AssertTopicRule(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateKeysAndCertificateResponse = { ["certificateArn"] = true, ["keyPair"] = true, ["certificateId"] = true, ["certificatePem"] = true, nil }

function asserts.AssertCreateKeysAndCertificateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateKeysAndCertificateResponse to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["keyPair"] then asserts.AssertKeyPair(struct["keyPair"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	if struct["certificatePem"] then asserts.AssertCertificatePem(struct["certificatePem"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateKeysAndCertificateResponse[k], "CreateKeysAndCertificateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateKeysAndCertificateResponse
-- <p>The output of the CreateKeysAndCertificate operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The ARN of the certificate.</p>
-- * keyPair [KeyPair] <p>The generated key pair.</p>
-- * certificateId [CertificateId] <p>The ID of the certificate. AWS IoT issues a default subject name for the certificate (for example, AWS IoT Certificate).</p>
-- * certificatePem [CertificatePem] <p>The certificate data, in PEM format.</p>
-- @return CreateKeysAndCertificateResponse structure as a key-value pair table
function M.CreateKeysAndCertificateResponse(args)
	assert(args, "You must provide an argument table when creating CreateKeysAndCertificateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["keyPair"] = args["keyPair"],
		["certificateId"] = args["certificateId"],
		["certificatePem"] = args["certificatePem"],
	}
	asserts.AssertCreateKeysAndCertificateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCertificatesResponse = { ["certificates"] = true, ["nextMarker"] = true, nil }

function asserts.AssertListCertificatesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCertificatesResponse to be of type 'table'")
	if struct["certificates"] then asserts.AssertCertificates(struct["certificates"]) end
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCertificatesResponse[k], "ListCertificatesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCertificatesResponse
-- <p>The output of the ListCertificates operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificates [Certificates] <p>The descriptions of the certificates.</p>
-- * nextMarker [Marker] <p>The marker for the next set of results, or null if there are no additional results.</p>
-- @return ListCertificatesResponse structure as a key-value pair table
function M.ListCertificatesResponse(args)
	assert(args, "You must provide an argument table when creating ListCertificatesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificates"] = args["certificates"],
		["nextMarker"] = args["nextMarker"],
	}
	asserts.AssertListCertificatesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListJobsRequest = { ["status"] = true, ["thingGroupName"] = true, ["maxResults"] = true, ["targetSelection"] = true, ["thingGroupId"] = true, ["nextToken"] = true, nil }

function asserts.AssertListJobsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListJobsRequest to be of type 'table'")
	if struct["status"] then asserts.AssertJobStatus(struct["status"]) end
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["maxResults"] then asserts.AssertLaserMaxResults(struct["maxResults"]) end
	if struct["targetSelection"] then asserts.AssertTargetSelection(struct["targetSelection"]) end
	if struct["thingGroupId"] then asserts.AssertThingGroupId(struct["thingGroupId"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListJobsRequest[k], "ListJobsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListJobsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [JobStatus] <p>An optional filter that lets you search for jobs that have the specified status.</p>
-- * thingGroupName [ThingGroupName] <p>A filter that limits the returned jobs to those for the specified group.</p>
-- * maxResults [LaserMaxResults] <p>The maximum number of results to return per request.</p>
-- * targetSelection [TargetSelection] <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. </p>
-- * thingGroupId [ThingGroupId] <p>A filter that limits the returned jobs to those for the specified group.</p>
-- * nextToken [NextToken] <p>The token to retrieve the next set of results.</p>
-- @return ListJobsRequest structure as a key-value pair table
function M.ListJobsRequest(args)
	assert(args, "You must provide an argument table when creating ListJobsRequest")
    local query_args = { 
        ["status"] = args["status"],
        ["thingGroupName"] = args["thingGroupName"],
        ["maxResults"] = args["maxResults"],
        ["targetSelection"] = args["targetSelection"],
        ["thingGroupId"] = args["thingGroupId"],
        ["nextToken"] = args["nextToken"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["thingGroupName"] = args["thingGroupName"],
		["maxResults"] = args["maxResults"],
		["targetSelection"] = args["targetSelection"],
		["thingGroupId"] = args["thingGroupId"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListJobsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListV2LoggingLevelsResponse = { ["nextToken"] = true, ["logTargetConfigurations"] = true, nil }

function asserts.AssertListV2LoggingLevelsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListV2LoggingLevelsResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["logTargetConfigurations"] then asserts.AssertLogTargetConfigurations(struct["logTargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListV2LoggingLevelsResponse[k], "ListV2LoggingLevelsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListV2LoggingLevelsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
-- * logTargetConfigurations [LogTargetConfigurations] <p>The logging configuration for a target.</p>
-- @return ListV2LoggingLevelsResponse structure as a key-value pair table
function M.ListV2LoggingLevelsResponse(args)
	assert(args, "You must provide an argument table when creating ListV2LoggingLevelsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["logTargetConfigurations"] = args["logTargetConfigurations"],
	}
	asserts.AssertListV2LoggingLevelsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeThingTypeResponse = { ["thingTypeName"] = true, ["thingTypeId"] = true, ["thingTypeMetadata"] = true, ["thingTypeProperties"] = true, ["thingTypeArn"] = true, nil }

function asserts.AssertDescribeThingTypeResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeThingTypeResponse to be of type 'table'")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["thingTypeId"] then asserts.AssertThingTypeId(struct["thingTypeId"]) end
	if struct["thingTypeMetadata"] then asserts.AssertThingTypeMetadata(struct["thingTypeMetadata"]) end
	if struct["thingTypeProperties"] then asserts.AssertThingTypeProperties(struct["thingTypeProperties"]) end
	if struct["thingTypeArn"] then asserts.AssertThingTypeArn(struct["thingTypeArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeThingTypeResponse[k], "DescribeThingTypeResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeThingTypeResponse
-- <p>The output for the DescribeThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- * thingTypeId [ThingTypeId] <p>The thing type ID.</p>
-- * thingTypeMetadata [ThingTypeMetadata] <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.</p>
-- * thingTypeProperties [ThingTypeProperties] <p>The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.</p>
-- * thingTypeArn [ThingTypeArn] <p>The thing type ARN.</p>
-- @return DescribeThingTypeResponse structure as a key-value pair table
function M.DescribeThingTypeResponse(args)
	assert(args, "You must provide an argument table when creating DescribeThingTypeResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["thingTypeId"] = args["thingTypeId"],
		["thingTypeMetadata"] = args["thingTypeMetadata"],
		["thingTypeProperties"] = args["thingTypeProperties"],
		["thingTypeArn"] = args["thingTypeArn"],
	}
	asserts.AssertDescribeThingTypeResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCertificatesByCAResponse = { ["certificates"] = true, ["nextMarker"] = true, nil }

function asserts.AssertListCertificatesByCAResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCertificatesByCAResponse to be of type 'table'")
	if struct["certificates"] then asserts.AssertCertificates(struct["certificates"]) end
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCertificatesByCAResponse[k], "ListCertificatesByCAResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCertificatesByCAResponse
-- <p>The output of the ListCertificatesByCA operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificates [Certificates] <p>The device certificates signed by the specified CA certificate.</p>
-- * nextMarker [Marker] <p>The marker for the next set of results, or null if there are no additional results.</p>
-- @return ListCertificatesByCAResponse structure as a key-value pair table
function M.ListCertificatesByCAResponse(args)
	assert(args, "You must provide an argument table when creating ListCertificatesByCAResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificates"] = args["certificates"],
		["nextMarker"] = args["nextMarker"],
	}
	asserts.AssertListCertificatesByCAResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateAuthorizerRequest = { ["status"] = true, ["tokenKeyName"] = true, ["tokenSigningPublicKeys"] = true, ["authorizerName"] = true, ["authorizerFunctionArn"] = true, nil }

function asserts.AssertCreateAuthorizerRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateAuthorizerRequest to be of type 'table'")
	assert(struct["authorizerName"], "Expected key authorizerName to exist in table")
	assert(struct["authorizerFunctionArn"], "Expected key authorizerFunctionArn to exist in table")
	assert(struct["tokenKeyName"], "Expected key tokenKeyName to exist in table")
	assert(struct["tokenSigningPublicKeys"], "Expected key tokenSigningPublicKeys to exist in table")
	if struct["status"] then asserts.AssertAuthorizerStatus(struct["status"]) end
	if struct["tokenKeyName"] then asserts.AssertTokenKeyName(struct["tokenKeyName"]) end
	if struct["tokenSigningPublicKeys"] then asserts.AssertPublicKeyMap(struct["tokenSigningPublicKeys"]) end
	if struct["authorizerName"] then asserts.AssertAuthorizerName(struct["authorizerName"]) end
	if struct["authorizerFunctionArn"] then asserts.AssertAuthorizerFunctionArn(struct["authorizerFunctionArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateAuthorizerRequest[k], "CreateAuthorizerRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateAuthorizerRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [AuthorizerStatus] <p>The status of the create authorizer request.</p>
-- * tokenKeyName [TokenKeyName] <p>The name of the token key used to extract the token from the HTTP headers.</p>
-- * tokenSigningPublicKeys [PublicKeyMap] <p>The public keys used to verify the digital signature returned by your custom authentication service.</p>
-- * authorizerName [AuthorizerName] <p>The authorizer name.</p>
-- * authorizerFunctionArn [AuthorizerFunctionArn] <p>The ARN of the authorizer's Lambda function.</p>
-- Required key: authorizerName
-- Required key: authorizerFunctionArn
-- Required key: tokenKeyName
-- Required key: tokenSigningPublicKeys
-- @return CreateAuthorizerRequest structure as a key-value pair table
function M.CreateAuthorizerRequest(args)
	assert(args, "You must provide an argument table when creating CreateAuthorizerRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{authorizerName}"] = args["authorizerName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["tokenKeyName"] = args["tokenKeyName"],
		["tokenSigningPublicKeys"] = args["tokenSigningPublicKeys"],
		["authorizerName"] = args["authorizerName"],
		["authorizerFunctionArn"] = args["authorizerFunctionArn"],
	}
	asserts.AssertCreateAuthorizerRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateTargetsWithJobRequest = { ["comment"] = true, ["targets"] = true, ["jobId"] = true, nil }

function asserts.AssertAssociateTargetsWithJobRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateTargetsWithJobRequest to be of type 'table'")
	assert(struct["targets"], "Expected key targets to exist in table")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	if struct["comment"] then asserts.AssertComment(struct["comment"]) end
	if struct["targets"] then asserts.AssertJobTargets(struct["targets"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateTargetsWithJobRequest[k], "AssociateTargetsWithJobRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateTargetsWithJobRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * comment [Comment] <p>An optional comment string describing why the job was associated with the targets.</p>
-- * targets [JobTargets] <p>A list of thing group ARNs that define the targets of the job.</p>
-- * jobId [JobId] <p>The unique identifier you assigned to this job when it was created.</p>
-- Required key: targets
-- Required key: jobId
-- @return AssociateTargetsWithJobRequest structure as a key-value pair table
function M.AssociateTargetsWithJobRequest(args)
	assert(args, "You must provide an argument table when creating AssociateTargetsWithJobRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["comment"] = args["comment"],
		["targets"] = args["targets"],
		["jobId"] = args["jobId"],
	}
	asserts.AssertAssociateTargetsWithJobRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeJobExecutionResponse = { ["execution"] = true, nil }

function asserts.AssertDescribeJobExecutionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeJobExecutionResponse to be of type 'table'")
	if struct["execution"] then asserts.AssertJobExecution(struct["execution"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeJobExecutionResponse[k], "DescribeJobExecutionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeJobExecutionResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * execution [JobExecution] <p>Information about the job execution.</p>
-- @return DescribeJobExecutionResponse structure as a key-value pair table
function M.DescribeJobExecutionResponse(args)
	assert(args, "You must provide an argument table when creating DescribeJobExecutionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["execution"] = args["execution"],
	}
	asserts.AssertDescribeJobExecutionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterCACertificateResponse = { ["certificateArn"] = true, ["certificateId"] = true, nil }

function asserts.AssertRegisterCACertificateResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterCACertificateResponse to be of type 'table'")
	if struct["certificateArn"] then asserts.AssertCertificateArn(struct["certificateArn"]) end
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterCACertificateResponse[k], "RegisterCACertificateResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterCACertificateResponse
-- <p>The output from the RegisterCACertificateResponse operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateArn [CertificateArn] <p>The CA certificate ARN.</p>
-- * certificateId [CertificateId] <p>The CA certificate identifier.</p>
-- @return RegisterCACertificateResponse structure as a key-value pair table
function M.RegisterCACertificateResponse(args)
	assert(args, "You must provide an argument table when creating RegisterCACertificateResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateArn"] = args["certificateArn"],
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertRegisterCACertificateResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListOutgoingCertificatesResponse = { ["nextMarker"] = true, ["outgoingCertificates"] = true, nil }

function asserts.AssertListOutgoingCertificatesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListOutgoingCertificatesResponse to be of type 'table'")
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	if struct["outgoingCertificates"] then asserts.AssertOutgoingCertificates(struct["outgoingCertificates"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListOutgoingCertificatesResponse[k], "ListOutgoingCertificatesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListOutgoingCertificatesResponse
-- <p>The output from the ListOutgoingCertificates operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextMarker [Marker] <p>The marker for the next set of results.</p>
-- * outgoingCertificates [OutgoingCertificates] <p>The certificates that are being transferred but not yet accepted.</p>
-- @return ListOutgoingCertificatesResponse structure as a key-value pair table
function M.ListOutgoingCertificatesResponse(args)
	assert(args, "You must provide an argument table when creating ListOutgoingCertificatesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextMarker"] = args["nextMarker"],
		["outgoingCertificates"] = args["outgoingCertificates"],
	}
	asserts.AssertListOutgoingCertificatesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateSecurityProfileRequest = { ["behaviors"] = true, ["alertTargets"] = true, ["expectedVersion"] = true, ["securityProfileName"] = true, ["securityProfileDescription"] = true, nil }

function asserts.AssertUpdateSecurityProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateSecurityProfileRequest to be of type 'table'")
	assert(struct["securityProfileName"], "Expected key securityProfileName to exist in table")
	if struct["behaviors"] then asserts.AssertBehaviors(struct["behaviors"]) end
	if struct["alertTargets"] then asserts.AssertAlertTargets(struct["alertTargets"]) end
	if struct["expectedVersion"] then asserts.AssertOptionalVersion(struct["expectedVersion"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["securityProfileDescription"] then asserts.AssertSecurityProfileDescription(struct["securityProfileDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateSecurityProfileRequest[k], "UpdateSecurityProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateSecurityProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * behaviors [Behaviors] <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
-- * alertTargets [AlertTargets] <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
-- * expectedVersion [OptionalVersion] <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different than the actual version, a <code>VersionConflictException</code> is thrown.</p>
-- * securityProfileName [SecurityProfileName] <p>The name of the security profile you want to update.</p>
-- * securityProfileDescription [SecurityProfileDescription] <p>A description of the security profile.</p>
-- Required key: securityProfileName
-- @return UpdateSecurityProfileRequest structure as a key-value pair table
function M.UpdateSecurityProfileRequest(args)
	assert(args, "You must provide an argument table when creating UpdateSecurityProfileRequest")
    local query_args = { 
        ["expectedVersion"] = args["expectedVersion"],
    }
    local uri_args = { 
        ["{securityProfileName}"] = args["securityProfileName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["behaviors"] = args["behaviors"],
		["alertTargets"] = args["alertTargets"],
		["expectedVersion"] = args["expectedVersion"],
		["securityProfileName"] = args["securityProfileName"],
		["securityProfileDescription"] = args["securityProfileDescription"],
	}
	asserts.AssertUpdateSecurityProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StopThingRegistrationTaskRequest = { ["taskId"] = true, nil }

function asserts.AssertStopThingRegistrationTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopThingRegistrationTaskRequest to be of type 'table'")
	assert(struct["taskId"], "Expected key taskId to exist in table")
	if struct["taskId"] then asserts.AssertTaskId(struct["taskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopThingRegistrationTaskRequest[k], "StopThingRegistrationTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopThingRegistrationTaskRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * taskId [TaskId] <p>The bulk thing provisioning task ID.</p>
-- Required key: taskId
-- @return StopThingRegistrationTaskRequest structure as a key-value pair table
function M.StopThingRegistrationTaskRequest(args)
	assert(args, "You must provide an argument table when creating StopThingRegistrationTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{taskId}"] = args["taskId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["taskId"] = args["taskId"],
	}
	asserts.AssertStopThingRegistrationTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAuditTasksResponse = { ["nextToken"] = true, ["tasks"] = true, nil }

function asserts.AssertListAuditTasksResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAuditTasksResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["tasks"] then asserts.AssertAuditTaskMetadataList(struct["tasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAuditTasksResponse[k], "ListAuditTasksResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAuditTasksResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- * tasks [AuditTaskMetadataList] <p>The audits that were performed during the specified time period.</p>
-- @return ListAuditTasksResponse structure as a key-value pair table
function M.ListAuditTasksResponse(args)
	assert(args, "You must provide an argument table when creating ListAuditTasksResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["tasks"] = args["tasks"],
	}
	asserts.AssertListAuditTasksResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListViolationEventsRequest = { ["endTime"] = true, ["maxResults"] = true, ["securityProfileName"] = true, ["thingName"] = true, ["startTime"] = true, ["nextToken"] = true, nil }

function asserts.AssertListViolationEventsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListViolationEventsRequest to be of type 'table'")
	assert(struct["startTime"], "Expected key startTime to exist in table")
	assert(struct["endTime"], "Expected key endTime to exist in table")
	if struct["endTime"] then asserts.AssertTimestamp(struct["endTime"]) end
	if struct["maxResults"] then asserts.AssertMaxResults(struct["maxResults"]) end
	if struct["securityProfileName"] then asserts.AssertSecurityProfileName(struct["securityProfileName"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	if struct["startTime"] then asserts.AssertTimestamp(struct["startTime"]) end
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListViolationEventsRequest[k], "ListViolationEventsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListViolationEventsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * endTime [Timestamp] <p>The end time for the alerts to be listed.</p>
-- * maxResults [MaxResults] <p>The maximum number of results to return at one time.</p>
-- * securityProfileName [SecurityProfileName] <p>A filter to limit results to those alerts generated by the specified security profile.</p>
-- * thingName [ThingName] <p>A filter to limit results to those alerts caused by the specified thing.</p>
-- * startTime [Timestamp] <p>The start time for the alerts to be listed.</p>
-- * nextToken [NextToken] <p>The token for the next set of results.</p>
-- Required key: startTime
-- Required key: endTime
-- @return ListViolationEventsRequest structure as a key-value pair table
function M.ListViolationEventsRequest(args)
	assert(args, "You must provide an argument table when creating ListViolationEventsRequest")
    local query_args = { 
        ["endTime"] = args["endTime"],
        ["maxResults"] = args["maxResults"],
        ["securityProfileName"] = args["securityProfileName"],
        ["thingName"] = args["thingName"],
        ["startTime"] = args["startTime"],
        ["nextToken"] = args["nextToken"],
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["endTime"] = args["endTime"],
		["maxResults"] = args["maxResults"],
		["securityProfileName"] = args["securityProfileName"],
		["thingName"] = args["thingName"],
		["startTime"] = args["startTime"],
		["nextToken"] = args["nextToken"],
	}
	asserts.AssertListViolationEventsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CodeSigningSignature = { ["inlineDocument"] = true, nil }

function asserts.AssertCodeSigningSignature(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CodeSigningSignature to be of type 'table'")
	if struct["inlineDocument"] then asserts.AssertSignature(struct["inlineDocument"]) end
	for k,_ in pairs(struct) do
		assert(keys.CodeSigningSignature[k], "CodeSigningSignature contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CodeSigningSignature
-- <p>Describes the signature for a file.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * inlineDocument [Signature] <p>A base64 encoded binary representation of the code signing signature.</p>
-- @return CodeSigningSignature structure as a key-value pair table
function M.CodeSigningSignature(args)
	assert(args, "You must provide an argument table when creating CodeSigningSignature")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["inlineDocument"] = args["inlineDocument"],
	}
	asserts.AssertCodeSigningSignature(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCACertificatesResponse = { ["certificates"] = true, ["nextMarker"] = true, nil }

function asserts.AssertListCACertificatesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCACertificatesResponse to be of type 'table'")
	if struct["certificates"] then asserts.AssertCACertificates(struct["certificates"]) end
	if struct["nextMarker"] then asserts.AssertMarker(struct["nextMarker"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCACertificatesResponse[k], "ListCACertificatesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCACertificatesResponse
-- <p>The output from the ListCACertificates operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificates [CACertificates] <p>The CA certificates registered in your AWS account.</p>
-- * nextMarker [Marker] <p>The current position within the list of CA certificates.</p>
-- @return ListCACertificatesResponse structure as a key-value pair table
function M.ListCACertificatesResponse(args)
	assert(args, "You must provide an argument table when creating ListCACertificatesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["certificates"] = args["certificates"],
		["nextMarker"] = args["nextMarker"],
	}
	asserts.AssertListCACertificatesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateRoleAliasRequest = { ["roleArn"] = true, ["credentialDurationSeconds"] = true, ["roleAlias"] = true, nil }

function asserts.AssertCreateRoleAliasRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRoleAliasRequest to be of type 'table'")
	assert(struct["roleAlias"], "Expected key roleAlias to exist in table")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	if struct["roleArn"] then asserts.AssertRoleArn(struct["roleArn"]) end
	if struct["credentialDurationSeconds"] then asserts.AssertCredentialDurationSeconds(struct["credentialDurationSeconds"]) end
	if struct["roleAlias"] then asserts.AssertRoleAlias(struct["roleAlias"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRoleAliasRequest[k], "CreateRoleAliasRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRoleAliasRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [RoleArn] <p>The role ARN.</p>
-- * credentialDurationSeconds [CredentialDurationSeconds] <p>How long (in seconds) the credentials will be valid.</p>
-- * roleAlias [RoleAlias] <p>The role alias that points to a role ARN. This allows you to change the role without having to update the device.</p>
-- Required key: roleAlias
-- Required key: roleArn
-- @return CreateRoleAliasRequest structure as a key-value pair table
function M.CreateRoleAliasRequest(args)
	assert(args, "You must provide an argument table when creating CreateRoleAliasRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{roleAlias}"] = args["roleAlias"],
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["credentialDurationSeconds"] = args["credentialDurationSeconds"],
		["roleAlias"] = args["roleAlias"],
	}
	asserts.AssertCreateRoleAliasRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledAuditMetadata = { ["dayOfWeek"] = true, ["scheduledAuditName"] = true, ["frequency"] = true, ["scheduledAuditArn"] = true, ["dayOfMonth"] = true, nil }

function asserts.AssertScheduledAuditMetadata(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledAuditMetadata to be of type 'table'")
	if struct["dayOfWeek"] then asserts.AssertDayOfWeek(struct["dayOfWeek"]) end
	if struct["scheduledAuditName"] then asserts.AssertScheduledAuditName(struct["scheduledAuditName"]) end
	if struct["frequency"] then asserts.AssertAuditFrequency(struct["frequency"]) end
	if struct["scheduledAuditArn"] then asserts.AssertScheduledAuditArn(struct["scheduledAuditArn"]) end
	if struct["dayOfMonth"] then asserts.AssertDayOfMonth(struct["dayOfMonth"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledAuditMetadata[k], "ScheduledAuditMetadata contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledAuditMetadata
-- <p>Information about the scheduled audit.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * dayOfWeek [DayOfWeek] <p>The day of the week on which the scheduled audit is run (if the <code>frequency</code> is "WEEKLY" or "BIWEEKLY").</p>
-- * scheduledAuditName [ScheduledAuditName] <p>The name of the scheduled audit.</p>
-- * frequency [AuditFrequency] <p>How often the scheduled audit takes place.</p>
-- * scheduledAuditArn [ScheduledAuditArn] <p>The ARN of the scheduled audit.</p>
-- * dayOfMonth [DayOfMonth] <p>The day of the month on which the scheduled audit is run (if the <code>frequency</code> is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
-- @return ScheduledAuditMetadata structure as a key-value pair table
function M.ScheduledAuditMetadata(args)
	assert(args, "You must provide an argument table when creating ScheduledAuditMetadata")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["dayOfWeek"] = args["dayOfWeek"],
		["scheduledAuditName"] = args["scheduledAuditName"],
		["frequency"] = args["frequency"],
		["scheduledAuditArn"] = args["scheduledAuditArn"],
		["dayOfMonth"] = args["dayOfMonth"],
	}
	asserts.AssertScheduledAuditMetadata(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateThingRequest = { ["thingTypeName"] = true, ["removeThingType"] = true, ["attributePayload"] = true, ["expectedVersion"] = true, ["thingName"] = true, nil }

function asserts.AssertUpdateThingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateThingRequest to be of type 'table'")
	assert(struct["thingName"], "Expected key thingName to exist in table")
	if struct["thingTypeName"] then asserts.AssertThingTypeName(struct["thingTypeName"]) end
	if struct["removeThingType"] then asserts.AssertRemoveThingType(struct["removeThingType"]) end
	if struct["attributePayload"] then asserts.AssertAttributePayload(struct["attributePayload"]) end
	if struct["expectedVersion"] then asserts.AssertOptionalVersion(struct["expectedVersion"]) end
	if struct["thingName"] then asserts.AssertThingName(struct["thingName"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateThingRequest[k], "UpdateThingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateThingRequest
-- <p>The input for the UpdateThing operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingTypeName [ThingTypeName] <p>The name of the thing type.</p>
-- * removeThingType [RemoveThingType] <p>Remove a thing type association. If <b>true</b>, the association is removed.</p>
-- * attributePayload [AttributePayload] <p>A list of thing attributes, a JSON string containing name-value pairs. For example:</p> <p> <code>{\"attributes\":{\"name1\":\"value2\"}}</code> </p> <p>This data is used to add new attributes or update existing attributes.</p>
-- * expectedVersion [OptionalVersion] <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>UpdateThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
-- * thingName [ThingName] <p>The name of the thing to update.</p>
-- Required key: thingName
-- @return UpdateThingRequest structure as a key-value pair table
function M.UpdateThingRequest(args)
	assert(args, "You must provide an argument table when creating UpdateThingRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{thingName}"] = args["thingName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["thingTypeName"] = args["thingTypeName"],
		["removeThingType"] = args["removeThingType"],
		["attributePayload"] = args["attributePayload"],
		["expectedVersion"] = args["expectedVersion"],
		["thingName"] = args["thingName"],
	}
	asserts.AssertUpdateThingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ThingGroupProperties = { ["attributePayload"] = true, ["thingGroupDescription"] = true, nil }

function asserts.AssertThingGroupProperties(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ThingGroupProperties to be of type 'table'")
	if struct["attributePayload"] then asserts.AssertAttributePayload(struct["attributePayload"]) end
	if struct["thingGroupDescription"] then asserts.AssertThingGroupDescription(struct["thingGroupDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.ThingGroupProperties[k], "ThingGroupProperties contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ThingGroupProperties
-- <p>Thing group properties.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * attributePayload [AttributePayload] <p>The thing group attributes in JSON format.</p>
-- * thingGroupDescription [ThingGroupDescription] <p>The thing group description.</p>
-- @return ThingGroupProperties structure as a key-value pair table
function M.ThingGroupProperties(args)
	assert(args, "You must provide an argument table when creating ThingGroupProperties")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["attributePayload"] = args["attributePayload"],
		["thingGroupDescription"] = args["thingGroupDescription"],
	}
	asserts.AssertThingGroupProperties(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.JobExecutionSummary = { ["status"] = true, ["startedAt"] = true, ["lastUpdatedAt"] = true, ["queuedAt"] = true, ["executionNumber"] = true, nil }

function asserts.AssertJobExecutionSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected JobExecutionSummary to be of type 'table'")
	if struct["status"] then asserts.AssertJobExecutionStatus(struct["status"]) end
	if struct["startedAt"] then asserts.AssertDateType(struct["startedAt"]) end
	if struct["lastUpdatedAt"] then asserts.AssertDateType(struct["lastUpdatedAt"]) end
	if struct["queuedAt"] then asserts.AssertDateType(struct["queuedAt"]) end
	if struct["executionNumber"] then asserts.AssertExecutionNumber(struct["executionNumber"]) end
	for k,_ in pairs(struct) do
		assert(keys.JobExecutionSummary[k], "JobExecutionSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type JobExecutionSummary
-- <p>The job execution summary.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * status [JobExecutionStatus] <p>The status of the job execution.</p>
-- * startedAt [DateType] <p>The time, in milliseconds since the epoch, when the job execution started.</p>
-- * lastUpdatedAt [DateType] <p>The time, in milliseconds since the epoch, when the job execution was last updated.</p>
-- * queuedAt [DateType] <p>The time, in milliseconds since the epoch, when the job execution was queued.</p>
-- * executionNumber [ExecutionNumber] <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used later in commands which return or update job execution information.</p>
-- @return JobExecutionSummary structure as a key-value pair table
function M.JobExecutionSummary(args)
	assert(args, "You must provide an argument table when creating JobExecutionSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["status"] = args["status"],
		["startedAt"] = args["startedAt"],
		["lastUpdatedAt"] = args["lastUpdatedAt"],
		["queuedAt"] = args["queuedAt"],
		["executionNumber"] = args["executionNumber"],
	}
	asserts.AssertJobExecutionSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListPrincipalPoliciesRequest = { ["marker"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, ["principal"] = true, nil }

function asserts.AssertListPrincipalPoliciesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListPrincipalPoliciesRequest to be of type 'table'")
	assert(struct["principal"], "Expected key principal to exist in table")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListPrincipalPoliciesRequest[k], "ListPrincipalPoliciesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListPrincipalPoliciesRequest
-- <p>The input for the ListPrincipalPolicies operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The marker for the next set of results.</p>
-- * ascendingOrder [AscendingOrder] <p>Specifies the order for results. If true, results are returned in ascending creation order.</p>
-- * pageSize [PageSize] <p>The result page size.</p>
-- * principal [Principal] <p>The principal.</p>
-- Required key: principal
-- @return ListPrincipalPoliciesRequest structure as a key-value pair table
function M.ListPrincipalPoliciesRequest(args)
	assert(args, "You must provide an argument table when creating ListPrincipalPoliciesRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
    }
    local header_args = { 
        ["x-amzn-iot-principal"] = args["principal"],
    }
	local all_args = { 
		["marker"] = args["marker"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
		["principal"] = args["principal"],
	}
	asserts.AssertListPrincipalPoliciesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SetV2LoggingOptionsRequest = { ["roleArn"] = true, ["defaultLogLevel"] = true, ["disableAllLogs"] = true, nil }

function asserts.AssertSetV2LoggingOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SetV2LoggingOptionsRequest to be of type 'table'")
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["defaultLogLevel"] then asserts.AssertLogLevel(struct["defaultLogLevel"]) end
	if struct["disableAllLogs"] then asserts.AssertDisableAllLogs(struct["disableAllLogs"]) end
	for k,_ in pairs(struct) do
		assert(keys.SetV2LoggingOptionsRequest[k], "SetV2LoggingOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SetV2LoggingOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [AwsArn] <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
-- * defaultLogLevel [LogLevel] <p>The default logging level.</p>
-- * disableAllLogs [DisableAllLogs] <p>If true all logs are disabled. The default is false.</p>
-- @return SetV2LoggingOptionsRequest structure as a key-value pair table
function M.SetV2LoggingOptionsRequest(args)
	assert(args, "You must provide an argument table when creating SetV2LoggingOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["defaultLogLevel"] = args["defaultLogLevel"],
		["disableAllLogs"] = args["disableAllLogs"],
	}
	asserts.AssertSetV2LoggingOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPolicyVersionResponse = { ["policyName"] = true, ["generationId"] = true, ["lastModifiedDate"] = true, ["isDefaultVersion"] = true, ["policyArn"] = true, ["policyDocument"] = true, ["policyVersionId"] = true, ["creationDate"] = true, nil }

function asserts.AssertGetPolicyVersionResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPolicyVersionResponse to be of type 'table'")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["generationId"] then asserts.AssertGenerationId(struct["generationId"]) end
	if struct["lastModifiedDate"] then asserts.AssertDateType(struct["lastModifiedDate"]) end
	if struct["isDefaultVersion"] then asserts.AssertIsDefaultVersion(struct["isDefaultVersion"]) end
	if struct["policyArn"] then asserts.AssertPolicyArn(struct["policyArn"]) end
	if struct["policyDocument"] then asserts.AssertPolicyDocument(struct["policyDocument"]) end
	if struct["policyVersionId"] then asserts.AssertPolicyVersionId(struct["policyVersionId"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPolicyVersionResponse[k], "GetPolicyVersionResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPolicyVersionResponse
-- <p>The output from the GetPolicyVersion operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * generationId [GenerationId] <p>The generation ID of the policy version.</p>
-- * lastModifiedDate [DateType] <p>The date the policy version was last modified.</p>
-- * isDefaultVersion [IsDefaultVersion] <p>Specifies whether the policy version is the default.</p>
-- * policyArn [PolicyArn] <p>The policy ARN.</p>
-- * policyDocument [PolicyDocument] <p>The JSON document that describes the policy.</p>
-- * policyVersionId [PolicyVersionId] <p>The policy version ID.</p>
-- * creationDate [DateType] <p>The date the policy version was created.</p>
-- @return GetPolicyVersionResponse structure as a key-value pair table
function M.GetPolicyVersionResponse(args)
	assert(args, "You must provide an argument table when creating GetPolicyVersionResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["generationId"] = args["generationId"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["isDefaultVersion"] = args["isDefaultVersion"],
		["policyArn"] = args["policyArn"],
		["policyDocument"] = args["policyDocument"],
		["policyVersionId"] = args["policyVersionId"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertGetPolicyVersionResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateJobRequest = { ["documentSource"] = true, ["description"] = true, ["presignedUrlConfig"] = true, ["jobId"] = true, ["jobExecutionsRolloutConfig"] = true, ["targetSelection"] = true, ["timeoutConfig"] = true, ["document"] = true, ["targets"] = true, nil }

function asserts.AssertCreateJobRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateJobRequest to be of type 'table'")
	assert(struct["jobId"], "Expected key jobId to exist in table")
	assert(struct["targets"], "Expected key targets to exist in table")
	if struct["documentSource"] then asserts.AssertJobDocumentSource(struct["documentSource"]) end
	if struct["description"] then asserts.AssertJobDescription(struct["description"]) end
	if struct["presignedUrlConfig"] then asserts.AssertPresignedUrlConfig(struct["presignedUrlConfig"]) end
	if struct["jobId"] then asserts.AssertJobId(struct["jobId"]) end
	if struct["jobExecutionsRolloutConfig"] then asserts.AssertJobExecutionsRolloutConfig(struct["jobExecutionsRolloutConfig"]) end
	if struct["targetSelection"] then asserts.AssertTargetSelection(struct["targetSelection"]) end
	if struct["timeoutConfig"] then asserts.AssertTimeoutConfig(struct["timeoutConfig"]) end
	if struct["document"] then asserts.AssertJobDocument(struct["document"]) end
	if struct["targets"] then asserts.AssertJobTargets(struct["targets"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateJobRequest[k], "CreateJobRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateJobRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * documentSource [JobDocumentSource] <p>An S3 link to the job document.</p>
-- * description [JobDescription] <p>A short text description of the job.</p>
-- * presignedUrlConfig [PresignedUrlConfig] <p>Configuration information for pre-signed S3 URLs.</p>
-- * jobId [JobId] <p>A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.</p>
-- * jobExecutionsRolloutConfig [JobExecutionsRolloutConfig] <p>Allows you to create a staged rollout of the job.</p>
-- * targetSelection [TargetSelection] <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p>
-- * timeoutConfig [TimeoutConfig] <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
-- * document [JobDocument] <p>The job document.</p>
-- * targets [JobTargets] <p>A list of things and thing groups to which the job should be sent.</p>
-- Required key: jobId
-- Required key: targets
-- @return CreateJobRequest structure as a key-value pair table
function M.CreateJobRequest(args)
	assert(args, "You must provide an argument table when creating CreateJobRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{jobId}"] = args["jobId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["documentSource"] = args["documentSource"],
		["description"] = args["description"],
		["presignedUrlConfig"] = args["presignedUrlConfig"],
		["jobId"] = args["jobId"],
		["jobExecutionsRolloutConfig"] = args["jobExecutionsRolloutConfig"],
		["targetSelection"] = args["targetSelection"],
		["timeoutConfig"] = args["timeoutConfig"],
		["document"] = args["document"],
		["targets"] = args["targets"],
	}
	asserts.AssertCreateJobRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.BehaviorCriteria = { ["durationSeconds"] = true, ["comparisonOperator"] = true, ["value"] = true, nil }

function asserts.AssertBehaviorCriteria(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BehaviorCriteria to be of type 'table'")
	if struct["durationSeconds"] then asserts.AssertDurationSeconds(struct["durationSeconds"]) end
	if struct["comparisonOperator"] then asserts.AssertComparisonOperator(struct["comparisonOperator"]) end
	if struct["value"] then asserts.AssertMetricValue(struct["value"]) end
	for k,_ in pairs(struct) do
		assert(keys.BehaviorCriteria[k], "BehaviorCriteria contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BehaviorCriteria
-- <p>The criteria by which the behavior is determined to be normal.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * durationSeconds [DurationSeconds] <p>Use this to specify the period of time over which the behavior is evaluated, for those criteria which have a time dimension (for example, <code>NUM_MESSAGES_SENT</code>).</p>
-- * comparisonOperator [ComparisonOperator] <p>The operator that relates the thing measured (<code>metric</code>) to the criteria (<code>value</code>).</p>
-- * value [MetricValue] <p>The value to be compared with the <code>metric</code>.</p>
-- @return BehaviorCriteria structure as a key-value pair table
function M.BehaviorCriteria(args)
	assert(args, "You must provide an argument table when creating BehaviorCriteria")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["durationSeconds"] = args["durationSeconds"],
		["comparisonOperator"] = args["comparisonOperator"],
		["value"] = args["value"],
	}
	asserts.AssertBehaviorCriteria(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RepublishAction = { ["topic"] = true, ["roleArn"] = true, nil }

function asserts.AssertRepublishAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RepublishAction to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["topic"], "Expected key topic to exist in table")
	if struct["topic"] then asserts.AssertTopicPattern(struct["topic"]) end
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.RepublishAction[k], "RepublishAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RepublishAction
-- <p>Describes an action to republish to another topic.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * topic [TopicPattern] <p>The name of the MQTT topic.</p>
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access.</p>
-- Required key: roleArn
-- Required key: topic
-- @return RepublishAction structure as a key-value pair table
function M.RepublishAction(args)
	assert(args, "You must provide an argument table when creating RepublishAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["topic"] = args["topic"],
		["roleArn"] = args["roleArn"],
	}
	asserts.AssertRepublishAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteSecurityProfileResponse = { nil }

function asserts.AssertDeleteSecurityProfileResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSecurityProfileResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeleteSecurityProfileResponse[k], "DeleteSecurityProfileResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSecurityProfileResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeleteSecurityProfileResponse structure as a key-value pair table
function M.DeleteSecurityProfileResponse(args)
	assert(args, "You must provide an argument table when creating DeleteSecurityProfileResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeleteSecurityProfileResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LogTargetConfiguration = { ["logTarget"] = true, ["logLevel"] = true, nil }

function asserts.AssertLogTargetConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LogTargetConfiguration to be of type 'table'")
	if struct["logTarget"] then asserts.AssertLogTarget(struct["logTarget"]) end
	if struct["logLevel"] then asserts.AssertLogLevel(struct["logLevel"]) end
	for k,_ in pairs(struct) do
		assert(keys.LogTargetConfiguration[k], "LogTargetConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LogTargetConfiguration
-- <p>The target configuration.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * logTarget [LogTarget] <p>A log target</p>
-- * logLevel [LogLevel] <p>The logging level.</p>
-- @return LogTargetConfiguration structure as a key-value pair table
function M.LogTargetConfiguration(args)
	assert(args, "You must provide an argument table when creating LogTargetConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["logTarget"] = args["logTarget"],
		["logLevel"] = args["logLevel"],
	}
	asserts.AssertLogTargetConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeprecateThingTypeResponse = { nil }

function asserts.AssertDeprecateThingTypeResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeprecateThingTypeResponse to be of type 'table'")
	for k,_ in pairs(struct) do
		assert(keys.DeprecateThingTypeResponse[k], "DeprecateThingTypeResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeprecateThingTypeResponse
-- <p>The output for the DeprecateThingType operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- @return DeprecateThingTypeResponse structure as a key-value pair table
function M.DeprecateThingTypeResponse(args)
	assert(args, "You must provide an argument table when creating DeprecateThingTypeResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
	}
	asserts.AssertDeprecateThingTypeResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListScheduledAuditsResponse = { ["nextToken"] = true, ["scheduledAudits"] = true, nil }

function asserts.AssertListScheduledAuditsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListScheduledAuditsResponse to be of type 'table'")
	if struct["nextToken"] then asserts.AssertNextToken(struct["nextToken"]) end
	if struct["scheduledAudits"] then asserts.AssertScheduledAuditMetadataList(struct["scheduledAudits"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListScheduledAuditsResponse[k], "ListScheduledAuditsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListScheduledAuditsResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * nextToken [NextToken] <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
-- * scheduledAudits [ScheduledAuditMetadataList] <p>The list of scheduled audits.</p>
-- @return ListScheduledAuditsResponse structure as a key-value pair table
function M.ListScheduledAuditsResponse(args)
	assert(args, "You must provide an argument table when creating ListScheduledAuditsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["nextToken"] = args["nextToken"],
		["scheduledAudits"] = args["scheduledAudits"],
	}
	asserts.AssertListScheduledAuditsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteStreamRequest = { ["streamId"] = true, nil }

function asserts.AssertDeleteStreamRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteStreamRequest to be of type 'table'")
	assert(struct["streamId"], "Expected key streamId to exist in table")
	if struct["streamId"] then asserts.AssertStreamId(struct["streamId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteStreamRequest[k], "DeleteStreamRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteStreamRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * streamId [StreamId] <p>The stream ID.</p>
-- Required key: streamId
-- @return DeleteStreamRequest structure as a key-value pair table
function M.DeleteStreamRequest(args)
	assert(args, "You must provide an argument table when creating DeleteStreamRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{streamId}"] = args["streamId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["streamId"] = args["streamId"],
	}
	asserts.AssertDeleteStreamRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LambdaAction = { ["functionArn"] = true, nil }

function asserts.AssertLambdaAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LambdaAction to be of type 'table'")
	assert(struct["functionArn"], "Expected key functionArn to exist in table")
	if struct["functionArn"] then asserts.AssertFunctionArn(struct["functionArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.LambdaAction[k], "LambdaAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LambdaAction
-- <p>Describes an action to invoke a Lambda function.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * functionArn [FunctionArn] <p>The ARN of the Lambda function.</p>
-- Required key: functionArn
-- @return LambdaAction structure as a key-value pair table
function M.LambdaAction(args)
	assert(args, "You must provide an argument table when creating LambdaAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["functionArn"] = args["functionArn"],
	}
	asserts.AssertLambdaAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPolicyResponse = { ["policyName"] = true, ["generationId"] = true, ["lastModifiedDate"] = true, ["policyArn"] = true, ["policyDocument"] = true, ["defaultVersionId"] = true, ["creationDate"] = true, nil }

function asserts.AssertGetPolicyResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPolicyResponse to be of type 'table'")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["generationId"] then asserts.AssertGenerationId(struct["generationId"]) end
	if struct["lastModifiedDate"] then asserts.AssertDateType(struct["lastModifiedDate"]) end
	if struct["policyArn"] then asserts.AssertPolicyArn(struct["policyArn"]) end
	if struct["policyDocument"] then asserts.AssertPolicyDocument(struct["policyDocument"]) end
	if struct["defaultVersionId"] then asserts.AssertPolicyVersionId(struct["defaultVersionId"]) end
	if struct["creationDate"] then asserts.AssertDateType(struct["creationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPolicyResponse[k], "GetPolicyResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPolicyResponse
-- <p>The output from the GetPolicy operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The policy name.</p>
-- * generationId [GenerationId] <p>The generation ID of the policy.</p>
-- * lastModifiedDate [DateType] <p>The date the policy was last modified.</p>
-- * policyArn [PolicyArn] <p>The policy ARN.</p>
-- * policyDocument [PolicyDocument] <p>The JSON document that describes the policy.</p>
-- * defaultVersionId [PolicyVersionId] <p>The default policy version ID.</p>
-- * creationDate [DateType] <p>The date the policy was created.</p>
-- @return GetPolicyResponse structure as a key-value pair table
function M.GetPolicyResponse(args)
	assert(args, "You must provide an argument table when creating GetPolicyResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["generationId"] = args["generationId"],
		["lastModifiedDate"] = args["lastModifiedDate"],
		["policyArn"] = args["policyArn"],
		["policyDocument"] = args["policyDocument"],
		["defaultVersionId"] = args["defaultVersionId"],
		["creationDate"] = args["creationDate"],
	}
	asserts.AssertGetPolicyResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateThingGroupResponse = { ["thingGroupName"] = true, ["thingGroupArn"] = true, ["thingGroupId"] = true, nil }

function asserts.AssertCreateThingGroupResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateThingGroupResponse to be of type 'table'")
	if struct["thingGroupName"] then asserts.AssertThingGroupName(struct["thingGroupName"]) end
	if struct["thingGroupArn"] then asserts.AssertThingGroupArn(struct["thingGroupArn"]) end
	if struct["thingGroupId"] then asserts.AssertThingGroupId(struct["thingGroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateThingGroupResponse[k], "CreateThingGroupResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateThingGroupResponse
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * thingGroupName [ThingGroupName] <p>The thing group name.</p>
-- * thingGroupArn [ThingGroupArn] <p>The thing group ARN.</p>
-- * thingGroupId [ThingGroupId] <p>The thing group ID.</p>
-- @return CreateThingGroupResponse structure as a key-value pair table
function M.CreateThingGroupResponse(args)
	assert(args, "You must provide an argument table when creating CreateThingGroupResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["thingGroupName"] = args["thingGroupName"],
		["thingGroupArn"] = args["thingGroupArn"],
		["thingGroupId"] = args["thingGroupId"],
	}
	asserts.AssertCreateThingGroupResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.KinesisAction = { ["roleArn"] = true, ["streamName"] = true, ["partitionKey"] = true, nil }

function asserts.AssertKinesisAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KinesisAction to be of type 'table'")
	assert(struct["roleArn"], "Expected key roleArn to exist in table")
	assert(struct["streamName"], "Expected key streamName to exist in table")
	if struct["roleArn"] then asserts.AssertAwsArn(struct["roleArn"]) end
	if struct["streamName"] then asserts.AssertStreamName(struct["streamName"]) end
	if struct["partitionKey"] then asserts.AssertPartitionKey(struct["partitionKey"]) end
	for k,_ in pairs(struct) do
		assert(keys.KinesisAction[k], "KinesisAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KinesisAction
-- <p>Describes an action to write data to an Amazon Kinesis stream.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * roleArn [AwsArn] <p>The ARN of the IAM role that grants access to the Amazon Kinesis stream.</p>
-- * streamName [StreamName] <p>The name of the Amazon Kinesis stream.</p>
-- * partitionKey [PartitionKey] <p>The partition key.</p>
-- Required key: roleArn
-- Required key: streamName
-- @return KinesisAction structure as a key-value pair table
function M.KinesisAction(args)
	assert(args, "You must provide an argument table when creating KinesisAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["roleArn"] = args["roleArn"],
		["streamName"] = args["streamName"],
		["partitionKey"] = args["partitionKey"],
	}
	asserts.AssertKinesisAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListCertificatesByCARequest = { ["marker"] = true, ["caCertificateId"] = true, ["ascendingOrder"] = true, ["pageSize"] = true, nil }

function asserts.AssertListCertificatesByCARequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListCertificatesByCARequest to be of type 'table'")
	assert(struct["caCertificateId"], "Expected key caCertificateId to exist in table")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["caCertificateId"] then asserts.AssertCertificateId(struct["caCertificateId"]) end
	if struct["ascendingOrder"] then asserts.AssertAscendingOrder(struct["ascendingOrder"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListCertificatesByCARequest[k], "ListCertificatesByCARequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListCertificatesByCARequest
-- <p>The input to the ListCertificatesByCA operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The marker for the next set of results.</p>
-- * caCertificateId [CertificateId] <p>The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.</p>
-- * ascendingOrder [AscendingOrder] <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
-- * pageSize [PageSize] <p>The result page size.</p>
-- Required key: caCertificateId
-- @return ListCertificatesByCARequest structure as a key-value pair table
function M.ListCertificatesByCARequest(args)
	assert(args, "You must provide an argument table when creating ListCertificatesByCARequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["isAscendingOrder"] = args["ascendingOrder"],
        ["pageSize"] = args["pageSize"],
    }
    local uri_args = { 
        ["{caCertificateId}"] = args["caCertificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["caCertificateId"] = args["caCertificateId"],
		["ascendingOrder"] = args["ascendingOrder"],
		["pageSize"] = args["pageSize"],
	}
	asserts.AssertListCertificatesByCARequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ListAttachedPoliciesRequest = { ["marker"] = true, ["target"] = true, ["pageSize"] = true, ["recursive"] = true, nil }

function asserts.AssertListAttachedPoliciesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ListAttachedPoliciesRequest to be of type 'table'")
	assert(struct["target"], "Expected key target to exist in table")
	if struct["marker"] then asserts.AssertMarker(struct["marker"]) end
	if struct["target"] then asserts.AssertPolicyTarget(struct["target"]) end
	if struct["pageSize"] then asserts.AssertPageSize(struct["pageSize"]) end
	if struct["recursive"] then asserts.AssertRecursive(struct["recursive"]) end
	for k,_ in pairs(struct) do
		assert(keys.ListAttachedPoliciesRequest[k], "ListAttachedPoliciesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ListAttachedPoliciesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * marker [Marker] <p>The token to retrieve the next set of results.</p>
-- * target [PolicyTarget] <p>The group for which the policies will be listed.</p>
-- * pageSize [PageSize] <p>The maximum number of results to be returned per request.</p>
-- * recursive [Recursive] <p>When true, recursively list attached policies.</p>
-- Required key: target
-- @return ListAttachedPoliciesRequest structure as a key-value pair table
function M.ListAttachedPoliciesRequest(args)
	assert(args, "You must provide an argument table when creating ListAttachedPoliciesRequest")
    local query_args = { 
        ["marker"] = args["marker"],
        ["pageSize"] = args["pageSize"],
        ["recursive"] = args["recursive"],
    }
    local uri_args = { 
        ["{target}"] = args["target"],
    }
    local header_args = { 
    }
	local all_args = { 
		["marker"] = args["marker"],
		["target"] = args["target"],
		["pageSize"] = args["pageSize"],
		["recursive"] = args["recursive"],
	}
	asserts.AssertListAttachedPoliciesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelCertificateTransferRequest = { ["certificateId"] = true, nil }

function asserts.AssertCancelCertificateTransferRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelCertificateTransferRequest to be of type 'table'")
	assert(struct["certificateId"], "Expected key certificateId to exist in table")
	if struct["certificateId"] then asserts.AssertCertificateId(struct["certificateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelCertificateTransferRequest[k], "CancelCertificateTransferRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelCertificateTransferRequest
-- <p>The input for the CancelCertificateTransfer operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * certificateId [CertificateId] <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
-- Required key: certificateId
-- @return CancelCertificateTransferRequest structure as a key-value pair table
function M.CancelCertificateTransferRequest(args)
	assert(args, "You must provide an argument table when creating CancelCertificateTransferRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{certificateId}"] = args["certificateId"],
    }
    local header_args = { 
    }
	local all_args = { 
		["certificateId"] = args["certificateId"],
	}
	asserts.AssertCancelCertificateTransferRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachPrincipalPolicyRequest = { ["policyName"] = true, ["principal"] = true, nil }

function asserts.AssertDetachPrincipalPolicyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachPrincipalPolicyRequest to be of type 'table'")
	assert(struct["policyName"], "Expected key policyName to exist in table")
	assert(struct["principal"], "Expected key principal to exist in table")
	if struct["policyName"] then asserts.AssertPolicyName(struct["policyName"]) end
	if struct["principal"] then asserts.AssertPrincipal(struct["principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachPrincipalPolicyRequest[k], "DetachPrincipalPolicyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachPrincipalPolicyRequest
-- <p>The input for the DetachPrincipalPolicy operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * policyName [PolicyName] <p>The name of the policy to detach.</p>
-- * principal [Principal] <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
-- Required key: policyName
-- Required key: principal
-- @return DetachPrincipalPolicyRequest structure as a key-value pair table
function M.DetachPrincipalPolicyRequest(args)
	assert(args, "You must provide an argument table when creating DetachPrincipalPolicyRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{policyName}"] = args["policyName"],
    }
    local header_args = { 
        ["x-amzn-iot-principal"] = args["principal"],
    }
	local all_args = { 
		["policyName"] = args["policyName"],
		["principal"] = args["principal"],
	}
	asserts.AssertDetachPrincipalPolicyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EnableTopicRuleRequest = { ["ruleName"] = true, nil }

function asserts.AssertEnableTopicRuleRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableTopicRuleRequest to be of type 'table'")
	assert(struct["ruleName"], "Expected key ruleName to exist in table")
	if struct["ruleName"] then asserts.AssertRuleName(struct["ruleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableTopicRuleRequest[k], "EnableTopicRuleRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableTopicRuleRequest
-- <p>The input for the EnableTopicRuleRequest operation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ruleName [RuleName] <p>The name of the topic rule to enable.</p>
-- Required key: ruleName
-- @return EnableTopicRuleRequest structure as a key-value pair table
function M.EnableTopicRuleRequest(args)
	assert(args, "You must provide an argument table when creating EnableTopicRuleRequest")
    local query_args = { 
    }
    local uri_args = { 
        ["{ruleName}"] = args["ruleName"],
    }
    local header_args = { 
    }
	local all_args = { 
		["ruleName"] = args["ruleName"],
	}
	asserts.AssertEnableTopicRuleRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

function asserts.AssertBehaviorMetric(str)
	assert(str)
	assert(type(str) == "string", "Expected BehaviorMetric to be of type 'string'")
end

--  
function M.BehaviorMetric(str)
	asserts.AssertBehaviorMetric(str)
	return str
end

function asserts.AssertInlineDocument(str)
	assert(str)
	assert(type(str) == "string", "Expected InlineDocument to be of type 'string'")
end

--  
function M.InlineDocument(str)
	asserts.AssertInlineDocument(str)
	return str
end

function asserts.AssertPrincipalId(str)
	assert(str)
	assert(type(str) == "string", "Expected PrincipalId to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PrincipalId(str)
	asserts.AssertPrincipalId(str)
	return str
end

function asserts.AssertKeyValue(str)
	assert(str)
	assert(type(str) == "string", "Expected KeyValue to be of type 'string'")
	assert(#str <= 5120, "Expected string to be max 5120 characters")
end

--  
function M.KeyValue(str)
	asserts.AssertKeyValue(str)
	return str
end

function asserts.AssertPolicyDocument(str)
	assert(str)
	assert(type(str) == "string", "Expected PolicyDocument to be of type 'string'")
end

--  
function M.PolicyDocument(str)
	asserts.AssertPolicyDocument(str)
	return str
end

function asserts.AssertStateMachineName(str)
	assert(str)
	assert(type(str) == "string", "Expected StateMachineName to be of type 'string'")
end

--  
function M.StateMachineName(str)
	asserts.AssertStateMachineName(str)
	return str
end

function asserts.AssertCertificateId(str)
	assert(str)
	assert(type(str) == "string", "Expected CertificateId to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 64, "Expected string to be min 64 characters")
end

--  
function M.CertificateId(str)
	asserts.AssertCertificateId(str)
	return str
end

function asserts.AssertMessageFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected MessageFormat to be of type 'string'")
end

--  
function M.MessageFormat(str)
	asserts.AssertMessageFormat(str)
	return str
end

function asserts.AssertAwsIotJobArn(str)
	assert(str)
	assert(type(str) == "string", "Expected AwsIotJobArn to be of type 'string'")
end

--  
function M.AwsIotJobArn(str)
	asserts.AssertAwsIotJobArn(str)
	return str
end

function asserts.AssertPartitionKey(str)
	assert(str)
	assert(type(str) == "string", "Expected PartitionKey to be of type 'string'")
end

--  
function M.PartitionKey(str)
	asserts.AssertPartitionKey(str)
	return str
end

function asserts.AssertBucketName(str)
	assert(str)
	assert(type(str) == "string", "Expected BucketName to be of type 'string'")
end

--  
function M.BucketName(str)
	asserts.AssertBucketName(str)
	return str
end

function asserts.AssertDayOfMonth(str)
	assert(str)
	assert(type(str) == "string", "Expected DayOfMonth to be of type 'string'")
end

--  
function M.DayOfMonth(str)
	asserts.AssertDayOfMonth(str)
	return str
end

function asserts.AssertAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected AttributeName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
end

--  
function M.AttributeName(str)
	asserts.AssertAttributeName(str)
	return str
end

function asserts.AssertAuthorizerFunctionArn(str)
	assert(str)
	assert(type(str) == "string", "Expected AuthorizerFunctionArn to be of type 'string'")
end

--  
function M.AuthorizerFunctionArn(str)
	asserts.AssertAuthorizerFunctionArn(str)
	return str
end

function asserts.AssertDayOfWeek(str)
	assert(str)
	assert(type(str) == "string", "Expected DayOfWeek to be of type 'string'")
end

--  
function M.DayOfWeek(str)
	asserts.AssertDayOfWeek(str)
	return str
end

function asserts.AssertThingArn(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingArn to be of type 'string'")
end

--  
function M.ThingArn(str)
	asserts.AssertThingArn(str)
	return str
end

function asserts.AssertTableName(str)
	assert(str)
	assert(type(str) == "string", "Expected TableName to be of type 'string'")
end

--  
function M.TableName(str)
	asserts.AssertTableName(str)
	return str
end

function asserts.AssertResourceArn(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceArn to be of type 'string'")
end

--  
function M.ResourceArn(str)
	asserts.AssertResourceArn(str)
	return str
end

function asserts.AssertReportType(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportType to be of type 'string'")
end

--  
function M.ReportType(str)
	asserts.AssertReportType(str)
	return str
end

function asserts.AssertCertificateArn(str)
	assert(str)
	assert(type(str) == "string", "Expected CertificateArn to be of type 'string'")
end

--  
function M.CertificateArn(str)
	asserts.AssertCertificateArn(str)
	return str
end

function asserts.AssertElasticsearchEndpoint(str)
	assert(str)
	assert(type(str) == "string", "Expected ElasticsearchEndpoint to be of type 'string'")
end

--  
function M.ElasticsearchEndpoint(str)
	asserts.AssertElasticsearchEndpoint(str)
	return str
end

function asserts.AssertStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected Status to be of type 'string'")
end

--  
function M.Status(str)
	asserts.AssertStatus(str)
	return str
end

function asserts.AssertJobArn(str)
	assert(str)
	assert(type(str) == "string", "Expected JobArn to be of type 'string'")
end

--  
function M.JobArn(str)
	asserts.AssertJobArn(str)
	return str
end

function asserts.AssertOTAUpdateId(str)
	assert(str)
	assert(type(str) == "string", "Expected OTAUpdateId to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.OTAUpdateId(str)
	asserts.AssertOTAUpdateId(str)
	return str
end

function asserts.AssertComment(str)
	assert(str)
	assert(type(str) == "string", "Expected Comment to be of type 'string'")
	assert(#str <= 2028, "Expected string to be max 2028 characters")
end

--  
function M.Comment(str)
	asserts.AssertComment(str)
	return str
end

function asserts.AssertAlertTargetArn(str)
	assert(str)
	assert(type(str) == "string", "Expected AlertTargetArn to be of type 'string'")
end

--  
function M.AlertTargetArn(str)
	asserts.AssertAlertTargetArn(str)
	return str
end

function asserts.AssertScheduledAuditName(str)
	assert(str)
	assert(type(str) == "string", "Expected ScheduledAuditName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ScheduledAuditName(str)
	asserts.AssertScheduledAuditName(str)
	return str
end

function asserts.AssertS3Key(str)
	assert(str)
	assert(type(str) == "string", "Expected S3Key to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.S3Key(str)
	asserts.AssertS3Key(str)
	return str
end

function asserts.AssertAlarmName(str)
	assert(str)
	assert(type(str) == "string", "Expected AlarmName to be of type 'string'")
end

--  
function M.AlarmName(str)
	asserts.AssertAlarmName(str)
	return str
end

function asserts.AssertIndexStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected IndexStatus to be of type 'string'")
end

--  
function M.IndexStatus(str)
	asserts.AssertIndexStatus(str)
	return str
end

function asserts.AssertStreamName(str)
	assert(str)
	assert(type(str) == "string", "Expected StreamName to be of type 'string'")
end

--  
function M.StreamName(str)
	asserts.AssertStreamName(str)
	return str
end

function asserts.AssertBehaviorName(str)
	assert(str)
	assert(type(str) == "string", "Expected BehaviorName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.BehaviorName(str)
	asserts.AssertBehaviorName(str)
	return str
end

function asserts.AssertRoleArn(str)
	assert(str)
	assert(type(str) == "string", "Expected RoleArn to be of type 'string'")
	assert(#str <= 2048, "Expected string to be max 2048 characters")
	assert(#str >= 20, "Expected string to be min 20 characters")
end

--  
function M.RoleArn(str)
	asserts.AssertRoleArn(str)
	return str
end

function asserts.AssertFileName(str)
	assert(str)
	assert(type(str) == "string", "Expected FileName to be of type 'string'")
end

--  
function M.FileName(str)
	asserts.AssertFileName(str)
	return str
end

function asserts.AssertAuthorizerStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AuthorizerStatus to be of type 'string'")
end

--  
function M.AuthorizerStatus(str)
	asserts.AssertAuthorizerStatus(str)
	return str
end

function asserts.AssertSigningJobId(str)
	assert(str)
	assert(type(str) == "string", "Expected SigningJobId to be of type 'string'")
end

--  
function M.SigningJobId(str)
	asserts.AssertSigningJobId(str)
	return str
end

function asserts.AssertCidr(str)
	assert(str)
	assert(type(str) == "string", "Expected Cidr to be of type 'string'")
	assert(#str <= 43, "Expected string to be max 43 characters")
	assert(#str >= 2, "Expected string to be min 2 characters")
end

--  
function M.Cidr(str)
	asserts.AssertCidr(str)
	return str
end

function asserts.AssertOTAUpdateDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected OTAUpdateDescription to be of type 'string'")
	assert(#str <= 2028, "Expected string to be max 2028 characters")
end

--  
function M.OTAUpdateDescription(str)
	asserts.AssertOTAUpdateDescription(str)
	return str
end

function asserts.AssertSecurityProfileName(str)
	assert(str)
	assert(type(str) == "string", "Expected SecurityProfileName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.SecurityProfileName(str)
	asserts.AssertSecurityProfileName(str)
	return str
end

function asserts.AssertChannelName(str)
	assert(str)
	assert(type(str) == "string", "Expected ChannelName to be of type 'string'")
end

--  
function M.ChannelName(str)
	asserts.AssertChannelName(str)
	return str
end

function asserts.AssertAuditNotificationType(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditNotificationType to be of type 'string'")
end

--  
function M.AuditNotificationType(str)
	asserts.AssertAuditNotificationType(str)
	return str
end

function asserts.AssertAuditTaskStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditTaskStatus to be of type 'string'")
end

--  
function M.AuditTaskStatus(str)
	asserts.AssertAuditTaskStatus(str)
	return str
end

function asserts.AssertScheduledAuditArn(str)
	assert(str)
	assert(type(str) == "string", "Expected ScheduledAuditArn to be of type 'string'")
end

--  
function M.ScheduledAuditArn(str)
	asserts.AssertScheduledAuditArn(str)
	return str
end

function asserts.AssertSigningProfileName(str)
	assert(str)
	assert(type(str) == "string", "Expected SigningProfileName to be of type 'string'")
end

--  
function M.SigningProfileName(str)
	asserts.AssertSigningProfileName(str)
	return str
end

function asserts.AssertAutoRegistrationStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AutoRegistrationStatus to be of type 'string'")
end

--  
function M.AutoRegistrationStatus(str)
	asserts.AssertAutoRegistrationStatus(str)
	return str
end

function asserts.AssertStateValue(str)
	assert(str)
	assert(type(str) == "string", "Expected StateValue to be of type 'string'")
end

--  
function M.StateValue(str)
	asserts.AssertStateValue(str)
	return str
end

function asserts.AssertKeyName(str)
	assert(str)
	assert(type(str) == "string", "Expected KeyName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.KeyName(str)
	asserts.AssertKeyName(str)
	return str
end

function asserts.AssertActionType(str)
	assert(str)
	assert(type(str) == "string", "Expected ActionType to be of type 'string'")
end

--  
function M.ActionType(str)
	asserts.AssertActionType(str)
	return str
end

function asserts.AssertPolicyVersionId(str)
	assert(str)
	assert(type(str) == "string", "Expected PolicyVersionId to be of type 'string'")
end

--  
function M.PolicyVersionId(str)
	asserts.AssertPolicyVersionId(str)
	return str
end

function asserts.AssertAuditTaskId(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditTaskId to be of type 'string'")
	assert(#str <= 40, "Expected string to be max 40 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AuditTaskId(str)
	asserts.AssertAuditTaskId(str)
	return str
end

function asserts.AssertAuditCheckName(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditCheckName to be of type 'string'")
end

-- <p>An audit check name. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
function M.AuditCheckName(str)
	asserts.AssertAuditCheckName(str)
	return str
end

function asserts.AssertMissingContextValue(str)
	assert(str)
	assert(type(str) == "string", "Expected MissingContextValue to be of type 'string'")
end

--  
function M.MissingContextValue(str)
	asserts.AssertMissingContextValue(str)
	return str
end

function asserts.AssertS3FileUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected S3FileUrl to be of type 'string'")
	assert(#str <= 65535, "Expected string to be max 65535 characters")
end

--  
function M.S3FileUrl(str)
	asserts.AssertS3FileUrl(str)
	return str
end

function asserts.AssertStreamDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected StreamDescription to be of type 'string'")
	assert(#str <= 2028, "Expected string to be max 2028 characters")
end

--  
function M.StreamDescription(str)
	asserts.AssertStreamDescription(str)
	return str
end

function asserts.AssertAttributeValue(str)
	assert(str)
	assert(type(str) == "string", "Expected AttributeValue to be of type 'string'")
	assert(#str <= 800, "Expected string to be max 800 characters")
end

--  
function M.AttributeValue(str)
	asserts.AssertAttributeValue(str)
	return str
end

function asserts.AssertReasonForNonComplianceCode(str)
	assert(str)
	assert(type(str) == "string", "Expected ReasonForNonComplianceCode to be of type 'string'")
end

--  
function M.ReasonForNonComplianceCode(str)
	asserts.AssertReasonForNonComplianceCode(str)
	return str
end

function asserts.AssertCertificateName(str)
	assert(str)
	assert(type(str) == "string", "Expected CertificateName to be of type 'string'")
end

--  
function M.CertificateName(str)
	asserts.AssertCertificateName(str)
	return str
end

function asserts.AssertPlatform(str)
	assert(str)
	assert(type(str) == "string", "Expected Platform to be of type 'string'")
end

--  
function M.Platform(str)
	asserts.AssertPlatform(str)
	return str
end

function asserts.AssertAlertTargetType(str)
	assert(str)
	assert(type(str) == "string", "Expected AlertTargetType to be of type 'string'")
end

-- <p>The type of alert target: one of "SNS".</p>
function M.AlertTargetType(str)
	asserts.AssertAlertTargetType(str)
	return str
end

function asserts.AssertDeliveryStreamName(str)
	assert(str)
	assert(type(str) == "string", "Expected DeliveryStreamName to be of type 'string'")
end

--  
function M.DeliveryStreamName(str)
	asserts.AssertDeliveryStreamName(str)
	return str
end

function asserts.AssertTokenKeyName(str)
	assert(str)
	assert(type(str) == "string", "Expected TokenKeyName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.TokenKeyName(str)
	asserts.AssertTokenKeyName(str)
	return str
end

function asserts.AssertKey(str)
	assert(str)
	assert(type(str) == "string", "Expected Key to be of type 'string'")
end

--  
function M.Key(str)
	asserts.AssertKey(str)
	return str
end

function asserts.AssertAwsIotSqlVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected AwsIotSqlVersion to be of type 'string'")
end

--  
function M.AwsIotSqlVersion(str)
	asserts.AssertAwsIotSqlVersion(str)
	return str
end

function asserts.AssertThingId(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingId to be of type 'string'")
end

--  
function M.ThingId(str)
	asserts.AssertThingId(str)
	return str
end

function asserts.AssertCognitoIdentityPoolId(str)
	assert(str)
	assert(type(str) == "string", "Expected CognitoIdentityPoolId to be of type 'string'")
end

--  
function M.CognitoIdentityPoolId(str)
	asserts.AssertCognitoIdentityPoolId(str)
	return str
end

function asserts.AssertS3Bucket(str)
	assert(str)
	assert(type(str) == "string", "Expected S3Bucket to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.S3Bucket(str)
	asserts.AssertS3Bucket(str)
	return str
end

function asserts.AssertErrorMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected ErrorMessage to be of type 'string'")
	assert(#str <= 2048, "Expected string to be max 2048 characters")
end

--  
function M.ErrorMessage(str)
	asserts.AssertErrorMessage(str)
	return str
end

function asserts.AssertLogTargetType(str)
	assert(str)
	assert(type(str) == "string", "Expected LogTargetType to be of type 'string'")
end

--  
function M.LogTargetType(str)
	asserts.AssertLogTargetType(str)
	return str
end

function asserts.AssertAuditFindingSeverity(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditFindingSeverity to be of type 'string'")
end

--  
function M.AuditFindingSeverity(str)
	asserts.AssertAuditFindingSeverity(str)
	return str
end

function asserts.AssertAuditTaskType(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditTaskType to be of type 'string'")
end

--  
function M.AuditTaskType(str)
	asserts.AssertAuditTaskType(str)
	return str
end

function asserts.AssertDetailsValue(str)
	assert(str)
	assert(type(str) == "string", "Expected DetailsValue to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.DetailsValue(str)
	asserts.AssertDetailsValue(str)
	return str
end

function asserts.AssertAuditCheckRunStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditCheckRunStatus to be of type 'string'")
end

--  
function M.AuditCheckRunStatus(str)
	asserts.AssertAuditCheckRunStatus(str)
	return str
end

function asserts.AssertSalesforceToken(str)
	assert(str)
	assert(type(str) == "string", "Expected SalesforceToken to be of type 'string'")
	assert(#str >= 40, "Expected string to be min 40 characters")
end

--  
function M.SalesforceToken(str)
	asserts.AssertSalesforceToken(str)
	return str
end

function asserts.AssertTargetArn(str)
	assert(str)
	assert(type(str) == "string", "Expected TargetArn to be of type 'string'")
end

--  
function M.TargetArn(str)
	asserts.AssertTargetArn(str)
	return str
end

function asserts.AssertHashAlgorithm(str)
	assert(str)
	assert(type(str) == "string", "Expected HashAlgorithm to be of type 'string'")
end

--  
function M.HashAlgorithm(str)
	asserts.AssertHashAlgorithm(str)
	return str
end

function asserts.AssertLogLevel(str)
	assert(str)
	assert(type(str) == "string", "Expected LogLevel to be of type 'string'")
end

--  
function M.LogLevel(str)
	asserts.AssertLogLevel(str)
	return str
end

function asserts.AssertJsonDocument(str)
	assert(str)
	assert(type(str) == "string", "Expected JsonDocument to be of type 'string'")
end

--  
function M.JsonDocument(str)
	asserts.AssertJsonDocument(str)
	return str
end

function asserts.AssertThingGroupArn(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingGroupArn to be of type 'string'")
end

--  
function M.ThingGroupArn(str)
	asserts.AssertThingGroupArn(str)
	return str
end

function asserts.AssertRangeKeyValue(str)
	assert(str)
	assert(type(str) == "string", "Expected RangeKeyValue to be of type 'string'")
end

--  
function M.RangeKeyValue(str)
	asserts.AssertRangeKeyValue(str)
	return str
end

function asserts.AssertCode(str)
	assert(str)
	assert(type(str) == "string", "Expected Code to be of type 'string'")
end

--  
function M.Code(str)
	asserts.AssertCode(str)
	return str
end

function asserts.AssertQueueUrl(str)
	assert(str)
	assert(type(str) == "string", "Expected QueueUrl to be of type 'string'")
end

--  
function M.QueueUrl(str)
	asserts.AssertQueueUrl(str)
	return str
end

function asserts.AssertPrivateKey(str)
	assert(str)
	assert(type(str) == "string", "Expected PrivateKey to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PrivateKey(str)
	asserts.AssertPrivateKey(str)
	return str
end

function asserts.AssertJobDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected JobDescription to be of type 'string'")
	assert(#str <= 2028, "Expected string to be max 2028 characters")
end

--  
function M.JobDescription(str)
	asserts.AssertJobDescription(str)
	return str
end

function asserts.AssertErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected ErrorCode to be of type 'string'")
end

--  
function M.ErrorCode(str)
	asserts.AssertErrorCode(str)
	return str
end

function asserts.AssertFirehoseSeparator(str)
	assert(str)
	assert(type(str) == "string", "Expected FirehoseSeparator to be of type 'string'")
end

--  
function M.FirehoseSeparator(str)
	asserts.AssertFirehoseSeparator(str)
	return str
end

function asserts.AssertQueryVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected QueryVersion to be of type 'string'")
end

--  
function M.QueryVersion(str)
	asserts.AssertQueryVersion(str)
	return str
end

function asserts.AssertCACertificateStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected CACertificateStatus to be of type 'string'")
end

--  
function M.CACertificateStatus(str)
	asserts.AssertCACertificateStatus(str)
	return str
end

function asserts.AssertStateReason(str)
	assert(str)
	assert(type(str) == "string", "Expected StateReason to be of type 'string'")
end

--  
function M.StateReason(str)
	asserts.AssertStateReason(str)
	return str
end

function asserts.AssertThingGroupName(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingGroupName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ThingGroupName(str)
	asserts.AssertThingGroupName(str)
	return str
end

function asserts.AssertRoleAlias(str)
	assert(str)
	assert(type(str) == "string", "Expected RoleAlias to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.RoleAlias(str)
	asserts.AssertRoleAlias(str)
	return str
end

function asserts.AssertTaskId(str)
	assert(str)
	assert(type(str) == "string", "Expected TaskId to be of type 'string'")
	assert(#str <= 40, "Expected string to be max 40 characters")
end

--  
function M.TaskId(str)
	asserts.AssertTaskId(str)
	return str
end

function asserts.AssertRuleName(str)
	assert(str)
	assert(type(str) == "string", "Expected RuleName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.RuleName(str)
	asserts.AssertRuleName(str)
	return str
end

function asserts.AssertElasticsearchIndex(str)
	assert(str)
	assert(type(str) == "string", "Expected ElasticsearchIndex to be of type 'string'")
end

--  
function M.ElasticsearchIndex(str)
	asserts.AssertElasticsearchIndex(str)
	return str
end

function asserts.AssertResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceType to be of type 'string'")
end

--  
function M.ResourceType(str)
	asserts.AssertResourceType(str)
	return str
end

function asserts.AssertAuthorizerName(str)
	assert(str)
	assert(type(str) == "string", "Expected AuthorizerName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.AuthorizerName(str)
	asserts.AssertAuthorizerName(str)
	return str
end

function asserts.AssertViolationId(str)
	assert(str)
	assert(type(str) == "string", "Expected ViolationId to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ViolationId(str)
	asserts.AssertViolationId(str)
	return str
end

function asserts.AssertTokenSignature(str)
	assert(str)
	assert(type(str) == "string", "Expected TokenSignature to be of type 'string'")
	assert(#str <= 2560, "Expected string to be max 2560 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.TokenSignature(str)
	asserts.AssertTokenSignature(str)
	return str
end

function asserts.AssertAuditFrequency(str)
	assert(str)
	assert(type(str) == "string", "Expected AuditFrequency to be of type 'string'")
end

--  
function M.AuditFrequency(str)
	asserts.AssertAuditFrequency(str)
	return str
end

function asserts.AssertOTAUpdateErrorMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected OTAUpdateErrorMessage to be of type 'string'")
end

--  
function M.OTAUpdateErrorMessage(str)
	asserts.AssertOTAUpdateErrorMessage(str)
	return str
end

function asserts.AssertEndpointAddress(str)
	assert(str)
	assert(type(str) == "string", "Expected EndpointAddress to be of type 'string'")
end

--  
function M.EndpointAddress(str)
	asserts.AssertEndpointAddress(str)
	return str
end

function asserts.AssertPolicyTarget(str)
	assert(str)
	assert(type(str) == "string", "Expected PolicyTarget to be of type 'string'")
end

--  
function M.PolicyTarget(str)
	asserts.AssertPolicyTarget(str)
	return str
end

function asserts.AssertValue(str)
	assert(str)
	assert(type(str) == "string", "Expected Value to be of type 'string'")
end

--  
function M.Value(str)
	asserts.AssertValue(str)
	return str
end

function asserts.AssertCertificatePem(str)
	assert(str)
	assert(type(str) == "string", "Expected CertificatePem to be of type 'string'")
	assert(#str <= 65536, "Expected string to be max 65536 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

-- <p>The PEM of a certificate.</p>
function M.CertificatePem(str)
	asserts.AssertCertificatePem(str)
	return str
end

function asserts.AssertDynamoKeyType(str)
	assert(str)
	assert(type(str) == "string", "Expected DynamoKeyType to be of type 'string'")
end

--  
function M.DynamoKeyType(str)
	asserts.AssertDynamoKeyType(str)
	return str
end

function asserts.AssertElasticsearchId(str)
	assert(str)
	assert(type(str) == "string", "Expected ElasticsearchId to be of type 'string'")
end

--  
function M.ElasticsearchId(str)
	asserts.AssertElasticsearchId(str)
	return str
end

function asserts.AssertStreamId(str)
	assert(str)
	assert(type(str) == "string", "Expected StreamId to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.StreamId(str)
	asserts.AssertStreamId(str)
	return str
end

function asserts.AssertHashKeyField(str)
	assert(str)
	assert(type(str) == "string", "Expected HashKeyField to be of type 'string'")
end

--  
function M.HashKeyField(str)
	asserts.AssertHashKeyField(str)
	return str
end

function asserts.AssertJobId(str)
	assert(str)
	assert(type(str) == "string", "Expected JobId to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.JobId(str)
	asserts.AssertJobId(str)
	return str
end

function asserts.AssertTarget(str)
	assert(str)
	assert(type(str) == "string", "Expected Target to be of type 'string'")
end

--  
function M.Target(str)
	asserts.AssertTarget(str)
	return str
end

function asserts.AssertJobStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected JobStatus to be of type 'string'")
end

--  
function M.JobStatus(str)
	asserts.AssertJobStatus(str)
	return str
end

function asserts.AssertRangeKeyField(str)
	assert(str)
	assert(type(str) == "string", "Expected RangeKeyField to be of type 'string'")
end

--  
function M.RangeKeyField(str)
	asserts.AssertRangeKeyField(str)
	return str
end

function asserts.AssertSecurityProfileArn(str)
	assert(str)
	assert(type(str) == "string", "Expected SecurityProfileArn to be of type 'string'")
end

--  
function M.SecurityProfileArn(str)
	asserts.AssertSecurityProfileArn(str)
	return str
end

function asserts.AssertRoleAliasArn(str)
	assert(str)
	assert(type(str) == "string", "Expected RoleAliasArn to be of type 'string'")
end

--  
function M.RoleAliasArn(str)
	asserts.AssertRoleAliasArn(str)
	return str
end

function asserts.AssertResourceLogicalId(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceLogicalId to be of type 'string'")
end

--  
function M.ResourceLogicalId(str)
	asserts.AssertResourceLogicalId(str)
	return str
end

function asserts.AssertRegistryS3BucketName(str)
	assert(str)
	assert(type(str) == "string", "Expected RegistryS3BucketName to be of type 'string'")
	assert(#str <= 256, "Expected string to be max 256 characters")
	assert(#str >= 3, "Expected string to be min 3 characters")
end

--  
function M.RegistryS3BucketName(str)
	asserts.AssertRegistryS3BucketName(str)
	return str
end

function asserts.AssertProcessingTargetName(str)
	assert(str)
	assert(type(str) == "string", "Expected ProcessingTargetName to be of type 'string'")
end

--  
function M.ProcessingTargetName(str)
	asserts.AssertProcessingTargetName(str)
	return str
end

function asserts.AssertThingGroupIndexingMode(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingGroupIndexingMode to be of type 'string'")
end

--  
function M.ThingGroupIndexingMode(str)
	asserts.AssertThingGroupIndexingMode(str)
	return str
end

function asserts.AssertEndpointType(str)
	assert(str)
	assert(type(str) == "string", "Expected EndpointType to be of type 'string'")
end

--  
function M.EndpointType(str)
	asserts.AssertEndpointType(str)
	return str
end

function asserts.AssertThingTypeDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingTypeDescription to be of type 'string'")
	assert(#str <= 2028, "Expected string to be max 2028 characters")
end

--  
function M.ThingTypeDescription(str)
	asserts.AssertThingTypeDescription(str)
	return str
end

function asserts.AssertJobDocument(str)
	assert(str)
	assert(type(str) == "string", "Expected JobDocument to be of type 'string'")
	assert(#str <= 32768, "Expected string to be max 32768 characters")
end

--  
function M.JobDocument(str)
	asserts.AssertJobDocument(str)
	return str
end

function asserts.AssertAwsIotJobId(str)
	assert(str)
	assert(type(str) == "string", "Expected AwsIotJobId to be of type 'string'")
end

--  
function M.AwsIotJobId(str)
	asserts.AssertAwsIotJobId(str)
	return str
end

function asserts.AssertCannedAccessControlList(str)
	assert(str)
	assert(type(str) == "string", "Expected CannedAccessControlList to be of type 'string'")
end

--  
function M.CannedAccessControlList(str)
	asserts.AssertCannedAccessControlList(str)
	return str
end

function asserts.AssertThingTypeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingTypeName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ThingTypeName(str)
	asserts.AssertThingTypeName(str)
	return str
end

function asserts.AssertMarker(str)
	assert(str)
	assert(type(str) == "string", "Expected Marker to be of type 'string'")
end

--  
function M.Marker(str)
	asserts.AssertMarker(str)
	return str
end

function asserts.AssertDetailsKey(str)
	assert(str)
	assert(type(str) == "string", "Expected DetailsKey to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.DetailsKey(str)
	asserts.AssertDetailsKey(str)
	return str
end

function asserts.AssertPolicyName(str)
	assert(str)
	assert(type(str) == "string", "Expected PolicyName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PolicyName(str)
	asserts.AssertPolicyName(str)
	return str
end

function asserts.AssertClientId(str)
	assert(str)
	assert(type(str) == "string", "Expected ClientId to be of type 'string'")
end

--  
function M.ClientId(str)
	asserts.AssertClientId(str)
	return str
end

function asserts.AssertSignatureAlgorithm(str)
	assert(str)
	assert(type(str) == "string", "Expected SignatureAlgorithm to be of type 'string'")
end

--  
function M.SignatureAlgorithm(str)
	asserts.AssertSignatureAlgorithm(str)
	return str
end

function asserts.AssertOTAUpdateArn(str)
	assert(str)
	assert(type(str) == "string", "Expected OTAUpdateArn to be of type 'string'")
end

--  
function M.OTAUpdateArn(str)
	asserts.AssertOTAUpdateArn(str)
	return str
end

function asserts.AssertThingName(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ThingName(str)
	asserts.AssertThingName(str)
	return str
end

function asserts.AssertResource(str)
	assert(str)
	assert(type(str) == "string", "Expected Resource to be of type 'string'")
end

--  
function M.Resource(str)
	asserts.AssertResource(str)
	return str
end

function asserts.AssertThingGroupId(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingGroupId to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.ThingGroupId(str)
	asserts.AssertThingGroupId(str)
	return str
end

function asserts.AssertRegistryS3KeyName(str)
	assert(str)
	assert(type(str) == "string", "Expected RegistryS3KeyName to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.RegistryS3KeyName(str)
	asserts.AssertRegistryS3KeyName(str)
	return str
end

function asserts.AssertHashKeyValue(str)
	assert(str)
	assert(type(str) == "string", "Expected HashKeyValue to be of type 'string'")
end

--  
function M.HashKeyValue(str)
	asserts.AssertHashKeyValue(str)
	return str
end

function asserts.AssertPayloadField(str)
	assert(str)
	assert(type(str) == "string", "Expected PayloadField to be of type 'string'")
end

--  
function M.PayloadField(str)
	asserts.AssertPayloadField(str)
	return str
end

function asserts.AssertThingTypeArn(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingTypeArn to be of type 'string'")
end

--  
function M.ThingTypeArn(str)
	asserts.AssertThingTypeArn(str)
	return str
end

function asserts.AssertPublicKey(str)
	assert(str)
	assert(type(str) == "string", "Expected PublicKey to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.PublicKey(str)
	asserts.AssertPublicKey(str)
	return str
end

function asserts.AssertTopicPattern(str)
	assert(str)
	assert(type(str) == "string", "Expected TopicPattern to be of type 'string'")
end

--  
function M.TopicPattern(str)
	asserts.AssertTopicPattern(str)
	return str
end

function asserts.AssertTargetSelection(str)
	assert(str)
	assert(type(str) == "string", "Expected TargetSelection to be of type 'string'")
end

--  
function M.TargetSelection(str)
	asserts.AssertTargetSelection(str)
	return str
end

function asserts.AssertAttributeKey(str)
	assert(str)
	assert(type(str) == "string", "Expected AttributeKey to be of type 'string'")
end

--  
function M.AttributeKey(str)
	asserts.AssertAttributeKey(str)
	return str
end

function asserts.AssertJobDocumentSource(str)
	assert(str)
	assert(type(str) == "string", "Expected JobDocumentSource to be of type 'string'")
	assert(#str <= 1350, "Expected string to be max 1350 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.JobDocumentSource(str)
	asserts.AssertJobDocumentSource(str)
	return str
end

function asserts.AssertPrincipalArn(str)
	assert(str)
	assert(type(str) == "string", "Expected PrincipalArn to be of type 'string'")
end

--  
function M.PrincipalArn(str)
	asserts.AssertPrincipalArn(str)
	return str
end

function asserts.AssertCertificateSigningRequest(str)
	assert(str)
	assert(type(str) == "string", "Expected CertificateSigningRequest to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.CertificateSigningRequest(str)
	asserts.AssertCertificateSigningRequest(str)
	return str
end

function asserts.AssertToken(str)
	assert(str)
	assert(type(str) == "string", "Expected Token to be of type 'string'")
	assert(#str <= 6144, "Expected string to be max 6144 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.Token(str)
	asserts.AssertToken(str)
	return str
end

function asserts.AssertJobExecutionStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected JobExecutionStatus to be of type 'string'")
end

--  
function M.JobExecutionStatus(str)
	asserts.AssertJobExecutionStatus(str)
	return str
end

function asserts.AssertGenerationId(str)
	assert(str)
	assert(type(str) == "string", "Expected GenerationId to be of type 'string'")
end

--  
function M.GenerationId(str)
	asserts.AssertGenerationId(str)
	return str
end

function asserts.AssertTopic(str)
	assert(str)
	assert(type(str) == "string", "Expected Topic to be of type 'string'")
end

--  
function M.Topic(str)
	asserts.AssertTopic(str)
	return str
end

function asserts.AssertViolationEventType(str)
	assert(str)
	assert(type(str) == "string", "Expected ViolationEventType to be of type 'string'")
end

--  
function M.ViolationEventType(str)
	asserts.AssertViolationEventType(str)
	return str
end

function asserts.AssertSecurityProfileDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected SecurityProfileDescription to be of type 'string'")
	assert(#str <= 1000, "Expected string to be max 1000 characters")
end

--  
function M.SecurityProfileDescription(str)
	asserts.AssertSecurityProfileDescription(str)
	return str
end

function asserts.AssertPolicyArn(str)
	assert(str)
	assert(type(str) == "string", "Expected PolicyArn to be of type 'string'")
end

--  
function M.PolicyArn(str)
	asserts.AssertPolicyArn(str)
	return str
end

function asserts.AssertOTAUpdateStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected OTAUpdateStatus to be of type 'string'")
end

--  
function M.OTAUpdateStatus(str)
	asserts.AssertOTAUpdateStatus(str)
	return str
end

function asserts.AssertString(str)
	assert(str)
	assert(type(str) == "string", "Expected String to be of type 'string'")
end

--  
function M.String(str)
	asserts.AssertString(str)
	return str
end

function asserts.AssertOTAUpdateFileVersion(str)
	assert(str)
	assert(type(str) == "string", "Expected OTAUpdateFileVersion to be of type 'string'")
end

--  
function M.OTAUpdateFileVersion(str)
	asserts.AssertOTAUpdateFileVersion(str)
	return str
end

function asserts.AssertExecutionNamePrefix(str)
	assert(str)
	assert(type(str) == "string", "Expected ExecutionNamePrefix to be of type 'string'")
end

--  
function M.ExecutionNamePrefix(str)
	asserts.AssertExecutionNamePrefix(str)
	return str
end

function asserts.AssertAuthorizerArn(str)
	assert(str)
	assert(type(str) == "string", "Expected AuthorizerArn to be of type 'string'")
end

--  
function M.AuthorizerArn(str)
	asserts.AssertAuthorizerArn(str)
	return str
end

function asserts.AssertElasticsearchType(str)
	assert(str)
	assert(type(str) == "string", "Expected ElasticsearchType to be of type 'string'")
end

--  
function M.ElasticsearchType(str)
	asserts.AssertElasticsearchType(str)
	return str
end

function asserts.AssertFunctionArn(str)
	assert(str)
	assert(type(str) == "string", "Expected FunctionArn to be of type 'string'")
end

--  
function M.FunctionArn(str)
	asserts.AssertFunctionArn(str)
	return str
end

function asserts.AssertEventType(str)
	assert(str)
	assert(type(str) == "string", "Expected EventType to be of type 'string'")
end

--  
function M.EventType(str)
	asserts.AssertEventType(str)
	return str
end

function asserts.AssertMessage(str)
	assert(str)
	assert(type(str) == "string", "Expected Message to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
end

--  
function M.Message(str)
	asserts.AssertMessage(str)
	return str
end

function asserts.AssertThingIndexingMode(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingIndexingMode to be of type 'string'")
end

--  
function M.ThingIndexingMode(str)
	asserts.AssertThingIndexingMode(str)
	return str
end

function asserts.AssertDynamoOperation(str)
	assert(str)
	assert(type(str) == "string", "Expected DynamoOperation to be of type 'string'")
end

--  
function M.DynamoOperation(str)
	asserts.AssertDynamoOperation(str)
	return str
end

function asserts.AssertSecurityProfileTargetArn(str)
	assert(str)
	assert(type(str) == "string", "Expected SecurityProfileTargetArn to be of type 'string'")
end

--  
function M.SecurityProfileTargetArn(str)
	asserts.AssertSecurityProfileTargetArn(str)
	return str
end

function asserts.AssertReasonForNonCompliance(str)
	assert(str)
	assert(type(str) == "string", "Expected ReasonForNonCompliance to be of type 'string'")
end

--  
function M.ReasonForNonCompliance(str)
	asserts.AssertReasonForNonCompliance(str)
	return str
end

function asserts.AssertLogTargetName(str)
	assert(str)
	assert(type(str) == "string", "Expected LogTargetName to be of type 'string'")
end

--  
function M.LogTargetName(str)
	asserts.AssertLogTargetName(str)
	return str
end

function asserts.AssertSalesforceEndpoint(str)
	assert(str)
	assert(type(str) == "string", "Expected SalesforceEndpoint to be of type 'string'")
	assert(#str <= 2000, "Expected string to be max 2000 characters")
end

--  
function M.SalesforceEndpoint(str)
	asserts.AssertSalesforceEndpoint(str)
	return str
end

function asserts.AssertThingTypeId(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingTypeId to be of type 'string'")
end

--  
function M.ThingTypeId(str)
	asserts.AssertThingTypeId(str)
	return str
end

function asserts.AssertRuleArn(str)
	assert(str)
	assert(type(str) == "string", "Expected RuleArn to be of type 'string'")
end

--  
function M.RuleArn(str)
	asserts.AssertRuleArn(str)
	return str
end

function asserts.AssertAwsArn(str)
	assert(str)
	assert(type(str) == "string", "Expected AwsArn to be of type 'string'")
end

--  
function M.AwsArn(str)
	asserts.AssertAwsArn(str)
	return str
end

function asserts.AssertComparisonOperator(str)
	assert(str)
	assert(type(str) == "string", "Expected ComparisonOperator to be of type 'string'")
end

--  
function M.ComparisonOperator(str)
	asserts.AssertComparisonOperator(str)
	return str
end

function asserts.AssertPrefix(str)
	assert(str)
	assert(type(str) == "string", "Expected Prefix to be of type 'string'")
end

--  
function M.Prefix(str)
	asserts.AssertPrefix(str)
	return str
end

function asserts.AssertRegistrationCode(str)
	assert(str)
	assert(type(str) == "string", "Expected RegistrationCode to be of type 'string'")
	assert(#str <= 64, "Expected string to be max 64 characters")
	assert(#str >= 64, "Expected string to be min 64 characters")
end

--  
function M.RegistrationCode(str)
	asserts.AssertRegistrationCode(str)
	return str
end

function asserts.AssertAwsAccountId(str)
	assert(str)
	assert(type(str) == "string", "Expected AwsAccountId to be of type 'string'")
	assert(#str <= 12, "Expected string to be max 12 characters")
	assert(#str >= 12, "Expected string to be min 12 characters")
end

--  
function M.AwsAccountId(str)
	asserts.AssertAwsAccountId(str)
	return str
end

function asserts.AssertNextToken(str)
	assert(str)
	assert(type(str) == "string", "Expected NextToken to be of type 'string'")
end

--  
function M.NextToken(str)
	asserts.AssertNextToken(str)
	return str
end

function asserts.AssertDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected Description to be of type 'string'")
end

--  
function M.Description(str)
	asserts.AssertDescription(str)
	return str
end

function asserts.AssertParameter(str)
	assert(str)
	assert(type(str) == "string", "Expected Parameter to be of type 'string'")
end

--  
function M.Parameter(str)
	asserts.AssertParameter(str)
	return str
end

function asserts.AssertCertificatePathOnDevice(str)
	assert(str)
	assert(type(str) == "string", "Expected CertificatePathOnDevice to be of type 'string'")
end

--  
function M.CertificatePathOnDevice(str)
	asserts.AssertCertificatePathOnDevice(str)
	return str
end

function asserts.AssertThingGroupDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected ThingGroupDescription to be of type 'string'")
	assert(#str <= 2028, "Expected string to be max 2028 characters")
end

--  
function M.ThingGroupDescription(str)
	asserts.AssertThingGroupDescription(str)
	return str
end

function asserts.AssertTemplateBody(str)
	assert(str)
	assert(type(str) == "string", "Expected TemplateBody to be of type 'string'")
end

--  
function M.TemplateBody(str)
	asserts.AssertTemplateBody(str)
	return str
end

function asserts.AssertStreamArn(str)
	assert(str)
	assert(type(str) == "string", "Expected StreamArn to be of type 'string'")
end

--  
function M.StreamArn(str)
	asserts.AssertStreamArn(str)
	return str
end

function asserts.AssertS3Version(str)
	assert(str)
	assert(type(str) == "string", "Expected S3Version to be of type 'string'")
end

--  
function M.S3Version(str)
	asserts.AssertS3Version(str)
	return str
end

function asserts.AssertIndexSchema(str)
	assert(str)
	assert(type(str) == "string", "Expected IndexSchema to be of type 'string'")
end

--  
function M.IndexSchema(str)
	asserts.AssertIndexSchema(str)
	return str
end

function asserts.AssertCertificateStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected CertificateStatus to be of type 'string'")
end

--  
function M.CertificateStatus(str)
	asserts.AssertCertificateStatus(str)
	return str
end

function asserts.AssertAuthDecision(str)
	assert(str)
	assert(type(str) == "string", "Expected AuthDecision to be of type 'string'")
end

--  
function M.AuthDecision(str)
	asserts.AssertAuthDecision(str)
	return str
end

function asserts.AssertIndexName(str)
	assert(str)
	assert(type(str) == "string", "Expected IndexName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.IndexName(str)
	asserts.AssertIndexName(str)
	return str
end

function asserts.AssertSQL(str)
	assert(str)
	assert(type(str) == "string", "Expected SQL to be of type 'string'")
end

--  
function M.SQL(str)
	asserts.AssertSQL(str)
	return str
end

function asserts.AssertQueryString(str)
	assert(str)
	assert(type(str) == "string", "Expected QueryString to be of type 'string'")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.QueryString(str)
	asserts.AssertQueryString(str)
	return str
end

function asserts.AssertPrincipal(str)
	assert(str)
	assert(type(str) == "string", "Expected Principal to be of type 'string'")
end

--  
function M.Principal(str)
	asserts.AssertPrincipal(str)
	return str
end

function asserts.AssertExpiresInSec(long)
	assert(long)
	assert(type(long) == "number", "Expected ExpiresInSec to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.ExpiresInSec(long)
	asserts.AssertExpiresInSec(long)
	return long
end

function asserts.AssertVersion(long)
	assert(long)
	assert(type(long) == "number", "Expected Version to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.Version(long)
	asserts.AssertVersion(long)
	return long
end

function asserts.AssertTotalResourcesCount(long)
	assert(long)
	assert(type(long) == "number", "Expected TotalResourcesCount to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.TotalResourcesCount(long)
	asserts.AssertTotalResourcesCount(long)
	return long
end

function asserts.AssertExecutionNumber(long)
	assert(long)
	assert(type(long) == "number", "Expected ExecutionNumber to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.ExecutionNumber(long)
	asserts.AssertExecutionNumber(long)
	return long
end

function asserts.AssertVersionNumber(long)
	assert(long)
	assert(type(long) == "number", "Expected VersionNumber to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.VersionNumber(long)
	asserts.AssertVersionNumber(long)
	return long
end

function asserts.AssertNonCompliantResourcesCount(long)
	assert(long)
	assert(type(long) == "number", "Expected NonCompliantResourcesCount to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.NonCompliantResourcesCount(long)
	asserts.AssertNonCompliantResourcesCount(long)
	return long
end

function asserts.AssertInProgressTimeoutInMinutes(long)
	assert(long)
	assert(type(long) == "number", "Expected InProgressTimeoutInMinutes to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.InProgressTimeoutInMinutes(long)
	asserts.AssertInProgressTimeoutInMinutes(long)
	return long
end

function asserts.AssertExpectedVersion(long)
	assert(long)
	assert(type(long) == "number", "Expected ExpectedVersion to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.ExpectedVersion(long)
	asserts.AssertExpectedVersion(long)
	return long
end

function asserts.AssertOptionalVersion(long)
	assert(long)
	assert(type(long) == "number", "Expected OptionalVersion to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.OptionalVersion(long)
	asserts.AssertOptionalVersion(long)
	return long
end

function asserts.AssertUnsignedLong(long)
	assert(long)
	assert(type(long) == "number", "Expected UnsignedLong to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.UnsignedLong(long)
	asserts.AssertUnsignedLong(long)
	return long
end

function asserts.AssertApproximateSecondsBeforeTimedOut(long)
	assert(long)
	assert(type(long) == "number", "Expected ApproximateSecondsBeforeTimedOut to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.ApproximateSecondsBeforeTimedOut(long)
	asserts.AssertApproximateSecondsBeforeTimedOut(long)
	return long
end

function asserts.AssertFailedThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected FailedThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.FailedThings(integer)
	asserts.AssertFailedThings(integer)
	return integer
end

function asserts.AssertCompliantChecksCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected CompliantChecksCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.CompliantChecksCount(integer)
	asserts.AssertCompliantChecksCount(integer)
	return integer
end

function asserts.AssertInProgressChecksCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected InProgressChecksCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.InProgressChecksCount(integer)
	asserts.AssertInProgressChecksCount(integer)
	return integer
end

function asserts.AssertInProgressThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected InProgressThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.InProgressThings(integer)
	asserts.AssertInProgressThings(integer)
	return integer
end

function asserts.AssertPercentage(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Percentage to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 100, "Expected integer to be max 100")
end

function M.Percentage(integer)
	asserts.AssertPercentage(integer)
	return integer
end

function asserts.AssertFailedChecksCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected FailedChecksCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.FailedChecksCount(integer)
	asserts.AssertFailedChecksCount(integer)
	return integer
end

function asserts.AssertRejectedThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected RejectedThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.RejectedThings(integer)
	asserts.AssertRejectedThings(integer)
	return integer
end

function asserts.AssertPageSize(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PageSize to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 250, "Expected integer to be max 250")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.PageSize(integer)
	asserts.AssertPageSize(integer)
	return integer
end

function asserts.AssertCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Count to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.Count(integer)
	asserts.AssertCount(integer)
	return integer
end

function asserts.AssertTimedOutThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected TimedOutThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.TimedOutThings(integer)
	asserts.AssertTimedOutThings(integer)
	return integer
end

function asserts.AssertWaitingForDataCollectionChecksCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected WaitingForDataCollectionChecksCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.WaitingForDataCollectionChecksCount(integer)
	asserts.AssertWaitingForDataCollectionChecksCount(integer)
	return integer
end

function asserts.AssertMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 250, "Expected integer to be max 250")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.MaxResults(integer)
	asserts.AssertMaxResults(integer)
	return integer
end

function asserts.AssertFileId(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected FileId to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 255, "Expected integer to be max 255")
end

function M.FileId(integer)
	asserts.AssertFileId(integer)
	return integer
end

function asserts.AssertQueuedThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected QueuedThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.QueuedThings(integer)
	asserts.AssertQueuedThings(integer)
	return integer
end

function asserts.AssertTotalChecksCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected TotalChecksCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.TotalChecksCount(integer)
	asserts.AssertTotalChecksCount(integer)
	return integer
end

function asserts.AssertSeconds(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Seconds to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.Seconds(integer)
	asserts.AssertSeconds(integer)
	return integer
end

function asserts.AssertCanceledChecksCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected CanceledChecksCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.CanceledChecksCount(integer)
	asserts.AssertCanceledChecksCount(integer)
	return integer
end

function asserts.AssertMaxJobExecutionsPerMin(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxJobExecutionsPerMin to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 1000, "Expected integer to be max 1000")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.MaxJobExecutionsPerMin(integer)
	asserts.AssertMaxJobExecutionsPerMin(integer)
	return integer
end

function asserts.AssertMaximumPerMinute(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaximumPerMinute to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 1000, "Expected integer to be max 1000")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.MaximumPerMinute(integer)
	asserts.AssertMaximumPerMinute(integer)
	return integer
end

function asserts.AssertNonCompliantChecksCount(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected NonCompliantChecksCount to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.NonCompliantChecksCount(integer)
	asserts.AssertNonCompliantChecksCount(integer)
	return integer
end

function asserts.AssertDurationSeconds(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected DurationSeconds to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.DurationSeconds(integer)
	asserts.AssertDurationSeconds(integer)
	return integer
end

function asserts.AssertCustomerVersion(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected CustomerVersion to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.CustomerVersion(integer)
	asserts.AssertCustomerVersion(integer)
	return integer
end

function asserts.AssertPort(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Port to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 65535, "Expected integer to be max 65535")
end

function M.Port(integer)
	asserts.AssertPort(integer)
	return integer
end

function asserts.AssertStreamVersion(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected StreamVersion to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 65535, "Expected integer to be max 65535")
end

function M.StreamVersion(integer)
	asserts.AssertStreamVersion(integer)
	return integer
end

function asserts.AssertSucceededThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected SucceededThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.SucceededThings(integer)
	asserts.AssertSucceededThings(integer)
	return integer
end

function asserts.AssertRegistryMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected RegistryMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 250, "Expected integer to be max 250")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.RegistryMaxResults(integer)
	asserts.AssertRegistryMaxResults(integer)
	return integer
end

function asserts.AssertCredentialDurationSeconds(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected CredentialDurationSeconds to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 3600, "Expected integer to be max 3600")
	assert(integer >= 900, "Expected integer to be min 900")
end

function M.CredentialDurationSeconds(integer)
	asserts.AssertCredentialDurationSeconds(integer)
	return integer
end

function asserts.AssertSkyfallMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected SkyfallMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 250, "Expected integer to be max 250")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.SkyfallMaxResults(integer)
	asserts.AssertSkyfallMaxResults(integer)
	return integer
end

function asserts.AssertRemovedThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected RemovedThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.RemovedThings(integer)
	asserts.AssertRemovedThings(integer)
	return integer
end

function asserts.AssertLaserMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected LaserMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 250, "Expected integer to be max 250")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.LaserMaxResults(integer)
	asserts.AssertLaserMaxResults(integer)
	return integer
end

function asserts.AssertQueryMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected QueryMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 500, "Expected integer to be max 500")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.QueryMaxResults(integer)
	asserts.AssertQueryMaxResults(integer)
	return integer
end

function asserts.AssertCanceledThings(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected CanceledThings to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.CanceledThings(integer)
	asserts.AssertCanceledThings(integer)
	return integer
end

function asserts.AssertGEMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected GEMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 10000, "Expected integer to be max 10000")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.GEMaxResults(integer)
	asserts.AssertGEMaxResults(integer)
	return integer
end

function asserts.AssertRemoveThingType(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected RemoveThingType to be of type 'boolean'")
end

function M.RemoveThingType(boolean)
	asserts.AssertRemoveThingType(boolean)
	return boolean
end

function asserts.AssertFlag(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Flag to be of type 'boolean'")
end

function M.Flag(boolean)
	asserts.AssertFlag(boolean)
	return boolean
end

function asserts.AssertSetAsActiveFlag(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected SetAsActiveFlag to be of type 'boolean'")
end

function M.SetAsActiveFlag(boolean)
	asserts.AssertSetAsActiveFlag(boolean)
	return boolean
end

function asserts.AssertForced(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Forced to be of type 'boolean'")
end

function M.Forced(boolean)
	asserts.AssertForced(boolean)
	return boolean
end

function asserts.AssertRecursiveWithoutDefault(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected RecursiveWithoutDefault to be of type 'boolean'")
end

function M.RecursiveWithoutDefault(boolean)
	asserts.AssertRecursiveWithoutDefault(boolean)
	return boolean
end

function asserts.AssertForceDelete(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected ForceDelete to be of type 'boolean'")
end

function M.ForceDelete(boolean)
	asserts.AssertForceDelete(boolean)
	return boolean
end

function asserts.AssertIsAuthenticated(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected IsAuthenticated to be of type 'boolean'")
end

function M.IsAuthenticated(boolean)
	asserts.AssertIsAuthenticated(boolean)
	return boolean
end

function asserts.AssertEnabled(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Enabled to be of type 'boolean'")
end

function M.Enabled(boolean)
	asserts.AssertEnabled(boolean)
	return boolean
end

function asserts.AssertCheckCompliant(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected CheckCompliant to be of type 'boolean'")
end

function M.CheckCompliant(boolean)
	asserts.AssertCheckCompliant(boolean)
	return boolean
end

function asserts.AssertBoolean(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Boolean to be of type 'boolean'")
end

function M.Boolean(boolean)
	asserts.AssertBoolean(boolean)
	return boolean
end

function asserts.AssertSetAsDefault(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected SetAsDefault to be of type 'boolean'")
end

function M.SetAsDefault(boolean)
	asserts.AssertSetAsDefault(boolean)
	return boolean
end

function asserts.AssertRecursive(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Recursive to be of type 'boolean'")
end

function M.Recursive(boolean)
	asserts.AssertRecursive(boolean)
	return boolean
end

function asserts.AssertIsDisabled(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected IsDisabled to be of type 'boolean'")
end

function M.IsDisabled(boolean)
	asserts.AssertIsDisabled(boolean)
	return boolean
end

function asserts.AssertDeleteStream(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected DeleteStream to be of type 'boolean'")
end

function M.DeleteStream(boolean)
	asserts.AssertDeleteStream(boolean)
	return boolean
end

function asserts.AssertRemoveAutoRegistration(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected RemoveAutoRegistration to be of type 'boolean'")
end

function M.RemoveAutoRegistration(boolean)
	asserts.AssertRemoveAutoRegistration(boolean)
	return boolean
end

function asserts.AssertSetAsActive(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected SetAsActive to be of type 'boolean'")
end

function M.SetAsActive(boolean)
	asserts.AssertSetAsActive(boolean)
	return boolean
end

function asserts.AssertDisableAllLogs(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected DisableAllLogs to be of type 'boolean'")
end

function M.DisableAllLogs(boolean)
	asserts.AssertDisableAllLogs(boolean)
	return boolean
end

function asserts.AssertAllowAutoRegistration(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected AllowAutoRegistration to be of type 'boolean'")
end

function M.AllowAutoRegistration(boolean)
	asserts.AssertAllowAutoRegistration(boolean)
	return boolean
end

function asserts.AssertUseBase64(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected UseBase64 to be of type 'boolean'")
end

function M.UseBase64(boolean)
	asserts.AssertUseBase64(boolean)
	return boolean
end

function asserts.AssertAscendingOrder(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected AscendingOrder to be of type 'boolean'")
end

function M.AscendingOrder(boolean)
	asserts.AssertAscendingOrder(boolean)
	return boolean
end

function asserts.AssertValid(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Valid to be of type 'boolean'")
end

function M.Valid(boolean)
	asserts.AssertValid(boolean)
	return boolean
end

function asserts.AssertDeleteScheduledAudits(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected DeleteScheduledAudits to be of type 'boolean'")
end

function M.DeleteScheduledAudits(boolean)
	asserts.AssertDeleteScheduledAudits(boolean)
	return boolean
end

function asserts.AssertForceDeleteAWSJob(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected ForceDeleteAWSJob to be of type 'boolean'")
end

function M.ForceDeleteAWSJob(boolean)
	asserts.AssertForceDeleteAWSJob(boolean)
	return boolean
end

function asserts.AssertIsDefaultVersion(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected IsDefaultVersion to be of type 'boolean'")
end

function M.IsDefaultVersion(boolean)
	asserts.AssertIsDefaultVersion(boolean)
	return boolean
end

function asserts.AssertForceFlag(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected ForceFlag to be of type 'boolean'")
end

function M.ForceFlag(boolean)
	asserts.AssertForceFlag(boolean)
	return boolean
end

function asserts.AssertUndoDeprecate(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected UndoDeprecate to be of type 'boolean'")
end

function M.UndoDeprecate(boolean)
	asserts.AssertUndoDeprecate(boolean)
	return boolean
end

function asserts.AssertAuditDetails(map)
	assert(map)
	assert(type(map) == "table", "Expected AuditDetails to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAuditCheckName(k)
		asserts.AssertAuditCheckDetails(v)
	end
end

function M.AuditDetails(map)
	asserts.AssertAuditDetails(map)
	return map
end

function asserts.AssertStringMap(map)
	assert(map)
	assert(type(map) == "table", "Expected StringMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertString(k)
		asserts.AssertString(v)
	end
end

function M.StringMap(map)
	asserts.AssertStringMap(map)
	return map
end

function asserts.AssertAdditionalParameterMap(map)
	assert(map)
	assert(type(map) == "table", "Expected AdditionalParameterMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAttributeKey(k)
		asserts.AssertValue(v)
	end
end

function M.AdditionalParameterMap(map)
	asserts.AssertAdditionalParameterMap(map)
	return map
end

function asserts.AssertDetailsMap(map)
	assert(map)
	assert(type(map) == "table", "Expected DetailsMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertDetailsKey(k)
		asserts.AssertDetailsValue(v)
	end
end

function M.DetailsMap(map)
	asserts.AssertDetailsMap(map)
	return map
end

function asserts.AssertEventConfigurations(map)
	assert(map)
	assert(type(map) == "table", "Expected EventConfigurations to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertEventType(k)
		asserts.AssertConfiguration(v)
	end
end

function M.EventConfigurations(map)
	asserts.AssertEventConfigurations(map)
	return map
end

function asserts.AssertResourceArns(map)
	assert(map)
	assert(type(map) == "table", "Expected ResourceArns to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertResourceLogicalId(k)
		asserts.AssertResourceArn(v)
	end
end

function M.ResourceArns(map)
	asserts.AssertResourceArns(map)
	return map
end

function asserts.AssertAttributesMap(map)
	assert(map)
	assert(type(map) == "table", "Expected AttributesMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAttributeKey(k)
		asserts.AssertValue(v)
	end
end

function M.AttributesMap(map)
	asserts.AssertAttributesMap(map)
	return map
end

function asserts.AssertAuditCheckConfigurations(map)
	assert(map)
	assert(type(map) == "table", "Expected AuditCheckConfigurations to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAuditCheckName(k)
		asserts.AssertAuditCheckConfiguration(v)
	end
end

function M.AuditCheckConfigurations(map)
	asserts.AssertAuditCheckConfigurations(map)
	return map
end

function asserts.AssertPublicKeyMap(map)
	assert(map)
	assert(type(map) == "table", "Expected PublicKeyMap to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertKeyName(k)
		asserts.AssertKeyValue(v)
	end
end

function M.PublicKeyMap(map)
	asserts.AssertPublicKeyMap(map)
	return map
end

function asserts.AssertAuditNotificationTargetConfigurations(map)
	assert(map)
	assert(type(map) == "table", "Expected AuditNotificationTargetConfigurations to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAuditNotificationType(k)
		asserts.AssertAuditNotificationTarget(v)
	end
end

function M.AuditNotificationTargetConfigurations(map)
	asserts.AssertAuditNotificationTargetConfigurations(map)
	return map
end

function asserts.AssertAttributes(map)
	assert(map)
	assert(type(map) == "table", "Expected Attributes to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAttributeName(k)
		asserts.AssertAttributeValue(v)
	end
end

function M.Attributes(map)
	asserts.AssertAttributes(map)
	return map
end

function asserts.AssertParameters(map)
	assert(map)
	assert(type(map) == "table", "Expected Parameters to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertParameter(k)
		asserts.AssertValue(v)
	end
end

function M.Parameters(map)
	asserts.AssertParameters(map)
	return map
end

function asserts.AssertAlertTargets(map)
	assert(map)
	assert(type(map) == "table", "Expected AlertTargets to be of type 'table'")
	for k,v in pairs(map) do
		asserts.AssertAlertTargetType(k)
		asserts.AssertAlertTarget(v)
	end
end

function M.AlertTargets(map)
	asserts.AssertAlertTargets(map)
	return map
end

function asserts.AssertCreatedAtDate(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected CreatedAtDate to be of type 'string'")
end

function M.CreatedAtDate(timestamp)
	asserts.AssertCreatedAtDate(timestamp)
	return timestamp
end

function asserts.AssertCreationDate(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected CreationDate to be of type 'string'")
end

function M.CreationDate(timestamp)
	asserts.AssertCreationDate(timestamp)
	return timestamp
end

function asserts.AssertTimestamp(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected Timestamp to be of type 'string'")
end

function M.Timestamp(timestamp)
	asserts.AssertTimestamp(timestamp)
	return timestamp
end

function asserts.AssertDateType(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected DateType to be of type 'string'")
end

function M.DateType(timestamp)
	asserts.AssertDateType(timestamp)
	return timestamp
end

function asserts.AssertLastModifiedDate(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected LastModifiedDate to be of type 'string'")
end

function M.LastModifiedDate(timestamp)
	asserts.AssertLastModifiedDate(timestamp)
	return timestamp
end

function asserts.AssertDeprecationDate(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected DeprecationDate to be of type 'string'")
end

function M.DeprecationDate(timestamp)
	asserts.AssertDeprecationDate(timestamp)
	return timestamp
end

function asserts.AssertSignature(blob)
	assert(blob)
	assert(type(blob) == "string", "Expected Signature to be of type 'string'")
end

function M.Signature(blob)
	asserts.AssertSignature(blob)
	return blob
end

function asserts.AssertCertificates(list)
	assert(list)
	assert(type(list) == "table", "Expected Certificates to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCertificate(v)
	end
end

--  
-- List of Certificate objects
function M.Certificates(list)
	asserts.AssertCertificates(list)
	return list
end

function asserts.AssertBehaviors(list)
	assert(list)
	assert(type(list) == "table", "Expected Behaviors to be of type ''table")
	assert(#list <= 100, "Expected list to be contain 100 elements")
	for _,v in ipairs(list) do
		asserts.AssertBehavior(v)
	end
end

--  
-- List of Behavior objects
function M.Behaviors(list)
	asserts.AssertBehaviors(list)
	return list
end

function asserts.AssertThingGroupDocumentList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingGroupDocumentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertThingGroupDocument(v)
	end
end

--  
-- List of ThingGroupDocument objects
function M.ThingGroupDocumentList(list)
	asserts.AssertThingGroupDocumentList(list)
	return list
end

function asserts.AssertViolationEvents(list)
	assert(list)
	assert(type(list) == "table", "Expected ViolationEvents to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertViolationEvent(v)
	end
end

--  
-- List of ViolationEvent objects
function M.ViolationEvents(list)
	asserts.AssertViolationEvents(list)
	return list
end

function asserts.AssertOTAUpdateFiles(list)
	assert(list)
	assert(type(list) == "table", "Expected OTAUpdateFiles to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertOTAUpdateFile(v)
	end
end

--  
-- List of OTAUpdateFile objects
function M.OTAUpdateFiles(list)
	asserts.AssertOTAUpdateFiles(list)
	return list
end

function asserts.AssertCidrs(list)
	assert(list)
	assert(type(list) == "table", "Expected Cidrs to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCidr(v)
	end
end

--  
-- List of Cidr objects
function M.Cidrs(list)
	asserts.AssertCidrs(list)
	return list
end

function asserts.AssertStreamFiles(list)
	assert(list)
	assert(type(list) == "table", "Expected StreamFiles to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertStreamFile(v)
	end
end

--  
-- List of StreamFile objects
function M.StreamFiles(list)
	asserts.AssertStreamFiles(list)
	return list
end

function asserts.AssertThingGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertThingGroupName(v)
	end
end

--  
-- List of ThingGroupName objects
function M.ThingGroupList(list)
	asserts.AssertThingGroupList(list)
	return list
end

function asserts.AssertJobExecutionSummaryForThingList(list)
	assert(list)
	assert(type(list) == "table", "Expected JobExecutionSummaryForThingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertJobExecutionSummaryForThing(v)
	end
end

--  
-- List of JobExecutionSummaryForThing objects
function M.JobExecutionSummaryForThingList(list)
	asserts.AssertJobExecutionSummaryForThingList(list)
	return list
end

function asserts.AssertPolicies(list)
	assert(list)
	assert(type(list) == "table", "Expected Policies to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPolicy(v)
	end
end

--  
-- List of Policy objects
function M.Policies(list)
	asserts.AssertPolicies(list)
	return list
end

function asserts.AssertOutgoingCertificates(list)
	assert(list)
	assert(type(list) == "table", "Expected OutgoingCertificates to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertOutgoingCertificate(v)
	end
end

--  
-- List of OutgoingCertificate objects
function M.OutgoingCertificates(list)
	asserts.AssertOutgoingCertificates(list)
	return list
end

function asserts.AssertSecurityProfileIdentifiers(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityProfileIdentifiers to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityProfileIdentifier(v)
	end
end

--  
-- List of SecurityProfileIdentifier objects
function M.SecurityProfileIdentifiers(list)
	asserts.AssertSecurityProfileIdentifiers(list)
	return list
end

function asserts.AssertPolicyTargets(list)
	assert(list)
	assert(type(list) == "table", "Expected PolicyTargets to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPolicyTarget(v)
	end
end

--  
-- List of PolicyTarget objects
function M.PolicyTargets(list)
	asserts.AssertPolicyTargets(list)
	return list
end

function asserts.AssertSecurityProfileTargets(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityProfileTargets to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityProfileTarget(v)
	end
end

--  
-- List of SecurityProfileTarget objects
function M.SecurityProfileTargets(list)
	asserts.AssertSecurityProfileTargets(list)
	return list
end

function asserts.AssertAuthResults(list)
	assert(list)
	assert(type(list) == "table", "Expected AuthResults to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAuthResult(v)
	end
end

--  
-- List of AuthResult objects
function M.AuthResults(list)
	asserts.AssertAuthResults(list)
	return list
end

function asserts.AssertThingNameList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingNameList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertThingName(v)
	end
end

--  
-- List of ThingName objects
function M.ThingNameList(list)
	asserts.AssertThingNameList(list)
	return list
end

function asserts.AssertOTAUpdatesSummary(list)
	assert(list)
	assert(type(list) == "table", "Expected OTAUpdatesSummary to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertOTAUpdateSummary(v)
	end
end

--  
-- List of OTAUpdateSummary objects
function M.OTAUpdatesSummary(list)
	asserts.AssertOTAUpdatesSummary(list)
	return list
end

function asserts.AssertPolicyDocuments(list)
	assert(list)
	assert(type(list) == "table", "Expected PolicyDocuments to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPolicyDocument(v)
	end
end

--  
-- List of PolicyDocument objects
function M.PolicyDocuments(list)
	asserts.AssertPolicyDocuments(list)
	return list
end

function asserts.AssertTargetAuditCheckNames(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetAuditCheckNames to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAuditCheckName(v)
	end
end

--  
-- List of AuditCheckName objects
function M.TargetAuditCheckNames(list)
	asserts.AssertTargetAuditCheckNames(list)
	return list
end

function asserts.AssertPorts(list)
	assert(list)
	assert(type(list) == "table", "Expected Ports to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPort(v)
	end
end

--  
-- List of Port objects
function M.Ports(list)
	asserts.AssertPorts(list)
	return list
end

function asserts.AssertThingTypeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingTypeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertThingTypeDefinition(v)
	end
end

--  
-- List of ThingTypeDefinition objects
function M.ThingTypeList(list)
	asserts.AssertThingTypeList(list)
	return list
end

function asserts.AssertAuditFindings(list)
	assert(list)
	assert(type(list) == "table", "Expected AuditFindings to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAuditFinding(v)
	end
end

--  
-- List of AuditFinding objects
function M.AuditFindings(list)
	asserts.AssertAuditFindings(list)
	return list
end

function asserts.AssertRoleAliases(list)
	assert(list)
	assert(type(list) == "table", "Expected RoleAliases to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRoleAlias(v)
	end
end

--  
-- List of RoleAlias objects
function M.RoleAliases(list)
	asserts.AssertRoleAliases(list)
	return list
end

function asserts.AssertActiveViolations(list)
	assert(list)
	assert(type(list) == "table", "Expected ActiveViolations to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertActiveViolation(v)
	end
end

--  
-- List of ActiveViolation objects
function M.ActiveViolations(list)
	asserts.AssertActiveViolations(list)
	return list
end

function asserts.AssertValidationErrors(list)
	assert(list)
	assert(type(list) == "table", "Expected ValidationErrors to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertValidationError(v)
	end
end

--  
-- List of ValidationError objects
function M.ValidationErrors(list)
	asserts.AssertValidationErrors(list)
	return list
end

function asserts.AssertThingAttributeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingAttributeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertThingAttribute(v)
	end
end

--  
-- List of ThingAttribute objects
function M.ThingAttributeList(list)
	asserts.AssertThingAttributeList(list)
	return list
end

function asserts.AssertAuthorizers(list)
	assert(list)
	assert(type(list) == "table", "Expected Authorizers to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAuthorizerSummary(v)
	end
end

--  
-- List of AuthorizerSummary objects
function M.Authorizers(list)
	asserts.AssertAuthorizers(list)
	return list
end

function asserts.AssertCACertificates(list)
	assert(list)
	assert(type(list) == "table", "Expected CACertificates to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCACertificate(v)
	end
end

--  
-- List of CACertificate objects
function M.CACertificates(list)
	asserts.AssertCACertificates(list)
	return list
end

function asserts.AssertJobExecutionSummaryForJobList(list)
	assert(list)
	assert(type(list) == "table", "Expected JobExecutionSummaryForJobList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertJobExecutionSummaryForJob(v)
	end
end

--  
-- List of JobExecutionSummaryForJob objects
function M.JobExecutionSummaryForJobList(list)
	asserts.AssertJobExecutionSummaryForJobList(list)
	return list
end

function asserts.AssertJobTargets(list)
	assert(list)
	assert(type(list) == "table", "Expected JobTargets to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertTargetArn(v)
	end
end

--  
-- List of TargetArn objects
function M.JobTargets(list)
	asserts.AssertJobTargets(list)
	return list
end

function asserts.AssertThingGroupNameAndArnList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingGroupNameAndArnList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertGroupNameAndArn(v)
	end
end

--  
-- List of GroupNameAndArn objects
function M.ThingGroupNameAndArnList(list)
	asserts.AssertThingGroupNameAndArnList(list)
	return list
end

function asserts.AssertScheduledAuditMetadataList(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledAuditMetadataList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledAuditMetadata(v)
	end
end

--  
-- List of ScheduledAuditMetadata objects
function M.ScheduledAuditMetadataList(list)
	asserts.AssertScheduledAuditMetadataList(list)
	return list
end

function asserts.AssertSearchableAttributes(list)
	assert(list)
	assert(type(list) == "table", "Expected SearchableAttributes to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAttributeName(v)
	end
end

--  
-- List of AttributeName objects
function M.SearchableAttributes(list)
	asserts.AssertSearchableAttributes(list)
	return list
end

function asserts.AssertResources(list)
	assert(list)
	assert(type(list) == "table", "Expected Resources to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertResource(v)
	end
end

--  
-- List of Resource objects
function M.Resources(list)
	asserts.AssertResources(list)
	return list
end

function asserts.AssertActionList(list)
	assert(list)
	assert(type(list) == "table", "Expected ActionList to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	for _,v in ipairs(list) do
		asserts.AssertAction(v)
	end
end

--  
-- List of Action objects
function M.ActionList(list)
	asserts.AssertActionList(list)
	return list
end

function asserts.AssertJobSummaryList(list)
	assert(list)
	assert(type(list) == "table", "Expected JobSummaryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertJobSummary(v)
	end
end

--  
-- List of JobSummary objects
function M.JobSummaryList(list)
	asserts.AssertJobSummaryList(list)
	return list
end

function asserts.AssertIndexNamesList(list)
	assert(list)
	assert(type(list) == "table", "Expected IndexNamesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIndexName(v)
	end
end

--  
-- List of IndexName objects
function M.IndexNamesList(list)
	asserts.AssertIndexNamesList(list)
	return list
end

function asserts.AssertThingGroupNameList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingGroupNameList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertThingGroupName(v)
	end
end

--  
-- List of ThingGroupName objects
function M.ThingGroupNameList(list)
	asserts.AssertThingGroupNameList(list)
	return list
end

function asserts.AssertPrincipals(list)
	assert(list)
	assert(type(list) == "table", "Expected Principals to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrincipalArn(v)
	end
end

--  
-- List of PrincipalArn objects
function M.Principals(list)
	asserts.AssertPrincipals(list)
	return list
end

function asserts.AssertAuditTaskMetadataList(list)
	assert(list)
	assert(type(list) == "table", "Expected AuditTaskMetadataList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAuditTaskMetadata(v)
	end
end

--  
-- List of AuditTaskMetadata objects
function M.AuditTaskMetadataList(list)
	asserts.AssertAuditTaskMetadataList(list)
	return list
end

function asserts.AssertMissingContextValues(list)
	assert(list)
	assert(type(list) == "table", "Expected MissingContextValues to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMissingContextValue(v)
	end
end

--  
-- List of MissingContextValue objects
function M.MissingContextValues(list)
	asserts.AssertMissingContextValues(list)
	return list
end

function asserts.AssertThingDocumentList(list)
	assert(list)
	assert(type(list) == "table", "Expected ThingDocumentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertThingDocument(v)
	end
end

--  
-- List of ThingDocument objects
function M.ThingDocumentList(list)
	asserts.AssertThingDocumentList(list)
	return list
end

function asserts.AssertTargets(list)
	assert(list)
	assert(type(list) == "table", "Expected Targets to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertTarget(v)
	end
end

--  
-- List of Target objects
function M.Targets(list)
	asserts.AssertTargets(list)
	return list
end

function asserts.AssertEffectivePolicies(list)
	assert(list)
	assert(type(list) == "table", "Expected EffectivePolicies to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEffectivePolicy(v)
	end
end

--  
-- List of EffectivePolicy objects
function M.EffectivePolicies(list)
	asserts.AssertEffectivePolicies(list)
	return list
end

function asserts.AssertLogTargetConfigurations(list)
	assert(list)
	assert(type(list) == "table", "Expected LogTargetConfigurations to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLogTargetConfiguration(v)
	end
end

--  
-- List of LogTargetConfiguration objects
function M.LogTargetConfigurations(list)
	asserts.AssertLogTargetConfigurations(list)
	return list
end

function asserts.AssertProcessingTargetNameList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProcessingTargetNameList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertProcessingTargetName(v)
	end
end

--  
-- List of ProcessingTargetName objects
function M.ProcessingTargetNameList(list)
	asserts.AssertProcessingTargetNameList(list)
	return list
end

function asserts.AssertAuthInfos(list)
	assert(list)
	assert(type(list) == "table", "Expected AuthInfos to be of type ''table")
	assert(#list <= 10, "Expected list to be contain 10 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertAuthInfo(v)
	end
end

--  
-- List of AuthInfo objects
function M.AuthInfos(list)
	asserts.AssertAuthInfos(list)
	return list
end

function asserts.AssertTaskIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected TaskIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTaskId(v)
	end
end

--  
-- List of TaskId objects
function M.TaskIdList(list)
	asserts.AssertTaskIdList(list)
	return list
end

function asserts.AssertRelatedResources(list)
	assert(list)
	assert(type(list) == "table", "Expected RelatedResources to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRelatedResource(v)
	end
end

--  
-- List of RelatedResource objects
function M.RelatedResources(list)
	asserts.AssertRelatedResources(list)
	return list
end

function asserts.AssertTopicRuleList(list)
	assert(list)
	assert(type(list) == "table", "Expected TopicRuleList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTopicRuleListItem(v)
	end
end

--  
-- List of TopicRuleListItem objects
function M.TopicRuleList(list)
	asserts.AssertTopicRuleList(list)
	return list
end

function asserts.AssertStreamsSummary(list)
	assert(list)
	assert(type(list) == "table", "Expected StreamsSummary to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStreamSummary(v)
	end
end

--  
-- List of StreamSummary objects
function M.StreamsSummary(list)
	asserts.AssertStreamsSummary(list)
	return list
end

function asserts.AssertPolicyVersions(list)
	assert(list)
	assert(type(list) == "table", "Expected PolicyVersions to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPolicyVersion(v)
	end
end

--  
-- List of PolicyVersion objects
function M.PolicyVersions(list)
	asserts.AssertPolicyVersions(list)
	return list
end

function asserts.AssertPolicyNames(list)
	assert(list)
	assert(type(list) == "table", "Expected PolicyNames to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPolicyName(v)
	end
end

--  
-- List of PolicyName objects
function M.PolicyNames(list)
	asserts.AssertPolicyNames(list)
	return list
end

function asserts.AssertS3FileUrlList(list)
	assert(list)
	assert(type(list) == "table", "Expected S3FileUrlList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertS3FileUrl(v)
	end
end

--  
-- List of S3FileUrl objects
function M.S3FileUrlList(list)
	asserts.AssertS3FileUrlList(list)
	return list
end

function asserts.AssertSecurityProfileTargetMappings(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityProfileTargetMappings to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityProfileTargetMapping(v)
	end
end

--  
-- List of SecurityProfileTargetMapping objects
function M.SecurityProfileTargetMappings(list)
	asserts.AssertSecurityProfileTargetMappings(list)
	return list
end


local content_type = require "aws-sdk.core.content_type"
local request_headers = require "aws-sdk.core.request_headers"
local request_handlers = require "aws-sdk.core.request_handlers"

local settings = {}


local function endpoint_for_region(region, use_dualstack)
	if not use_dualstack then
		if region == "us-east-1" then
			return "iot.amazonaws.com"
		end
	end
	local ss = { "iot" }
	if use_dualstack then
		ss[#ss + 1] = "dualstack"
	end
	ss[#ss + 1] = region
	ss[#ss + 1] = "amazonaws.com"
	if region == "cn-north-1" then
		ss[#ss + 1] = "cn"
	end
	return table.concat(ss, ".")
end


function M.init(config)
	assert(config, "You must provide a config table")
	assert(config.region, "You must provide a region in the config table")

	settings.service = M.metadata.endpoint_prefix
	settings.protocol = M.metadata.protocol
	settings.region = config.region
	settings.endpoint = config.endpoint_override or endpoint_for_region(config.region, config.use_dualstack)
	settings.signature_version = M.metadata.signature_version
	settings.uri = (config.scheme or "https") .. "://" .. settings.endpoint
end


--
-- OPERATIONS
--
--- Call ReplaceTopicRule asynchronously, invoking a callback when done
-- @param ReplaceTopicRuleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReplaceTopicRuleAsync(ReplaceTopicRuleRequest, cb)
	assert(ReplaceTopicRuleRequest, "You must provide a ReplaceTopicRuleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceTopicRule",
	}
	for header,value in pairs(ReplaceTopicRuleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/rules/{ruleName}", ReplaceTopicRuleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceTopicRule synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceTopicRuleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReplaceTopicRuleSync(ReplaceTopicRuleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceTopicRuleAsync(ReplaceTopicRuleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListViolationEvents asynchronously, invoking a callback when done
-- @param ListViolationEventsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListViolationEventsAsync(ListViolationEventsRequest, cb)
	assert(ListViolationEventsRequest, "You must provide a ListViolationEventsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListViolationEvents",
	}
	for header,value in pairs(ListViolationEventsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/violation-events", ListViolationEventsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListViolationEvents synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListViolationEventsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListViolationEventsSync(ListViolationEventsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListViolationEventsAsync(ListViolationEventsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateThingGroupsForThing asynchronously, invoking a callback when done
-- @param UpdateThingGroupsForThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateThingGroupsForThingAsync(UpdateThingGroupsForThingRequest, cb)
	assert(UpdateThingGroupsForThingRequest, "You must provide a UpdateThingGroupsForThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateThingGroupsForThing",
	}
	for header,value in pairs(UpdateThingGroupsForThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/updateThingGroupsForThing", UpdateThingGroupsForThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateThingGroupsForThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateThingGroupsForThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateThingGroupsForThingSync(UpdateThingGroupsForThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateThingGroupsForThingAsync(UpdateThingGroupsForThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeprecateThingType asynchronously, invoking a callback when done
-- @param DeprecateThingTypeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeprecateThingTypeAsync(DeprecateThingTypeRequest, cb)
	assert(DeprecateThingTypeRequest, "You must provide a DeprecateThingTypeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeprecateThingType",
	}
	for header,value in pairs(DeprecateThingTypeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/thing-types/{thingTypeName}/deprecate", DeprecateThingTypeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeprecateThingType synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeprecateThingTypeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeprecateThingTypeSync(DeprecateThingTypeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeprecateThingTypeAsync(DeprecateThingTypeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StartOnDemandAuditTask asynchronously, invoking a callback when done
-- @param StartOnDemandAuditTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StartOnDemandAuditTaskAsync(StartOnDemandAuditTaskRequest, cb)
	assert(StartOnDemandAuditTaskRequest, "You must provide a StartOnDemandAuditTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".StartOnDemandAuditTask",
	}
	for header,value in pairs(StartOnDemandAuditTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/audit/tasks", StartOnDemandAuditTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StartOnDemandAuditTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartOnDemandAuditTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StartOnDemandAuditTaskSync(StartOnDemandAuditTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartOnDemandAuditTaskAsync(StartOnDemandAuditTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListAuthorizers asynchronously, invoking a callback when done
-- @param ListAuthorizersRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListAuthorizersAsync(ListAuthorizersRequest, cb)
	assert(ListAuthorizersRequest, "You must provide a ListAuthorizersRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListAuthorizers",
	}
	for header,value in pairs(ListAuthorizersRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/authorizers/", ListAuthorizersRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListAuthorizers synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListAuthorizersRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListAuthorizersSync(ListAuthorizersRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListAuthorizersAsync(ListAuthorizersRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteAuthorizer asynchronously, invoking a callback when done
-- @param DeleteAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteAuthorizerAsync(DeleteAuthorizerRequest, cb)
	assert(DeleteAuthorizerRequest, "You must provide a DeleteAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteAuthorizer",
	}
	for header,value in pairs(DeleteAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/authorizer/{authorizerName}", DeleteAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteAuthorizerSync(DeleteAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteAuthorizerAsync(DeleteAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SetV2LoggingLevel asynchronously, invoking a callback when done
-- @param SetV2LoggingLevelRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SetV2LoggingLevelAsync(SetV2LoggingLevelRequest, cb)
	assert(SetV2LoggingLevelRequest, "You must provide a SetV2LoggingLevelRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".SetV2LoggingLevel",
	}
	for header,value in pairs(SetV2LoggingLevelRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/v2LoggingLevel", SetV2LoggingLevelRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SetV2LoggingLevel synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SetV2LoggingLevelRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SetV2LoggingLevelSync(SetV2LoggingLevelRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SetV2LoggingLevelAsync(SetV2LoggingLevelRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RejectCertificateTransfer asynchronously, invoking a callback when done
-- @param RejectCertificateTransferRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RejectCertificateTransferAsync(RejectCertificateTransferRequest, cb)
	assert(RejectCertificateTransferRequest, "You must provide a RejectCertificateTransferRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RejectCertificateTransfer",
	}
	for header,value in pairs(RejectCertificateTransferRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/reject-certificate-transfer/{certificateId}", RejectCertificateTransferRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RejectCertificateTransfer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RejectCertificateTransferRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RejectCertificateTransferSync(RejectCertificateTransferRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RejectCertificateTransferAsync(RejectCertificateTransferRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRoleAlias asynchronously, invoking a callback when done
-- @param DeleteRoleAliasRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteRoleAliasAsync(DeleteRoleAliasRequest, cb)
	assert(DeleteRoleAliasRequest, "You must provide a DeleteRoleAliasRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteRoleAlias",
	}
	for header,value in pairs(DeleteRoleAliasRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/role-aliases/{roleAlias}", DeleteRoleAliasRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRoleAlias synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRoleAliasRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteRoleAliasSync(DeleteRoleAliasRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRoleAliasAsync(DeleteRoleAliasRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSecurityProfile asynchronously, invoking a callback when done
-- @param DescribeSecurityProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSecurityProfileAsync(DescribeSecurityProfileRequest, cb)
	assert(DescribeSecurityProfileRequest, "You must provide a DescribeSecurityProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSecurityProfile",
	}
	for header,value in pairs(DescribeSecurityProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/security-profiles/{securityProfileName}", DescribeSecurityProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSecurityProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSecurityProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSecurityProfileSync(DescribeSecurityProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSecurityProfileAsync(DescribeSecurityProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListAuditTasks asynchronously, invoking a callback when done
-- @param ListAuditTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListAuditTasksAsync(ListAuditTasksRequest, cb)
	assert(ListAuditTasksRequest, "You must provide a ListAuditTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListAuditTasks",
	}
	for header,value in pairs(ListAuditTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/audit/tasks", ListAuditTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListAuditTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListAuditTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListAuditTasksSync(ListAuditTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListAuditTasksAsync(ListAuditTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SetDefaultAuthorizer asynchronously, invoking a callback when done
-- @param SetDefaultAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SetDefaultAuthorizerAsync(SetDefaultAuthorizerRequest, cb)
	assert(SetDefaultAuthorizerRequest, "You must provide a SetDefaultAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".SetDefaultAuthorizer",
	}
	for header,value in pairs(SetDefaultAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/default-authorizer", SetDefaultAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SetDefaultAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SetDefaultAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SetDefaultAuthorizerSync(SetDefaultAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SetDefaultAuthorizerAsync(SetDefaultAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListCACertificates asynchronously, invoking a callback when done
-- @param ListCACertificatesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListCACertificatesAsync(ListCACertificatesRequest, cb)
	assert(ListCACertificatesRequest, "You must provide a ListCACertificatesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListCACertificates",
	}
	for header,value in pairs(ListCACertificatesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/cacertificates", ListCACertificatesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListCACertificates synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListCACertificatesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListCACertificatesSync(ListCACertificatesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListCACertificatesAsync(ListCACertificatesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetTopicRule asynchronously, invoking a callback when done
-- @param GetTopicRuleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetTopicRuleAsync(GetTopicRuleRequest, cb)
	assert(GetTopicRuleRequest, "You must provide a GetTopicRuleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetTopicRule",
	}
	for header,value in pairs(GetTopicRuleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/rules/{ruleName}", GetTopicRuleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetTopicRule synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetTopicRuleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetTopicRuleSync(GetTopicRuleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetTopicRuleAsync(GetTopicRuleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAuthorizer asynchronously, invoking a callback when done
-- @param DescribeAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAuthorizerAsync(DescribeAuthorizerRequest, cb)
	assert(DescribeAuthorizerRequest, "You must provide a DescribeAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAuthorizer",
	}
	for header,value in pairs(DescribeAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/authorizer/{authorizerName}", DescribeAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAuthorizerSync(DescribeAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAuthorizerAsync(DescribeAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeDefaultAuthorizer asynchronously, invoking a callback when done
-- @param DescribeDefaultAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeDefaultAuthorizerAsync(DescribeDefaultAuthorizerRequest, cb)
	assert(DescribeDefaultAuthorizerRequest, "You must provide a DescribeDefaultAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeDefaultAuthorizer",
	}
	for header,value in pairs(DescribeDefaultAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/default-authorizer", DescribeDefaultAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeDefaultAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeDefaultAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeDefaultAuthorizerSync(DescribeDefaultAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeDefaultAuthorizerAsync(DescribeDefaultAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetJobDocument asynchronously, invoking a callback when done
-- @param GetJobDocumentRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetJobDocumentAsync(GetJobDocumentRequest, cb)
	assert(GetJobDocumentRequest, "You must provide a GetJobDocumentRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetJobDocument",
	}
	for header,value in pairs(GetJobDocumentRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/jobs/{jobId}/job-document", GetJobDocumentRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetJobDocument synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetJobDocumentRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetJobDocumentSync(GetJobDocumentRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetJobDocumentAsync(GetJobDocumentRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAuditTask asynchronously, invoking a callback when done
-- @param DescribeAuditTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAuditTaskAsync(DescribeAuditTaskRequest, cb)
	assert(DescribeAuditTaskRequest, "You must provide a DescribeAuditTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAuditTask",
	}
	for header,value in pairs(DescribeAuditTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/audit/tasks/{taskId}", DescribeAuditTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAuditTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAuditTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAuditTaskSync(DescribeAuditTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAuditTaskAsync(DescribeAuditTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeStream asynchronously, invoking a callback when done
-- @param DescribeStreamRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeStreamAsync(DescribeStreamRequest, cb)
	assert(DescribeStreamRequest, "You must provide a DescribeStreamRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeStream",
	}
	for header,value in pairs(DescribeStreamRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/streams/{streamId}", DescribeStreamRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeStream synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeStreamRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeStreamSync(DescribeStreamRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeStreamAsync(DescribeStreamRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelJob asynchronously, invoking a callback when done
-- @param CancelJobRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelJobAsync(CancelJobRequest, cb)
	assert(CancelJobRequest, "You must provide a CancelJobRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelJob",
	}
	for header,value in pairs(CancelJobRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/jobs/{jobId}/cancel", CancelJobRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelJob synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelJobRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelJobSync(CancelJobRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelJobAsync(CancelJobRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListTargetsForSecurityProfile asynchronously, invoking a callback when done
-- @param ListTargetsForSecurityProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListTargetsForSecurityProfileAsync(ListTargetsForSecurityProfileRequest, cb)
	assert(ListTargetsForSecurityProfileRequest, "You must provide a ListTargetsForSecurityProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListTargetsForSecurityProfile",
	}
	for header,value in pairs(ListTargetsForSecurityProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/security-profiles/{securityProfileName}/targets", ListTargetsForSecurityProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListTargetsForSecurityProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListTargetsForSecurityProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListTargetsForSecurityProfileSync(ListTargetsForSecurityProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListTargetsForSecurityProfileAsync(ListTargetsForSecurityProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterCACertificate asynchronously, invoking a callback when done
-- @param RegisterCACertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterCACertificateAsync(RegisterCACertificateRequest, cb)
	assert(RegisterCACertificateRequest, "You must provide a RegisterCACertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RegisterCACertificate",
	}
	for header,value in pairs(RegisterCACertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/cacertificate", RegisterCACertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterCACertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterCACertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterCACertificateSync(RegisterCACertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterCACertificateAsync(RegisterCACertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeEndpoint asynchronously, invoking a callback when done
-- @param DescribeEndpointRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeEndpointAsync(DescribeEndpointRequest, cb)
	assert(DescribeEndpointRequest, "You must provide a DescribeEndpointRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeEndpoint",
	}
	for header,value in pairs(DescribeEndpointRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/endpoint", DescribeEndpointRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeEndpoint synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeEndpointRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeEndpointSync(DescribeEndpointRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeEndpointAsync(DescribeEndpointRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeThingType asynchronously, invoking a callback when done
-- @param DescribeThingTypeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeThingTypeAsync(DescribeThingTypeRequest, cb)
	assert(DescribeThingTypeRequest, "You must provide a DescribeThingTypeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeThingType",
	}
	for header,value in pairs(DescribeThingTypeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-types/{thingTypeName}", DescribeThingTypeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeThingType synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeThingTypeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeThingTypeSync(DescribeThingTypeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeThingTypeAsync(DescribeThingTypeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteJob asynchronously, invoking a callback when done
-- @param DeleteJobRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteJobAsync(DeleteJobRequest, cb)
	assert(DeleteJobRequest, "You must provide a DeleteJobRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteJob",
	}
	for header,value in pairs(DeleteJobRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/jobs/{jobId}", DeleteJobRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteJob synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteJobRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteJobSync(DeleteJobRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteJobAsync(DeleteJobRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThingRegistrationTaskReports asynchronously, invoking a callback when done
-- @param ListThingRegistrationTaskReportsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingRegistrationTaskReportsAsync(ListThingRegistrationTaskReportsRequest, cb)
	assert(ListThingRegistrationTaskReportsRequest, "You must provide a ListThingRegistrationTaskReportsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThingRegistrationTaskReports",
	}
	for header,value in pairs(ListThingRegistrationTaskReportsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-registration-tasks/{taskId}/reports", ListThingRegistrationTaskReportsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThingRegistrationTaskReports synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingRegistrationTaskReportsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingRegistrationTaskReportsSync(ListThingRegistrationTaskReportsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingRegistrationTaskReportsAsync(ListThingRegistrationTaskReportsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachSecurityProfile asynchronously, invoking a callback when done
-- @param DetachSecurityProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachSecurityProfileAsync(DetachSecurityProfileRequest, cb)
	assert(DetachSecurityProfileRequest, "You must provide a DetachSecurityProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachSecurityProfile",
	}
	for header,value in pairs(DetachSecurityProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/security-profiles/{securityProfileName}/targets", DetachSecurityProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachSecurityProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachSecurityProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachSecurityProfileSync(DetachSecurityProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachSecurityProfileAsync(DetachSecurityProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeJobExecution asynchronously, invoking a callback when done
-- @param DescribeJobExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeJobExecutionAsync(DescribeJobExecutionRequest, cb)
	assert(DescribeJobExecutionRequest, "You must provide a DescribeJobExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeJobExecution",
	}
	for header,value in pairs(DescribeJobExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/jobs/{jobId}", DescribeJobExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeJobExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeJobExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeJobExecutionSync(DescribeJobExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeJobExecutionAsync(DescribeJobExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeScheduledAudit asynchronously, invoking a callback when done
-- @param DescribeScheduledAuditRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeScheduledAuditAsync(DescribeScheduledAuditRequest, cb)
	assert(DescribeScheduledAuditRequest, "You must provide a DescribeScheduledAuditRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeScheduledAudit",
	}
	for header,value in pairs(DescribeScheduledAuditRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/audit/scheduledaudits/{scheduledAuditName}", DescribeScheduledAuditRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeScheduledAudit synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeScheduledAuditRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeScheduledAuditSync(DescribeScheduledAuditRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeScheduledAuditAsync(DescribeScheduledAuditRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteTopicRule asynchronously, invoking a callback when done
-- @param DeleteTopicRuleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteTopicRuleAsync(DeleteTopicRuleRequest, cb)
	assert(DeleteTopicRuleRequest, "You must provide a DeleteTopicRuleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteTopicRule",
	}
	for header,value in pairs(DeleteTopicRuleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/rules/{ruleName}", DeleteTopicRuleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteTopicRule synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteTopicRuleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteTopicRuleSync(DeleteTopicRuleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteTopicRuleAsync(DeleteTopicRuleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteOTAUpdate asynchronously, invoking a callback when done
-- @param DeleteOTAUpdateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteOTAUpdateAsync(DeleteOTAUpdateRequest, cb)
	assert(DeleteOTAUpdateRequest, "You must provide a DeleteOTAUpdateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteOTAUpdate",
	}
	for header,value in pairs(DeleteOTAUpdateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/otaUpdates/{otaUpdateId}", DeleteOTAUpdateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteOTAUpdate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteOTAUpdateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteOTAUpdateSync(DeleteOTAUpdateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteOTAUpdateAsync(DeleteOTAUpdateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateThing asynchronously, invoking a callback when done
-- @param UpdateThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateThingAsync(UpdateThingRequest, cb)
	assert(UpdateThingRequest, "You must provide a UpdateThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateThing",
	}
	for header,value in pairs(UpdateThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}", UpdateThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateThingSync(UpdateThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateThingAsync(UpdateThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableTopicRule asynchronously, invoking a callback when done
-- @param EnableTopicRuleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.EnableTopicRuleAsync(EnableTopicRuleRequest, cb)
	assert(EnableTopicRuleRequest, "You must provide a EnableTopicRuleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableTopicRule",
	}
	for header,value in pairs(EnableTopicRuleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/rules/{ruleName}/enable", EnableTopicRuleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableTopicRule synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableTopicRuleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.EnableTopicRuleSync(EnableTopicRuleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableTopicRuleAsync(EnableTopicRuleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateAccountAuditConfiguration asynchronously, invoking a callback when done
-- @param UpdateAccountAuditConfigurationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateAccountAuditConfigurationAsync(UpdateAccountAuditConfigurationRequest, cb)
	assert(UpdateAccountAuditConfigurationRequest, "You must provide a UpdateAccountAuditConfigurationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateAccountAuditConfiguration",
	}
	for header,value in pairs(UpdateAccountAuditConfigurationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/audit/configuration", UpdateAccountAuditConfigurationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateAccountAuditConfiguration synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateAccountAuditConfigurationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateAccountAuditConfigurationSync(UpdateAccountAuditConfigurationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateAccountAuditConfigurationAsync(UpdateAccountAuditConfigurationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetPolicy asynchronously, invoking a callback when done
-- @param GetPolicyRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetPolicyAsync(GetPolicyRequest, cb)
	assert(GetPolicyRequest, "You must provide a GetPolicyRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetPolicy",
	}
	for header,value in pairs(GetPolicyRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}", GetPolicyRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetPolicy synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetPolicyRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetPolicySync(GetPolicyRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetPolicyAsync(GetPolicyRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call TransferCertificate asynchronously, invoking a callback when done
-- @param TransferCertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.TransferCertificateAsync(TransferCertificateRequest, cb)
	assert(TransferCertificateRequest, "You must provide a TransferCertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".TransferCertificate",
	}
	for header,value in pairs(TransferCertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/transfer-certificate/{certificateId}", TransferCertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call TransferCertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param TransferCertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.TransferCertificateSync(TransferCertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.TransferCertificateAsync(TransferCertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteThingGroup asynchronously, invoking a callback when done
-- @param DeleteThingGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteThingGroupAsync(DeleteThingGroupRequest, cb)
	assert(DeleteThingGroupRequest, "You must provide a DeleteThingGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteThingGroup",
	}
	for header,value in pairs(DeleteThingGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/{thingGroupName}", DeleteThingGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteThingGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteThingGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteThingGroupSync(DeleteThingGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteThingGroupAsync(DeleteThingGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StartThingRegistrationTask asynchronously, invoking a callback when done
-- @param StartThingRegistrationTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StartThingRegistrationTaskAsync(StartThingRegistrationTaskRequest, cb)
	assert(StartThingRegistrationTaskRequest, "You must provide a StartThingRegistrationTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".StartThingRegistrationTask",
	}
	for header,value in pairs(StartThingRegistrationTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/thing-registration-tasks", StartThingRegistrationTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StartThingRegistrationTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartThingRegistrationTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StartThingRegistrationTaskSync(StartThingRegistrationTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartThingRegistrationTaskAsync(StartThingRegistrationTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SearchIndex asynchronously, invoking a callback when done
-- @param SearchIndexRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SearchIndexAsync(SearchIndexRequest, cb)
	assert(SearchIndexRequest, "You must provide a SearchIndexRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".SearchIndex",
	}
	for header,value in pairs(SearchIndexRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/indices/search", SearchIndexRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SearchIndex synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SearchIndexRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SearchIndexSync(SearchIndexRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SearchIndexAsync(SearchIndexRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteCertificate asynchronously, invoking a callback when done
-- @param DeleteCertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteCertificateAsync(DeleteCertificateRequest, cb)
	assert(DeleteCertificateRequest, "You must provide a DeleteCertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteCertificate",
	}
	for header,value in pairs(DeleteCertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/certificates/{certificateId}", DeleteCertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteCertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteCertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteCertificateSync(DeleteCertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteCertificateAsync(DeleteCertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListStreams asynchronously, invoking a callback when done
-- @param ListStreamsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListStreamsAsync(ListStreamsRequest, cb)
	assert(ListStreamsRequest, "You must provide a ListStreamsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListStreams",
	}
	for header,value in pairs(ListStreamsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/streams", ListStreamsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListStreams synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListStreamsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListStreamsSync(ListStreamsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListStreamsAsync(ListStreamsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetV2LoggingOptions asynchronously, invoking a callback when done
-- @param GetV2LoggingOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetV2LoggingOptionsAsync(GetV2LoggingOptionsRequest, cb)
	assert(GetV2LoggingOptionsRequest, "You must provide a GetV2LoggingOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetV2LoggingOptions",
	}
	for header,value in pairs(GetV2LoggingOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/v2LoggingOptions", GetV2LoggingOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetV2LoggingOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetV2LoggingOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetV2LoggingOptionsSync(GetV2LoggingOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetV2LoggingOptionsAsync(GetV2LoggingOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteV2LoggingLevel asynchronously, invoking a callback when done
-- @param DeleteV2LoggingLevelRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteV2LoggingLevelAsync(DeleteV2LoggingLevelRequest, cb)
	assert(DeleteV2LoggingLevelRequest, "You must provide a DeleteV2LoggingLevelRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteV2LoggingLevel",
	}
	for header,value in pairs(DeleteV2LoggingLevelRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/v2LoggingLevel", DeleteV2LoggingLevelRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteV2LoggingLevel synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteV2LoggingLevelRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteV2LoggingLevelSync(DeleteV2LoggingLevelRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteV2LoggingLevelAsync(DeleteV2LoggingLevelRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListOutgoingCertificates asynchronously, invoking a callback when done
-- @param ListOutgoingCertificatesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListOutgoingCertificatesAsync(ListOutgoingCertificatesRequest, cb)
	assert(ListOutgoingCertificatesRequest, "You must provide a ListOutgoingCertificatesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListOutgoingCertificates",
	}
	for header,value in pairs(ListOutgoingCertificatesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/certificates-out-going", ListOutgoingCertificatesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListOutgoingCertificates synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListOutgoingCertificatesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListOutgoingCertificatesSync(ListOutgoingCertificatesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListOutgoingCertificatesAsync(ListOutgoingCertificatesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachThingPrincipal asynchronously, invoking a callback when done
-- @param AttachThingPrincipalRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachThingPrincipalAsync(AttachThingPrincipalRequest, cb)
	assert(AttachThingPrincipalRequest, "You must provide a AttachThingPrincipalRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachThingPrincipal",
	}
	for header,value in pairs(AttachThingPrincipalRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/principals", AttachThingPrincipalRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachThingPrincipal synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachThingPrincipalRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachThingPrincipalSync(AttachThingPrincipalRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachThingPrincipalAsync(AttachThingPrincipalRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptCertificateTransfer asynchronously, invoking a callback when done
-- @param AcceptCertificateTransferRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AcceptCertificateTransferAsync(AcceptCertificateTransferRequest, cb)
	assert(AcceptCertificateTransferRequest, "You must provide a AcceptCertificateTransferRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AcceptCertificateTransfer",
	}
	for header,value in pairs(AcceptCertificateTransferRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/accept-certificate-transfer/{certificateId}", AcceptCertificateTransferRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptCertificateTransfer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptCertificateTransferRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AcceptCertificateTransferSync(AcceptCertificateTransferRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptCertificateTransferAsync(AcceptCertificateTransferRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListAttachedPolicies asynchronously, invoking a callback when done
-- @param ListAttachedPoliciesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListAttachedPoliciesAsync(ListAttachedPoliciesRequest, cb)
	assert(ListAttachedPoliciesRequest, "You must provide a ListAttachedPoliciesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListAttachedPolicies",
	}
	for header,value in pairs(ListAttachedPoliciesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/attached-policies/{target}", ListAttachedPoliciesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListAttachedPolicies synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListAttachedPoliciesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListAttachedPoliciesSync(ListAttachedPoliciesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListAttachedPoliciesAsync(ListAttachedPoliciesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ClearDefaultAuthorizer asynchronously, invoking a callback when done
-- @param ClearDefaultAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ClearDefaultAuthorizerAsync(ClearDefaultAuthorizerRequest, cb)
	assert(ClearDefaultAuthorizerRequest, "You must provide a ClearDefaultAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ClearDefaultAuthorizer",
	}
	for header,value in pairs(ClearDefaultAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/default-authorizer", ClearDefaultAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ClearDefaultAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ClearDefaultAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ClearDefaultAuthorizerSync(ClearDefaultAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ClearDefaultAuthorizerAsync(ClearDefaultAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateAuthorizer asynchronously, invoking a callback when done
-- @param CreateAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateAuthorizerAsync(CreateAuthorizerRequest, cb)
	assert(CreateAuthorizerRequest, "You must provide a CreateAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateAuthorizer",
	}
	for header,value in pairs(CreateAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/authorizer/{authorizerName}", CreateAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateAuthorizerSync(CreateAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateAuthorizerAsync(CreateAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call TestAuthorization asynchronously, invoking a callback when done
-- @param TestAuthorizationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.TestAuthorizationAsync(TestAuthorizationRequest, cb)
	assert(TestAuthorizationRequest, "You must provide a TestAuthorizationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".TestAuthorization",
	}
	for header,value in pairs(TestAuthorizationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/test-authorization", TestAuthorizationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call TestAuthorization synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param TestAuthorizationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.TestAuthorizationSync(TestAuthorizationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.TestAuthorizationAsync(TestAuthorizationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelAuditTask asynchronously, invoking a callback when done
-- @param CancelAuditTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelAuditTaskAsync(CancelAuditTaskRequest, cb)
	assert(CancelAuditTaskRequest, "You must provide a CancelAuditTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelAuditTask",
	}
	for header,value in pairs(CancelAuditTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/audit/tasks/{taskId}/cancel", CancelAuditTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelAuditTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelAuditTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelAuditTaskSync(CancelAuditTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelAuditTaskAsync(CancelAuditTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetIndexingConfiguration asynchronously, invoking a callback when done
-- @param GetIndexingConfigurationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetIndexingConfigurationAsync(GetIndexingConfigurationRequest, cb)
	assert(GetIndexingConfigurationRequest, "You must provide a GetIndexingConfigurationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetIndexingConfiguration",
	}
	for header,value in pairs(GetIndexingConfigurationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/indexing/config", GetIndexingConfigurationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetIndexingConfiguration synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetIndexingConfigurationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetIndexingConfigurationSync(GetIndexingConfigurationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetIndexingConfigurationAsync(GetIndexingConfigurationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRegistrationCode asynchronously, invoking a callback when done
-- @param DeleteRegistrationCodeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteRegistrationCodeAsync(DeleteRegistrationCodeRequest, cb)
	assert(DeleteRegistrationCodeRequest, "You must provide a DeleteRegistrationCodeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteRegistrationCode",
	}
	for header,value in pairs(DeleteRegistrationCodeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/registrationcode", DeleteRegistrationCodeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRegistrationCode synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRegistrationCodeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteRegistrationCodeSync(DeleteRegistrationCodeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRegistrationCodeAsync(DeleteRegistrationCodeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListTopicRules asynchronously, invoking a callback when done
-- @param ListTopicRulesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListTopicRulesAsync(ListTopicRulesRequest, cb)
	assert(ListTopicRulesRequest, "You must provide a ListTopicRulesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListTopicRules",
	}
	for header,value in pairs(ListTopicRulesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/rules", ListTopicRulesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListTopicRules synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListTopicRulesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListTopicRulesSync(ListTopicRulesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListTopicRulesAsync(ListTopicRulesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreatePolicyVersion asynchronously, invoking a callback when done
-- @param CreatePolicyVersionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreatePolicyVersionAsync(CreatePolicyVersionRequest, cb)
	assert(CreatePolicyVersionRequest, "You must provide a CreatePolicyVersionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreatePolicyVersion",
	}
	for header,value in pairs(CreatePolicyVersionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}/version", CreatePolicyVersionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreatePolicyVersion synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreatePolicyVersionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreatePolicyVersionSync(CreatePolicyVersionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreatePolicyVersionAsync(CreatePolicyVersionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListActiveViolations asynchronously, invoking a callback when done
-- @param ListActiveViolationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListActiveViolationsAsync(ListActiveViolationsRequest, cb)
	assert(ListActiveViolationsRequest, "You must provide a ListActiveViolationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListActiveViolations",
	}
	for header,value in pairs(ListActiveViolationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/active-violations", ListActiveViolationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListActiveViolations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListActiveViolationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListActiveViolationsSync(ListActiveViolationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListActiveViolationsAsync(ListActiveViolationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListScheduledAudits asynchronously, invoking a callback when done
-- @param ListScheduledAuditsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListScheduledAuditsAsync(ListScheduledAuditsRequest, cb)
	assert(ListScheduledAuditsRequest, "You must provide a ListScheduledAuditsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListScheduledAudits",
	}
	for header,value in pairs(ListScheduledAuditsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/audit/scheduledaudits", ListScheduledAuditsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListScheduledAudits synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListScheduledAuditsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListScheduledAuditsSync(ListScheduledAuditsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListScheduledAuditsAsync(ListScheduledAuditsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteScheduledAudit asynchronously, invoking a callback when done
-- @param DeleteScheduledAuditRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteScheduledAuditAsync(DeleteScheduledAuditRequest, cb)
	assert(DeleteScheduledAuditRequest, "You must provide a DeleteScheduledAuditRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteScheduledAudit",
	}
	for header,value in pairs(DeleteScheduledAuditRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/audit/scheduledaudits/{scheduledAuditName}", DeleteScheduledAuditRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteScheduledAudit synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteScheduledAuditRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteScheduledAuditSync(DeleteScheduledAuditRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteScheduledAuditAsync(DeleteScheduledAuditRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeThingRegistrationTask asynchronously, invoking a callback when done
-- @param DescribeThingRegistrationTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeThingRegistrationTaskAsync(DescribeThingRegistrationTaskRequest, cb)
	assert(DescribeThingRegistrationTaskRequest, "You must provide a DescribeThingRegistrationTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeThingRegistrationTask",
	}
	for header,value in pairs(DescribeThingRegistrationTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-registration-tasks/{taskId}", DescribeThingRegistrationTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeThingRegistrationTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeThingRegistrationTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeThingRegistrationTaskSync(DescribeThingRegistrationTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeThingRegistrationTaskAsync(DescribeThingRegistrationTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListV2LoggingLevels asynchronously, invoking a callback when done
-- @param ListV2LoggingLevelsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListV2LoggingLevelsAsync(ListV2LoggingLevelsRequest, cb)
	assert(ListV2LoggingLevelsRequest, "You must provide a ListV2LoggingLevelsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListV2LoggingLevels",
	}
	for header,value in pairs(ListV2LoggingLevelsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/v2LoggingLevel", ListV2LoggingLevelsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListV2LoggingLevels synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListV2LoggingLevelsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListV2LoggingLevelsSync(ListV2LoggingLevelsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListV2LoggingLevelsAsync(ListV2LoggingLevelsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIndex asynchronously, invoking a callback when done
-- @param DescribeIndexRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeIndexAsync(DescribeIndexRequest, cb)
	assert(DescribeIndexRequest, "You must provide a DescribeIndexRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeIndex",
	}
	for header,value in pairs(DescribeIndexRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/indices/{indexName}", DescribeIndexRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIndex synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIndexRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeIndexSync(DescribeIndexRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIndexAsync(DescribeIndexRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RemoveThingFromThingGroup asynchronously, invoking a callback when done
-- @param RemoveThingFromThingGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RemoveThingFromThingGroupAsync(RemoveThingFromThingGroupRequest, cb)
	assert(RemoveThingFromThingGroupRequest, "You must provide a RemoveThingFromThingGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RemoveThingFromThingGroup",
	}
	for header,value in pairs(RemoveThingFromThingGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/removeThingFromThingGroup", RemoveThingFromThingGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RemoveThingFromThingGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RemoveThingFromThingGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RemoveThingFromThingGroupSync(RemoveThingFromThingGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RemoveThingFromThingGroupAsync(RemoveThingFromThingGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetOTAUpdate asynchronously, invoking a callback when done
-- @param GetOTAUpdateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetOTAUpdateAsync(GetOTAUpdateRequest, cb)
	assert(GetOTAUpdateRequest, "You must provide a GetOTAUpdateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetOTAUpdate",
	}
	for header,value in pairs(GetOTAUpdateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/otaUpdates/{otaUpdateId}", GetOTAUpdateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetOTAUpdate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetOTAUpdateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetOTAUpdateSync(GetOTAUpdateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetOTAUpdateAsync(GetOTAUpdateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListCertificates asynchronously, invoking a callback when done
-- @param ListCertificatesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListCertificatesAsync(ListCertificatesRequest, cb)
	assert(ListCertificatesRequest, "You must provide a ListCertificatesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListCertificates",
	}
	for header,value in pairs(ListCertificatesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/certificates", ListCertificatesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListCertificates synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListCertificatesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListCertificatesSync(ListCertificatesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListCertificatesAsync(ListCertificatesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeletePolicy asynchronously, invoking a callback when done
-- @param DeletePolicyRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeletePolicyAsync(DeletePolicyRequest, cb)
	assert(DeletePolicyRequest, "You must provide a DeletePolicyRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeletePolicy",
	}
	for header,value in pairs(DeletePolicyRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}", DeletePolicyRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeletePolicy synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeletePolicyRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeletePolicySync(DeletePolicyRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeletePolicyAsync(DeletePolicyRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeletePolicyVersion asynchronously, invoking a callback when done
-- @param DeletePolicyVersionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeletePolicyVersionAsync(DeletePolicyVersionRequest, cb)
	assert(DeletePolicyVersionRequest, "You must provide a DeletePolicyVersionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeletePolicyVersion",
	}
	for header,value in pairs(DeletePolicyVersionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}/version/{policyVersionId}", DeletePolicyVersionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeletePolicyVersion synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeletePolicyVersionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeletePolicyVersionSync(DeletePolicyVersionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeletePolicyVersionAsync(DeletePolicyVersionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateRoleAlias asynchronously, invoking a callback when done
-- @param CreateRoleAliasRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateRoleAliasAsync(CreateRoleAliasRequest, cb)
	assert(CreateRoleAliasRequest, "You must provide a CreateRoleAliasRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateRoleAlias",
	}
	for header,value in pairs(CreateRoleAliasRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/role-aliases/{roleAlias}", CreateRoleAliasRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateRoleAlias synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateRoleAliasRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateRoleAliasSync(CreateRoleAliasRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateRoleAliasAsync(CreateRoleAliasRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateTopicRule asynchronously, invoking a callback when done
-- @param CreateTopicRuleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateTopicRuleAsync(CreateTopicRuleRequest, cb)
	assert(CreateTopicRuleRequest, "You must provide a CreateTopicRuleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateTopicRule",
	}
	for header,value in pairs(CreateTopicRuleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/rules/{ruleName}", CreateTopicRuleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateTopicRule synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateTopicRuleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateTopicRuleSync(CreateTopicRuleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateTopicRuleAsync(CreateTopicRuleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeRoleAlias asynchronously, invoking a callback when done
-- @param DescribeRoleAliasRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeRoleAliasAsync(DescribeRoleAliasRequest, cb)
	assert(DescribeRoleAliasRequest, "You must provide a DescribeRoleAliasRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeRoleAlias",
	}
	for header,value in pairs(DescribeRoleAliasRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/role-aliases/{roleAlias}", DescribeRoleAliasRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeRoleAlias synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeRoleAliasRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeRoleAliasSync(DescribeRoleAliasRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeRoleAliasAsync(DescribeRoleAliasRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListCertificatesByCA asynchronously, invoking a callback when done
-- @param ListCertificatesByCARequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListCertificatesByCAAsync(ListCertificatesByCARequest, cb)
	assert(ListCertificatesByCARequest, "You must provide a ListCertificatesByCARequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListCertificatesByCA",
	}
	for header,value in pairs(ListCertificatesByCARequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/certificates-by-ca/{caCertificateId}", ListCertificatesByCARequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListCertificatesByCA synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListCertificatesByCARequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListCertificatesByCASync(ListCertificatesByCARequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListCertificatesByCAAsync(ListCertificatesByCARequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateThingGroup asynchronously, invoking a callback when done
-- @param CreateThingGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateThingGroupAsync(CreateThingGroupRequest, cb)
	assert(CreateThingGroupRequest, "You must provide a CreateThingGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateThingGroup",
	}
	for header,value in pairs(CreateThingGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/{thingGroupName}", CreateThingGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateThingGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateThingGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateThingGroupSync(CreateThingGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateThingGroupAsync(CreateThingGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateOTAUpdate asynchronously, invoking a callback when done
-- @param CreateOTAUpdateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateOTAUpdateAsync(CreateOTAUpdateRequest, cb)
	assert(CreateOTAUpdateRequest, "You must provide a CreateOTAUpdateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateOTAUpdate",
	}
	for header,value in pairs(CreateOTAUpdateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/otaUpdates/{otaUpdateId}", CreateOTAUpdateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateOTAUpdate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateOTAUpdateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateOTAUpdateSync(CreateOTAUpdateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateOTAUpdateAsync(CreateOTAUpdateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateTargetsWithJob asynchronously, invoking a callback when done
-- @param AssociateTargetsWithJobRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssociateTargetsWithJobAsync(AssociateTargetsWithJobRequest, cb)
	assert(AssociateTargetsWithJobRequest, "You must provide a AssociateTargetsWithJobRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateTargetsWithJob",
	}
	for header,value in pairs(AssociateTargetsWithJobRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/jobs/{jobId}/targets", AssociateTargetsWithJobRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateTargetsWithJob synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateTargetsWithJobRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssociateTargetsWithJobSync(AssociateTargetsWithJobRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateTargetsWithJobAsync(AssociateTargetsWithJobRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeJob asynchronously, invoking a callback when done
-- @param DescribeJobRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeJobAsync(DescribeJobRequest, cb)
	assert(DescribeJobRequest, "You must provide a DescribeJobRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeJob",
	}
	for header,value in pairs(DescribeJobRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/jobs/{jobId}", DescribeJobRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeJob synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeJobRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeJobSync(DescribeJobRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeJobAsync(DescribeJobRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeCACertificate asynchronously, invoking a callback when done
-- @param DescribeCACertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeCACertificateAsync(DescribeCACertificateRequest, cb)
	assert(DescribeCACertificateRequest, "You must provide a DescribeCACertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeCACertificate",
	}
	for header,value in pairs(DescribeCACertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/cacertificate/{caCertificateId}", DescribeCACertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeCACertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeCACertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeCACertificateSync(DescribeCACertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeCACertificateAsync(DescribeCACertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetPolicyVersion asynchronously, invoking a callback when done
-- @param GetPolicyVersionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetPolicyVersionAsync(GetPolicyVersionRequest, cb)
	assert(GetPolicyVersionRequest, "You must provide a GetPolicyVersionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetPolicyVersion",
	}
	for header,value in pairs(GetPolicyVersionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}/version/{policyVersionId}", GetPolicyVersionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetPolicyVersion synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetPolicyVersionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetPolicyVersionSync(GetPolicyVersionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetPolicyVersionAsync(GetPolicyVersionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThingRegistrationTasks asynchronously, invoking a callback when done
-- @param ListThingRegistrationTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingRegistrationTasksAsync(ListThingRegistrationTasksRequest, cb)
	assert(ListThingRegistrationTasksRequest, "You must provide a ListThingRegistrationTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThingRegistrationTasks",
	}
	for header,value in pairs(ListThingRegistrationTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-registration-tasks", ListThingRegistrationTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThingRegistrationTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingRegistrationTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingRegistrationTasksSync(ListThingRegistrationTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingRegistrationTasksAsync(ListThingRegistrationTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListJobs asynchronously, invoking a callback when done
-- @param ListJobsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListJobsAsync(ListJobsRequest, cb)
	assert(ListJobsRequest, "You must provide a ListJobsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListJobs",
	}
	for header,value in pairs(ListJobsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/jobs", ListJobsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListJobs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListJobsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListJobsSync(ListJobsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListJobsAsync(ListJobsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThingTypes asynchronously, invoking a callback when done
-- @param ListThingTypesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingTypesAsync(ListThingTypesRequest, cb)
	assert(ListThingTypesRequest, "You must provide a ListThingTypesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThingTypes",
	}
	for header,value in pairs(ListThingTypesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-types", ListThingTypesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThingTypes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingTypesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingTypesSync(ListThingTypesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingTypesAsync(ListThingTypesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateKeysAndCertificate asynchronously, invoking a callback when done
-- @param CreateKeysAndCertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateKeysAndCertificateAsync(CreateKeysAndCertificateRequest, cb)
	assert(CreateKeysAndCertificateRequest, "You must provide a CreateKeysAndCertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateKeysAndCertificate",
	}
	for header,value in pairs(CreateKeysAndCertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/keys-and-certificate", CreateKeysAndCertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateKeysAndCertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateKeysAndCertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateKeysAndCertificateSync(CreateKeysAndCertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateKeysAndCertificateAsync(CreateKeysAndCertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSecurityProfile asynchronously, invoking a callback when done
-- @param DeleteSecurityProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteSecurityProfileAsync(DeleteSecurityProfileRequest, cb)
	assert(DeleteSecurityProfileRequest, "You must provide a DeleteSecurityProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSecurityProfile",
	}
	for header,value in pairs(DeleteSecurityProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/security-profiles/{securityProfileName}", DeleteSecurityProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSecurityProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSecurityProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteSecurityProfileSync(DeleteSecurityProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSecurityProfileAsync(DeleteSecurityProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ValidateSecurityProfileBehaviors asynchronously, invoking a callback when done
-- @param ValidateSecurityProfileBehaviorsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ValidateSecurityProfileBehaviorsAsync(ValidateSecurityProfileBehaviorsRequest, cb)
	assert(ValidateSecurityProfileBehaviorsRequest, "You must provide a ValidateSecurityProfileBehaviorsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ValidateSecurityProfileBehaviors",
	}
	for header,value in pairs(ValidateSecurityProfileBehaviorsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/security-profile-behaviors/validate", ValidateSecurityProfileBehaviorsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ValidateSecurityProfileBehaviors synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ValidateSecurityProfileBehaviorsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ValidateSecurityProfileBehaviorsSync(ValidateSecurityProfileBehaviorsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ValidateSecurityProfileBehaviorsAsync(ValidateSecurityProfileBehaviorsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThings asynchronously, invoking a callback when done
-- @param ListThingsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingsAsync(ListThingsRequest, cb)
	assert(ListThingsRequest, "You must provide a ListThingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThings",
	}
	for header,value in pairs(ListThingsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/things", ListThingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingsSync(ListThingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingsAsync(ListThingsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateScheduledAudit asynchronously, invoking a callback when done
-- @param CreateScheduledAuditRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateScheduledAuditAsync(CreateScheduledAuditRequest, cb)
	assert(CreateScheduledAuditRequest, "You must provide a CreateScheduledAuditRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateScheduledAudit",
	}
	for header,value in pairs(CreateScheduledAuditRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/audit/scheduledaudits/{scheduledAuditName}", CreateScheduledAuditRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateScheduledAudit synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateScheduledAuditRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateScheduledAuditSync(CreateScheduledAuditRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateScheduledAuditAsync(CreateScheduledAuditRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListRoleAliases asynchronously, invoking a callback when done
-- @param ListRoleAliasesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListRoleAliasesAsync(ListRoleAliasesRequest, cb)
	assert(ListRoleAliasesRequest, "You must provide a ListRoleAliasesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListRoleAliases",
	}
	for header,value in pairs(ListRoleAliasesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/role-aliases", ListRoleAliasesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListRoleAliases synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListRoleAliasesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListRoleAliasesSync(ListRoleAliasesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListRoleAliasesAsync(ListRoleAliasesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSecurityProfile asynchronously, invoking a callback when done
-- @param CreateSecurityProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateSecurityProfileAsync(CreateSecurityProfileRequest, cb)
	assert(CreateSecurityProfileRequest, "You must provide a CreateSecurityProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSecurityProfile",
	}
	for header,value in pairs(CreateSecurityProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/security-profiles/{securityProfileName}", CreateSecurityProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSecurityProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSecurityProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateSecurityProfileSync(CreateSecurityProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSecurityProfileAsync(CreateSecurityProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateCertificate asynchronously, invoking a callback when done
-- @param UpdateCertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateCertificateAsync(UpdateCertificateRequest, cb)
	assert(UpdateCertificateRequest, "You must provide a UpdateCertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateCertificate",
	}
	for header,value in pairs(UpdateCertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/certificates/{certificateId}", UpdateCertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateCertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateCertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateCertificateSync(UpdateCertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateCertificateAsync(UpdateCertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetRegistrationCode asynchronously, invoking a callback when done
-- @param GetRegistrationCodeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetRegistrationCodeAsync(GetRegistrationCodeRequest, cb)
	assert(GetRegistrationCodeRequest, "You must provide a GetRegistrationCodeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetRegistrationCode",
	}
	for header,value in pairs(GetRegistrationCodeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/registrationcode", GetRegistrationCodeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetRegistrationCode synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetRegistrationCodeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetRegistrationCodeSync(GetRegistrationCodeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetRegistrationCodeAsync(GetRegistrationCodeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SetV2LoggingOptions asynchronously, invoking a callback when done
-- @param SetV2LoggingOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SetV2LoggingOptionsAsync(SetV2LoggingOptionsRequest, cb)
	assert(SetV2LoggingOptionsRequest, "You must provide a SetV2LoggingOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".SetV2LoggingOptions",
	}
	for header,value in pairs(SetV2LoggingOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/v2LoggingOptions", SetV2LoggingOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SetV2LoggingOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SetV2LoggingOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SetV2LoggingOptionsSync(SetV2LoggingOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SetV2LoggingOptionsAsync(SetV2LoggingOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListPrincipalThings asynchronously, invoking a callback when done
-- @param ListPrincipalThingsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListPrincipalThingsAsync(ListPrincipalThingsRequest, cb)
	assert(ListPrincipalThingsRequest, "You must provide a ListPrincipalThingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListPrincipalThings",
	}
	for header,value in pairs(ListPrincipalThingsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/principals/things", ListPrincipalThingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListPrincipalThings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListPrincipalThingsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListPrincipalThingsSync(ListPrincipalThingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListPrincipalThingsAsync(ListPrincipalThingsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelJobExecution asynchronously, invoking a callback when done
-- @param CancelJobExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelJobExecutionAsync(CancelJobExecutionRequest, cb)
	assert(CancelJobExecutionRequest, "You must provide a CancelJobExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelJobExecution",
	}
	for header,value in pairs(CancelJobExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/jobs/{jobId}/cancel", CancelJobExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelJobExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelJobExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelJobExecutionSync(CancelJobExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelJobExecutionAsync(CancelJobExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListAuditFindings asynchronously, invoking a callback when done
-- @param ListAuditFindingsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListAuditFindingsAsync(ListAuditFindingsRequest, cb)
	assert(ListAuditFindingsRequest, "You must provide a ListAuditFindingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListAuditFindings",
	}
	for header,value in pairs(ListAuditFindingsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/audit/findings", ListAuditFindingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListAuditFindings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListAuditFindingsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListAuditFindingsSync(ListAuditFindingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListAuditFindingsAsync(ListAuditFindingsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteJobExecution asynchronously, invoking a callback when done
-- @param DeleteJobExecutionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteJobExecutionAsync(DeleteJobExecutionRequest, cb)
	assert(DeleteJobExecutionRequest, "You must provide a DeleteJobExecutionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteJobExecution",
	}
	for header,value in pairs(DeleteJobExecutionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}", DeleteJobExecutionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteJobExecution synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteJobExecutionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteJobExecutionSync(DeleteJobExecutionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteJobExecutionAsync(DeleteJobExecutionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetEffectivePolicies asynchronously, invoking a callback when done
-- @param GetEffectivePoliciesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetEffectivePoliciesAsync(GetEffectivePoliciesRequest, cb)
	assert(GetEffectivePoliciesRequest, "You must provide a GetEffectivePoliciesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetEffectivePolicies",
	}
	for header,value in pairs(GetEffectivePoliciesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/effective-policies", GetEffectivePoliciesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetEffectivePolicies synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetEffectivePoliciesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetEffectivePoliciesSync(GetEffectivePoliciesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetEffectivePoliciesAsync(GetEffectivePoliciesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateCertificateFromCsr asynchronously, invoking a callback when done
-- @param CreateCertificateFromCsrRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateCertificateFromCsrAsync(CreateCertificateFromCsrRequest, cb)
	assert(CreateCertificateFromCsrRequest, "You must provide a CreateCertificateFromCsrRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateCertificateFromCsr",
	}
	for header,value in pairs(CreateCertificateFromCsrRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/certificates", CreateCertificateFromCsrRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateCertificateFromCsr synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateCertificateFromCsrRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateCertificateFromCsrSync(CreateCertificateFromCsrRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateCertificateFromCsrAsync(CreateCertificateFromCsrRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SetLoggingOptions asynchronously, invoking a callback when done
-- @param SetLoggingOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SetLoggingOptionsAsync(SetLoggingOptionsRequest, cb)
	assert(SetLoggingOptionsRequest, "You must provide a SetLoggingOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".SetLoggingOptions",
	}
	for header,value in pairs(SetLoggingOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/loggingOptions", SetLoggingOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SetLoggingOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SetLoggingOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SetLoggingOptionsSync(SetLoggingOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SetLoggingOptionsAsync(SetLoggingOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteStream asynchronously, invoking a callback when done
-- @param DeleteStreamRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteStreamAsync(DeleteStreamRequest, cb)
	assert(DeleteStreamRequest, "You must provide a DeleteStreamRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteStream",
	}
	for header,value in pairs(DeleteStreamRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/streams/{streamId}", DeleteStreamRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteStream synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteStreamRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteStreamSync(DeleteStreamRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteStreamAsync(DeleteStreamRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableTopicRule asynchronously, invoking a callback when done
-- @param DisableTopicRuleRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisableTopicRuleAsync(DisableTopicRuleRequest, cb)
	assert(DisableTopicRuleRequest, "You must provide a DisableTopicRuleRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisableTopicRule",
	}
	for header,value in pairs(DisableTopicRuleRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/rules/{ruleName}/disable", DisableTopicRuleRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisableTopicRule synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableTopicRuleRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisableTopicRuleSync(DisableTopicRuleRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableTopicRuleAsync(DisableTopicRuleRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call TestInvokeAuthorizer asynchronously, invoking a callback when done
-- @param TestInvokeAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.TestInvokeAuthorizerAsync(TestInvokeAuthorizerRequest, cb)
	assert(TestInvokeAuthorizerRequest, "You must provide a TestInvokeAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".TestInvokeAuthorizer",
	}
	for header,value in pairs(TestInvokeAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/authorizer/{authorizerName}/test", TestInvokeAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call TestInvokeAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param TestInvokeAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.TestInvokeAuthorizerSync(TestInvokeAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.TestInvokeAuthorizerAsync(TestInvokeAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateIndexingConfiguration asynchronously, invoking a callback when done
-- @param UpdateIndexingConfigurationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateIndexingConfigurationAsync(UpdateIndexingConfigurationRequest, cb)
	assert(UpdateIndexingConfigurationRequest, "You must provide a UpdateIndexingConfigurationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateIndexingConfiguration",
	}
	for header,value in pairs(UpdateIndexingConfigurationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/indexing/config", UpdateIndexingConfigurationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateIndexingConfiguration synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateIndexingConfigurationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateIndexingConfigurationSync(UpdateIndexingConfigurationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateIndexingConfigurationAsync(UpdateIndexingConfigurationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreatePolicy asynchronously, invoking a callback when done
-- @param CreatePolicyRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreatePolicyAsync(CreatePolicyRequest, cb)
	assert(CreatePolicyRequest, "You must provide a CreatePolicyRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreatePolicy",
	}
	for header,value in pairs(CreatePolicyRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}", CreatePolicyRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreatePolicy synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreatePolicyRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreatePolicySync(CreatePolicyRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreatePolicyAsync(CreatePolicyRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachSecurityProfile asynchronously, invoking a callback when done
-- @param AttachSecurityProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachSecurityProfileAsync(AttachSecurityProfileRequest, cb)
	assert(AttachSecurityProfileRequest, "You must provide a AttachSecurityProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachSecurityProfile",
	}
	for header,value in pairs(AttachSecurityProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/security-profiles/{securityProfileName}/targets", AttachSecurityProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachSecurityProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachSecurityProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachSecurityProfileSync(AttachSecurityProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachSecurityProfileAsync(AttachSecurityProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListJobExecutionsForThing asynchronously, invoking a callback when done
-- @param ListJobExecutionsForThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListJobExecutionsForThingAsync(ListJobExecutionsForThingRequest, cb)
	assert(ListJobExecutionsForThingRequest, "You must provide a ListJobExecutionsForThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListJobExecutionsForThing",
	}
	for header,value in pairs(ListJobExecutionsForThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/jobs", ListJobExecutionsForThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListJobExecutionsForThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListJobExecutionsForThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListJobExecutionsForThingSync(ListJobExecutionsForThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListJobExecutionsForThingAsync(ListJobExecutionsForThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterCertificate asynchronously, invoking a callback when done
-- @param RegisterCertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterCertificateAsync(RegisterCertificateRequest, cb)
	assert(RegisterCertificateRequest, "You must provide a RegisterCertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RegisterCertificate",
	}
	for header,value in pairs(RegisterCertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/certificate/register", RegisterCertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterCertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterCertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterCertificateSync(RegisterCertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterCertificateAsync(RegisterCertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListOTAUpdates asynchronously, invoking a callback when done
-- @param ListOTAUpdatesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListOTAUpdatesAsync(ListOTAUpdatesRequest, cb)
	assert(ListOTAUpdatesRequest, "You must provide a ListOTAUpdatesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListOTAUpdates",
	}
	for header,value in pairs(ListOTAUpdatesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/otaUpdates", ListOTAUpdatesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListOTAUpdates synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListOTAUpdatesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListOTAUpdatesSync(ListOTAUpdatesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListOTAUpdatesAsync(ListOTAUpdatesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteThingType asynchronously, invoking a callback when done
-- @param DeleteThingTypeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteThingTypeAsync(DeleteThingTypeRequest, cb)
	assert(DeleteThingTypeRequest, "You must provide a DeleteThingTypeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteThingType",
	}
	for header,value in pairs(DeleteThingTypeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/thing-types/{thingTypeName}", DeleteThingTypeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteThingType synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteThingTypeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteThingTypeSync(DeleteThingTypeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteThingTypeAsync(DeleteThingTypeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeThingGroup asynchronously, invoking a callback when done
-- @param DescribeThingGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeThingGroupAsync(DescribeThingGroupRequest, cb)
	assert(DescribeThingGroupRequest, "You must provide a DescribeThingGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeThingGroup",
	}
	for header,value in pairs(DescribeThingGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/{thingGroupName}", DescribeThingGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeThingGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeThingGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeThingGroupSync(DescribeThingGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeThingGroupAsync(DescribeThingGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StopThingRegistrationTask asynchronously, invoking a callback when done
-- @param StopThingRegistrationTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StopThingRegistrationTaskAsync(StopThingRegistrationTaskRequest, cb)
	assert(StopThingRegistrationTaskRequest, "You must provide a StopThingRegistrationTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".StopThingRegistrationTask",
	}
	for header,value in pairs(StopThingRegistrationTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/thing-registration-tasks/{taskId}/cancel", StopThingRegistrationTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StopThingRegistrationTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StopThingRegistrationTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StopThingRegistrationTaskSync(StopThingRegistrationTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StopThingRegistrationTaskAsync(StopThingRegistrationTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AddThingToThingGroup asynchronously, invoking a callback when done
-- @param AddThingToThingGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AddThingToThingGroupAsync(AddThingToThingGroupRequest, cb)
	assert(AddThingToThingGroupRequest, "You must provide a AddThingToThingGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AddThingToThingGroup",
	}
	for header,value in pairs(AddThingToThingGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/addThingToThingGroup", AddThingToThingGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AddThingToThingGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AddThingToThingGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AddThingToThingGroupSync(AddThingToThingGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AddThingToThingGroupAsync(AddThingToThingGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call SetDefaultPolicyVersion asynchronously, invoking a callback when done
-- @param SetDefaultPolicyVersionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.SetDefaultPolicyVersionAsync(SetDefaultPolicyVersionRequest, cb)
	assert(SetDefaultPolicyVersionRequest, "You must provide a SetDefaultPolicyVersionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".SetDefaultPolicyVersion",
	}
	for header,value in pairs(SetDefaultPolicyVersionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}/version/{policyVersionId}", SetDefaultPolicyVersionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call SetDefaultPolicyVersion synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param SetDefaultPolicyVersionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.SetDefaultPolicyVersionSync(SetDefaultPolicyVersionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.SetDefaultPolicyVersionAsync(SetDefaultPolicyVersionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListPolicyVersions asynchronously, invoking a callback when done
-- @param ListPolicyVersionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListPolicyVersionsAsync(ListPolicyVersionsRequest, cb)
	assert(ListPolicyVersionsRequest, "You must provide a ListPolicyVersionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListPolicyVersions",
	}
	for header,value in pairs(ListPolicyVersionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/policies/{policyName}/version", ListPolicyVersionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListPolicyVersions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListPolicyVersionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListPolicyVersionsSync(ListPolicyVersionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListPolicyVersionsAsync(ListPolicyVersionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAccountAuditConfiguration asynchronously, invoking a callback when done
-- @param DescribeAccountAuditConfigurationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAccountAuditConfigurationAsync(DescribeAccountAuditConfigurationRequest, cb)
	assert(DescribeAccountAuditConfigurationRequest, "You must provide a DescribeAccountAuditConfigurationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAccountAuditConfiguration",
	}
	for header,value in pairs(DescribeAccountAuditConfigurationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/audit/configuration", DescribeAccountAuditConfigurationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAccountAuditConfiguration synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAccountAuditConfigurationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAccountAuditConfigurationSync(DescribeAccountAuditConfigurationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAccountAuditConfigurationAsync(DescribeAccountAuditConfigurationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetLoggingOptions asynchronously, invoking a callback when done
-- @param GetLoggingOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetLoggingOptionsAsync(GetLoggingOptionsRequest, cb)
	assert(GetLoggingOptionsRequest, "You must provide a GetLoggingOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetLoggingOptions",
	}
	for header,value in pairs(GetLoggingOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/loggingOptions", GetLoggingOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetLoggingOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetLoggingOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetLoggingOptionsSync(GetLoggingOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetLoggingOptionsAsync(GetLoggingOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachPolicy asynchronously, invoking a callback when done
-- @param DetachPolicyRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachPolicyAsync(DetachPolicyRequest, cb)
	assert(DetachPolicyRequest, "You must provide a DetachPolicyRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachPolicy",
	}
	for header,value in pairs(DetachPolicyRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/target-policies/{policyName}", DetachPolicyRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachPolicy synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachPolicyRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachPolicySync(DetachPolicyRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachPolicyAsync(DetachPolicyRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThingGroups asynchronously, invoking a callback when done
-- @param ListThingGroupsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingGroupsAsync(ListThingGroupsRequest, cb)
	assert(ListThingGroupsRequest, "You must provide a ListThingGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThingGroups",
	}
	for header,value in pairs(ListThingGroupsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-groups", ListThingGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThingGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingGroupsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingGroupsSync(ListThingGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingGroupsAsync(ListThingGroupsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterThing asynchronously, invoking a callback when done
-- @param RegisterThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterThingAsync(RegisterThingRequest, cb)
	assert(RegisterThingRequest, "You must provide a RegisterThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RegisterThing",
	}
	for header,value in pairs(RegisterThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/things", RegisterThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterThingSync(RegisterThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterThingAsync(RegisterThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateRoleAlias asynchronously, invoking a callback when done
-- @param UpdateRoleAliasRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateRoleAliasAsync(UpdateRoleAliasRequest, cb)
	assert(UpdateRoleAliasRequest, "You must provide a UpdateRoleAliasRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateRoleAlias",
	}
	for header,value in pairs(UpdateRoleAliasRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/role-aliases/{roleAlias}", UpdateRoleAliasRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateRoleAlias synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateRoleAliasRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateRoleAliasSync(UpdateRoleAliasRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateRoleAliasAsync(UpdateRoleAliasRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteCACertificate asynchronously, invoking a callback when done
-- @param DeleteCACertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteCACertificateAsync(DeleteCACertificateRequest, cb)
	assert(DeleteCACertificateRequest, "You must provide a DeleteCACertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteCACertificate",
	}
	for header,value in pairs(DeleteCACertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/cacertificate/{caCertificateId}", DeleteCACertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteCACertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteCACertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteCACertificateSync(DeleteCACertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteCACertificateAsync(DeleteCACertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateSecurityProfile asynchronously, invoking a callback when done
-- @param UpdateSecurityProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateSecurityProfileAsync(UpdateSecurityProfileRequest, cb)
	assert(UpdateSecurityProfileRequest, "You must provide a UpdateSecurityProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateSecurityProfile",
	}
	for header,value in pairs(UpdateSecurityProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/security-profiles/{securityProfileName}", UpdateSecurityProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateSecurityProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateSecurityProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateSecurityProfileSync(UpdateSecurityProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateSecurityProfileAsync(UpdateSecurityProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateThingType asynchronously, invoking a callback when done
-- @param CreateThingTypeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateThingTypeAsync(CreateThingTypeRequest, cb)
	assert(CreateThingTypeRequest, "You must provide a CreateThingTypeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateThingType",
	}
	for header,value in pairs(CreateThingTypeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/thing-types/{thingTypeName}", CreateThingTypeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateThingType synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateThingTypeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateThingTypeSync(CreateThingTypeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateThingTypeAsync(CreateThingTypeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteAccountAuditConfiguration asynchronously, invoking a callback when done
-- @param DeleteAccountAuditConfigurationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteAccountAuditConfigurationAsync(DeleteAccountAuditConfigurationRequest, cb)
	assert(DeleteAccountAuditConfigurationRequest, "You must provide a DeleteAccountAuditConfigurationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteAccountAuditConfiguration",
	}
	for header,value in pairs(DeleteAccountAuditConfigurationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/audit/configuration", DeleteAccountAuditConfigurationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteAccountAuditConfiguration synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteAccountAuditConfigurationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteAccountAuditConfigurationSync(DeleteAccountAuditConfigurationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteAccountAuditConfigurationAsync(DeleteAccountAuditConfigurationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateStream asynchronously, invoking a callback when done
-- @param UpdateStreamRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateStreamAsync(UpdateStreamRequest, cb)
	assert(UpdateStreamRequest, "You must provide a UpdateStreamRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateStream",
	}
	for header,value in pairs(UpdateStreamRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/streams/{streamId}", UpdateStreamRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateStream synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateStreamRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateStreamSync(UpdateStreamRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateStreamAsync(UpdateStreamRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateJob asynchronously, invoking a callback when done
-- @param CreateJobRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateJobAsync(CreateJobRequest, cb)
	assert(CreateJobRequest, "You must provide a CreateJobRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateJob",
	}
	for header,value in pairs(CreateJobRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/jobs/{jobId}", CreateJobRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateJob synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateJobRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateJobSync(CreateJobRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateJobAsync(CreateJobRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteThing asynchronously, invoking a callback when done
-- @param DeleteThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteThingAsync(DeleteThingRequest, cb)
	assert(DeleteThingRequest, "You must provide a DeleteThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteThing",
	}
	for header,value in pairs(DeleteThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}", DeleteThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteThingSync(DeleteThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteThingAsync(DeleteThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachPolicy asynchronously, invoking a callback when done
-- @param AttachPolicyRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachPolicyAsync(AttachPolicyRequest, cb)
	assert(AttachPolicyRequest, "You must provide a AttachPolicyRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachPolicy",
	}
	for header,value in pairs(AttachPolicyRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/target-policies/{policyName}", AttachPolicyRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachPolicy synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachPolicyRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachPolicySync(AttachPolicyRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachPolicyAsync(AttachPolicyRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListSecurityProfilesForTarget asynchronously, invoking a callback when done
-- @param ListSecurityProfilesForTargetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListSecurityProfilesForTargetAsync(ListSecurityProfilesForTargetRequest, cb)
	assert(ListSecurityProfilesForTargetRequest, "You must provide a ListSecurityProfilesForTargetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListSecurityProfilesForTarget",
	}
	for header,value in pairs(ListSecurityProfilesForTargetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/security-profiles-for-target", ListSecurityProfilesForTargetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListSecurityProfilesForTarget synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListSecurityProfilesForTargetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListSecurityProfilesForTargetSync(ListSecurityProfilesForTargetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListSecurityProfilesForTargetAsync(ListSecurityProfilesForTargetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListJobExecutionsForJob asynchronously, invoking a callback when done
-- @param ListJobExecutionsForJobRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListJobExecutionsForJobAsync(ListJobExecutionsForJobRequest, cb)
	assert(ListJobExecutionsForJobRequest, "You must provide a ListJobExecutionsForJobRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListJobExecutionsForJob",
	}
	for header,value in pairs(ListJobExecutionsForJobRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/jobs/{jobId}/things", ListJobExecutionsForJobRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListJobExecutionsForJob synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListJobExecutionsForJobRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListJobExecutionsForJobSync(ListJobExecutionsForJobRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListJobExecutionsForJobAsync(ListJobExecutionsForJobRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListIndices asynchronously, invoking a callback when done
-- @param ListIndicesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListIndicesAsync(ListIndicesRequest, cb)
	assert(ListIndicesRequest, "You must provide a ListIndicesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListIndices",
	}
	for header,value in pairs(ListIndicesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/indices", ListIndicesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListIndices synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListIndicesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListIndicesSync(ListIndicesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListIndicesAsync(ListIndicesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateCACertificate asynchronously, invoking a callback when done
-- @param UpdateCACertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateCACertificateAsync(UpdateCACertificateRequest, cb)
	assert(UpdateCACertificateRequest, "You must provide a UpdateCACertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateCACertificate",
	}
	for header,value in pairs(UpdateCACertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/cacertificate/{caCertificateId}", UpdateCACertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateCACertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateCACertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateCACertificateSync(UpdateCACertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateCACertificateAsync(UpdateCACertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateAuthorizer asynchronously, invoking a callback when done
-- @param UpdateAuthorizerRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateAuthorizerAsync(UpdateAuthorizerRequest, cb)
	assert(UpdateAuthorizerRequest, "You must provide a UpdateAuthorizerRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateAuthorizer",
	}
	for header,value in pairs(UpdateAuthorizerRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PUT")
	if request_handler then
		request_handler(settings.uri, "/authorizer/{authorizerName}", UpdateAuthorizerRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateAuthorizer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateAuthorizerRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateAuthorizerSync(UpdateAuthorizerRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateAuthorizerAsync(UpdateAuthorizerRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateStream asynchronously, invoking a callback when done
-- @param CreateStreamRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateStreamAsync(CreateStreamRequest, cb)
	assert(CreateStreamRequest, "You must provide a CreateStreamRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateStream",
	}
	for header,value in pairs(CreateStreamRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/streams/{streamId}", CreateStreamRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateStream synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateStreamRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateStreamSync(CreateStreamRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateStreamAsync(CreateStreamRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateEventConfigurations asynchronously, invoking a callback when done
-- @param UpdateEventConfigurationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateEventConfigurationsAsync(UpdateEventConfigurationsRequest, cb)
	assert(UpdateEventConfigurationsRequest, "You must provide a UpdateEventConfigurationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateEventConfigurations",
	}
	for header,value in pairs(UpdateEventConfigurationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/event-configurations", UpdateEventConfigurationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateEventConfigurations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateEventConfigurationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateEventConfigurationsSync(UpdateEventConfigurationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateEventConfigurationsAsync(UpdateEventConfigurationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelCertificateTransfer asynchronously, invoking a callback when done
-- @param CancelCertificateTransferRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelCertificateTransferAsync(CancelCertificateTransferRequest, cb)
	assert(CancelCertificateTransferRequest, "You must provide a CancelCertificateTransferRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelCertificateTransfer",
	}
	for header,value in pairs(CancelCertificateTransferRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/cancel-certificate-transfer/{certificateId}", CancelCertificateTransferRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelCertificateTransfer synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelCertificateTransferRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelCertificateTransferSync(CancelCertificateTransferRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelCertificateTransferAsync(CancelCertificateTransferRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThingsInThingGroup asynchronously, invoking a callback when done
-- @param ListThingsInThingGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingsInThingGroupAsync(ListThingsInThingGroupRequest, cb)
	assert(ListThingsInThingGroupRequest, "You must provide a ListThingsInThingGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThingsInThingGroup",
	}
	for header,value in pairs(ListThingsInThingGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/{thingGroupName}/things", ListThingsInThingGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThingsInThingGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingsInThingGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingsInThingGroupSync(ListThingsInThingGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingsInThingGroupAsync(ListThingsInThingGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeCertificate asynchronously, invoking a callback when done
-- @param DescribeCertificateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeCertificateAsync(DescribeCertificateRequest, cb)
	assert(DescribeCertificateRequest, "You must provide a DescribeCertificateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeCertificate",
	}
	for header,value in pairs(DescribeCertificateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/certificates/{certificateId}", DescribeCertificateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeCertificate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeCertificateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeCertificateSync(DescribeCertificateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeCertificateAsync(DescribeCertificateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeEventConfigurations asynchronously, invoking a callback when done
-- @param DescribeEventConfigurationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeEventConfigurationsAsync(DescribeEventConfigurationsRequest, cb)
	assert(DescribeEventConfigurationsRequest, "You must provide a DescribeEventConfigurationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeEventConfigurations",
	}
	for header,value in pairs(DescribeEventConfigurationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/event-configurations", DescribeEventConfigurationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeEventConfigurations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeEventConfigurationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeEventConfigurationsSync(DescribeEventConfigurationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeEventConfigurationsAsync(DescribeEventConfigurationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListSecurityProfiles asynchronously, invoking a callback when done
-- @param ListSecurityProfilesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListSecurityProfilesAsync(ListSecurityProfilesRequest, cb)
	assert(ListSecurityProfilesRequest, "You must provide a ListSecurityProfilesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListSecurityProfiles",
	}
	for header,value in pairs(ListSecurityProfilesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/security-profiles", ListSecurityProfilesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListSecurityProfiles synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListSecurityProfilesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListSecurityProfilesSync(ListSecurityProfilesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListSecurityProfilesAsync(ListSecurityProfilesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachThingPrincipal asynchronously, invoking a callback when done
-- @param DetachThingPrincipalRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachThingPrincipalAsync(DetachThingPrincipalRequest, cb)
	assert(DetachThingPrincipalRequest, "You must provide a DetachThingPrincipalRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachThingPrincipal",
	}
	for header,value in pairs(DetachThingPrincipalRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "DELETE")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/principals", DetachThingPrincipalRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachThingPrincipal synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachThingPrincipalRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachThingPrincipalSync(DetachThingPrincipalRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachThingPrincipalAsync(DetachThingPrincipalRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListTargetsForPolicy asynchronously, invoking a callback when done
-- @param ListTargetsForPolicyRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListTargetsForPolicyAsync(ListTargetsForPolicyRequest, cb)
	assert(ListTargetsForPolicyRequest, "You must provide a ListTargetsForPolicyRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListTargetsForPolicy",
	}
	for header,value in pairs(ListTargetsForPolicyRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/policy-targets/{policyName}", ListTargetsForPolicyRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListTargetsForPolicy synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListTargetsForPolicyRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListTargetsForPolicySync(ListTargetsForPolicyRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListTargetsForPolicyAsync(ListTargetsForPolicyRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListPolicies asynchronously, invoking a callback when done
-- @param ListPoliciesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListPoliciesAsync(ListPoliciesRequest, cb)
	assert(ListPoliciesRequest, "You must provide a ListPoliciesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListPolicies",
	}
	for header,value in pairs(ListPoliciesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/policies", ListPoliciesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListPolicies synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListPoliciesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListPoliciesSync(ListPoliciesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListPoliciesAsync(ListPoliciesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateThing asynchronously, invoking a callback when done
-- @param CreateThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateThingAsync(CreateThingRequest, cb)
	assert(CreateThingRequest, "You must provide a CreateThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateThing",
	}
	for header,value in pairs(CreateThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "POST")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}", CreateThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateThingSync(CreateThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateThingAsync(CreateThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThingGroupsForThing asynchronously, invoking a callback when done
-- @param ListThingGroupsForThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingGroupsForThingAsync(ListThingGroupsForThingRequest, cb)
	assert(ListThingGroupsForThingRequest, "You must provide a ListThingGroupsForThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThingGroupsForThing",
	}
	for header,value in pairs(ListThingGroupsForThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/thing-groups", ListThingGroupsForThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThingGroupsForThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingGroupsForThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingGroupsForThingSync(ListThingGroupsForThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingGroupsForThingAsync(ListThingGroupsForThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateScheduledAudit asynchronously, invoking a callback when done
-- @param UpdateScheduledAuditRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateScheduledAuditAsync(UpdateScheduledAuditRequest, cb)
	assert(UpdateScheduledAuditRequest, "You must provide a UpdateScheduledAuditRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateScheduledAudit",
	}
	for header,value in pairs(UpdateScheduledAuditRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/audit/scheduledaudits/{scheduledAuditName}", UpdateScheduledAuditRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateScheduledAudit synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateScheduledAuditRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateScheduledAuditSync(UpdateScheduledAuditRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateScheduledAuditAsync(UpdateScheduledAuditRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ListThingPrincipals asynchronously, invoking a callback when done
-- @param ListThingPrincipalsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ListThingPrincipalsAsync(ListThingPrincipalsRequest, cb)
	assert(ListThingPrincipalsRequest, "You must provide a ListThingPrincipalsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ListThingPrincipals",
	}
	for header,value in pairs(ListThingPrincipalsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}/principals", ListThingPrincipalsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ListThingPrincipals synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ListThingPrincipalsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ListThingPrincipalsSync(ListThingPrincipalsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ListThingPrincipalsAsync(ListThingPrincipalsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateThingGroup asynchronously, invoking a callback when done
-- @param UpdateThingGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateThingGroupAsync(UpdateThingGroupRequest, cb)
	assert(UpdateThingGroupRequest, "You must provide a UpdateThingGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateThingGroup",
	}
	for header,value in pairs(UpdateThingGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "PATCH")
	if request_handler then
		request_handler(settings.uri, "/thing-groups/{thingGroupName}", UpdateThingGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateThingGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateThingGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateThingGroupSync(UpdateThingGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateThingGroupAsync(UpdateThingGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeThing asynchronously, invoking a callback when done
-- @param DescribeThingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeThingAsync(DescribeThingRequest, cb)
	assert(DescribeThingRequest, "You must provide a DescribeThingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeThing",
	}
	for header,value in pairs(DescribeThingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("rest-json", "GET")
	if request_handler then
		request_handler(settings.uri, "/things/{thingName}", DescribeThingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeThing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeThingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeThingSync(DescribeThingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeThingAsync(DescribeThingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end


return M
