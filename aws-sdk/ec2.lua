--- GENERATED CODE - DO NOT MODIFY
-- Amazon Elastic Compute Cloud (ec2-2016-11-15)

local M = {}

M.metadata = {
	api_version = "2016-11-15",
	json_version = "",
	protocol = "ec2",
	checksum_format = "",
	endpoint_prefix = "ec2",
	service_abbreviation = "Amazon EC2",
	service_full_name = "Amazon Elastic Compute Cloud",
	signature_version = "v4",
	target_prefix = "",
	timestamp_format = "",
	global_endpoint = "",
	uid = "ec2-2016-11-15",
}

local keys = {}
local asserts = {}

keys.NetworkAcl = { ["Associations"] = true, ["NetworkAclId"] = true, ["VpcId"] = true, ["Tags"] = true, ["Entries"] = true, ["IsDefault"] = true, nil }

function asserts.AssertNetworkAcl(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAcl to be of type 'table'")
	if struct["Associations"] then asserts.AssertNetworkAclAssociationList(struct["Associations"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Entries"] then asserts.AssertNetworkAclEntryList(struct["Entries"]) end
	if struct["IsDefault"] then asserts.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAcl[k], "NetworkAcl contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAcl
-- <p>Describes a network ACL.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Associations [NetworkAclAssociationList] <p>Any associations between the network ACL and one or more subnets</p>
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * VpcId [String] <p>The ID of the VPC for the network ACL.</p>
-- * Tags [TagList] <p>Any tags assigned to the network ACL.</p>
-- * Entries [NetworkAclEntryList] <p>One or more entries (rules) in the network ACL.</p>
-- * IsDefault [Boolean] <p>Indicates whether this is the default network ACL for the VPC.</p>
-- @return NetworkAcl structure as a key-value pair table
function M.NetworkAcl(args)
	assert(args, "You must provide an argument table when creating NetworkAcl")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Associations"] = args["Associations"],
		["NetworkAclId"] = args["NetworkAclId"],
		["VpcId"] = args["VpcId"],
		["Tags"] = args["Tags"],
		["Entries"] = args["Entries"],
		["IsDefault"] = args["IsDefault"],
	}
	asserts.AssertNetworkAcl(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSecurityGroupResult = { ["GroupId"] = true, nil }

function asserts.AssertCreateSecurityGroupResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupResult to be of type 'table'")
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityGroupResult[k], "CreateSecurityGroupResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return CreateSecurityGroupResult structure as a key-value pair table
function M.CreateSecurityGroupResult(args)
	assert(args, "You must provide an argument table when creating CreateSecurityGroupResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertCreateSecurityGroupResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateFpgaImageResult = { ["FpgaImageId"] = true, ["FpgaImageGlobalId"] = true, nil }

function asserts.AssertCreateFpgaImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageResult to be of type 'table'")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["FpgaImageGlobalId"] then asserts.AssertString(struct["FpgaImageGlobalId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFpgaImageResult[k], "CreateFpgaImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- * FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
-- @return CreateFpgaImageResult structure as a key-value pair table
function M.CreateFpgaImageResult(args)
	assert(args, "You must provide an argument table when creating CreateFpgaImageResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageId"] = args["FpgaImageId"],
		["FpgaImageGlobalId"] = args["FpgaImageGlobalId"],
	}
	asserts.AssertCreateFpgaImageResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcCidrBlockState = { ["State"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVpcCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcCidrBlockState to be of type 'table'")
	if struct["State"] then asserts.AssertVpcCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcCidrBlockState[k], "VpcCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [VpcCidrBlockStateCode] <p>The state of the CIDR block.</p>
-- * StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
-- @return VpcCidrBlockState structure as a key-value pair table
function M.VpcCidrBlockState(args)
	assert(args, "You must provide an argument table when creating VpcCidrBlockState")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertVpcCidrBlockState(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceBlockDeviceMapping = { ["DeviceName"] = true, ["Ebs"] = true, nil }

function asserts.AssertInstanceBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Ebs"] then asserts.AssertEbsInstanceBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceBlockDeviceMapping[k], "InstanceBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * Ebs [EbsInstanceBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
-- @return InstanceBlockDeviceMapping structure as a key-value pair table
function M.InstanceBlockDeviceMapping(args)
	assert(args, "You must provide an argument table when creating InstanceBlockDeviceMapping")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceName"] = args["DeviceName"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertInstanceBlockDeviceMapping(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportInstanceTaskDetails = { ["InstanceId"] = true, ["Platform"] = true, ["Description"] = true, ["Volumes"] = true, nil }

function asserts.AssertImportInstanceTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceTaskDetails to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Volumes"] then asserts.AssertImportInstanceVolumeDetailSet(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceTaskDetails[k], "ImportInstanceTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceTaskDetails
-- <p>Describes an import instance task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Platform [PlatformValues] <p>The instance operating system.</p>
-- * Description [String] <p>A description of the task.</p>
-- * Volumes [ImportInstanceVolumeDetailSet] <p>One or more volumes.</p>
-- @return ImportInstanceTaskDetails structure as a key-value pair table
function M.ImportInstanceTaskDetails(args)
	assert(args, "You must provide an argument table when creating ImportInstanceTaskDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Platform"] = args["Platform"],
		["Description"] = args["Description"],
		["Volumes"] = args["Volumes"],
	}
	asserts.AssertImportInstanceTaskDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDefaultSubnetResult = { ["Subnet"] = true, nil }

function asserts.AssertCreateDefaultSubnetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDefaultSubnetResult to be of type 'table'")
	if struct["Subnet"] then asserts.AssertSubnet(struct["Subnet"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDefaultSubnetResult[k], "CreateDefaultSubnetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDefaultSubnetResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Subnet [Subnet] <p>Information about the subnet.</p>
-- @return CreateDefaultSubnetResult structure as a key-value pair table
function M.CreateDefaultSubnetResult(args)
	assert(args, "You must provide an argument table when creating CreateDefaultSubnetResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Subnet"] = args["Subnet"],
	}
	asserts.AssertCreateDefaultSubnetResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PurchaseRequest = { ["InstanceCount"] = true, ["PurchaseToken"] = true, nil }

function asserts.AssertPurchaseRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PurchaseToken"], "Expected key PurchaseToken to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["PurchaseToken"] then asserts.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseRequest[k], "PurchaseRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseRequest
-- <p>Describes a request to purchase Scheduled Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The number of instances.</p>
-- * PurchaseToken [String] <p>The purchase token.</p>
-- Required key: InstanceCount
-- Required key: PurchaseToken
-- @return PurchaseRequest structure as a key-value pair table
function M.PurchaseRequest(args)
	assert(args, "You must provide an argument table when creating PurchaseRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceCount"] = args["InstanceCount"],
		["PurchaseToken"] = args["PurchaseToken"],
	}
	asserts.AssertPurchaseRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceCreditSpecificationRequest = { ["InstanceId"] = true, ["CpuCredits"] = true, nil }

function asserts.AssertInstanceCreditSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCreditSpecificationRequest to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["CpuCredits"] then asserts.AssertString(struct["CpuCredits"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCreditSpecificationRequest[k], "InstanceCreditSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCreditSpecificationRequest
-- <p>Describes the credit option for CPU usage of a T2 or T3 instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * CpuCredits [String] <p>The credit option for CPU usage of the instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>
-- @return InstanceCreditSpecificationRequest structure as a key-value pair table
function M.InstanceCreditSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating InstanceCreditSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["CpuCredits"] = args["CpuCredits"],
	}
	asserts.AssertInstanceCreditSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpnConnectionsResult = { ["VpnConnections"] = true, nil }

function asserts.AssertDescribeVpnConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsResult to be of type 'table'")
	if struct["VpnConnections"] then asserts.AssertVpnConnectionList(struct["VpnConnections"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnConnectionsResult[k], "DescribeVpnConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsResult
-- <p>Contains the output of DescribeVpnConnections.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnections [VpnConnectionList] <p>Information about one or more VPN connections.</p>
-- @return DescribeVpnConnectionsResult structure as a key-value pair table
function M.DescribeVpnConnectionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpnConnectionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpnConnections"] = args["VpnConnections"],
	}
	asserts.AssertDescribeVpnConnectionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcTenancyResult = { ["ReturnValue"] = true, nil }

function asserts.AssertModifyVpcTenancyResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcTenancyResult to be of type 'table'")
	if struct["ReturnValue"] then asserts.AssertBoolean(struct["ReturnValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcTenancyResult[k], "ModifyVpcTenancyResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcTenancyResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReturnValue [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, returns an error.</p>
-- @return ModifyVpcTenancyResult structure as a key-value pair table
function M.ModifyVpcTenancyResult(args)
	assert(args, "You must provide an argument table when creating ModifyVpcTenancyResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReturnValue"] = args["ReturnValue"],
	}
	asserts.AssertModifyVpcTenancyResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcPeeringConnectionRequest = { ["VpcId"] = true, ["PeerOwnerId"] = true, ["PeerRegion"] = true, ["PeerVpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PeerOwnerId"] then asserts.AssertString(struct["PeerOwnerId"]) end
	if struct["PeerRegion"] then asserts.AssertString(struct["PeerRegion"]) end
	if struct["PeerVpcId"] then asserts.AssertString(struct["PeerVpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcPeeringConnectionRequest[k], "CreateVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the requester VPC. You must specify this parameter in the request.</p>
-- * PeerOwnerId [String] <p>The AWS account ID of the owner of the accepter VPC.</p> <p>Default: Your AWS account ID</p>
-- * PeerRegion [String] <p>The region code for the accepter VPC, if the accepter VPC is located in a region other than the region in which you make the request.</p> <p>Default: The region in which you make the request.</p>
-- * PeerVpcId [String] <p>The ID of the VPC with which you are creating the VPC peering connection. You must specify this parameter in the request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return CreateVpcPeeringConnectionRequest structure as a key-value pair table
function M.CreateVpcPeeringConnectionRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpcPeeringConnectionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["PeerOwnerId"] = args["PeerOwnerId"],
		["PeerRegion"] = args["PeerRegion"],
		["PeerVpcId"] = args["PeerVpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateVpcPeeringConnectionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyCapacityReservationResult = { ["Return"] = true, nil }

function asserts.AssertModifyCapacityReservationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyCapacityReservationResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyCapacityReservationResult[k], "ModifyCapacityReservationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyCapacityReservationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Information about the Capacity Reservation.</p>
-- @return ModifyCapacityReservationResult structure as a key-value pair table
function M.ModifyCapacityReservationResult(args)
	assert(args, "You must provide an argument table when creating ModifyCapacityReservationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyCapacityReservationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpnConnectionRouteRequest = { ["VpnConnectionId"] = true, ["DestinationCidrBlock"] = true, nil }

function asserts.AssertDeleteVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnConnectionRouteRequest[k], "DeleteVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRouteRequest
-- <p>Contains the parameters for DeleteVpnConnectionRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required key: DestinationCidrBlock
-- Required key: VpnConnectionId
-- @return DeleteVpnConnectionRouteRequest structure as a key-value pair table
function M.DeleteVpnConnectionRouteRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpnConnectionRouteRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpnConnectionId"] = args["VpnConnectionId"],
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
	}
	asserts.AssertDeleteVpnConnectionRouteRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesNetworkInterface = { ["PrivateIpAddressConfigs"] = true, ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertScheduledInstancesNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesNetworkInterface to be of type 'table'")
	if struct["PrivateIpAddressConfigs"] then asserts.AssertPrivateIpAddressConfigSet(struct["PrivateIpAddressConfigs"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertScheduledInstancesSecurityGroupIdSet(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertScheduledInstancesIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesNetworkInterface[k], "ScheduledInstancesNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesNetworkInterface
-- <p>Describes a network interface for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrivateIpAddressConfigs [PrivateIpAddressConfigSet] <p>The private IPv4 addresses.</p>
-- * DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- * Description [String] <p>The description.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether to delete the interface when the instance is terminated.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- * Groups [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- * Ipv6Addresses [ScheduledInstancesIpv6AddressList] <p>One or more specific IPv6 addresses from the subnet range.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses.</p>
-- @return ScheduledInstancesNetworkInterface structure as a key-value pair table
function M.ScheduledInstancesNetworkInterface(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesNetworkInterface")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrivateIpAddressConfigs"] = args["PrivateIpAddressConfigs"],
		["DeviceIndex"] = args["DeviceIndex"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["SubnetId"] = args["SubnetId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociatePublicIpAddress"] = args["AssociatePublicIpAddress"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
	}
	asserts.AssertScheduledInstancesNetworkInterface(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPasswordDataRequest = { ["InstanceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetPasswordDataRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPasswordDataRequest[k], "GetPasswordDataRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataRequest
-- <p>Contains the parameters for GetPasswordData.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the Windows instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- @return GetPasswordDataRequest structure as a key-value pair table
function M.GetPasswordDataRequest(args)
	assert(args, "You must provide an argument table when creating GetPasswordDataRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertGetPasswordDataRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeImagesResult = { ["Images"] = true, nil }

function asserts.AssertDescribeImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesResult to be of type 'table'")
	if struct["Images"] then asserts.AssertImageList(struct["Images"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImagesResult[k], "DescribeImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesResult
-- <p>Contains the output of DescribeImages.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Images [ImageList] <p>Information about one or more images.</p>
-- @return DescribeImagesResult structure as a key-value pair table
function M.DescribeImagesResult(args)
	assert(args, "You must provide an argument table when creating DescribeImagesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Images"] = args["Images"],
	}
	asserts.AssertDescribeImagesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PurchaseScheduledInstancesResult = { ["ScheduledInstanceSet"] = true, nil }

function asserts.AssertPurchaseScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesResult to be of type 'table'")
	if struct["ScheduledInstanceSet"] then asserts.AssertPurchasedScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseScheduledInstancesResult[k], "PurchaseScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesResult
-- <p>Contains the output of PurchaseScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduledInstanceSet [PurchasedScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
-- @return PurchaseScheduledInstancesResult structure as a key-value pair table
function M.PurchaseScheduledInstancesResult(args)
	assert(args, "You must provide an argument table when creating PurchaseScheduledInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ScheduledInstanceSet"] = args["ScheduledInstanceSet"],
	}
	asserts.AssertPurchaseScheduledInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Host = { ["HostId"] = true, ["Tags"] = true, ["HostProperties"] = true, ["State"] = true, ["Instances"] = true, ["HostReservationId"] = true, ["AvailabilityZone"] = true, ["AvailableCapacity"] = true, ["ClientToken"] = true, ["ReleaseTime"] = true, ["AllocationTime"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertHost(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Host to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["HostProperties"] then asserts.AssertHostProperties(struct["HostProperties"]) end
	if struct["State"] then asserts.AssertAllocationState(struct["State"]) end
	if struct["Instances"] then asserts.AssertHostInstanceList(struct["Instances"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["AvailableCapacity"] then asserts.AssertAvailableCapacity(struct["AvailableCapacity"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ReleaseTime"] then asserts.AssertDateTime(struct["ReleaseTime"]) end
	if struct["AllocationTime"] then asserts.AssertDateTime(struct["AllocationTime"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.Host[k], "Host contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Host
-- <p>Describes the properties of the Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostId [String] <p>The ID of the Dedicated Host.</p>
-- * Tags [TagList] <p>Any tags assigned to the Dedicated Host.</p>
-- * HostProperties [HostProperties] <p>The hardware specifications of the Dedicated Host.</p>
-- * State [AllocationState] <p>The Dedicated Host's state.</p>
-- * Instances [HostInstanceList] <p>The IDs and instance type that are currently running on the Dedicated Host.</p>
-- * HostReservationId [String] <p>The reservation ID of the Dedicated Host. This returns a <code>null</code> response if the Dedicated Host doesn't have an associated reservation.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the Dedicated Host.</p>
-- * AvailableCapacity [AvailableCapacity] <p>The number of new instances that can be launched onto the Dedicated Host.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- * ReleaseTime [DateTime] <p>The time that the Dedicated Host was released.</p>
-- * AllocationTime [DateTime] <p>The time that the Dedicated Host was allocated.</p>
-- * AutoPlacement [AutoPlacement] <p>Whether auto-placement is on or off.</p>
-- @return Host structure as a key-value pair table
function M.Host(args)
	assert(args, "You must provide an argument table when creating Host")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostId"] = args["HostId"],
		["Tags"] = args["Tags"],
		["HostProperties"] = args["HostProperties"],
		["State"] = args["State"],
		["Instances"] = args["Instances"],
		["HostReservationId"] = args["HostReservationId"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["AvailableCapacity"] = args["AvailableCapacity"],
		["ClientToken"] = args["ClientToken"],
		["ReleaseTime"] = args["ReleaseTime"],
		["AllocationTime"] = args["AllocationTime"],
		["AutoPlacement"] = args["AutoPlacement"],
	}
	asserts.AssertHost(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFleetsResult = { ["UnsuccessfulFleetDeletions"] = true, ["SuccessfulFleetDeletions"] = true, nil }

function asserts.AssertDeleteFleetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFleetsResult to be of type 'table'")
	if struct["UnsuccessfulFleetDeletions"] then asserts.AssertDeleteFleetErrorSet(struct["UnsuccessfulFleetDeletions"]) end
	if struct["SuccessfulFleetDeletions"] then asserts.AssertDeleteFleetSuccessSet(struct["SuccessfulFleetDeletions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFleetsResult[k], "DeleteFleetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFleetsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UnsuccessfulFleetDeletions [DeleteFleetErrorSet] <p>Information about the EC2 Fleets that are not successfully deleted.</p>
-- * SuccessfulFleetDeletions [DeleteFleetSuccessSet] <p>Information about the EC2 Fleets that are successfully deleted.</p>
-- @return DeleteFleetsResult structure as a key-value pair table
function M.DeleteFleetsResult(args)
	assert(args, "You must provide an argument table when creating DeleteFleetsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UnsuccessfulFleetDeletions"] = args["UnsuccessfulFleetDeletions"],
		["SuccessfulFleetDeletions"] = args["SuccessfulFleetDeletions"],
	}
	asserts.AssertDeleteFleetsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelReservedInstancesListingRequest = { ["ReservedInstancesListingId"] = true, nil }

function asserts.AssertCancelReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ReservedInstancesListingId"], "Expected key ReservedInstancesListingId to exist in table")
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelReservedInstancesListingRequest[k], "CancelReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingRequest
-- <p>Contains the parameters for CancelReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- Required key: ReservedInstancesListingId
-- @return CancelReservedInstancesListingRequest structure as a key-value pair table
function M.CancelReservedInstancesListingRequest(args)
	assert(args, "You must provide an argument table when creating CancelReservedInstancesListingRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesListingId"] = args["ReservedInstancesListingId"],
	}
	asserts.AssertCancelReservedInstancesListingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSubnetResult = { ["Subnet"] = true, nil }

function asserts.AssertCreateSubnetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetResult to be of type 'table'")
	if struct["Subnet"] then asserts.AssertSubnet(struct["Subnet"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSubnetResult[k], "CreateSubnetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Subnet [Subnet] <p>Information about the subnet.</p>
-- @return CreateSubnetResult structure as a key-value pair table
function M.CreateSubnetResult(args)
	assert(args, "You must provide an argument table when creating CreateSubnetResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Subnet"] = args["Subnet"],
	}
	asserts.AssertCreateSubnetResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeTagsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeTagsRequest[k], "DescribeTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>key</code> - The tag key.</p> </li> <li> <p> <code>resource-id</code> - The ID of the resource.</p> </li> <li> <p> <code>resource-type</code> - The resource type (<code>customer-gateway</code> | <code>dedicated-host</code> | <code>dhcp-options</code> | <code>elastic-ip</code> | <code>fleet</code> | <code>fpga-image</code> | <code>image</code> | <code>instance</code> | <code>internet-gateway</code> | <code>launch-template</code> | <code>natgateway</code> | <code>network-acl</code> | <code>network-interface</code> | <code>reserved-instances</code> | <code>route-table</code> | <code>security-group</code> | <code>snapshot</code> | <code>spot-instances-request</code> | <code>subnet</code> | <code>volume</code> | <code>vpc</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of the tag. For example, specify "tag:Owner" for the filter name and "TeamA" for the filter value to find resources with the tag "Owner=TeamA".</p> </li> <li> <p> <code>value</code> - The tag value.</p> </li> </ul>
-- @return DescribeTagsRequest structure as a key-value pair table
function M.DescribeTagsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeTagsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeTagsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstancePrivateIpAddress = { ["PrivateDnsName"] = true, ["PrivateIpAddress"] = true, ["Primary"] = true, ["Association"] = true, nil }

function asserts.AssertInstancePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstancePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then asserts.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstancePrivateIpAddress[k], "InstancePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstancePrivateIpAddress
-- <p>Describes a private IPv4 address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrivateDnsName [String] <p>The private IPv4 DNS name.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address of the network interface.</p>
-- * Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>
-- * Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IP address for the network interface.</p>
-- @return InstancePrivateIpAddress structure as a key-value pair table
function M.InstancePrivateIpAddress(args)
	assert(args, "You must provide an argument table when creating InstancePrivateIpAddress")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrivateDnsName"] = args["PrivateDnsName"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Primary"] = args["Primary"],
		["Association"] = args["Association"],
	}
	asserts.AssertInstancePrivateIpAddress(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateInstanceExportTaskRequest = { ["InstanceId"] = true, ["TargetEnvironment"] = true, ["Description"] = true, ["ExportToS3Task"] = true, nil }

function asserts.AssertCreateInstanceExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then asserts.AssertExportEnvironment(struct["TargetEnvironment"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ExportToS3Task"] then asserts.AssertExportToS3TaskSpecification(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInstanceExportTaskRequest[k], "CreateInstanceExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskRequest
-- <p>Contains the parameters for CreateInstanceExportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
-- * Description [String] <p>A description for the conversion task or the resource being exported. The maximum length is 255 bytes.</p>
-- * ExportToS3Task [ExportToS3TaskSpecification] <p>The format and location for an instance export task.</p>
-- Required key: InstanceId
-- @return CreateInstanceExportTaskRequest structure as a key-value pair table
function M.CreateInstanceExportTaskRequest(args)
	assert(args, "You must provide an argument table when creating CreateInstanceExportTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["TargetEnvironment"] = args["TargetEnvironment"],
		["Description"] = args["Description"],
		["ExportToS3Task"] = args["ExportToS3Task"],
	}
	asserts.AssertCreateInstanceExportTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateInstanceExportTaskResult = { ["ExportTask"] = true, nil }

function asserts.AssertCreateInstanceExportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInstanceExportTaskResult to be of type 'table'")
	if struct["ExportTask"] then asserts.AssertExportTask(struct["ExportTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInstanceExportTaskResult[k], "CreateInstanceExportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInstanceExportTaskResult
-- <p>Contains the output for CreateInstanceExportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTask [ExportTask] <p>Information about the instance export task.</p>
-- @return CreateInstanceExportTaskResult structure as a key-value pair table
function M.CreateInstanceExportTaskResult(args)
	assert(args, "You must provide an argument table when creating CreateInstanceExportTaskResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExportTask"] = args["ExportTask"],
	}
	asserts.AssertCreateInstanceExportTaskResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateBlockDeviceMapping = { ["DeviceName"] = true, ["VirtualName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertLaunchTemplateBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateBlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertLaunchTemplateEbsBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateBlockDeviceMapping[k], "LaunchTemplateBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateBlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The device name.</p>
-- * VirtualName [String] <p>The virtual device name (ephemeralN).</p>
-- * NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- * Ebs [LaunchTemplateEbsBlockDevice] <p>Information about the block device for an EBS volume.</p>
-- @return LaunchTemplateBlockDeviceMapping structure as a key-value pair table
function M.LaunchTemplateBlockDeviceMapping(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateBlockDeviceMapping")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceName"] = args["DeviceName"],
		["VirtualName"] = args["VirtualName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertLaunchTemplateBlockDeviceMapping(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RejectVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertRejectVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcPeeringConnectionRequest[k], "RejectVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required key: VpcPeeringConnectionId
-- @return RejectVpcPeeringConnectionRequest structure as a key-value pair table
function M.RejectVpcPeeringConnectionRequest(args)
	assert(args, "You must provide an argument table when creating RejectVpcPeeringConnectionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertRejectVpcPeeringConnectionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplate = { ["LatestVersionNumber"] = true, ["Tags"] = true, ["LaunchTemplateId"] = true, ["LaunchTemplateName"] = true, ["DefaultVersionNumber"] = true, ["CreatedBy"] = true, ["CreateTime"] = true, nil }

function asserts.AssertLaunchTemplate(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplate to be of type 'table'")
	if struct["LatestVersionNumber"] then asserts.AssertLong(struct["LatestVersionNumber"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["DefaultVersionNumber"] then asserts.AssertLong(struct["DefaultVersionNumber"]) end
	if struct["CreatedBy"] then asserts.AssertString(struct["CreatedBy"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplate[k], "LaunchTemplate contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplate
-- <p>Describes a launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LatestVersionNumber [Long] <p>The version number of the latest version of the launch template.</p>
-- * Tags [TagList] <p>The tags for the launch template.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template.</p>
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template.</p>
-- * DefaultVersionNumber [Long] <p>The version number of the default version of the launch template.</p>
-- * CreatedBy [String] <p>The principal that created the launch template. </p>
-- * CreateTime [DateTime] <p>The time launch template was created.</p>
-- @return LaunchTemplate structure as a key-value pair table
function M.LaunchTemplate(args)
	assert(args, "You must provide an argument table when creating LaunchTemplate")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LatestVersionNumber"] = args["LatestVersionNumber"],
		["Tags"] = args["Tags"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["DefaultVersionNumber"] = args["DefaultVersionNumber"],
		["CreatedBy"] = args["CreatedBy"],
		["CreateTime"] = args["CreateTime"],
	}
	asserts.AssertLaunchTemplate(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CopyImageResult = { ["ImageId"] = true, nil }

function asserts.AssertCopyImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyImageResult[k], "CopyImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageResult
-- <p>Contains the output of CopyImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImageId [String] <p>The ID of the new AMI.</p>
-- @return CopyImageResult structure as a key-value pair table
function M.CopyImageResult(args)
	assert(args, "You must provide an argument table when creating CopyImageResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertCopyImageResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstancesConfiguration = { ["Platform"] = true, ["AvailabilityZone"] = true, ["Scope"] = true, ["InstanceType"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertReservedInstancesConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesConfiguration to be of type 'table'")
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesConfiguration[k], "ReservedInstancesConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesConfiguration
-- <p>Describes the configuration settings for the modified Reserved Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Platform [String] <p>The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the modified Reserved Instances.</p>
-- * Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or instances in a specific Availability Zone.</p>
-- * InstanceType [InstanceType] <p>The instance type for the modified Reserved Instances.</p>
-- * InstanceCount [Integer] <p>The number of modified Reserved Instances.</p>
-- @return ReservedInstancesConfiguration structure as a key-value pair table
function M.ReservedInstancesConfiguration(args)
	assert(args, "You must provide an argument table when creating ReservedInstancesConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Platform"] = args["Platform"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Scope"] = args["Scope"],
		["InstanceType"] = args["InstanceType"],
		["InstanceCount"] = args["InstanceCount"],
	}
	asserts.AssertReservedInstancesConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Region = { ["Endpoint"] = true, ["RegionName"] = true, nil }

function asserts.AssertRegion(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Region to be of type 'table'")
	if struct["Endpoint"] then asserts.AssertString(struct["Endpoint"]) end
	if struct["RegionName"] then asserts.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(keys.Region[k], "Region contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Region
-- <p>Describes a region.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Endpoint [String] <p>The region service endpoint.</p>
-- * RegionName [String] <p>The name of the region.</p>
-- @return Region structure as a key-value pair table
function M.Region(args)
	assert(args, "You must provide an argument table when creating Region")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Endpoint"] = args["Endpoint"],
		["RegionName"] = args["RegionName"],
	}
	asserts.AssertRegion(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TargetCapacitySpecificationRequest = { ["OnDemandTargetCapacity"] = true, ["SpotTargetCapacity"] = true, ["TotalTargetCapacity"] = true, ["DefaultTargetCapacityType"] = true, nil }

function asserts.AssertTargetCapacitySpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetCapacitySpecificationRequest to be of type 'table'")
	assert(struct["TotalTargetCapacity"], "Expected key TotalTargetCapacity to exist in table")
	if struct["OnDemandTargetCapacity"] then asserts.AssertInteger(struct["OnDemandTargetCapacity"]) end
	if struct["SpotTargetCapacity"] then asserts.AssertInteger(struct["SpotTargetCapacity"]) end
	if struct["TotalTargetCapacity"] then asserts.AssertInteger(struct["TotalTargetCapacity"]) end
	if struct["DefaultTargetCapacityType"] then asserts.AssertDefaultTargetCapacityType(struct["DefaultTargetCapacityType"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetCapacitySpecificationRequest[k], "TargetCapacitySpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetCapacitySpecificationRequest
-- <p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OnDemandTargetCapacity [Integer] <p>The number of On-Demand units to request.</p>
-- * SpotTargetCapacity [Integer] <p>The number of Spot units to request.</p>
-- * TotalTargetCapacity [Integer] <p>The number of units to request, filled using <code>DefaultTargetCapacityType</code>.</p>
-- * DefaultTargetCapacityType [DefaultTargetCapacityType] <p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or <code>On-Demand</code>.</p>
-- Required key: TotalTargetCapacity
-- @return TargetCapacitySpecificationRequest structure as a key-value pair table
function M.TargetCapacitySpecificationRequest(args)
	assert(args, "You must provide an argument table when creating TargetCapacitySpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OnDemandTargetCapacity"] = args["OnDemandTargetCapacity"],
		["SpotTargetCapacity"] = args["SpotTargetCapacity"],
		["TotalTargetCapacity"] = args["TotalTargetCapacity"],
		["DefaultTargetCapacityType"] = args["DefaultTargetCapacityType"],
	}
	asserts.AssertTargetCapacitySpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AllocateHostsRequest = { ["AvailabilityZone"] = true, ["TagSpecifications"] = true, ["ClientToken"] = true, ["AutoPlacement"] = true, ["InstanceType"] = true, ["Quantity"] = true, nil }

function asserts.AssertAllocateHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["InstanceType"], "Expected key InstanceType to exist in table")
	assert(struct["Quantity"], "Expected key Quantity to exist in table")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["Quantity"] then asserts.AssertInteger(struct["Quantity"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateHostsRequest[k], "AllocateHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone for the Dedicated Hosts.</p>
-- * TagSpecifications [TagSpecificationList] <p>The tags to apply to the Dedicated Host during creation.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. </p>
-- * AutoPlacement [AutoPlacement] <p>This is enabled by default. This property allows instances to be automatically placed onto available Dedicated Hosts, when you are launching instances without specifying a host ID.</p> <p>Default: Enabled</p>
-- * InstanceType [String] <p>Specify the instance type for which to configure your Dedicated Hosts. When you specify the instance type, that is the only instance type that you can launch onto that host.</p>
-- * Quantity [Integer] <p>The number of Dedicated Hosts to allocate to your account with these parameters.</p>
-- Required key: AvailabilityZone
-- Required key: InstanceType
-- Required key: Quantity
-- @return AllocateHostsRequest structure as a key-value pair table
function M.AllocateHostsRequest(args)
	assert(args, "You must provide an argument table when creating AllocateHostsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["TagSpecifications"] = args["TagSpecifications"],
		["ClientToken"] = args["ClientToken"],
		["AutoPlacement"] = args["AutoPlacement"],
		["InstanceType"] = args["InstanceType"],
		["Quantity"] = args["Quantity"],
	}
	asserts.AssertAllocateHostsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotFleetRequestHistoryResponse = { ["HistoryRecords"] = true, ["SpotFleetRequestId"] = true, ["NextToken"] = true, ["LastEvaluatedTime"] = true, ["StartTime"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestHistoryResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryResponse to be of type 'table'")
	assert(struct["HistoryRecords"], "Expected key HistoryRecords to exist in table")
	assert(struct["LastEvaluatedTime"], "Expected key LastEvaluatedTime to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["HistoryRecords"] then asserts.AssertHistoryRecords(struct["HistoryRecords"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["LastEvaluatedTime"] then asserts.AssertDateTime(struct["LastEvaluatedTime"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestHistoryResponse[k], "DescribeSpotFleetRequestHistoryResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryResponse
-- <p>Contains the output of DescribeSpotFleetRequestHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HistoryRecords [HistoryRecords] <p>Information about the events in the history of the Spot Fleet request.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- * LastEvaluatedTime [DateTime] <p>The last date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). All records up to this time were retrieved.</p> <p>If <code>nextToken</code> indicates that there are more results, this value is not present.</p>
-- * StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required key: HistoryRecords
-- Required key: LastEvaluatedTime
-- Required key: SpotFleetRequestId
-- Required key: StartTime
-- @return DescribeSpotFleetRequestHistoryResponse structure as a key-value pair table
function M.DescribeSpotFleetRequestHistoryResponse(args)
	assert(args, "You must provide an argument table when creating DescribeSpotFleetRequestHistoryResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HistoryRecords"] = args["HistoryRecords"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["NextToken"] = args["NextToken"],
		["LastEvaluatedTime"] = args["LastEvaluatedTime"],
		["StartTime"] = args["StartTime"],
	}
	asserts.AssertDescribeSpotFleetRequestHistoryResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PurchaseReservedInstancesOfferingRequest = { ["ReservedInstancesOfferingId"] = true, ["InstanceCount"] = true, ["DryRun"] = true, ["LimitPrice"] = true, nil }

function asserts.AssertPurchaseReservedInstancesOfferingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingRequest to be of type 'table'")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["ReservedInstancesOfferingId"], "Expected key ReservedInstancesOfferingId to exist in table")
	if struct["ReservedInstancesOfferingId"] then asserts.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LimitPrice"] then asserts.AssertReservedInstanceLimitPrice(struct["LimitPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseReservedInstancesOfferingRequest[k], "PurchaseReservedInstancesOfferingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingRequest
-- <p>Contains the parameters for PurchaseReservedInstancesOffering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering to purchase.</p>
-- * InstanceCount [Integer] <p>The number of Reserved Instances to purchase.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * LimitPrice [ReservedInstanceLimitPrice] <p>Specified for Reserved Instance Marketplace offerings to limit the total order and ensure that the Reserved Instances are not purchased at unexpected prices.</p>
-- Required key: InstanceCount
-- Required key: ReservedInstancesOfferingId
-- @return PurchaseReservedInstancesOfferingRequest structure as a key-value pair table
function M.PurchaseReservedInstancesOfferingRequest(args)
	assert(args, "You must provide an argument table when creating PurchaseReservedInstancesOfferingRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesOfferingId"] = args["ReservedInstancesOfferingId"],
		["InstanceCount"] = args["InstanceCount"],
		["DryRun"] = args["DryRun"],
		["LimitPrice"] = args["LimitPrice"],
	}
	asserts.AssertPurchaseReservedInstancesOfferingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FlowLog = { ["LogDestinationType"] = true, ["ResourceId"] = true, ["CreationTime"] = true, ["LogGroupName"] = true, ["TrafficType"] = true, ["FlowLogStatus"] = true, ["FlowLogId"] = true, ["DeliverLogsPermissionArn"] = true, ["LogDestination"] = true, ["DeliverLogsStatus"] = true, ["DeliverLogsErrorMessage"] = true, nil }

function asserts.AssertFlowLog(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FlowLog to be of type 'table'")
	if struct["LogDestinationType"] then asserts.AssertLogDestinationType(struct["LogDestinationType"]) end
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["CreationTime"] then asserts.AssertDateTime(struct["CreationTime"]) end
	if struct["LogGroupName"] then asserts.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then asserts.AssertTrafficType(struct["TrafficType"]) end
	if struct["FlowLogStatus"] then asserts.AssertString(struct["FlowLogStatus"]) end
	if struct["FlowLogId"] then asserts.AssertString(struct["FlowLogId"]) end
	if struct["DeliverLogsPermissionArn"] then asserts.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["LogDestination"] then asserts.AssertString(struct["LogDestination"]) end
	if struct["DeliverLogsStatus"] then asserts.AssertString(struct["DeliverLogsStatus"]) end
	if struct["DeliverLogsErrorMessage"] then asserts.AssertString(struct["DeliverLogsErrorMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.FlowLog[k], "FlowLog contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FlowLog
-- <p>Describes a flow log.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LogDestinationType [LogDestinationType] <p>Specifies the type of destination to which the flow log data is published. Flow log data can be published to CloudWatch Logs or Amazon S3.</p>
-- * ResourceId [String] <p>The ID of the resource on which the flow log was created.</p>
-- * CreationTime [DateTime] <p>The date and time the flow log was created.</p>
-- * LogGroupName [String] <p>The name of the flow log group.</p>
-- * TrafficType [TrafficType] <p>The type of traffic captured for the flow log.</p>
-- * FlowLogStatus [String] <p>The status of the flow log (<code>ACTIVE</code>).</p>
-- * FlowLogId [String] <p>The flow log ID.</p>
-- * DeliverLogsPermissionArn [String] <p>The ARN of the IAM role that posts logs to CloudWatch Logs.</p>
-- * LogDestination [String] <p>Specifies the destination to which the flow log data is published. Flow log data can be published to an CloudWatch Logs log group or an Amazon S3 bucket. If the flow log publishes to CloudWatch Logs, this element indicates the Amazon Resource Name (ARN) of the CloudWatch Logs log group to which the data is published. If the flow log publishes to Amazon S3, this element indicates the ARN of the Amazon S3 bucket to which the data is published.</p>
-- * DeliverLogsStatus [String] <p>The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p>
-- * DeliverLogsErrorMessage [String] <p>Information about the error that occurred. <code>Rate limited</code> indicates that CloudWatch Logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of log groups that you can create. <code>Access error</code> indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. <code>Unknown error</code> indicates an internal error.</p>
-- @return FlowLog structure as a key-value pair table
function M.FlowLog(args)
	assert(args, "You must provide an argument table when creating FlowLog")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LogDestinationType"] = args["LogDestinationType"],
		["ResourceId"] = args["ResourceId"],
		["CreationTime"] = args["CreationTime"],
		["LogGroupName"] = args["LogGroupName"],
		["TrafficType"] = args["TrafficType"],
		["FlowLogStatus"] = args["FlowLogStatus"],
		["FlowLogId"] = args["FlowLogId"],
		["DeliverLogsPermissionArn"] = args["DeliverLogsPermissionArn"],
		["LogDestination"] = args["LogDestination"],
		["DeliverLogsStatus"] = args["DeliverLogsStatus"],
		["DeliverLogsErrorMessage"] = args["DeliverLogsErrorMessage"],
	}
	asserts.AssertFlowLog(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RequestSpotInstancesRequest = { ["InstanceCount"] = true, ["DryRun"] = true, ["LaunchGroup"] = true, ["BlockDurationMinutes"] = true, ["LaunchSpecification"] = true, ["AvailabilityZoneGroup"] = true, ["ClientToken"] = true, ["ValidUntil"] = true, ["ValidFrom"] = true, ["Type"] = true, ["InstanceInterruptionBehavior"] = true, ["SpotPrice"] = true, nil }

function asserts.AssertRequestSpotInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesRequest to be of type 'table'")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LaunchGroup"] then asserts.AssertString(struct["LaunchGroup"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["LaunchSpecification"] then asserts.AssertRequestSpotLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["AvailabilityZoneGroup"] then asserts.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then asserts.AssertSpotInstanceType(struct["Type"]) end
	if struct["InstanceInterruptionBehavior"] then asserts.AssertInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotInstancesRequest[k], "RequestSpotInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesRequest
-- <p>Contains the parameters for RequestSpotInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The maximum number of Spot Instances to launch.</p> <p>Default: 1</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * LaunchGroup [String] <p>The instance launch group. Launch groups are Spot Instances that launch together and terminate together.</p> <p>Default: Instances are launched and terminated individually</p>
-- * BlockDurationMinutes [Integer] <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p> <p>The duration period starts as soon as your Spot Instance receives its instance ID. At the end of the duration period, Amazon EC2 marks the Spot Instance for termination and provides a Spot Instance termination notice, which gives the instance a two-minute warning before it terminates.</p> <p>You can't specify an Availability Zone group or a launch group if you specify a duration.</p>
-- * LaunchSpecification [RequestSpotLaunchSpecification] <p>The launch specification.</p>
-- * AvailabilityZoneGroup [String] <p>The user-specified name for a logical grouping of requests.</p> <p>When you specify an Availability Zone group in a Spot Instance request, all Spot Instances in the request are launched in the same Availability Zone. Instance proximity is maintained with this parameter, but the choice of Availability Zone is not. The group applies only to requests for Spot Instances of the same instance type. Any additional Spot Instance requests that are specified with the same Availability Zone group name are launched in that same Availability Zone, as long as at least one instance from the group is still active.</p> <p>If there is no active instance running in the Availability Zone group that you specify for a new Spot Instance request (all instances are terminated, the request is expired, or the maximum price you specified falls below current Spot price), then Amazon EC2 launches the instance in any Availability Zone where the constraint can be met. Consequently, the subsequent set of Spot Instances could be placed in a different zone from the original request, even if you specified the same Availability Zone group.</p> <p>Default: Instances are launched in any available Availability Zone.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
-- * ValidUntil [DateTime] <p>The end date of the request. If this is a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached. The default end date is 7 days from the current date.</p>
-- * ValidFrom [DateTime] <p>The start date of the request. If this is a one-time request, the request becomes active at this date and time and remains active until all instances launch, the request expires, or the request is canceled. If the request is persistent, the request becomes active at this date and time and remains active until it expires or is canceled.</p>
-- * Type [SpotInstanceType] <p>The Spot Instance request type.</p> <p>Default: <code>one-time</code> </p>
-- * InstanceInterruptionBehavior [InstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
-- * SpotPrice [String] <p>The maximum price per hour that you are willing to pay for a Spot Instance. The default is the On-Demand price.</p>
-- @return RequestSpotInstancesRequest structure as a key-value pair table
function M.RequestSpotInstancesRequest(args)
	assert(args, "You must provide an argument table when creating RequestSpotInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceCount"] = args["InstanceCount"],
		["DryRun"] = args["DryRun"],
		["LaunchGroup"] = args["LaunchGroup"],
		["BlockDurationMinutes"] = args["BlockDurationMinutes"],
		["LaunchSpecification"] = args["LaunchSpecification"],
		["AvailabilityZoneGroup"] = args["AvailabilityZoneGroup"],
		["ClientToken"] = args["ClientToken"],
		["ValidUntil"] = args["ValidUntil"],
		["ValidFrom"] = args["ValidFrom"],
		["Type"] = args["Type"],
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
		["SpotPrice"] = args["SpotPrice"],
	}
	asserts.AssertRequestSpotInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateCpuOptions = { ["CoreCount"] = true, ["ThreadsPerCore"] = true, nil }

function asserts.AssertLaunchTemplateCpuOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateCpuOptions to be of type 'table'")
	if struct["CoreCount"] then asserts.AssertInteger(struct["CoreCount"]) end
	if struct["ThreadsPerCore"] then asserts.AssertInteger(struct["ThreadsPerCore"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateCpuOptions[k], "LaunchTemplateCpuOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateCpuOptions
-- <p>The CPU options for the instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CoreCount [Integer] <p>The number of CPU cores for the instance.</p>
-- * ThreadsPerCore [Integer] <p>The number of threads per CPU core.</p>
-- @return LaunchTemplateCpuOptions structure as a key-value pair table
function M.LaunchTemplateCpuOptions(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateCpuOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CoreCount"] = args["CoreCount"],
		["ThreadsPerCore"] = args["ThreadsPerCore"],
	}
	asserts.AssertLaunchTemplateCpuOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisableVpcClassicLinkDnsSupportRequest = { ["VpcId"] = true, nil }

function asserts.AssertDisableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkDnsSupportRequest[k], "DisableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return DisableVpcClassicLinkDnsSupportRequest structure as a key-value pair table
function M.DisableVpcClassicLinkDnsSupportRequest(args)
	assert(args, "You must provide an argument table when creating DisableVpcClassicLinkDnsSupportRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertDisableVpcClassicLinkDnsSupportRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.BlobAttributeValue = { ["Value"] = true, nil }

function asserts.AssertBlobAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlobAttributeValue to be of type 'table'")
	if struct["Value"] then asserts.AssertBlob(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.BlobAttributeValue[k], "BlobAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlobAttributeValue
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [Blob] 
-- @return BlobAttributeValue structure as a key-value pair table
function M.BlobAttributeValue(args)
	assert(args, "You must provide an argument table when creating BlobAttributeValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Value"] = args["Value"],
	}
	asserts.AssertBlobAttributeValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DnsEntry = { ["HostedZoneId"] = true, ["DnsName"] = true, nil }

function asserts.AssertDnsEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DnsEntry to be of type 'table'")
	if struct["HostedZoneId"] then asserts.AssertString(struct["HostedZoneId"]) end
	if struct["DnsName"] then asserts.AssertString(struct["DnsName"]) end
	for k,_ in pairs(struct) do
		assert(keys.DnsEntry[k], "DnsEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DnsEntry
-- <p>Describes a DNS entry.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostedZoneId [String] <p>The ID of the private hosted zone.</p>
-- * DnsName [String] <p>The DNS name.</p>
-- @return DnsEntry structure as a key-value pair table
function M.DnsEntry(args)
	assert(args, "You must provide an argument table when creating DnsEntry")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostedZoneId"] = args["HostedZoneId"],
		["DnsName"] = args["DnsName"],
	}
	asserts.AssertDnsEntry(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelSpotInstanceRequestsRequest = { ["SpotInstanceRequestIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertCancelSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsRequest to be of type 'table'")
	assert(struct["SpotInstanceRequestIds"], "Expected key SpotInstanceRequestIds to exist in table")
	if struct["SpotInstanceRequestIds"] then asserts.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotInstanceRequestsRequest[k], "CancelSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsRequest
-- <p>Contains the parameters for CancelSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot Instance request IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SpotInstanceRequestIds
-- @return CancelSpotInstanceRequestsRequest structure as a key-value pair table
function M.CancelSpotInstanceRequestsRequest(args)
	assert(args, "You must provide an argument table when creating CancelSpotInstanceRequestsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotInstanceRequestIds"] = args["SpotInstanceRequestIds"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCancelSpotInstanceRequestsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CidrAuthorizationContext = { ["Message"] = true, ["Signature"] = true, nil }

function asserts.AssertCidrAuthorizationContext(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CidrAuthorizationContext to be of type 'table'")
	assert(struct["Message"], "Expected key Message to exist in table")
	assert(struct["Signature"], "Expected key Signature to exist in table")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Signature"] then asserts.AssertString(struct["Signature"]) end
	for k,_ in pairs(struct) do
		assert(keys.CidrAuthorizationContext[k], "CidrAuthorizationContext contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CidrAuthorizationContext
-- <p>Provides authorization for Amazon to bring a specific IP address range to a specific AWS account using bring your own IP addresses (BYOIP).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The plain-text authorization message for the prefix and account.</p>
-- * Signature [String] <p>The signed authorization message for the prefix and account.</p>
-- Required key: Message
-- Required key: Signature
-- @return CidrAuthorizationContext structure as a key-value pair table
function M.CidrAuthorizationContext(args)
	assert(args, "You must provide an argument table when creating CidrAuthorizationContext")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Signature"] = args["Signature"],
	}
	asserts.AssertCidrAuthorizationContext(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteSnapshotRequest = { ["SnapshotId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSnapshotRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSnapshotRequest[k], "DeleteSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSnapshotRequest
-- <p>Contains the parameters for DeleteSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SnapshotId
-- @return DeleteSnapshotRequest structure as a key-value pair table
function M.DeleteSnapshotRequest(args)
	assert(args, "You must provide an argument table when creating DeleteSnapshotRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SnapshotId"] = args["SnapshotId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteSnapshotRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachClassicLinkVpcRequest = { ["InstanceId"] = true, ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDetachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachClassicLinkVpcRequest[k], "DetachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance to unlink from the VPC.</p>
-- * VpcId [String] <p>The ID of the VPC to which the instance is linked.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- Required key: VpcId
-- @return DetachClassicLinkVpcRequest structure as a key-value pair table
function M.DetachClassicLinkVpcRequest(args)
	assert(args, "You must provide an argument table when creating DetachClassicLinkVpcRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDetachClassicLinkVpcRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SnapshotTaskDetail = { ["Status"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["DiskImageSize"] = true, ["SnapshotId"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["UserBucket"] = true, nil }

function asserts.AssertSnapshotTaskDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotTaskDetail to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then asserts.AssertDouble(struct["DiskImageSize"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then asserts.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotTaskDetail[k], "SnapshotTaskDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotTaskDetail
-- <p>Details about the import snapshot task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status for the import snapshot task.</p>
-- * Description [String] <p>The description of the snapshot.</p>
-- * Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- * Url [String] <p>The URL of the disk image from which the snapshot is created.</p>
-- * DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- * SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- * Progress [String] <p>The percentage of completion for the import snapshot task.</p>
-- * StatusMessage [String] <p>A detailed status message for the import snapshot task.</p>
-- * UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
-- @return SnapshotTaskDetail structure as a key-value pair table
function M.SnapshotTaskDetail(args)
	assert(args, "You must provide an argument table when creating SnapshotTaskDetail")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
		["Url"] = args["Url"],
		["DiskImageSize"] = args["DiskImageSize"],
		["SnapshotId"] = args["SnapshotId"],
		["Progress"] = args["Progress"],
		["StatusMessage"] = args["StatusMessage"],
		["UserBucket"] = args["UserBucket"],
	}
	asserts.AssertSnapshotTaskDetail(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Tag = { ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertTag(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Tag to be of type 'table'")
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.Tag[k], "Tag contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Tag
-- <p>Describes a tag.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [String] <p>The value of the tag.</p> <p>Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.</p>
-- * Key [String] <p>The key of the tag.</p> <p>Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with <code>aws:</code>.</p>
-- @return Tag structure as a key-value pair table
function M.Tag(args)
	assert(args, "You must provide an argument table when creating Tag")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Value"] = args["Value"],
		["Key"] = args["Key"],
	}
	asserts.AssertTag(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesPlacement = { ["GroupName"] = true, ["AvailabilityZone"] = true, nil }

function asserts.AssertScheduledInstancesPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPlacement to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesPlacement[k], "ScheduledInstancesPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPlacement
-- <p>Describes the placement for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the placement group.</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- @return ScheduledInstancesPlacement structure as a key-value pair table
function M.ScheduledInstancesPlacement(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesPlacement")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["AvailabilityZone"] = args["AvailabilityZone"],
	}
	asserts.AssertScheduledInstancesPlacement(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFpgaImagesResult = { ["FpgaImages"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFpgaImagesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesResult to be of type 'table'")
	if struct["FpgaImages"] then asserts.AssertFpgaImageList(struct["FpgaImages"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImagesResult[k], "DescribeFpgaImagesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImages [FpgaImageList] <p>Information about one or more FPGA images.</p>
-- * NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeFpgaImagesResult structure as a key-value pair table
function M.DescribeFpgaImagesResult(args)
	assert(args, "You must provide an argument table when creating DescribeFpgaImagesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImages"] = args["FpgaImages"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFpgaImagesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterfacePermission = { ["Permission"] = true, ["NetworkInterfaceId"] = true, ["AwsService"] = true, ["NetworkInterfacePermissionId"] = true, ["PermissionState"] = true, ["AwsAccountId"] = true, nil }

function asserts.AssertNetworkInterfacePermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfacePermission to be of type 'table'")
	if struct["Permission"] then asserts.AssertInterfacePermissionType(struct["Permission"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AwsService"] then asserts.AssertString(struct["AwsService"]) end
	if struct["NetworkInterfacePermissionId"] then asserts.AssertString(struct["NetworkInterfacePermissionId"]) end
	if struct["PermissionState"] then asserts.AssertNetworkInterfacePermissionState(struct["PermissionState"]) end
	if struct["AwsAccountId"] then asserts.AssertString(struct["AwsAccountId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfacePermission[k], "NetworkInterfacePermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfacePermission
-- <p>Describes a permission for a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Permission [InterfacePermissionType] <p>The type of permission.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AwsService [String] <p>The AWS service.</p>
-- * NetworkInterfacePermissionId [String] <p>The ID of the network interface permission.</p>
-- * PermissionState [NetworkInterfacePermissionState] <p>Information about the state of the permission.</p>
-- * AwsAccountId [String] <p>The AWS account ID.</p>
-- @return NetworkInterfacePermission structure as a key-value pair table
function M.NetworkInterfacePermission(args)
	assert(args, "You must provide an argument table when creating NetworkInterfacePermission")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Permission"] = args["Permission"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AwsService"] = args["AwsService"],
		["NetworkInterfacePermissionId"] = args["NetworkInterfacePermissionId"],
		["PermissionState"] = args["PermissionState"],
		["AwsAccountId"] = args["AwsAccountId"],
	}
	asserts.AssertNetworkInterfacePermission(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplatesMonitoring = { ["Enabled"] = true, nil }

function asserts.AssertLaunchTemplatesMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplatesMonitoring to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplatesMonitoring[k], "LaunchTemplatesMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplatesMonitoring
-- <p>Describes the monitoring for the instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
-- @return LaunchTemplatesMonitoring structure as a key-value pair table
function M.LaunchTemplatesMonitoring(args)
	assert(args, "You must provide an argument table when creating LaunchTemplatesMonitoring")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertLaunchTemplatesMonitoring(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyInstancePlacementResult = { ["Return"] = true, nil }

function asserts.AssertModifyInstancePlacementResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstancePlacementResult[k], "ModifyInstancePlacementResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
-- @return ModifyInstancePlacementResult structure as a key-value pair table
function M.ModifyInstancePlacementResult(args)
	assert(args, "You must provide an argument table when creating ModifyInstancePlacementResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyInstancePlacementResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSecurityGroupReferencesResult = { ["SecurityGroupReferenceSet"] = true, nil }

function asserts.AssertDescribeSecurityGroupReferencesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesResult to be of type 'table'")
	if struct["SecurityGroupReferenceSet"] then asserts.AssertSecurityGroupReferences(struct["SecurityGroupReferenceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupReferencesResult[k], "DescribeSecurityGroupReferencesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SecurityGroupReferenceSet [SecurityGroupReferences] <p>Information about the VPCs with the referencing security groups.</p>
-- @return DescribeSecurityGroupReferencesResult structure as a key-value pair table
function M.DescribeSecurityGroupReferencesResult(args)
	assert(args, "You must provide an argument table when creating DescribeSecurityGroupReferencesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SecurityGroupReferenceSet"] = args["SecurityGroupReferenceSet"],
	}
	asserts.AssertDescribeSecurityGroupReferencesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDhcpOptionsRequest = { ["DhcpOptionsIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsRequest to be of type 'table'")
	if struct["DhcpOptionsIds"] then asserts.AssertDhcpOptionsIdStringList(struct["DhcpOptionsIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDhcpOptionsRequest[k], "DescribeDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DhcpOptionsIds [DhcpOptionsIdStringList] <p>The IDs of one or more DHCP options sets.</p> <p>Default: Describes all your DHCP options sets.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>key</code> - The key for one of the options (for example, <code>domain-name</code>).</p> </li> <li> <p> <code>value</code> - The value for one of the options.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> </ul>
-- @return DescribeDhcpOptionsRequest structure as a key-value pair table
function M.DescribeDhcpOptionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeDhcpOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DhcpOptionsIds"] = args["DhcpOptionsIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeDhcpOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceIpv6AddressRequest = { ["Ipv6Address"] = true, nil }

function asserts.AssertInstanceIpv6AddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceIpv6AddressRequest to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceIpv6AddressRequest[k], "InstanceIpv6AddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceIpv6AddressRequest
-- <p>Describes an IPv6 address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Address [String] <p>The IPv6 address.</p>
-- @return InstanceIpv6AddressRequest structure as a key-value pair table
function M.InstanceIpv6AddressRequest(args)
	assert(args, "You must provide an argument table when creating InstanceIpv6AddressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6Address"] = args["Ipv6Address"],
	}
	asserts.AssertInstanceIpv6AddressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSecurityGroupsResult = { ["NextToken"] = true, ["SecurityGroups"] = true, nil }

function asserts.AssertDescribeSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["SecurityGroups"] then asserts.AssertSecurityGroupList(struct["SecurityGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupsResult[k], "DescribeSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * SecurityGroups [SecurityGroupList] <p>Information about one or more security groups.</p>
-- @return DescribeSecurityGroupsResult structure as a key-value pair table
function M.DescribeSecurityGroupsResult(args)
	assert(args, "You must provide an argument table when creating DescribeSecurityGroupsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["SecurityGroups"] = args["SecurityGroups"],
	}
	asserts.AssertDescribeSecurityGroupsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeprovisionByoipCidrResult = { ["ByoipCidr"] = true, nil }

function asserts.AssertDeprovisionByoipCidrResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeprovisionByoipCidrResult to be of type 'table'")
	if struct["ByoipCidr"] then asserts.AssertByoipCidr(struct["ByoipCidr"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeprovisionByoipCidrResult[k], "DeprovisionByoipCidrResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeprovisionByoipCidrResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ByoipCidr [ByoipCidr] <p>Information about the address range.</p>
-- @return DeprovisionByoipCidrResult structure as a key-value pair table
function M.DeprovisionByoipCidrResult(args)
	assert(args, "You must provide an argument table when creating DeprovisionByoipCidrResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ByoipCidr"] = args["ByoipCidr"],
	}
	asserts.AssertDeprovisionByoipCidrResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelExportTaskRequest = { ["ExportTaskId"] = true, nil }

function asserts.AssertCancelExportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelExportTaskRequest to be of type 'table'")
	assert(struct["ExportTaskId"], "Expected key ExportTaskId to exist in table")
	if struct["ExportTaskId"] then asserts.AssertString(struct["ExportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelExportTaskRequest[k], "CancelExportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelExportTaskRequest
-- <p>Contains the parameters for CancelExportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTaskId [String] <p>The ID of the export task. This is the ID returned by <code>CreateInstanceExportTask</code>.</p>
-- Required key: ExportTaskId
-- @return CancelExportTaskRequest structure as a key-value pair table
function M.CancelExportTaskRequest(args)
	assert(args, "You must provide an argument table when creating CancelExportTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExportTaskId"] = args["ExportTaskId"],
	}
	asserts.AssertCancelExportTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateCapacityReservationResult = { ["CapacityReservation"] = true, nil }

function asserts.AssertCreateCapacityReservationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCapacityReservationResult to be of type 'table'")
	if struct["CapacityReservation"] then asserts.AssertCapacityReservation(struct["CapacityReservation"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCapacityReservationResult[k], "CreateCapacityReservationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCapacityReservationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservation [CapacityReservation] <p>Information about the Capacity Reservation.</p>
-- @return CreateCapacityReservationResult structure as a key-value pair table
function M.CreateCapacityReservationResult(args)
	assert(args, "You must provide an argument table when creating CreateCapacityReservationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservation"] = args["CapacityReservation"],
	}
	asserts.AssertCreateCapacityReservationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyReservedInstancesResult = { ["ReservedInstancesModificationId"] = true, nil }

function asserts.AssertModifyReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstancesModificationId"] then asserts.AssertString(struct["ReservedInstancesModificationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyReservedInstancesResult[k], "ModifyReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesResult
-- <p>Contains the output of ModifyReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesModificationId [String] <p>The ID for the modification.</p>
-- @return ModifyReservedInstancesResult structure as a key-value pair table
function M.ModifyReservedInstancesResult(args)
	assert(args, "You must provide an argument table when creating ModifyReservedInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesModificationId"] = args["ReservedInstancesModificationId"],
	}
	asserts.AssertModifyReservedInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteDhcpOptionsRequest = { ["DryRun"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertDeleteDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteDhcpOptionsRequest[k], "DeleteDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteDhcpOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DhcpOptionsId [String] <p>The ID of the DHCP options set.</p>
-- Required key: DhcpOptionsId
-- @return DeleteDhcpOptionsRequest structure as a key-value pair table
function M.DeleteDhcpOptionsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteDhcpOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
	}
	asserts.AssertDeleteDhcpOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateEgressOnlyInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateEgressOnlyInternetGatewayRequest[k], "CreateEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC for which to create the egress-only internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required key: VpcId
-- @return CreateEgressOnlyInternetGatewayRequest structure as a key-value pair table
function M.CreateEgressOnlyInternetGatewayRequest(args)
	assert(args, "You must provide an argument table when creating CreateEgressOnlyInternetGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateEgressOnlyInternetGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancesResult = { ["Reservations"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesResult to be of type 'table'")
	if struct["Reservations"] then asserts.AssertReservationList(struct["Reservations"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancesResult[k], "DescribeInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesResult
-- <p>Contains the output of DescribeInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Reservations [ReservationList] <p>Zero or more reservations.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeInstancesResult structure as a key-value pair table
function M.DescribeInstancesResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Reservations"] = args["Reservations"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterface = { ["Status"] = true, ["MacAddress"] = true, ["SourceDestCheck"] = true, ["AvailabilityZone"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["VpcId"] = true, ["PrivateIpAddresses"] = true, ["RequesterManaged"] = true, ["PrivateDnsName"] = true, ["RequesterId"] = true, ["InterfaceType"] = true, ["Attachment"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["OwnerId"] = true, ["PrivateIpAddress"] = true, ["SubnetId"] = true, ["TagSet"] = true, ["Association"] = true, nil }

function asserts.AssertNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterface to be of type 'table'")
	if struct["Status"] then asserts.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then asserts.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertNetworkInterfacePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["RequesterManaged"] then asserts.AssertBoolean(struct["RequesterManaged"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["RequesterId"] then asserts.AssertString(struct["RequesterId"]) end
	if struct["InterfaceType"] then asserts.AssertNetworkInterfaceType(struct["InterfaceType"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertNetworkInterfaceIpv6AddressesList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["TagSet"] then asserts.AssertTagList(struct["TagSet"]) end
	if struct["Association"] then asserts.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterface[k], "NetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterface
-- <p>Describes a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- * MacAddress [String] <p>The MAC address.</p>
-- * SourceDestCheck [Boolean] <p>Indicates whether traffic to or from the instance is validated.</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * Description [String] <p>A description.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * PrivateIpAddresses [NetworkInterfacePrivateIpAddressList] <p>The private IPv4 addresses associated with the network interface.</p>
-- * RequesterManaged [Boolean] <p>Indicates whether the network interface is being managed by AWS.</p>
-- * PrivateDnsName [String] <p>The private DNS name.</p>
-- * RequesterId [String] <p>The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- * InterfaceType [NetworkInterfaceType] <p>The type of interface.</p>
-- * Attachment [NetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- * Groups [GroupIdentifierList] <p>Any security groups for the network interface.</p>
-- * Ipv6Addresses [NetworkInterfaceIpv6AddressesList] <p>The IPv6 addresses associated with the network interface.</p>
-- * OwnerId [String] <p>The AWS account ID of the owner of the network interface.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * TagSet [TagList] <p>Any tags assigned to the network interface.</p>
-- * Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
-- @return NetworkInterface structure as a key-value pair table
function M.NetworkInterface(args)
	assert(args, "You must provide an argument table when creating NetworkInterface")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["MacAddress"] = args["MacAddress"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Description"] = args["Description"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["VpcId"] = args["VpcId"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["RequesterManaged"] = args["RequesterManaged"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["RequesterId"] = args["RequesterId"],
		["InterfaceType"] = args["InterfaceType"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["OwnerId"] = args["OwnerId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["SubnetId"] = args["SubnetId"],
		["TagSet"] = args["TagSet"],
		["Association"] = args["Association"],
	}
	asserts.AssertNetworkInterface(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PriceScheduleSpecification = { ["Term"] = true, ["CurrencyCode"] = true, ["Price"] = true, nil }

function asserts.AssertPriceScheduleSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceScheduleSpecification to be of type 'table'")
	if struct["Term"] then asserts.AssertLong(struct["Term"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PriceScheduleSpecification[k], "PriceScheduleSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceScheduleSpecification
-- <p>Describes the price for a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- * Price [Double] <p>The fixed price for the term.</p>
-- @return PriceScheduleSpecification structure as a key-value pair table
function M.PriceScheduleSpecification(args)
	assert(args, "You must provide an argument table when creating PriceScheduleSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Term"] = args["Term"],
		["CurrencyCode"] = args["CurrencyCode"],
		["Price"] = args["Price"],
	}
	asserts.AssertPriceScheduleSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RequestSpotFleetResponse = { ["SpotFleetRequestId"] = true, nil }

function asserts.AssertRequestSpotFleetResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetResponse to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotFleetResponse[k], "RequestSpotFleetResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetResponse
-- <p>Contains the output of RequestSpotFleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- Required key: SpotFleetRequestId
-- @return RequestSpotFleetResponse structure as a key-value pair table
function M.RequestSpotFleetResponse(args)
	assert(args, "You must provide an argument table when creating RequestSpotFleetResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
	}
	asserts.AssertRequestSpotFleetResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateRouteTableRequest = { ["SubnetId"] = true, ["RouteTableId"] = true, ["DryRun"] = true, nil }

function asserts.AssertAssociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateRouteTableRequest[k], "AssociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: RouteTableId
-- Required key: SubnetId
-- @return AssociateRouteTableRequest structure as a key-value pair table
function M.AssociateRouteTableRequest(args)
	assert(args, "You must provide an argument table when creating AssociateRouteTableRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["RouteTableId"] = args["RouteTableId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertAssociateRouteTableRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotFleetTagSpecification = { ["ResourceType"] = true, ["Tags"] = true, nil }

function asserts.AssertSpotFleetTagSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetTagSpecification to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetTagSpecification[k], "SpotFleetTagSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetTagSpecification
-- <p>The tags for a Spot Fleet resource.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceType] <p>The type of resource. Currently, the only resource type that is supported is <code>instance</code>.</p>
-- * Tags [TagList] <p>The tags.</p>
-- @return SpotFleetTagSpecification structure as a key-value pair table
function M.SpotFleetTagSpecification(args)
	assert(args, "You must provide an argument table when creating SpotFleetTagSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertSpotFleetTagSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.HostReservation = { ["Count"] = true, ["End"] = true, ["HourlyPrice"] = true, ["InstanceFamily"] = true, ["CurrencyCode"] = true, ["OfferingId"] = true, ["PaymentOption"] = true, ["State"] = true, ["HostIdSet"] = true, ["Start"] = true, ["HostReservationId"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertHostReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostReservation to be of type 'table'")
	if struct["Count"] then asserts.AssertInteger(struct["Count"]) end
	if struct["End"] then asserts.AssertDateTime(struct["End"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["State"] then asserts.AssertReservationState(struct["State"]) end
	if struct["HostIdSet"] then asserts.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["Start"] then asserts.AssertDateTime(struct["Start"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostReservation[k], "HostReservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostReservation
-- <p>Details about the Dedicated Host Reservation and associated Dedicated Hosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Count [Integer] <p>The number of Dedicated Hosts the reservation is associated with.</p>
-- * End [DateTime] <p>The date and time that the reservation ends.</p>
-- * HourlyPrice [String] <p>The hourly price of the reservation.</p>
-- * InstanceFamily [String] <p>The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>upfrontPrice</code> and <code>hourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * OfferingId [String] <p>The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.</p>
-- * PaymentOption [PaymentOption] <p>The payment option selected for this reservation.</p>
-- * State [ReservationState] <p>The state of the reservation.</p>
-- * HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- * Start [DateTime] <p>The date and time that the reservation started.</p>
-- * HostReservationId [String] <p>The ID of the reservation that specifies the associated Dedicated Hosts.</p>
-- * UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- * Duration [Integer] <p>The length of the reservation's term, specified in seconds. Can be <code>31536000 (1 year)</code> | <code>94608000 (3 years)</code>.</p>
-- @return HostReservation structure as a key-value pair table
function M.HostReservation(args)
	assert(args, "You must provide an argument table when creating HostReservation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Count"] = args["Count"],
		["End"] = args["End"],
		["HourlyPrice"] = args["HourlyPrice"],
		["InstanceFamily"] = args["InstanceFamily"],
		["CurrencyCode"] = args["CurrencyCode"],
		["OfferingId"] = args["OfferingId"],
		["PaymentOption"] = args["PaymentOption"],
		["State"] = args["State"],
		["HostIdSet"] = args["HostIdSet"],
		["Start"] = args["Start"],
		["HostReservationId"] = args["HostReservationId"],
		["UpfrontPrice"] = args["UpfrontPrice"],
		["Duration"] = args["Duration"],
	}
	asserts.AssertHostReservation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FpgaImageAttribute = { ["FpgaImageId"] = true, ["ProductCodes"] = true, ["LoadPermissions"] = true, ["Name"] = true, ["Description"] = true, nil }

function asserts.AssertFpgaImageAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImageAttribute to be of type 'table'")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["LoadPermissions"] then asserts.AssertLoadPermissionList(struct["LoadPermissions"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.FpgaImageAttribute[k], "FpgaImageAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImageAttribute
-- <p>Describes an Amazon FPGA image (AFI) attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageId [String] <p>The ID of the AFI.</p>
-- * ProductCodes [ProductCodeList] <p>One or more product codes.</p>
-- * LoadPermissions [LoadPermissionList] <p>One or more load permissions.</p>
-- * Name [String] <p>The name of the AFI.</p>
-- * Description [String] <p>The description of the AFI.</p>
-- @return FpgaImageAttribute structure as a key-value pair table
function M.FpgaImageAttribute(args)
	assert(args, "You must provide an argument table when creating FpgaImageAttribute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageId"] = args["FpgaImageId"],
		["ProductCodes"] = args["ProductCodes"],
		["LoadPermissions"] = args["LoadPermissions"],
		["Name"] = args["Name"],
		["Description"] = args["Description"],
	}
	asserts.AssertFpgaImageAttribute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResetNetworkInterfaceAttributeRequest = { ["NetworkInterfaceId"] = true, ["DryRun"] = true, ["SourceDestCheck"] = true, nil }

function asserts.AssertResetNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SourceDestCheck"] then asserts.AssertString(struct["SourceDestCheck"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetNetworkInterfaceAttributeRequest[k], "ResetNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ResetNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SourceDestCheck [String] <p>The source/destination checking attribute. Resets the value to <code>true</code>.</p>
-- Required key: NetworkInterfaceId
-- @return ResetNetworkInterfaceAttributeRequest structure as a key-value pair table
function M.ResetNetworkInterfaceAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ResetNetworkInterfaceAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
		["SourceDestCheck"] = args["SourceDestCheck"],
	}
	asserts.AssertResetNetworkInterfaceAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterfacePrivateIpAddress = { ["PrivateDnsName"] = true, ["PrivateIpAddress"] = true, ["Primary"] = true, ["Association"] = true, nil }

function asserts.AssertNetworkInterfacePrivateIpAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfacePrivateIpAddress to be of type 'table'")
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["Association"] then asserts.AssertNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfacePrivateIpAddress[k], "NetworkInterfacePrivateIpAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfacePrivateIpAddress
-- <p>Describes the private IPv4 address of a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrivateDnsName [String] <p>The private DNS name.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address.</p>
-- * Primary [Boolean] <p>Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.</p>
-- * Association [NetworkInterfaceAssociation] <p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>
-- @return NetworkInterfacePrivateIpAddress structure as a key-value pair table
function M.NetworkInterfacePrivateIpAddress(args)
	assert(args, "You must provide an argument table when creating NetworkInterfacePrivateIpAddress")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrivateDnsName"] = args["PrivateDnsName"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Primary"] = args["Primary"],
		["Association"] = args["Association"],
	}
	asserts.AssertNetworkInterfacePrivateIpAddress(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFlowLogsRequest = { ["Filter"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["FlowLogIds"] = true, nil }

function asserts.AssertDescribeFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFlowLogsRequest[k], "DescribeFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>deliver-log-status</code> - The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p> </li> <li> <p> <code>log-destination-type</code> - The type of destination to which the flow log publishes data. Possible destination types include <code>cloud-watch-logs</code> and <code>S3</code>.</p> </li> <li> <p> <code>flow-log-id</code> - The ID of the flow log.</p> </li> <li> <p> <code>log-group-name</code> - The name of the log group.</p> </li> <li> <p> <code>resource-id</code> - The ID of the VPC, subnet, or network interface.</p> </li> <li> <p> <code>traffic-type</code> - The type of traffic (<code>ACCEPT</code> | <code>REJECT</code> | <code>ALL</code>).</p> </li> </ul>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000. If <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the flow log IDs parameter in the same request.</p>
-- * FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
-- @return DescribeFlowLogsRequest structure as a key-value pair table
function M.DescribeFlowLogsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeFlowLogsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Filter"] = args["Filter"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["FlowLogIds"] = args["FlowLogIds"],
	}
	asserts.AssertDescribeFlowLogsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateFpgaImageRequest = { ["DryRun"] = true, ["Name"] = true, ["LogsStorageLocation"] = true, ["InputStorageLocation"] = true, ["ClientToken"] = true, ["Description"] = true, nil }

function asserts.AssertCreateFpgaImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFpgaImageRequest to be of type 'table'")
	assert(struct["InputStorageLocation"], "Expected key InputStorageLocation to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["LogsStorageLocation"] then asserts.AssertStorageLocation(struct["LogsStorageLocation"]) end
	if struct["InputStorageLocation"] then asserts.AssertStorageLocation(struct["InputStorageLocation"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFpgaImageRequest[k], "CreateFpgaImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFpgaImageRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Name [String] <p>A name for the AFI.</p>
-- * LogsStorageLocation [StorageLocation] <p>The location in Amazon S3 for the output logs.</p>
-- * InputStorageLocation [StorageLocation] <p>The location of the encrypted design checkpoint in Amazon S3. The input must be a tarball.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * Description [String] <p>A description for the AFI.</p>
-- Required key: InputStorageLocation
-- @return CreateFpgaImageRequest structure as a key-value pair table
function M.CreateFpgaImageRequest(args)
	assert(args, "You must provide an argument table when creating CreateFpgaImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Name"] = args["Name"],
		["LogsStorageLocation"] = args["LogsStorageLocation"],
		["InputStorageLocation"] = args["InputStorageLocation"],
		["ClientToken"] = args["ClientToken"],
		["Description"] = args["Description"],
	}
	asserts.AssertCreateFpgaImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnassignIpv6AddressesResult = { ["NetworkInterfaceId"] = true, ["UnassignedIpv6Addresses"] = true, nil }

function asserts.AssertUnassignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesResult to be of type 'table'")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["UnassignedIpv6Addresses"] then asserts.AssertIpv6AddressList(struct["UnassignedIpv6Addresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignIpv6AddressesResult[k], "UnassignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * UnassignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses that have been unassigned from the network interface.</p>
-- @return UnassignIpv6AddressesResult structure as a key-value pair table
function M.UnassignIpv6AddressesResult(args)
	assert(args, "You must provide an argument table when creating UnassignIpv6AddressesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["UnassignedIpv6Addresses"] = args["UnassignedIpv6Addresses"],
	}
	asserts.AssertUnassignIpv6AddressesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchPermission = { ["UserId"] = true, ["Group"] = true, nil }

function asserts.AssertLaunchPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermission to be of type 'table'")
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchPermission[k], "LaunchPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermission
-- <p>Describes a launch permission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserId [String] <p>The AWS account ID.</p>
-- * Group [PermissionGroup] <p>The name of the group.</p>
-- @return LaunchPermission structure as a key-value pair table
function M.LaunchPermission(args)
	assert(args, "You must provide an argument table when creating LaunchPermission")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UserId"] = args["UserId"],
		["Group"] = args["Group"],
	}
	asserts.AssertLaunchPermission(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceStatusRequest = { ["DryRun"] = true, ["IncludeAllInstances"] = true, ["MaxResults"] = true, ["Filters"] = true, ["NextToken"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertDescribeInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["IncludeAllInstances"] then asserts.AssertBoolean(struct["IncludeAllInstances"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceStatusRequest[k], "DescribeInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusRequest
-- <p>Contains the parameters for DescribeInstanceStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * IncludeAllInstances [Boolean] <p>When <code>true</code>, includes the health status for all instances. When <code>false</code>, includes the health status for running instances only.</p> <p>Default: <code>false</code> </p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.code</code> - The code for the scheduled event (<code>instance-reboot</code> | <code>system-reboot</code> | <code>system-maintenance</code> | <code>instance-retirement</code> | <code>instance-stop</code>).</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the scheduled event (for example, <code>2014-09-15T17:15:20.000Z</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The code for the instance state, as a 16-bit unsigned integer. The high byte is used for internal purposes and should be ignored. The low byte is set based on the state represented. The valid values are 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-status.reachability</code> - Filters on instance status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>instance-status.status</code> - The status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> <li> <p> <code>system-status.reachability</code> - Filters on system status where the name is <code>reachability</code> (<code>passed</code> | <code>failed</code> | <code>initializing</code> | <code>insufficient-data</code>).</p> </li> <li> <p> <code>system-status.status</code> - The system status of the instance (<code>ok</code> | <code>impaired</code> | <code>initializing</code> | <code>insufficient-data</code> | <code>not-applicable</code>).</p> </li> </ul>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p> <p>Constraints: Maximum 100 explicitly specified instance IDs.</p>
-- @return DescribeInstanceStatusRequest structure as a key-value pair table
function M.DescribeInstanceStatusRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceStatusRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["IncludeAllInstances"] = args["IncludeAllInstances"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertDescribeInstanceStatusRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CopyFpgaImageRequest = { ["SourceFpgaImageId"] = true, ["DryRun"] = true, ["Description"] = true, ["SourceRegion"] = true, ["ClientToken"] = true, ["Name"] = true, nil }

function asserts.AssertCopyFpgaImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyFpgaImageRequest to be of type 'table'")
	assert(struct["SourceFpgaImageId"], "Expected key SourceFpgaImageId to exist in table")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	if struct["SourceFpgaImageId"] then asserts.AssertString(struct["SourceFpgaImageId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["SourceRegion"] then asserts.AssertString(struct["SourceRegion"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyFpgaImageRequest[k], "CopyFpgaImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyFpgaImageRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceFpgaImageId [String] <p>The ID of the source AFI.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>The description for the new AFI.</p>
-- * SourceRegion [String] <p>The region that contains the source AFI.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * Name [String] <p>The name for the new AFI. The default is the name of the source AFI.</p>
-- Required key: SourceFpgaImageId
-- Required key: SourceRegion
-- @return CopyFpgaImageRequest structure as a key-value pair table
function M.CopyFpgaImageRequest(args)
	assert(args, "You must provide an argument table when creating CopyFpgaImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SourceFpgaImageId"] = args["SourceFpgaImageId"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["SourceRegion"] = args["SourceRegion"],
		["ClientToken"] = args["ClientToken"],
		["Name"] = args["Name"],
	}
	asserts.AssertCopyFpgaImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FleetLaunchTemplateOverridesRequest = { ["AvailabilityZone"] = true, ["MaxPrice"] = true, ["WeightedCapacity"] = true, ["Priority"] = true, ["SubnetId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertFleetLaunchTemplateOverridesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FleetLaunchTemplateOverridesRequest to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["MaxPrice"] then asserts.AssertString(struct["MaxPrice"]) end
	if struct["WeightedCapacity"] then asserts.AssertDouble(struct["WeightedCapacity"]) end
	if struct["Priority"] then asserts.AssertDouble(struct["Priority"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.FleetLaunchTemplateOverridesRequest[k], "FleetLaunchTemplateOverridesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FleetLaunchTemplateOverridesRequest
-- <p>Describes overrides for a launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone in which to launch the instances.</p>
-- * MaxPrice [String] <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
-- * WeightedCapacity [Double] <p>The number of units provided by the specified instance type.</p>
-- * Priority [Double] <p>The priority for the launch template override. If <b>AllocationStrategy</b> is set to <code>prioritized</code>, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. Valid values are whole numbers starting at <code>0</code>. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instances.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- @return FleetLaunchTemplateOverridesRequest structure as a key-value pair table
function M.FleetLaunchTemplateOverridesRequest(args)
	assert(args, "You must provide an argument table when creating FleetLaunchTemplateOverridesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["MaxPrice"] = args["MaxPrice"],
		["WeightedCapacity"] = args["WeightedCapacity"],
		["Priority"] = args["Priority"],
		["SubnetId"] = args["SubnetId"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertFleetLaunchTemplateOverridesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportSnapshotTask = { ["SnapshotTaskDetail"] = true, ["Description"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportSnapshotTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotTask to be of type 'table'")
	if struct["SnapshotTaskDetail"] then asserts.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotTask[k], "ImportSnapshotTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotTask
-- <p>Describes an import snapshot task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotTaskDetail [SnapshotTaskDetail] <p>Describes an import snapshot task.</p>
-- * Description [String] <p>A description of the import snapshot task.</p>
-- * ImportTaskId [String] <p>The ID of the import snapshot task.</p>
-- @return ImportSnapshotTask structure as a key-value pair table
function M.ImportSnapshotTask(args)
	assert(args, "You must provide an argument table when creating ImportSnapshotTask")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SnapshotTaskDetail"] = args["SnapshotTaskDetail"],
		["Description"] = args["Description"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportSnapshotTask(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetHostReservationPurchasePreviewResult = { ["TotalHourlyPrice"] = true, ["Purchase"] = true, ["CurrencyCode"] = true, ["TotalUpfrontPrice"] = true, nil }

function asserts.AssertGetHostReservationPurchasePreviewResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then asserts.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then asserts.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then asserts.AssertString(struct["TotalUpfrontPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetHostReservationPurchasePreviewResult[k], "GetHostReservationPurchasePreviewResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TotalHourlyPrice [String] <p>The potential total hourly price of the reservation per hour.</p>
-- * Purchase [PurchaseSet] <p>The purchase information of the Dedicated Host reservation and the Dedicated Hosts associated with it.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * TotalUpfrontPrice [String] <p>The potential total upfront price. This is billed immediately.</p>
-- @return GetHostReservationPurchasePreviewResult structure as a key-value pair table
function M.GetHostReservationPurchasePreviewResult(args)
	assert(args, "You must provide an argument table when creating GetHostReservationPurchasePreviewResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TotalHourlyPrice"] = args["TotalHourlyPrice"],
		["Purchase"] = args["Purchase"],
		["CurrencyCode"] = args["CurrencyCode"],
		["TotalUpfrontPrice"] = args["TotalUpfrontPrice"],
	}
	asserts.AssertGetHostReservationPurchasePreviewResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LoadPermissionRequest = { ["UserId"] = true, ["Group"] = true, nil }

function asserts.AssertLoadPermissionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LoadPermissionRequest to be of type 'table'")
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(keys.LoadPermissionRequest[k], "LoadPermissionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LoadPermissionRequest
-- <p>Describes a load permission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserId [String] <p>The AWS account ID.</p>
-- * Group [PermissionGroup] <p>The name of the group.</p>
-- @return LoadPermissionRequest structure as a key-value pair table
function M.LoadPermissionRequest(args)
	assert(args, "You must provide an argument table when creating LoadPermissionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UserId"] = args["UserId"],
		["Group"] = args["Group"],
	}
	asserts.AssertLoadPermissionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnsuccessfulItem = { ["ResourceId"] = true, ["Error"] = true, nil }

function asserts.AssertUnsuccessfulItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["Error"] then asserts.AssertUnsuccessfulItemError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulItem[k], "UnsuccessfulItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItem
-- <p>Information about items that were not successfully processed in a batch call.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceId [String] <p>The ID of the resource.</p>
-- * Error [UnsuccessfulItemError] <p>Information about the error.</p>
-- Required key: Error
-- @return UnsuccessfulItem structure as a key-value pair table
function M.UnsuccessfulItem(args)
	assert(args, "You must provide an argument table when creating UnsuccessfulItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceId"] = args["ResourceId"],
		["Error"] = args["Error"],
	}
	asserts.AssertUnsuccessfulItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceMarketOptionsRequest = { ["SpotOptions"] = true, ["MarketType"] = true, nil }

function asserts.AssertInstanceMarketOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceMarketOptionsRequest to be of type 'table'")
	if struct["SpotOptions"] then asserts.AssertSpotMarketOptions(struct["SpotOptions"]) end
	if struct["MarketType"] then asserts.AssertMarketType(struct["MarketType"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceMarketOptionsRequest[k], "InstanceMarketOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceMarketOptionsRequest
-- <p>Describes the market (purchasing) option for the instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotOptions [SpotMarketOptions] <p>The options for Spot Instances.</p>
-- * MarketType [MarketType] <p>The market type.</p>
-- @return InstanceMarketOptionsRequest structure as a key-value pair table
function M.InstanceMarketOptionsRequest(args)
	assert(args, "You must provide an argument table when creating InstanceMarketOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotOptions"] = args["SpotOptions"],
		["MarketType"] = args["MarketType"],
	}
	asserts.AssertInstanceMarketOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PeeringConnectionOptionsRequest = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptionsRequest to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.PeeringConnectionOptionsRequest[k], "PeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptionsRequest
-- <p>The VPC peering connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>
-- * AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>
-- * AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC using ClassicLink to instances in a peer VPC.</p>
-- @return PeeringConnectionOptionsRequest structure as a key-value pair table
function M.PeeringConnectionOptionsRequest(args)
	assert(args, "You must provide an argument table when creating PeeringConnectionOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = args["AllowEgressFromLocalVpcToRemoteClassicLink"],
		["AllowDnsResolutionFromRemoteVpc"] = args["AllowDnsResolutionFromRemoteVpc"],
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = args["AllowEgressFromLocalClassicLinkToRemoteVpc"],
	}
	asserts.AssertPeeringConnectionOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateIamInstanceProfileSpecificationRequest = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertLaunchTemplateIamInstanceProfileSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateIamInstanceProfileSpecificationRequest to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateIamInstanceProfileSpecificationRequest[k], "LaunchTemplateIamInstanceProfileSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateIamInstanceProfileSpecificationRequest
-- <p>An IAM instance profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [String] <p>The name of the instance profile.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
-- @return LaunchTemplateIamInstanceProfileSpecificationRequest structure as a key-value pair table
function M.LaunchTemplateIamInstanceProfileSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateIamInstanceProfileSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertLaunchTemplateIamInstanceProfileSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceAttributeRequest = { ["InstanceId"] = true, ["Attribute"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceAttributeRequest[k], "DescribeInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceAttributeRequest
-- <p>Contains the parameters for DescribeInstanceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Attribute [InstanceAttributeName] <p>The instance attribute.</p> <p>Note: The <code>enaSupport</code> attribute is not supported at this time.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Attribute
-- Required key: InstanceId
-- @return DescribeInstanceAttributeRequest structure as a key-value pair table
function M.DescribeInstanceAttributeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeInstanceAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateSpotMarketOptionsRequest = { ["SpotInstanceType"] = true, ["BlockDurationMinutes"] = true, ["ValidUntil"] = true, ["MaxPrice"] = true, ["InstanceInterruptionBehavior"] = true, nil }

function asserts.AssertLaunchTemplateSpotMarketOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateSpotMarketOptionsRequest to be of type 'table'")
	if struct["SpotInstanceType"] then asserts.AssertSpotInstanceType(struct["SpotInstanceType"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["MaxPrice"] then asserts.AssertString(struct["MaxPrice"]) end
	if struct["InstanceInterruptionBehavior"] then asserts.AssertInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateSpotMarketOptionsRequest[k], "LaunchTemplateSpotMarketOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateSpotMarketOptionsRequest
-- <p>The options for Spot Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceType [SpotInstanceType] <p>The Spot Instance request type.</p>
-- * BlockDurationMinutes [Integer] <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>
-- * ValidUntil [DateTime] <p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date.</p>
-- * MaxPrice [String] <p>The maximum hourly price you're willing to pay for the Spot Instances.</p>
-- * InstanceInterruptionBehavior [InstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
-- @return LaunchTemplateSpotMarketOptionsRequest structure as a key-value pair table
function M.LaunchTemplateSpotMarketOptionsRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateSpotMarketOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotInstanceType"] = args["SpotInstanceType"],
		["BlockDurationMinutes"] = args["BlockDurationMinutes"],
		["ValidUntil"] = args["ValidUntil"],
		["MaxPrice"] = args["MaxPrice"],
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
	}
	asserts.AssertLaunchTemplateSpotMarketOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyLaunchTemplateRequest = { ["LaunchTemplateName"] = true, ["LaunchTemplateId"] = true, ["DefaultVersion"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertModifyLaunchTemplateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyLaunchTemplateRequest to be of type 'table'")
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	if struct["DefaultVersion"] then asserts.AssertString(struct["DefaultVersion"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyLaunchTemplateRequest[k], "ModifyLaunchTemplateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyLaunchTemplateRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * DefaultVersion [String] <p>The version number of the launch template to set as the default version.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- @return ModifyLaunchTemplateRequest structure as a key-value pair table
function M.ModifyLaunchTemplateRequest(args)
	assert(args, "You must provide an argument table when creating ModifyLaunchTemplateRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
		["DefaultVersion"] = args["DefaultVersion"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertModifyLaunchTemplateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpnConnectionOptions = { ["StaticRoutesOnly"] = true, nil }

function asserts.AssertVpnConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptions to be of type 'table'")
	if struct["StaticRoutesOnly"] then asserts.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnectionOptions[k], "VpnConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptions
-- <p>Describes VPN connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StaticRoutesOnly [Boolean] <p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>
-- @return VpnConnectionOptions structure as a key-value pair table
function M.VpnConnectionOptions(args)
	assert(args, "You must provide an argument table when creating VpnConnectionOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StaticRoutesOnly"] = args["StaticRoutesOnly"],
	}
	asserts.AssertVpnConnectionOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DiskImageDetail = { ["Bytes"] = true, ["ImportManifestUrl"] = true, ["Format"] = true, nil }

function asserts.AssertDiskImageDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDetail to be of type 'table'")
	assert(struct["Bytes"], "Expected key Bytes to exist in table")
	assert(struct["Format"], "Expected key Format to exist in table")
	assert(struct["ImportManifestUrl"], "Expected key ImportManifestUrl to exist in table")
	if struct["Bytes"] then asserts.AssertLong(struct["Bytes"]) end
	if struct["ImportManifestUrl"] then asserts.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then asserts.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageDetail[k], "DiskImageDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDetail
-- <p>Describes a disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Bytes [Long] <p>The size of the disk image, in GiB.</p>
-- * ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- * Format [DiskImageFormat] <p>The disk image format.</p>
-- Required key: Bytes
-- Required key: Format
-- Required key: ImportManifestUrl
-- @return DiskImageDetail structure as a key-value pair table
function M.DiskImageDetail(args)
	assert(args, "You must provide an argument table when creating DiskImageDetail")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Bytes"] = args["Bytes"],
		["ImportManifestUrl"] = args["ImportManifestUrl"],
		["Format"] = args["Format"],
	}
	asserts.AssertDiskImageDetail(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AvailabilityZone = { ["State"] = true, ["ZoneName"] = true, ["Messages"] = true, ["RegionName"] = true, nil }

function asserts.AssertAvailabilityZone(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZone to be of type 'table'")
	if struct["State"] then asserts.AssertAvailabilityZoneState(struct["State"]) end
	if struct["ZoneName"] then asserts.AssertString(struct["ZoneName"]) end
	if struct["Messages"] then asserts.AssertAvailabilityZoneMessageList(struct["Messages"]) end
	if struct["RegionName"] then asserts.AssertString(struct["RegionName"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailabilityZone[k], "AvailabilityZone contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZone
-- <p>Describes an Availability Zone.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [AvailabilityZoneState] <p>The state of the Availability Zone.</p>
-- * ZoneName [String] <p>The name of the Availability Zone.</p>
-- * Messages [AvailabilityZoneMessageList] <p>Any messages about the Availability Zone.</p>
-- * RegionName [String] <p>The name of the region.</p>
-- @return AvailabilityZone structure as a key-value pair table
function M.AvailabilityZone(args)
	assert(args, "You must provide an argument table when creating AvailabilityZone")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["ZoneName"] = args["ZoneName"],
		["Messages"] = args["Messages"],
		["RegionName"] = args["RegionName"],
	}
	asserts.AssertAvailabilityZone(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterfaceAttachment = { ["Status"] = true, ["DeviceIndex"] = true, ["AttachTime"] = true, ["InstanceId"] = true, ["DeleteOnTermination"] = true, ["AttachmentId"] = true, ["InstanceOwnerId"] = true, nil }

function asserts.AssertNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["InstanceOwnerId"] then asserts.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAttachment[k], "NetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [AttachmentStatus] <p>The attachment state.</p>
-- * DeviceIndex [Integer] <p>The device index of the network interface attachment on the instance.</p>
-- * AttachTime [DateTime] <p>The timestamp indicating when the attachment initiated.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- * InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
-- @return NetworkInterfaceAttachment structure as a key-value pair table
function M.NetworkInterfaceAttachment(args)
	assert(args, "You must provide an argument table when creating NetworkInterfaceAttachment")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DeviceIndex"] = args["DeviceIndex"],
		["AttachTime"] = args["AttachTime"],
		["InstanceId"] = args["InstanceId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["AttachmentId"] = args["AttachmentId"],
		["InstanceOwnerId"] = args["InstanceOwnerId"],
	}
	asserts.AssertNetworkInterfaceAttachment(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ElasticGpuHealth = { ["Status"] = true, nil }

function asserts.AssertElasticGpuHealth(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ElasticGpuHealth to be of type 'table'")
	if struct["Status"] then asserts.AssertElasticGpuStatus(struct["Status"]) end
	for k,_ in pairs(struct) do
		assert(keys.ElasticGpuHealth[k], "ElasticGpuHealth contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ElasticGpuHealth
-- <p>Describes the status of an Elastic GPU.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [ElasticGpuStatus] <p>The health status.</p>
-- @return ElasticGpuHealth structure as a key-value pair table
function M.ElasticGpuHealth(args)
	assert(args, "You must provide an argument table when creating ElasticGpuHealth")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
	}
	asserts.AssertElasticGpuHealth(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RunScheduledInstancesRequest = { ["ScheduledInstanceId"] = true, ["LaunchSpecification"] = true, ["InstanceCount"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertRunScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesRequest to be of type 'table'")
	assert(struct["LaunchSpecification"], "Expected key LaunchSpecification to exist in table")
	assert(struct["ScheduledInstanceId"], "Expected key ScheduledInstanceId to exist in table")
	if struct["ScheduledInstanceId"] then asserts.AssertString(struct["ScheduledInstanceId"]) end
	if struct["LaunchSpecification"] then asserts.AssertScheduledInstancesLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunScheduledInstancesRequest[k], "RunScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesRequest
-- <p>Contains the parameters for RunScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- * LaunchSpecification [ScheduledInstancesLaunchSpecification] <p>The launch specification. You must match the instance type, Availability Zone, network, and platform of the schedule that you purchased.</p>
-- * InstanceCount [Integer] <p>The number of instances.</p> <p>Default: 1</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: LaunchSpecification
-- Required key: ScheduledInstanceId
-- @return RunScheduledInstancesRequest structure as a key-value pair table
function M.RunScheduledInstancesRequest(args)
	assert(args, "You must provide an argument table when creating RunScheduledInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ScheduledInstanceId"] = args["ScheduledInstanceId"],
		["LaunchSpecification"] = args["LaunchSpecification"],
		["InstanceCount"] = args["InstanceCount"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertRunScheduledInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["VolumeIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVolumesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesRequest[k], "DescribeVolumesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesRequest
-- <p>Contains the parameters for DescribeVolumes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumes</code> in paginated output. When this parameter is used, <code>DescribeVolumes</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeVolumes</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 500; if <code>MaxResults</code> is given a value larger than 500, only 500 results are returned. If this parameter is not used, then <code>DescribeVolumes</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- * NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeVolumes</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.attach-time</code> - The time stamp when the attachment initiated.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Whether the volume is deleted on instance termination.</p> </li> <li> <p> <code>attachment.device</code> - The device name specified in the block device mapping (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance the volume is attached to.</p> </li> <li> <p> <code>attachment.status</code> - The attachment state (<code>attaching</code> | <code>attached</code> | <code>detaching</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone in which the volume was created.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the volume was created.</p> </li> <li> <p> <code>encrypted</code> - The encryption status of the volume.</p> </li> <li> <p> <code>size</code> - The size of the volume, in GiB.</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot from which the volume was created.</p> </li> <li> <p> <code>status</code> - The status of the volume (<code>creating</code> | <code>available</code> | <code>in-use</code> | <code>deleting</code> | <code>deleted</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>volume-id</code> - The volume ID.</p> </li> <li> <p> <code>volume-type</code> - The Amazon EBS volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> </li> </ul>
-- @return DescribeVolumesRequest structure as a key-value pair table
function M.DescribeVolumesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVolumesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["VolumeIds"] = args["VolumeIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVolumesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DiskImageDescription = { ["Checksum"] = true, ["Size"] = true, ["ImportManifestUrl"] = true, ["Format"] = true, nil }

function asserts.AssertDiskImageDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageDescription to be of type 'table'")
	if struct["Checksum"] then asserts.AssertString(struct["Checksum"]) end
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	if struct["ImportManifestUrl"] then asserts.AssertString(struct["ImportManifestUrl"]) end
	if struct["Format"] then asserts.AssertDiskImageFormat(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageDescription[k], "DiskImageDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageDescription
-- <p>Describes a disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Checksum [String] <p>The checksum computed for the disk image.</p>
-- * Size [Long] <p>The size of the disk image, in GiB.</p>
-- * ImportManifestUrl [String] <p>A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the "Query String Request Authentication Alternative" section of the <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html">VM Import Manifest</a>.</p>
-- * Format [DiskImageFormat] <p>The disk image format.</p>
-- @return DiskImageDescription structure as a key-value pair table
function M.DiskImageDescription(args)
	assert(args, "You must provide an argument table when creating DiskImageDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Checksum"] = args["Checksum"],
		["Size"] = args["Size"],
		["ImportManifestUrl"] = args["ImportManifestUrl"],
		["Format"] = args["Format"],
	}
	asserts.AssertDiskImageDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyFpgaImageAttributeRequest = { ["ProductCodes"] = true, ["UserGroups"] = true, ["DryRun"] = true, ["Description"] = true, ["Attribute"] = true, ["UserIds"] = true, ["OperationType"] = true, ["FpgaImageId"] = true, ["Name"] = true, ["LoadPermission"] = true, nil }

function asserts.AssertModifyFpgaImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyFpgaImageAttributeRequest to be of type 'table'")
	assert(struct["FpgaImageId"], "Expected key FpgaImageId to exist in table")
	if struct["ProductCodes"] then asserts.AssertProductCodeStringList(struct["ProductCodes"]) end
	if struct["UserGroups"] then asserts.AssertUserGroupStringList(struct["UserGroups"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Attribute"] then asserts.AssertFpgaImageAttributeName(struct["Attribute"]) end
	if struct["UserIds"] then asserts.AssertUserIdStringList(struct["UserIds"]) end
	if struct["OperationType"] then asserts.AssertOperationType(struct["OperationType"]) end
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["LoadPermission"] then asserts.AssertLoadPermissionModifications(struct["LoadPermission"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyFpgaImageAttributeRequest[k], "ModifyFpgaImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyFpgaImageAttributeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeStringList] <p>One or more product codes. After you add a product code to an AFI, it can't be removed. This parameter is valid only when modifying the <code>productCodes</code> attribute.</p>
-- * UserGroups [UserGroupStringList] <p>One or more user groups. This parameter is valid only when modifying the <code>loadPermission</code> attribute.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the AFI.</p>
-- * Attribute [FpgaImageAttributeName] <p>The name of the attribute.</p>
-- * UserIds [UserIdStringList] <p>One or more AWS account IDs. This parameter is valid only when modifying the <code>loadPermission</code> attribute.</p>
-- * OperationType [OperationType] <p>The operation type.</p>
-- * FpgaImageId [String] <p>The ID of the AFI.</p>
-- * Name [String] <p>A name for the AFI.</p>
-- * LoadPermission [LoadPermissionModifications] <p>The load permission for the AFI.</p>
-- Required key: FpgaImageId
-- @return ModifyFpgaImageAttributeRequest structure as a key-value pair table
function M.ModifyFpgaImageAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifyFpgaImageAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ProductCodes"] = args["ProductCodes"],
		["UserGroups"] = args["UserGroups"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Attribute"] = args["Attribute"],
		["UserIds"] = args["UserIds"],
		["OperationType"] = args["OperationType"],
		["FpgaImageId"] = args["FpgaImageId"],
		["Name"] = args["Name"],
		["LoadPermission"] = args["LoadPermission"],
	}
	asserts.AssertModifyFpgaImageAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelImportTaskRequest = { ["DryRun"] = true, ["CancelReason"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertCancelImportTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CancelReason"] then asserts.AssertString(struct["CancelReason"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelImportTaskRequest[k], "CancelImportTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskRequest
-- <p>Contains the parameters for CancelImportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * CancelReason [String] <p>The reason for canceling the task.</p>
-- * ImportTaskId [String] <p>The ID of the import image or import snapshot task to be canceled.</p>
-- @return CancelImportTaskRequest structure as a key-value pair table
function M.CancelImportTaskRequest(args)
	assert(args, "You must provide an argument table when creating CancelImportTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["CancelReason"] = args["CancelReason"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertCancelImportTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportInstanceRequest = { ["Platform"] = true, ["DiskImages"] = true, ["DryRun"] = true, ["Description"] = true, ["LaunchSpecification"] = true, nil }

function asserts.AssertImportInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceRequest to be of type 'table'")
	assert(struct["Platform"], "Expected key Platform to exist in table")
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["DiskImages"] then asserts.AssertDiskImageList(struct["DiskImages"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["LaunchSpecification"] then asserts.AssertImportInstanceLaunchSpecification(struct["LaunchSpecification"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceRequest[k], "ImportInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceRequest
-- <p>Contains the parameters for ImportInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Platform [PlatformValues] <p>The instance operating system.</p>
-- * DiskImages [DiskImageList] <p>The disk image.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the instance being imported.</p>
-- * LaunchSpecification [ImportInstanceLaunchSpecification] <p>The launch specification.</p>
-- Required key: Platform
-- @return ImportInstanceRequest structure as a key-value pair table
function M.ImportInstanceRequest(args)
	assert(args, "You must provide an argument table when creating ImportInstanceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Platform"] = args["Platform"],
		["DiskImages"] = args["DiskImages"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["LaunchSpecification"] = args["LaunchSpecification"],
	}
	asserts.AssertImportInstanceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAggregateIdFormatRequest = { ["DryRun"] = true, nil }

function asserts.AssertDescribeAggregateIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAggregateIdFormatRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAggregateIdFormatRequest[k], "DescribeAggregateIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAggregateIdFormatRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DescribeAggregateIdFormatRequest structure as a key-value pair table
function M.DescribeAggregateIdFormatRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAggregateIdFormatRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeAggregateIdFormatRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFpgaImageRequest = { ["FpgaImageId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteFpgaImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFpgaImageRequest to be of type 'table'")
	assert(struct["FpgaImageId"], "Expected key FpgaImageId to exist in table")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFpgaImageRequest[k], "DeleteFpgaImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFpgaImageRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageId [String] <p>The ID of the AFI.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: FpgaImageId
-- @return DeleteFpgaImageRequest structure as a key-value pair table
function M.DeleteFpgaImageRequest(args)
	assert(args, "You must provide an argument table when creating DeleteFpgaImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageId"] = args["FpgaImageId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteFpgaImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVolumeRequest = { ["AvailabilityZone"] = true, ["DryRun"] = true, ["TagSpecifications"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["KmsKeyId"] = true, ["SnapshotId"] = true, ["Iops"] = true, ["Size"] = true, nil }

function asserts.AssertCreateVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumeRequest[k], "CreateVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumeRequest
-- <p>Contains the parameters for CreateVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone in which to create the volume. Use <a>DescribeAvailabilityZones</a> to list the Availability Zones that are currently available to you.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TagSpecifications [TagSpecificationList] <p>The tags to apply to the volume during creation.</p>
-- * Encrypted [Boolean] <p>Specifies whether the volume should be encrypted. Encrypted Amazon EBS volumes may only be attached to instances that support Amazon EBS encryption. Volumes that are created from encrypted snapshots are automatically encrypted. There is no way to create an encrypted volume from an unencrypted snapshot or vice versa. If your AMI uses encrypted volumes, you can only launch it on supported instance types. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p> <p>Defaults: If no volume type is specified, the default is <code>standard</code> in us-east-1, eu-west-1, eu-central-1, us-west-2, us-west-1, sa-east-1, ap-northeast-1, ap-northeast-2, ap-southeast-1, ap-southeast-2, ap-south-1, us-gov-west-1, and cn-north-1. In all other regions, EBS defaults to <code>gp2</code>.</p>
-- * KmsKeyId [String] <p>An identifier for the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set. </p> <p>The CMK identifier may be provided in any of the following formats: </p> <ul> <li> <p>Key ID</p> </li> <li> <p>Key alias</p> </li> <li> <p>ARN using key ID. The ID ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. </p> </li> <li> <p>ARN using key alias. The alias ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>alias</code> namespace, and then the CMK alias. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:alias/<i>ExampleAlias</i>. </p> </li> </ul> <p>AWS parses <code>KmsKeyId</code> asynchronously, meaning that the action you call may appear to complete even though you provided an invalid identifier. The action will eventually fail. </p>
-- * SnapshotId [String] <p>The snapshot from which to create the volume.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) to provision for the volume, with a maximum ratio of 50 IOPS/GiB. Range is 100 to 32000 IOPS for volumes in most regions. For exceptions, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>This parameter is valid only for Provisioned IOPS SSD (io1) volumes.</p>
-- * Size [Integer] <p>The size of the volume, in GiBs.</p> <p>Constraints: 1-16384 for <code>gp2</code>, 4-16384 for <code>io1</code>, 500-16384 for <code>st1</code>, 500-16384 for <code>sc1</code>, and 1-1024 for <code>standard</code>. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- Required key: AvailabilityZone
-- @return CreateVolumeRequest structure as a key-value pair table
function M.CreateVolumeRequest(args)
	assert(args, "You must provide an argument table when creating CreateVolumeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["TagSpecifications"] = args["TagSpecifications"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["KmsKeyId"] = args["KmsKeyId"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
		["Size"] = args["Size"],
	}
	asserts.AssertCreateVolumeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeHostsResult = { ["NextToken"] = true, ["Hosts"] = true, nil }

function asserts.AssertDescribeHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Hosts"] then asserts.AssertHostList(struct["Hosts"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostsResult[k], "DescribeHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * Hosts [HostList] <p>Information about the Dedicated Hosts.</p>
-- @return DescribeHostsResult structure as a key-value pair table
function M.DescribeHostsResult(args)
	assert(args, "You must provide an argument table when creating DescribeHostsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Hosts"] = args["Hosts"],
	}
	asserts.AssertDescribeHostsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstanceRecurrenceRequest = { ["OccurrenceDays"] = true, ["Interval"] = true, ["Frequency"] = true, ["OccurrenceRelativeToEnd"] = true, ["OccurrenceUnit"] = true, nil }

function asserts.AssertScheduledInstanceRecurrenceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrenceRequest to be of type 'table'")
	if struct["OccurrenceDays"] then asserts.AssertOccurrenceDayRequestSet(struct["OccurrenceDays"]) end
	if struct["Interval"] then asserts.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then asserts.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then asserts.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then asserts.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceRecurrenceRequest[k], "ScheduledInstanceRecurrenceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrenceRequest
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OccurrenceDays [OccurrenceDayRequestSet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.</p>
-- * Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>Frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- * Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- * OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.</p>
-- * OccurrenceUnit [String] <p>The unit for <code>OccurrenceDays</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>). This value is required for a monthly schedule. You can't specify <code>DayOfWeek</code> with a weekly schedule. You can't specify this value with a daily schedule.</p>
-- @return ScheduledInstanceRecurrenceRequest structure as a key-value pair table
function M.ScheduledInstanceRecurrenceRequest(args)
	assert(args, "You must provide an argument table when creating ScheduledInstanceRecurrenceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OccurrenceDays"] = args["OccurrenceDays"],
		["Interval"] = args["Interval"],
		["Frequency"] = args["Frequency"],
		["OccurrenceRelativeToEnd"] = args["OccurrenceRelativeToEnd"],
		["OccurrenceUnit"] = args["OccurrenceUnit"],
	}
	asserts.AssertScheduledInstanceRecurrenceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumesResult = { ["NextToken"] = true, ["Volumes"] = true, nil }

function asserts.AssertDescribeVolumesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Volumes"] then asserts.AssertVolumeList(struct["Volumes"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesResult[k], "DescribeVolumesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesResult
-- <p>Contains the output of DescribeVolumes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumes</code> request. When the results of a <code>DescribeVolumes</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * Volumes [VolumeList] <p>Information about the volumes.</p>
-- @return DescribeVolumesResult structure as a key-value pair table
function M.DescribeVolumesResult(args)
	assert(args, "You must provide an argument table when creating DescribeVolumesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Volumes"] = args["Volumes"],
	}
	asserts.AssertDescribeVolumesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RouteTableAssociation = { ["SubnetId"] = true, ["RouteTableAssociationId"] = true, ["Main"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertRouteTableAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTableAssociation to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["RouteTableAssociationId"] then asserts.AssertString(struct["RouteTableAssociationId"]) end
	if struct["Main"] then asserts.AssertBoolean(struct["Main"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RouteTableAssociation[k], "RouteTableAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTableAssociation
-- <p>Describes an association between a route table and a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet. A subnet ID is not returned for an implicit association.</p>
-- * RouteTableAssociationId [String] <p>The ID of the association between a route table and a subnet.</p>
-- * Main [Boolean] <p>Indicates whether this is the main route table.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- @return RouteTableAssociation structure as a key-value pair table
function M.RouteTableAssociation(args)
	assert(args, "You must provide an argument table when creating RouteTableAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["RouteTableAssociationId"] = args["RouteTableAssociationId"],
		["Main"] = args["Main"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertRouteTableAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNatGatewaysRequest = { ["Filter"] = true, ["NextToken"] = true, ["NatGatewayIds"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeNatGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["NatGatewayIds"] then asserts.AssertValueStringList(struct["NatGatewayIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNatGatewaysRequest[k], "DescribeNatGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>nat-gateway-id</code> - The ID of the NAT gateway.</p> </li> <li> <p> <code>state</code> - The state of the NAT gateway (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet in which the NAT gateway resides.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC in which the NAT gateway resides.</p> </li> </ul>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * NatGatewayIds [ValueStringList] <p>One or more NAT gateway IDs.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
-- @return DescribeNatGatewaysRequest structure as a key-value pair table
function M.DescribeNatGatewaysRequest(args)
	assert(args, "You must provide an argument table when creating DescribeNatGatewaysRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Filter"] = args["Filter"],
		["NextToken"] = args["NextToken"],
		["NatGatewayIds"] = args["NatGatewayIds"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeNatGatewaysRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertDetachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachInternetGatewayRequest[k], "DetachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayId [String] <p>The ID of the internet gateway.</p>
-- Required key: InternetGatewayId
-- Required key: VpcId
-- @return DetachInternetGatewayRequest structure as a key-value pair table
function M.DetachInternetGatewayRequest(args)
	assert(args, "You must provide an argument table when creating DetachInternetGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertDetachInternetGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesEbs = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, ["Iops"] = true, nil }

function asserts.AssertScheduledInstancesEbs(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesEbs to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertString(struct["VolumeType"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesEbs[k], "ScheduledInstancesEbs contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesEbs
-- <p>Describes an EBS volume for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- * Encrypted [Boolean] <p>Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.</p>
-- * VolumeType [String] <p>The volume type. <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, Throughput Optimized HDD for <code>st1</code>, Cold HDD for <code>sc1</code>, or <code>standard</code> for Magnetic.</p> <p>Default: <code>standard</code> </p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about <code>gp2</code> baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code>volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- @return ScheduledInstancesEbs structure as a key-value pair table
function M.ScheduledInstancesEbs(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesEbs")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumeSize"] = args["VolumeSize"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
	}
	asserts.AssertScheduledInstancesEbs(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDefaultSubnetRequest = { ["AvailabilityZone"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateDefaultSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDefaultSubnetRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDefaultSubnetRequest[k], "CreateDefaultSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDefaultSubnetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone in which to create the default subnet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: AvailabilityZone
-- @return CreateDefaultSubnetRequest structure as a key-value pair table
function M.CreateDefaultSubnetRequest(args)
	assert(args, "You must provide an argument table when creating CreateDefaultSubnetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateDefaultSubnetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateImageRequest = { ["DryRun"] = true, ["Description"] = true, ["InstanceId"] = true, ["BlockDeviceMappings"] = true, ["NoReboot"] = true, ["Name"] = true, nil }

function asserts.AssertCreateImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["NoReboot"] then asserts.AssertBoolean(struct["NoReboot"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateImageRequest[k], "CreateImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageRequest
-- <p>Contains the parameters for CreateImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the new image.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * BlockDeviceMappings [BlockDeviceMappingRequestList] <p>Information about one or more block device mappings. This parameter cannot be used to modify the encryption status of existing volumes or snapshots. To create an AMI with encrypted snapshots, use the <a>CopyImage</a> action.</p>
-- * NoReboot [Boolean] <p>By default, Amazon EC2 attempts to shut down and reboot the instance before creating the image. If the 'No Reboot' option is set, Amazon EC2 doesn't shut down the instance before creating the image. When this option is used, file system integrity on the created image can't be guaranteed.</p>
-- * Name [String] <p>A name for the new image.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required key: InstanceId
-- Required key: Name
-- @return CreateImageRequest structure as a key-value pair table
function M.CreateImageRequest(args)
	assert(args, "You must provide an argument table when creating CreateImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["InstanceId"] = args["InstanceId"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["NoReboot"] = args["NoReboot"],
		["Name"] = args["Name"],
	}
	asserts.AssertCreateImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisableVpcClassicLinkDnsSupportResult = { ["Return"] = true, nil }

function asserts.AssertDisableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkDnsSupportResult[k], "DisableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkDnsSupportResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DisableVpcClassicLinkDnsSupportResult structure as a key-value pair table
function M.DisableVpcClassicLinkDnsSupportResult(args)
	assert(args, "You must provide an argument table when creating DisableVpcClassicLinkDnsSupportResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDisableVpcClassicLinkDnsSupportResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteLaunchTemplateVersionsResponseSuccessItem = { ["LaunchTemplateName"] = true, ["VersionNumber"] = true, ["LaunchTemplateId"] = true, nil }

function asserts.AssertDeleteLaunchTemplateVersionsResponseSuccessItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteLaunchTemplateVersionsResponseSuccessItem to be of type 'table'")
	if struct["LaunchTemplateName"] then asserts.AssertString(struct["LaunchTemplateName"]) end
	if struct["VersionNumber"] then asserts.AssertLong(struct["VersionNumber"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteLaunchTemplateVersionsResponseSuccessItem[k], "DeleteLaunchTemplateVersionsResponseSuccessItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteLaunchTemplateVersionsResponseSuccessItem
-- <p>Describes a launch template version that was successfully deleted.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateName [String] <p>The name of the launch template.</p>
-- * VersionNumber [Long] <p>The version number of the launch template.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template.</p>
-- @return DeleteLaunchTemplateVersionsResponseSuccessItem structure as a key-value pair table
function M.DeleteLaunchTemplateVersionsResponseSuccessItem(args)
	assert(args, "You must provide an argument table when creating DeleteLaunchTemplateVersionsResponseSuccessItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["VersionNumber"] = args["VersionNumber"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
	}
	asserts.AssertDeleteLaunchTemplateVersionsResponseSuccessItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePrefixListsResult = { ["NextToken"] = true, ["PrefixLists"] = true, nil }

function asserts.AssertDescribePrefixListsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["PrefixLists"] then asserts.AssertPrefixListSet(struct["PrefixLists"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrefixListsResult[k], "DescribePrefixListsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * PrefixLists [PrefixListSet] <p>All available prefix lists.</p>
-- @return DescribePrefixListsResult structure as a key-value pair table
function M.DescribePrefixListsResult(args)
	assert(args, "You must provide an argument table when creating DescribePrefixListsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["PrefixLists"] = args["PrefixLists"],
	}
	asserts.AssertDescribePrefixListsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateTagSpecificationRequest = { ["ResourceType"] = true, ["Tags"] = true, nil }

function asserts.AssertLaunchTemplateTagSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateTagSpecificationRequest to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateTagSpecificationRequest[k], "LaunchTemplateTagSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateTagSpecificationRequest
-- <p>The tags specification for the launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceType] <p>The type of resource to tag. Currently, the resource types that support tagging on creation are <code>instance</code> and <code>volume</code>. To tag a resource after it has been created, see <a>CreateTags</a>.</p>
-- * Tags [TagList] <p>The tags to apply to the resource.</p>
-- @return LaunchTemplateTagSpecificationRequest structure as a key-value pair table
function M.LaunchTemplateTagSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateTagSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertLaunchTemplateTagSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMovingAddressesResult = { ["MovingAddressStatuses"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeMovingAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesResult to be of type 'table'")
	if struct["MovingAddressStatuses"] then asserts.AssertMovingAddressStatusSet(struct["MovingAddressStatuses"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMovingAddressesResult[k], "DescribeMovingAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MovingAddressStatuses [MovingAddressStatusSet] <p>The status for each Elastic IP address.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeMovingAddressesResult structure as a key-value pair table
function M.DescribeMovingAddressesResult(args)
	assert(args, "You must provide an argument table when creating DescribeMovingAddressesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MovingAddressStatuses"] = args["MovingAddressStatuses"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeMovingAddressesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeModification = { ["TargetSize"] = true, ["TargetVolumeType"] = true, ["ModificationState"] = true, ["VolumeId"] = true, ["TargetIops"] = true, ["OriginalSize"] = true, ["StartTime"] = true, ["Progress"] = true, ["OriginalVolumeType"] = true, ["OriginalIops"] = true, ["EndTime"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVolumeModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeModification to be of type 'table'")
	if struct["TargetSize"] then asserts.AssertInteger(struct["TargetSize"]) end
	if struct["TargetVolumeType"] then asserts.AssertVolumeType(struct["TargetVolumeType"]) end
	if struct["ModificationState"] then asserts.AssertVolumeModificationState(struct["ModificationState"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["TargetIops"] then asserts.AssertInteger(struct["TargetIops"]) end
	if struct["OriginalSize"] then asserts.AssertInteger(struct["OriginalSize"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then asserts.AssertLong(struct["Progress"]) end
	if struct["OriginalVolumeType"] then asserts.AssertVolumeType(struct["OriginalVolumeType"]) end
	if struct["OriginalIops"] then asserts.AssertInteger(struct["OriginalIops"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeModification[k], "VolumeModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeModification
-- <p>Describes the modification status of an EBS volume.</p> <p>If the volume has never been modified, some element values will be null.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetSize [Integer] <p>The target size of the volume, in GiB.</p>
-- * TargetVolumeType [VolumeType] <p>The target EBS volume type of the volume.</p>
-- * ModificationState [VolumeModificationState] <p>The current modification state. The modification state is null for unmodified volumes.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- * TargetIops [Integer] <p>The target IOPS rate of the volume.</p>
-- * OriginalSize [Integer] <p>The original size of the volume.</p>
-- * StartTime [DateTime] <p>The modification start time.</p>
-- * Progress [Long] <p>The modification progress, from 0 to 100 percent complete.</p>
-- * OriginalVolumeType [VolumeType] <p>The original EBS volume type of the volume.</p>
-- * OriginalIops [Integer] <p>The original IOPS rate of the volume.</p>
-- * EndTime [DateTime] <p>The modification completion or failure time.</p>
-- * StatusMessage [String] <p>A status message about the modification progress or failure.</p>
-- @return VolumeModification structure as a key-value pair table
function M.VolumeModification(args)
	assert(args, "You must provide an argument table when creating VolumeModification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TargetSize"] = args["TargetSize"],
		["TargetVolumeType"] = args["TargetVolumeType"],
		["ModificationState"] = args["ModificationState"],
		["VolumeId"] = args["VolumeId"],
		["TargetIops"] = args["TargetIops"],
		["OriginalSize"] = args["OriginalSize"],
		["StartTime"] = args["StartTime"],
		["Progress"] = args["Progress"],
		["OriginalVolumeType"] = args["OriginalVolumeType"],
		["OriginalIops"] = args["OriginalIops"],
		["EndTime"] = args["EndTime"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertVolumeModification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifySnapshotAttributeRequest = { ["DryRun"] = true, ["Attribute"] = true, ["UserIds"] = true, ["GroupNames"] = true, ["CreateVolumePermission"] = true, ["OperationType"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertModifySnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySnapshotAttributeRequest to be of type 'table'")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["UserIds"] then asserts.AssertUserIdStringList(struct["UserIds"]) end
	if struct["GroupNames"] then asserts.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["CreateVolumePermission"] then asserts.AssertCreateVolumePermissionModifications(struct["CreateVolumePermission"]) end
	if struct["OperationType"] then asserts.AssertOperationType(struct["OperationType"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySnapshotAttributeRequest[k], "ModifySnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySnapshotAttributeRequest
-- <p>Contains the parameters for ModifySnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Attribute [SnapshotAttributeName] <p>The snapshot attribute to modify. Only volume creation permissions can be modified.</p>
-- * UserIds [UserIdStringList] <p>The account ID to modify for the snapshot.</p>
-- * GroupNames [GroupNameStringList] <p>The group to modify for the snapshot.</p>
-- * CreateVolumePermission [CreateVolumePermissionModifications] <p>A JSON representation of the snapshot attribute modification.</p>
-- * OperationType [OperationType] <p>The type of operation to perform to the attribute.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required key: SnapshotId
-- @return ModifySnapshotAttributeRequest structure as a key-value pair table
function M.ModifySnapshotAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifySnapshotAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Attribute"] = args["Attribute"],
		["UserIds"] = args["UserIds"],
		["GroupNames"] = args["GroupNames"],
		["CreateVolumePermission"] = args["CreateVolumePermission"],
		["OperationType"] = args["OperationType"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertModifySnapshotAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAddressesResult = { ["Addresses"] = true, nil }

function asserts.AssertDescribeAddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesResult to be of type 'table'")
	if struct["Addresses"] then asserts.AssertAddressList(struct["Addresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAddressesResult[k], "DescribeAddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Addresses [AddressList] <p>Information about one or more Elastic IP addresses.</p>
-- @return DescribeAddressesResult structure as a key-value pair table
function M.DescribeAddressesResult(args)
	assert(args, "You must provide an argument table when creating DescribeAddressesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Addresses"] = args["Addresses"],
	}
	asserts.AssertDescribeAddressesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceCreditSpecificationsResult = { ["NextToken"] = true, ["InstanceCreditSpecifications"] = true, nil }

function asserts.AssertDescribeInstanceCreditSpecificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceCreditSpecificationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["InstanceCreditSpecifications"] then asserts.AssertInstanceCreditSpecificationList(struct["InstanceCreditSpecifications"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceCreditSpecificationsResult[k], "DescribeInstanceCreditSpecificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceCreditSpecificationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * InstanceCreditSpecifications [InstanceCreditSpecificationList] <p>Information about the credit option for CPU usage of an instance.</p>
-- @return DescribeInstanceCreditSpecificationsResult structure as a key-value pair table
function M.DescribeInstanceCreditSpecificationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceCreditSpecificationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["InstanceCreditSpecifications"] = args["InstanceCreditSpecifications"],
	}
	asserts.AssertDescribeInstanceCreditSpecificationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RunInstancesMonitoringEnabled = { ["Enabled"] = true, nil }

function asserts.AssertRunInstancesMonitoringEnabled(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesMonitoringEnabled to be of type 'table'")
	assert(struct["Enabled"], "Expected key Enabled to exist in table")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunInstancesMonitoringEnabled[k], "RunInstancesMonitoringEnabled contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesMonitoringEnabled
-- <p>Describes the monitoring of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
-- Required key: Enabled
-- @return RunInstancesMonitoringEnabled structure as a key-value pair table
function M.RunInstancesMonitoringEnabled(args)
	assert(args, "You must provide an argument table when creating RunInstancesMonitoringEnabled")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertRunInstancesMonitoringEnabled(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateVersion = { ["VersionDescription"] = true, ["LaunchTemplateId"] = true, ["LaunchTemplateName"] = true, ["VersionNumber"] = true, ["CreatedBy"] = true, ["LaunchTemplateData"] = true, ["DefaultVersion"] = true, ["CreateTime"] = true, nil }

function asserts.AssertLaunchTemplateVersion(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateVersion to be of type 'table'")
	if struct["VersionDescription"] then asserts.AssertVersionDescription(struct["VersionDescription"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["VersionNumber"] then asserts.AssertLong(struct["VersionNumber"]) end
	if struct["CreatedBy"] then asserts.AssertString(struct["CreatedBy"]) end
	if struct["LaunchTemplateData"] then asserts.AssertResponseLaunchTemplateData(struct["LaunchTemplateData"]) end
	if struct["DefaultVersion"] then asserts.AssertBoolean(struct["DefaultVersion"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateVersion[k], "LaunchTemplateVersion contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateVersion
-- <p>Describes a launch template version.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VersionDescription [VersionDescription] <p>The description for the version.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template.</p>
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template.</p>
-- * VersionNumber [Long] <p>The version number.</p>
-- * CreatedBy [String] <p>The principal that created the version.</p>
-- * LaunchTemplateData [ResponseLaunchTemplateData] <p>Information about the launch template.</p>
-- * DefaultVersion [Boolean] <p>Indicates whether the version is the default version.</p>
-- * CreateTime [DateTime] <p>The time the version was created.</p>
-- @return LaunchTemplateVersion structure as a key-value pair table
function M.LaunchTemplateVersion(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateVersion")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VersionDescription"] = args["VersionDescription"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["VersionNumber"] = args["VersionNumber"],
		["CreatedBy"] = args["CreatedBy"],
		["LaunchTemplateData"] = args["LaunchTemplateData"],
		["DefaultVersion"] = args["DefaultVersion"],
		["CreateTime"] = args["CreateTime"],
	}
	asserts.AssertLaunchTemplateVersion(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.HostProperties = { ["Cores"] = true, ["TotalVCpus"] = true, ["InstanceType"] = true, ["Sockets"] = true, nil }

function asserts.AssertHostProperties(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostProperties to be of type 'table'")
	if struct["Cores"] then asserts.AssertInteger(struct["Cores"]) end
	if struct["TotalVCpus"] then asserts.AssertInteger(struct["TotalVCpus"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["Sockets"] then asserts.AssertInteger(struct["Sockets"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostProperties[k], "HostProperties contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostProperties
-- <p>Describes properties of a Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cores [Integer] <p>The number of cores on the Dedicated Host.</p>
-- * TotalVCpus [Integer] <p>The number of vCPUs on the Dedicated Host.</p>
-- * InstanceType [String] <p>The instance type size that the Dedicated Host supports (for example, <code>m3.medium</code>).</p>
-- * Sockets [Integer] <p>The number of sockets on the Dedicated Host.</p>
-- @return HostProperties structure as a key-value pair table
function M.HostProperties(args)
	assert(args, "You must provide an argument table when creating HostProperties")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Cores"] = args["Cores"],
		["TotalVCpus"] = args["TotalVCpus"],
		["InstanceType"] = args["InstanceType"],
		["Sockets"] = args["Sockets"],
	}
	asserts.AssertHostProperties(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceStatusSummary = { ["Status"] = true, ["Details"] = true, nil }

function asserts.AssertInstanceStatusSummary(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusSummary to be of type 'table'")
	if struct["Status"] then asserts.AssertSummaryStatus(struct["Status"]) end
	if struct["Details"] then asserts.AssertInstanceStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusSummary[k], "InstanceStatusSummary contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusSummary
-- <p>Describes the status of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [SummaryStatus] <p>The status.</p>
-- * Details [InstanceStatusDetailsList] <p>The system instance health or application instance health.</p>
-- @return InstanceStatusSummary structure as a key-value pair table
function M.InstanceStatusSummary(args)
	assert(args, "You must provide an argument table when creating InstanceStatusSummary")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Details"] = args["Details"],
	}
	asserts.AssertInstanceStatusSummary(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateLaunchTemplateResult = { ["LaunchTemplate"] = true, nil }

function asserts.AssertCreateLaunchTemplateResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateLaunchTemplateResult to be of type 'table'")
	if struct["LaunchTemplate"] then asserts.AssertLaunchTemplate(struct["LaunchTemplate"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateLaunchTemplateResult[k], "CreateLaunchTemplateResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateLaunchTemplateResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplate [LaunchTemplate] <p>Information about the launch template.</p>
-- @return CreateLaunchTemplateResult structure as a key-value pair table
function M.CreateLaunchTemplateResult(args)
	assert(args, "You must provide an argument table when creating CreateLaunchTemplateResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplate"] = args["LaunchTemplate"],
	}
	asserts.AssertCreateLaunchTemplateResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcsRequest = { ["DryRun"] = true, ["Filters"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then asserts.AssertVpcIdStringList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcsRequest[k], "DescribeVpcsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>cidr</code> - The primary IPv4 CIDR block of the VPC. The CIDR block you specify must exactly match the VPC's CIDR block for information to be returned for the VPC. Must contain the slash followed by one or two digits (for example, <code>/28</code>).</p> </li> <li> <p> <code>cidr-block-association.cidr-block</code> - An IPv4 CIDR block associated with the VPC.</p> </li> <li> <p> <code>cidr-block-association.association-id</code> - The association ID for an IPv4 CIDR block associated with the VPC.</p> </li> <li> <p> <code>cidr-block-association.state</code> - The state of an IPv4 CIDR block associated with the VPC.</p> </li> <li> <p> <code>dhcp-options-id</code> - The ID of a set of DHCP options.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - The association ID for an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the VPC.</p> </li> <li> <p> <code>isDefault</code> - Indicates whether the VPC is the default VPC.</p> </li> <li> <p> <code>state</code> - The state of the VPC (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC.</p> </li> </ul>
-- * VpcIds [VpcIdStringList] <p>One or more VPC IDs.</p> <p>Default: Describes all your VPCs.</p>
-- @return DescribeVpcsRequest structure as a key-value pair table
function M.DescribeVpcsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["VpcIds"] = args["VpcIds"],
	}
	asserts.AssertDescribeVpcsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SubnetIpv6CidrBlockAssociation = { ["Ipv6CidrBlock"] = true, ["AssociationId"] = true, ["Ipv6CidrBlockState"] = true, nil }

function asserts.AssertSubnetIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then asserts.AssertSubnetCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(keys.SubnetIpv6CidrBlockAssociation[k], "SubnetIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- * AssociationId [String] <p>The association ID for the CIDR block.</p>
-- * Ipv6CidrBlockState [SubnetCidrBlockState] <p>Information about the state of the CIDR block.</p>
-- @return SubnetIpv6CidrBlockAssociation structure as a key-value pair table
function M.SubnetIpv6CidrBlockAssociation(args)
	assert(args, "You must provide an argument table when creating SubnetIpv6CidrBlockAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["AssociationId"] = args["AssociationId"],
		["Ipv6CidrBlockState"] = args["Ipv6CidrBlockState"],
	}
	asserts.AssertSubnetIpv6CidrBlockAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFleetInstancesResult = { ["ActiveInstances"] = true, ["NextToken"] = true, ["FleetId"] = true, nil }

function asserts.AssertDescribeFleetInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFleetInstancesResult to be of type 'table'")
	if struct["ActiveInstances"] then asserts.AssertActiveInstanceSet(struct["ActiveInstances"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFleetInstancesResult[k], "DescribeFleetInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFleetInstancesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ActiveInstances [ActiveInstanceSet] <p>The running instances. This list is refreshed periodically and might be out of date.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- @return DescribeFleetInstancesResult structure as a key-value pair table
function M.DescribeFleetInstancesResult(args)
	assert(args, "You must provide an argument table when creating DescribeFleetInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ActiveInstances"] = args["ActiveInstances"],
		["NextToken"] = args["NextToken"],
		["FleetId"] = args["FleetId"],
	}
	asserts.AssertDescribeFleetInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateRouteTableResult = { ["RouteTable"] = true, nil }

function asserts.AssertCreateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableResult to be of type 'table'")
	if struct["RouteTable"] then asserts.AssertRouteTable(struct["RouteTable"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteTableResult[k], "CreateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTable [RouteTable] <p>Information about the route table.</p>
-- @return CreateRouteTableResult structure as a key-value pair table
function M.CreateRouteTableResult(args)
	assert(args, "You must provide an argument table when creating CreateRouteTableResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["RouteTable"] = args["RouteTable"],
	}
	asserts.AssertCreateRouteTableResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointResult = { ["Return"] = true, nil }

function asserts.AssertModifyVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointResult[k], "ModifyVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return ModifyVpcEndpointResult structure as a key-value pair table
function M.ModifyVpcEndpointResult(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyVpcEndpointResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeTagsResult = { ["NextToken"] = true, ["Tags"] = true, nil }

function asserts.AssertDescribeTagsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeTagsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Tags"] then asserts.AssertTagDescriptionList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeTagsResult[k], "DescribeTagsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeTagsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * Tags [TagDescriptionList] <p>The tags.</p>
-- @return DescribeTagsResult structure as a key-value pair table
function M.DescribeTagsResult(args)
	assert(args, "You must provide an argument table when creating DescribeTagsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertDescribeTagsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcPeeringConnectionResult = { ["Return"] = true, nil }

function asserts.AssertDeleteVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcPeeringConnectionResult[k], "DeleteVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DeleteVpcPeeringConnectionResult structure as a key-value pair table
function M.DeleteVpcPeeringConnectionResult(args)
	assert(args, "You must provide an argument table when creating DeleteVpcPeeringConnectionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDeleteVpcPeeringConnectionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFleetErrorItem = { ["FleetId"] = true, ["Error"] = true, nil }

function asserts.AssertDeleteFleetErrorItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFleetErrorItem to be of type 'table'")
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	if struct["Error"] then asserts.AssertDeleteFleetError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFleetErrorItem[k], "DeleteFleetErrorItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFleetErrorItem
-- <p>Describes an EC2 Fleet that was not successfully deleted.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- * Error [DeleteFleetError] <p>The error.</p>
-- @return DeleteFleetErrorItem structure as a key-value pair table
function M.DeleteFleetErrorItem(args)
	assert(args, "You must provide an argument table when creating DeleteFleetErrorItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FleetId"] = args["FleetId"],
		["Error"] = args["Error"],
	}
	asserts.AssertDeleteFleetErrorItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.BlockDeviceMapping = { ["DeviceName"] = true, ["VirtualName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BlockDeviceMapping to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertEbsBlockDevice(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.BlockDeviceMapping[k], "BlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BlockDeviceMapping
-- <p>Describes a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- * NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- * Ebs [EbsBlockDevice] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
-- @return BlockDeviceMapping structure as a key-value pair table
function M.BlockDeviceMapping(args)
	assert(args, "You must provide an argument table when creating BlockDeviceMapping")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceName"] = args["DeviceName"],
		["VirtualName"] = args["VirtualName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertBlockDeviceMapping(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFpgaImageResult = { ["Return"] = true, nil }

function asserts.AssertDeleteFpgaImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFpgaImageResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFpgaImageResult[k], "DeleteFpgaImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFpgaImageResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
-- @return DeleteFpgaImageResult structure as a key-value pair table
function M.DeleteFpgaImageResult(args)
	assert(args, "You must provide an argument table when creating DeleteFpgaImageResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDeleteFpgaImageResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportInstanceResult = { ["ConversionTask"] = true, nil }

function asserts.AssertImportInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceResult to be of type 'table'")
	if struct["ConversionTask"] then asserts.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceResult[k], "ImportInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceResult
-- <p>Contains the output for ImportInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
-- @return ImportInstanceResult structure as a key-value pair table
function M.ImportInstanceResult(args)
	assert(args, "You must provide an argument table when creating ImportInstanceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConversionTask"] = args["ConversionTask"],
	}
	asserts.AssertImportInstanceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteLaunchTemplateVersionsRequest = { ["LaunchTemplateName"] = true, ["LaunchTemplateId"] = true, ["DryRun"] = true, ["Versions"] = true, nil }

function asserts.AssertDeleteLaunchTemplateVersionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteLaunchTemplateVersionsRequest to be of type 'table'")
	assert(struct["Versions"], "Expected key Versions to exist in table")
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Versions"] then asserts.AssertVersionStringList(struct["Versions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteLaunchTemplateVersionsRequest[k], "DeleteLaunchTemplateVersionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteLaunchTemplateVersionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Versions [VersionStringList] <p>The version numbers of one or more launch template versions to delete.</p>
-- Required key: Versions
-- @return DeleteLaunchTemplateVersionsRequest structure as a key-value pair table
function M.DeleteLaunchTemplateVersionsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteLaunchTemplateVersionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
		["DryRun"] = args["DryRun"],
		["Versions"] = args["Versions"],
	}
	asserts.AssertDeleteLaunchTemplateVersionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateRouteTableResult = { ["AssociationId"] = true, nil }

function asserts.AssertAssociateRouteTableResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateRouteTableResult to be of type 'table'")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateRouteTableResult[k], "AssociateRouteTableResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateRouteTableResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The route table association ID. This ID is required for disassociating the route table.</p>
-- @return AssociateRouteTableResult structure as a key-value pair table
function M.AssociateRouteTableResult(args)
	assert(args, "You must provide an argument table when creating AssociateRouteTableResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertAssociateRouteTableResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DiskImageVolumeDescription = { ["Id"] = true, ["Size"] = true, nil }

function asserts.AssertDiskImageVolumeDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImageVolumeDescription to be of type 'table'")
	if struct["Id"] then asserts.AssertString(struct["Id"]) end
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImageVolumeDescription[k], "DiskImageVolumeDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImageVolumeDescription
-- <p>Describes a disk image volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Id [String] <p>The volume identifier.</p>
-- * Size [Long] <p>The size of the volume, in GiB.</p>
-- @return DiskImageVolumeDescription structure as a key-value pair table
function M.DiskImageVolumeDescription(args)
	assert(args, "You must provide an argument table when creating DiskImageVolumeDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Id"] = args["Id"],
		["Size"] = args["Size"],
	}
	asserts.AssertDiskImageVolumeDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResetFpgaImageAttributeRequest = { ["FpgaImageId"] = true, ["DryRun"] = true, ["Attribute"] = true, nil }

function asserts.AssertResetFpgaImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetFpgaImageAttributeRequest to be of type 'table'")
	assert(struct["FpgaImageId"], "Expected key FpgaImageId to exist in table")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Attribute"] then asserts.AssertResetFpgaImageAttributeName(struct["Attribute"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetFpgaImageAttributeRequest[k], "ResetFpgaImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetFpgaImageAttributeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageId [String] <p>The ID of the AFI.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Attribute [ResetFpgaImageAttributeName] <p>The attribute.</p>
-- Required key: FpgaImageId
-- @return ResetFpgaImageAttributeRequest structure as a key-value pair table
function M.ResetFpgaImageAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ResetFpgaImageAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageId"] = args["FpgaImageId"],
		["DryRun"] = args["DryRun"],
		["Attribute"] = args["Attribute"],
	}
	asserts.AssertResetFpgaImageAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Snapshot = { ["OwnerAlias"] = true, ["DataEncryptionKeyId"] = true, ["Description"] = true, ["VolumeSize"] = true, ["Tags"] = true, ["Encrypted"] = true, ["SnapshotId"] = true, ["VolumeId"] = true, ["StateMessage"] = true, ["State"] = true, ["KmsKeyId"] = true, ["StartTime"] = true, ["OwnerId"] = true, ["Progress"] = true, nil }

function asserts.AssertSnapshot(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Snapshot to be of type 'table'")
	if struct["OwnerAlias"] then asserts.AssertString(struct["OwnerAlias"]) end
	if struct["DataEncryptionKeyId"] then asserts.AssertString(struct["DataEncryptionKeyId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["StateMessage"] then asserts.AssertString(struct["StateMessage"]) end
	if struct["State"] then asserts.AssertSnapshotState(struct["State"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	for k,_ in pairs(struct) do
		assert(keys.Snapshot[k], "Snapshot contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Snapshot
-- <p>Describes a snapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerAlias [String] <p> Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. </p>
-- * DataEncryptionKeyId [String] <p>The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- * Description [String] <p>The description for the snapshot.</p>
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p>
-- * Tags [TagList] <p>Any tags assigned to the snapshot.</p>
-- * Encrypted [Boolean] <p>Indicates whether the snapshot is encrypted.</p>
-- * SnapshotId [String] <p>The ID of the snapshot. Each snapshot receives a unique identifier when it is created.</p>
-- * VolumeId [String] <p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any purpose.</p>
-- * StateMessage [String] <p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by the <a>DescribeSnapshots</a> API operation.</p>
-- * State [SnapshotState] <p>The snapshot state.</p>
-- * KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.</p>
-- * StartTime [DateTime] <p>The time stamp when the snapshot was initiated.</p>
-- * OwnerId [String] <p>The AWS account ID of the EBS snapshot owner.</p>
-- * Progress [String] <p>The progress of the snapshot, as a percentage.</p>
-- @return Snapshot structure as a key-value pair table
function M.Snapshot(args)
	assert(args, "You must provide an argument table when creating Snapshot")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OwnerAlias"] = args["OwnerAlias"],
		["DataEncryptionKeyId"] = args["DataEncryptionKeyId"],
		["Description"] = args["Description"],
		["VolumeSize"] = args["VolumeSize"],
		["Tags"] = args["Tags"],
		["Encrypted"] = args["Encrypted"],
		["SnapshotId"] = args["SnapshotId"],
		["VolumeId"] = args["VolumeId"],
		["StateMessage"] = args["StateMessage"],
		["State"] = args["State"],
		["KmsKeyId"] = args["KmsKeyId"],
		["StartTime"] = args["StartTime"],
		["OwnerId"] = args["OwnerId"],
		["Progress"] = args["Progress"],
	}
	asserts.AssertSnapshot(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcsResult = { ["Vpcs"] = true, nil }

function asserts.AssertDescribeVpcsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcsResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertVpcList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcsResult[k], "DescribeVpcsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpcs [VpcList] <p>Information about one or more VPCs.</p>
-- @return DescribeVpcsResult structure as a key-value pair table
function M.DescribeVpcsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Vpcs"] = args["Vpcs"],
	}
	asserts.AssertDescribeVpcsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcCidrBlockAssociation = { ["AssociationId"] = true, ["CidrBlock"] = true, ["CidrBlockState"] = true, nil }

function asserts.AssertVpcCidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcCidrBlockAssociation to be of type 'table'")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["CidrBlockState"] then asserts.AssertVpcCidrBlockState(struct["CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcCidrBlockAssociation[k], "VpcCidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcCidrBlockAssociation
-- <p>Describes an IPv4 CIDR block associated with a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The association ID for the IPv4 CIDR block.</p>
-- * CidrBlock [String] <p>The IPv4 CIDR block.</p>
-- * CidrBlockState [VpcCidrBlockState] <p>Information about the state of the CIDR block.</p>
-- @return VpcCidrBlockAssociation structure as a key-value pair table
function M.VpcCidrBlockAssociation(args)
	assert(args, "You must provide an argument table when creating VpcCidrBlockAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
		["CidrBlock"] = args["CidrBlock"],
		["CidrBlockState"] = args["CidrBlockState"],
	}
	asserts.AssertVpcCidrBlockAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteLaunchTemplateRequest = { ["LaunchTemplateName"] = true, ["LaunchTemplateId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteLaunchTemplateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteLaunchTemplateRequest to be of type 'table'")
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteLaunchTemplateRequest[k], "DeleteLaunchTemplateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteLaunchTemplateRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DeleteLaunchTemplateRequest structure as a key-value pair table
function M.DeleteLaunchTemplateRequest(args)
	assert(args, "You must provide an argument table when creating DeleteLaunchTemplateRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteLaunchTemplateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelSpotFleetRequestsErrorItem = { ["SpotFleetRequestId"] = true, ["Error"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsErrorItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsErrorItem to be of type 'table'")
	assert(struct["Error"], "Expected key Error to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["Error"] then asserts.AssertCancelSpotFleetRequestsError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsErrorItem[k], "CancelSpotFleetRequestsErrorItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsErrorItem
-- <p>Describes a Spot Fleet request that was not successfully canceled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- * Error [CancelSpotFleetRequestsError] <p>The error.</p>
-- Required key: Error
-- Required key: SpotFleetRequestId
-- @return CancelSpotFleetRequestsErrorItem structure as a key-value pair table
function M.CancelSpotFleetRequestsErrorItem(args)
	assert(args, "You must provide an argument table when creating CancelSpotFleetRequestsErrorItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["Error"] = args["Error"],
	}
	asserts.AssertCancelSpotFleetRequestsErrorItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteRouteRequest = { ["DestinationCidrBlock"] = true, ["DryRun"] = true, ["DestinationIpv6CidrBlock"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertDeleteRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteRouteRequest[k], "DeleteRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- Required key: RouteTableId
-- @return DeleteRouteRequest structure as a key-value pair table
function M.DeleteRouteRequest(args)
	assert(args, "You must provide an argument table when creating DeleteRouteRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["DryRun"] = args["DryRun"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertDeleteRouteRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceRouteRequest = { ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["RouteTableId"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, nil }

function asserts.AssertReplaceRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteRequest[k], "ReplaceRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.</p>
-- * EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- * NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- * GatewayId [String] <p>The ID of an internet gateway or virtual private gateway.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.</p>
-- Required key: RouteTableId
-- @return ReplaceRouteRequest structure as a key-value pair table
function M.ReplaceRouteRequest(args)
	assert(args, "You must provide an argument table when creating ReplaceRouteRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DryRun"] = args["DryRun"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["RouteTableId"] = args["RouteTableId"],
		["NatGatewayId"] = args["NatGatewayId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GatewayId"] = args["GatewayId"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
	}
	asserts.AssertReplaceRouteRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SecurityGroupReference = { ["ReferencingVpcId"] = true, ["GroupId"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertSecurityGroupReference(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroupReference to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	assert(struct["ReferencingVpcId"], "Expected key ReferencingVpcId to exist in table")
	if struct["ReferencingVpcId"] then asserts.AssertString(struct["ReferencingVpcId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityGroupReference[k], "SecurityGroupReference contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroupReference
-- <p>Describes a VPC with a security group that references your security group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReferencingVpcId [String] <p>The ID of the VPC with the referencing security group.</p>
-- * GroupId [String] <p>The ID of your security group.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required key: GroupId
-- Required key: ReferencingVpcId
-- @return SecurityGroupReference structure as a key-value pair table
function M.SecurityGroupReference(args)
	assert(args, "You must provide an argument table when creating SecurityGroupReference")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReferencingVpcId"] = args["ReferencingVpcId"],
		["GroupId"] = args["GroupId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertSecurityGroupReference(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AcceptVpcEndpointConnectionsRequest = { ["VpcEndpointIds"] = true, ["ServiceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertAcceptVpcEndpointConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcEndpointConnectionsRequest to be of type 'table'")
	assert(struct["ServiceId"], "Expected key ServiceId to exist in table")
	assert(struct["VpcEndpointIds"], "Expected key VpcEndpointIds to exist in table")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcEndpointConnectionsRequest[k], "AcceptVpcEndpointConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcEndpointConnectionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointIds [ValueStringList] <p>The IDs of one or more interface VPC endpoints.</p>
-- * ServiceId [String] <p>The ID of the endpoint service.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: ServiceId
-- Required key: VpcEndpointIds
-- @return AcceptVpcEndpointConnectionsRequest structure as a key-value pair table
function M.AcceptVpcEndpointConnectionsRequest(args)
	assert(args, "You must provide an argument table when creating AcceptVpcEndpointConnectionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcEndpointIds"] = args["VpcEndpointIds"],
		["ServiceId"] = args["ServiceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertAcceptVpcEndpointConnectionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeConversionTasksResult = { ["ConversionTasks"] = true, nil }

function asserts.AssertDescribeConversionTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksResult to be of type 'table'")
	if struct["ConversionTasks"] then asserts.AssertDescribeConversionTaskList(struct["ConversionTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeConversionTasksResult[k], "DescribeConversionTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksResult
-- <p>Contains the output for DescribeConversionTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTasks [DescribeConversionTaskList] <p>Information about the conversion tasks.</p>
-- @return DescribeConversionTasksResult structure as a key-value pair table
function M.DescribeConversionTasksResult(args)
	assert(args, "You must provide an argument table when creating DescribeConversionTasksResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConversionTasks"] = args["ConversionTasks"],
	}
	asserts.AssertDescribeConversionTasksResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSnapshotRequest = { ["TagSpecifications"] = true, ["DryRun"] = true, ["Description"] = true, ["VolumeId"] = true, nil }

function asserts.AssertCreateSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSnapshotRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSnapshotRequest[k], "CreateSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSnapshotRequest
-- <p>Contains the parameters for CreateSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TagSpecifications [TagSpecificationList] <p>The tags to apply to the snapshot during creation.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the snapshot.</p>
-- * VolumeId [String] <p>The ID of the EBS volume.</p>
-- Required key: VolumeId
-- @return CreateSnapshotRequest structure as a key-value pair table
function M.CreateSnapshotRequest(args)
	assert(args, "You must provide an argument table when creating CreateSnapshotRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TagSpecifications"] = args["TagSpecifications"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertCreateSnapshotRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDefaultVpcResult = { ["Vpc"] = true, nil }

function asserts.AssertCreateDefaultVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDefaultVpcResult to be of type 'table'")
	if struct["Vpc"] then asserts.AssertVpc(struct["Vpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDefaultVpcResult[k], "CreateDefaultVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDefaultVpcResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpc [Vpc] <p>Information about the VPC.</p>
-- @return CreateDefaultVpcResult structure as a key-value pair table
function M.CreateDefaultVpcResult(args)
	assert(args, "You must provide an argument table when creating CreateDefaultVpcResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Vpc"] = args["Vpc"],
	}
	asserts.AssertCreateDefaultVpcResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateSubnetCidrBlockRequest = { ["SubnetId"] = true, ["Ipv6CidrBlock"] = true, nil }

function asserts.AssertAssociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["Ipv6CidrBlock"], "Expected key Ipv6CidrBlock to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateSubnetCidrBlockRequest[k], "AssociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of your subnet.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block for your subnet. The subnet must have a /64 prefix length.</p>
-- Required key: Ipv6CidrBlock
-- Required key: SubnetId
-- @return AssociateSubnetCidrBlockRequest structure as a key-value pair table
function M.AssociateSubnetCidrBlockRequest(args)
	assert(args, "You must provide an argument table when creating AssociateSubnetCidrBlockRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
	}
	asserts.AssertAssociateSubnetCidrBlockRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateInstanceMarketOptions = { ["SpotOptions"] = true, ["MarketType"] = true, nil }

function asserts.AssertLaunchTemplateInstanceMarketOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateInstanceMarketOptions to be of type 'table'")
	if struct["SpotOptions"] then asserts.AssertLaunchTemplateSpotMarketOptions(struct["SpotOptions"]) end
	if struct["MarketType"] then asserts.AssertMarketType(struct["MarketType"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateInstanceMarketOptions[k], "LaunchTemplateInstanceMarketOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateInstanceMarketOptions
-- <p>The market (purchasing) option for the instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotOptions [LaunchTemplateSpotMarketOptions] <p>The options for Spot Instances.</p>
-- * MarketType [MarketType] <p>The market type.</p>
-- @return LaunchTemplateInstanceMarketOptions structure as a key-value pair table
function M.LaunchTemplateInstanceMarketOptions(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateInstanceMarketOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotOptions"] = args["SpotOptions"],
		["MarketType"] = args["MarketType"],
	}
	asserts.AssertLaunchTemplateInstanceMarketOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImageAttribute = { ["ProductCodes"] = true, ["Description"] = true, ["LaunchPermissions"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["RamdiskId"] = true, nil }

function asserts.AssertImageAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageAttribute to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["LaunchPermissions"] then asserts.AssertLaunchPermissionList(struct["LaunchPermissions"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertAttributeValue(struct["RamdiskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImageAttribute[k], "ImageAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageAttribute
-- <p>Describes an image attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeList] <p>One or more product codes.</p>
-- * Description [AttributeValue] <p>A description for the AMI.</p>
-- * LaunchPermissions [LaunchPermissionList] <p>One or more launch permissions.</p>
-- * SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- * KernelId [AttributeValue] <p>The kernel ID.</p>
-- * RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
-- @return ImageAttribute structure as a key-value pair table
function M.ImageAttribute(args)
	assert(args, "You must provide an argument table when creating ImageAttribute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ProductCodes"] = args["ProductCodes"],
		["Description"] = args["Description"],
		["LaunchPermissions"] = args["LaunchPermissions"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["ImageId"] = args["ImageId"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
	}
	asserts.AssertImageAttribute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteEgressOnlyInternetGatewayRequest = { ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteEgressOnlyInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayRequest to be of type 'table'")
	assert(struct["EgressOnlyInternetGatewayId"], "Expected key EgressOnlyInternetGatewayId to exist in table")
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteEgressOnlyInternetGatewayRequest[k], "DeleteEgressOnlyInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: EgressOnlyInternetGatewayId
-- @return DeleteEgressOnlyInternetGatewayRequest structure as a key-value pair table
function M.DeleteEgressOnlyInternetGatewayRequest(args)
	assert(args, "You must provide an argument table when creating DeleteEgressOnlyInternetGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteEgressOnlyInternetGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AcceptVpcEndpointConnectionsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertAcceptVpcEndpointConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcEndpointConnectionsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcEndpointConnectionsResult[k], "AcceptVpcEndpointConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcEndpointConnectionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the interface endpoints that were not accepted, if applicable.</p>
-- @return AcceptVpcEndpointConnectionsResult structure as a key-value pair table
function M.AcceptVpcEndpointConnectionsResult(args)
	assert(args, "You must provide an argument table when creating AcceptVpcEndpointConnectionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertAcceptVpcEndpointConnectionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnsuccessfulInstanceCreditSpecificationItemError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertUnsuccessfulInstanceCreditSpecificationItemError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulInstanceCreditSpecificationItemError to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertUnsuccessfulInstanceCreditSpecificationErrorCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulInstanceCreditSpecificationItemError[k], "UnsuccessfulInstanceCreditSpecificationItemError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulInstanceCreditSpecificationItemError
-- <p>Information about the error for the T2 or T3 instance whose credit option for CPU usage was not modified.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The applicable error message.</p>
-- * Code [UnsuccessfulInstanceCreditSpecificationErrorCode] <p>The error code.</p>
-- @return UnsuccessfulInstanceCreditSpecificationItemError structure as a key-value pair table
function M.UnsuccessfulInstanceCreditSpecificationItemError(args)
	assert(args, "You must provide an argument table when creating UnsuccessfulInstanceCreditSpecificationItemError")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertUnsuccessfulInstanceCreditSpecificationItemError(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeHostsRequest = { ["Filter"] = true, ["HostIds"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostsRequest[k], "DescribeHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>auto-placement</code> - Whether auto-placement is enabled or disabled (<code>on</code> | <code>off</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the host.</p> </li> <li> <p> <code>client-token</code> - The idempotency token that you provided when you allocated the host.</p> </li> <li> <p> <code>host-reservation-id</code> - The ID of the reservation assigned to this host.</p> </li> <li> <p> <code>instance-type</code> - The instance type size that the Dedicated Host is configured to support.</p> </li> <li> <p> <code>state</code> - The allocation state of the Dedicated Host (<code>available</code> | <code>under-assessment</code> | <code>permanent-failure</code> | <code>released</code> | <code>released-permanent-failure</code>).</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> </ul>
-- * HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts. The IDs are used for targeted instance launches.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error. You cannot specify this parameter and the host IDs parameter in the same request.</p>
-- @return DescribeHostsRequest structure as a key-value pair table
function M.DescribeHostsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeHostsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Filter"] = args["Filter"],
		["HostIds"] = args["HostIds"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeHostsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeImportImageTasksResult = { ["NextToken"] = true, ["ImportImageTasks"] = true, nil }

function asserts.AssertDescribeImportImageTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ImportImageTasks"] then asserts.AssertImportImageTaskList(struct["ImportImageTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportImageTasksResult[k], "DescribeImportImageTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksResult
-- <p>Contains the output for DescribeImportImageTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ImportImageTasks [ImportImageTaskList] <p>A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.</p>
-- @return DescribeImportImageTasksResult structure as a key-value pair table
function M.DescribeImportImageTasksResult(args)
	assert(args, "You must provide an argument table when creating DescribeImportImageTasksResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ImportImageTasks"] = args["ImportImageTasks"],
	}
	asserts.AssertDescribeImportImageTasksResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpnGateway = { ["AvailabilityZone"] = true, ["VpcAttachments"] = true, ["Tags"] = true, ["AmazonSideAsn"] = true, ["State"] = true, ["VpnGatewayId"] = true, ["Type"] = true, nil }

function asserts.AssertVpnGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnGateway to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["VpcAttachments"] then asserts.AssertVpcAttachmentList(struct["VpcAttachments"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["AmazonSideAsn"] then asserts.AssertLong(struct["AmazonSideAsn"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnGateway[k], "VpnGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnGateway
-- <p>Describes a virtual private gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.</p>
-- * VpcAttachments [VpcAttachmentList] <p>Any VPCs attached to the virtual private gateway.</p>
-- * Tags [TagList] <p>Any tags assigned to the virtual private gateway.</p>
-- * AmazonSideAsn [Long] <p>The private Autonomous System Number (ASN) for the Amazon side of a BGP session.</p>
-- * State [VpnState] <p>The current state of the virtual private gateway.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * Type [GatewayType] <p>The type of VPN connection the virtual private gateway supports.</p>
-- @return VpnGateway structure as a key-value pair table
function M.VpnGateway(args)
	assert(args, "You must provide an argument table when creating VpnGateway")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["VpcAttachments"] = args["VpcAttachments"],
		["Tags"] = args["Tags"],
		["AmazonSideAsn"] = args["AmazonSideAsn"],
		["State"] = args["State"],
		["VpnGatewayId"] = args["VpnGatewayId"],
		["Type"] = args["Type"],
	}
	asserts.AssertVpnGateway(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreatePlacementGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, ["Strategy"] = true, nil }

function asserts.AssertCreatePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreatePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	assert(struct["Strategy"], "Expected key Strategy to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Strategy"] then asserts.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreatePlacementGroupRequest[k], "CreatePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreatePlacementGroupRequest
-- <p>Contains the parameters for CreatePlacementGroup.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>A name for the placement group. Must be unique within the scope of your account for the region.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Strategy [PlacementStrategy] <p>The placement strategy.</p>
-- Required key: GroupName
-- Required key: Strategy
-- @return CreatePlacementGroupRequest structure as a key-value pair table
function M.CreatePlacementGroupRequest(args)
	assert(args, "You must provide an argument table when creating CreatePlacementGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
		["Strategy"] = args["Strategy"],
	}
	asserts.AssertCreatePlacementGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointConnectionsResult = { ["VpcEndpointConnections"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVpcEndpointConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointConnectionsResult to be of type 'table'")
	if struct["VpcEndpointConnections"] then asserts.AssertVpcEndpointConnectionSet(struct["VpcEndpointConnections"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointConnectionsResult[k], "DescribeVpcEndpointConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointConnectionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointConnections [VpcEndpointConnectionSet] <p>Information about one or more VPC endpoint connections.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeVpcEndpointConnectionsResult structure as a key-value pair table
function M.DescribeVpcEndpointConnectionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointConnectionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcEndpointConnections"] = args["VpcEndpointConnections"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeVpcEndpointConnectionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateIamInstanceProfileResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertDisassociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateIamInstanceProfileResult[k], "DisassociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
-- @return DisassociateIamInstanceProfileResult structure as a key-value pair table
function M.DisassociateIamInstanceProfileResult(args)
	assert(args, "You must provide an argument table when creating DisassociateIamInstanceProfileResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IamInstanceProfileAssociation"] = args["IamInstanceProfileAssociation"],
	}
	asserts.AssertDisassociateIamInstanceProfileResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssignIpv6AddressesResult = { ["AssignedIpv6Addresses"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertAssignIpv6AddressesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesResult to be of type 'table'")
	if struct["AssignedIpv6Addresses"] then asserts.AssertIpv6AddressList(struct["AssignedIpv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignIpv6AddressesResult[k], "AssignIpv6AddressesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssignedIpv6Addresses [Ipv6AddressList] <p>The IPv6 addresses assigned to the network interface.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- @return AssignIpv6AddressesResult structure as a key-value pair table
function M.AssignIpv6AddressesResult(args)
	assert(args, "You must provide an argument table when creating AssignIpv6AddressesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssignedIpv6Addresses"] = args["AssignedIpv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
	}
	asserts.AssertAssignIpv6AddressesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StaleSecurityGroup = { ["VpcId"] = true, ["StaleIpPermissionsEgress"] = true, ["GroupName"] = true, ["StaleIpPermissions"] = true, ["GroupId"] = true, ["Description"] = true, nil }

function asserts.AssertStaleSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleSecurityGroup to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["StaleIpPermissionsEgress"] then asserts.AssertStaleIpPermissionSet(struct["StaleIpPermissionsEgress"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["StaleIpPermissions"] then asserts.AssertStaleIpPermissionSet(struct["StaleIpPermissions"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.StaleSecurityGroup[k], "StaleSecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleSecurityGroup
-- <p>Describes a stale security group (a security group that contains stale rules).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC for the security group.</p>
-- * StaleIpPermissionsEgress [StaleIpPermissionSet] <p>Information about the stale outbound rules in the security group.</p>
-- * GroupName [String] <p>The name of the security group.</p>
-- * StaleIpPermissions [StaleIpPermissionSet] <p>Information about the stale inbound rules in the security group.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- * Description [String] <p>The description of the security group.</p>
-- Required key: GroupId
-- @return StaleSecurityGroup structure as a key-value pair table
function M.StaleSecurityGroup(args)
	assert(args, "You must provide an argument table when creating StaleSecurityGroup")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["StaleIpPermissionsEgress"] = args["StaleIpPermissionsEgress"],
		["GroupName"] = args["GroupName"],
		["StaleIpPermissions"] = args["StaleIpPermissions"],
		["GroupId"] = args["GroupId"],
		["Description"] = args["Description"],
	}
	asserts.AssertStaleSecurityGroup(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcPeeringConnectionVpcInfo = { ["PeeringOptions"] = true, ["VpcId"] = true, ["Region"] = true, ["Ipv6CidrBlockSet"] = true, ["OwnerId"] = true, ["CidrBlockSet"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertVpcPeeringConnectionVpcInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionVpcInfo to be of type 'table'")
	if struct["PeeringOptions"] then asserts.AssertVpcPeeringConnectionOptionsDescription(struct["PeeringOptions"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Region"] then asserts.AssertString(struct["Region"]) end
	if struct["Ipv6CidrBlockSet"] then asserts.AssertIpv6CidrBlockSet(struct["Ipv6CidrBlockSet"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["CidrBlockSet"] then asserts.AssertCidrBlockSet(struct["CidrBlockSet"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionVpcInfo[k], "VpcPeeringConnectionVpcInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionVpcInfo
-- <p>Describes a VPC in a VPC peering connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PeeringOptions [VpcPeeringConnectionOptionsDescription] <p>Information about the VPC peering connection options for the accepter or requester VPC.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Region [String] <p>The region in which the VPC is located.</p>
-- * Ipv6CidrBlockSet [Ipv6CidrBlockSet] <p>The IPv6 CIDR block for the VPC.</p>
-- * OwnerId [String] <p>The AWS account ID of the VPC owner.</p>
-- * CidrBlockSet [CidrBlockSet] <p>Information about the IPv4 CIDR blocks for the VPC.</p>
-- * CidrBlock [String] <p>The IPv4 CIDR block for the VPC.</p>
-- @return VpcPeeringConnectionVpcInfo structure as a key-value pair table
function M.VpcPeeringConnectionVpcInfo(args)
	assert(args, "You must provide an argument table when creating VpcPeeringConnectionVpcInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PeeringOptions"] = args["PeeringOptions"],
		["VpcId"] = args["VpcId"],
		["Region"] = args["Region"],
		["Ipv6CidrBlockSet"] = args["Ipv6CidrBlockSet"],
		["OwnerId"] = args["OwnerId"],
		["CidrBlockSet"] = args["CidrBlockSet"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertVpcPeeringConnectionVpcInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstancesModification = { ["Status"] = true, ["ModificationResults"] = true, ["EffectiveDate"] = true, ["CreateDate"] = true, ["StatusMessage"] = true, ["ClientToken"] = true, ["ReservedInstancesModificationId"] = true, ["ReservedInstancesIds"] = true, ["UpdateDate"] = true, nil }

function asserts.AssertReservedInstancesModification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModification to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["ModificationResults"] then asserts.AssertReservedInstancesModificationResultList(struct["ModificationResults"]) end
	if struct["EffectiveDate"] then asserts.AssertDateTime(struct["EffectiveDate"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesModificationId"] then asserts.AssertString(struct["ReservedInstancesModificationId"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedIntancesIds(struct["ReservedInstancesIds"]) end
	if struct["UpdateDate"] then asserts.AssertDateTime(struct["UpdateDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesModification[k], "ReservedInstancesModification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModification
-- <p>Describes a Reserved Instance modification.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>The status of the Reserved Instances modification request.</p>
-- * ModificationResults [ReservedInstancesModificationResultList] <p>Contains target configurations along with their corresponding new Reserved Instance IDs.</p>
-- * EffectiveDate [DateTime] <p>The time for the modification to become effective.</p>
-- * CreateDate [DateTime] <p>The time when the modification request was created.</p>
-- * StatusMessage [String] <p>The reason for the status.</p>
-- * ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * ReservedInstancesModificationId [String] <p>A unique ID for the Reserved Instance modification.</p>
-- * ReservedInstancesIds [ReservedIntancesIds] <p>The IDs of one or more Reserved Instances.</p>
-- * UpdateDate [DateTime] <p>The time when the modification request was last updated.</p>
-- @return ReservedInstancesModification structure as a key-value pair table
function M.ReservedInstancesModification(args)
	assert(args, "You must provide an argument table when creating ReservedInstancesModification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["ModificationResults"] = args["ModificationResults"],
		["EffectiveDate"] = args["EffectiveDate"],
		["CreateDate"] = args["CreateDate"],
		["StatusMessage"] = args["StatusMessage"],
		["ClientToken"] = args["ClientToken"],
		["ReservedInstancesModificationId"] = args["ReservedInstancesModificationId"],
		["ReservedInstancesIds"] = args["ReservedInstancesIds"],
		["UpdateDate"] = args["UpdateDate"],
	}
	asserts.AssertReservedInstancesModification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IamInstanceProfileSpecification = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertIamInstanceProfileSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileSpecification to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfileSpecification[k], "IamInstanceProfileSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileSpecification
-- <p>Describes an IAM instance profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [String] <p>The name of the instance profile.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
-- @return IamInstanceProfileSpecification structure as a key-value pair table
function M.IamInstanceProfileSpecification(args)
	assert(args, "You must provide an argument table when creating IamInstanceProfileSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertIamInstanceProfileSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumeAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDescribeVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Attribute"] then asserts.AssertVolumeAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeAttributeRequest[k], "DescribeVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeRequest
-- <p>Contains the parameters for DescribeVolumeAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [VolumeAttributeName] <p>The attribute of the volume. This parameter is required.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: Attribute
-- Required key: VolumeId
-- @return DescribeVolumeAttributeRequest structure as a key-value pair table
function M.DescribeVolumeAttributeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVolumeAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDescribeVolumeAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSecurityGroupsRequest = { ["DryRun"] = true, ["MaxResults"] = true, ["GroupNames"] = true, ["GroupIds"] = true, ["Filters"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["GroupNames"] then asserts.AssertGroupNameStringList(struct["GroupNames"]) end
	if struct["GroupIds"] then asserts.AssertGroupIdStringList(struct["GroupIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupsRequest[k], "DescribeSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000. If this parameter is not specified, then all results are returned.</p>
-- * GroupNames [GroupNameStringList] <p>[EC2-Classic and default VPC only] One or more security group names. You can specify either the security group name or the security group ID. For security groups in a nondefault VPC, use the <code>group-name</code> filter to describe security groups by name.</p> <p>Default: Describes all your security groups.</p>
-- * GroupIds [GroupIdStringList] <p>One or more security group IDs. Required for security groups in a nondefault VPC.</p> <p>Default: Describes all your security groups.</p>
-- * Filters [FilterList] <p>One or more filters. If using multiple filters for rules, the results include security groups for which any combination of rules - not necessarily a single rule - match all filters.</p> <ul> <li> <p> <code>description</code> - The description of the security group.</p> </li> <li> <p> <code>egress.ip-permission.cidr</code> - An IPv4 CIDR block for an outbound security group rule.</p> </li> <li> <p> <code>egress.ip-permission.from-port</code> - For an outbound rule, the start of port range for the TCP and UDP protocols, or an ICMP type number.</p> </li> <li> <p> <code>egress.ip-permission.group-id</code> - The ID of a security group that has been referenced in an outbound security group rule.</p> </li> <li> <p> <code>egress.ip-permission.group-name</code> - The name of a security group that has been referenced in an outbound security group rule.</p> </li> <li> <p> <code>egress.ip-permission.ipv6-cidr</code> - An IPv6 CIDR block for an outbound security group rule.</p> </li> <li> <p> <code>egress.ip-permission.prefix-list-id</code> - The ID (prefix) of the AWS service to which a security group rule allows outbound access.</p> </li> <li> <p> <code>egress.ip-permission.protocol</code> - The IP protocol for an outbound security group rule (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>egress.ip-permission.to-port</code> - For an outbound rule, the end of port range for the TCP and UDP protocols, or an ICMP code.</p> </li> <li> <p> <code>egress.ip-permission.user-id</code> - The ID of an AWS account that has been referenced in an outbound security group rule.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group. </p> </li> <li> <p> <code>group-name</code> - The name of the security group.</p> </li> <li> <p> <code>ip-permission.cidr</code> - An IPv4 CIDR block for an inbound security group rule.</p> </li> <li> <p> <code>ip-permission.from-port</code> - For an inbound rule, the start of port range for the TCP and UDP protocols, or an ICMP type number.</p> </li> <li> <p> <code>ip-permission.group-id</code> - The ID of a security group that has been referenced in an inbound security group rule.</p> </li> <li> <p> <code>ip-permission.group-name</code> - The name of a security group that has been referenced in an inbound security group rule.</p> </li> <li> <p> <code>ip-permission.ipv6-cidr</code> - An IPv6 CIDR block for an inbound security group rule.</p> </li> <li> <p> <code>ip-permission.prefix-list-id</code> - The ID (prefix) of the AWS service from which a security group rule allows inbound access.</p> </li> <li> <p> <code>ip-permission.protocol</code> - The IP protocol for an inbound security group rule (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>ip-permission.to-port</code> - For an inbound rule, the end of port range for the TCP and UDP protocols, or an ICMP code.</p> </li> <li> <p> <code>ip-permission.user-id</code> - The ID of an AWS account that has been referenced in an inbound security group rule.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the owner of the security group.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC specified when the security group was created.</p> </li> </ul>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- @return DescribeSecurityGroupsRequest structure as a key-value pair table
function M.DescribeSecurityGroupsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSecurityGroupsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["GroupNames"] = args["GroupNames"],
		["GroupIds"] = args["GroupIds"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSecurityGroupsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetLaunchTemplateDataResult = { ["LaunchTemplateData"] = true, nil }

function asserts.AssertGetLaunchTemplateDataResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetLaunchTemplateDataResult to be of type 'table'")
	if struct["LaunchTemplateData"] then asserts.AssertResponseLaunchTemplateData(struct["LaunchTemplateData"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetLaunchTemplateDataResult[k], "GetLaunchTemplateDataResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetLaunchTemplateDataResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateData [ResponseLaunchTemplateData] <p>The instance data.</p>
-- @return GetLaunchTemplateDataResult structure as a key-value pair table
function M.GetLaunchTemplateDataResult(args)
	assert(args, "You must provide an argument table when creating GetLaunchTemplateDataResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateData"] = args["LaunchTemplateData"],
	}
	asserts.AssertGetLaunchTemplateDataResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkAclEntry = { ["IcmpTypeCode"] = true, ["RuleNumber"] = true, ["Protocol"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertNetworkAclEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclEntry to be of type 'table'")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAclEntry[k], "NetworkAclEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclEntry
-- <p>Describes an entry in a network ACL.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP type and code.</p>
-- * RuleNumber [Integer] <p>The rule number for the entry. ACL entries are processed in ascending order by rule number.</p>
-- * Protocol [String] <p>The protocol number. A value of "-1" means all protocols.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation.</p>
-- * Egress [Boolean] <p>Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).</p>
-- * RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- * PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to.</p>
-- * CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation.</p>
-- @return NetworkAclEntry structure as a key-value pair table
function M.NetworkAclEntry(args)
	assert(args, "You must provide an argument table when creating NetworkAclEntry")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IcmpTypeCode"] = args["IcmpTypeCode"],
		["RuleNumber"] = args["RuleNumber"],
		["Protocol"] = args["Protocol"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["Egress"] = args["Egress"],
		["RuleAction"] = args["RuleAction"],
		["PortRange"] = args["PortRange"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertNetworkAclEntry(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TagDescription = { ["ResourceType"] = true, ["ResourceId"] = true, ["Value"] = true, ["Key"] = true, nil }

function asserts.AssertTagDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagDescription to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["ResourceId"] then asserts.AssertString(struct["ResourceId"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.TagDescription[k], "TagDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagDescription
-- <p>Describes a tag.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceType] <p>The resource type.</p>
-- * ResourceId [String] <p>The ID of the resource.</p>
-- * Value [String] <p>The tag value.</p>
-- * Key [String] <p>The tag key.</p>
-- @return TagDescription structure as a key-value pair table
function M.TagDescription(args)
	assert(args, "You must provide an argument table when creating TagDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["ResourceId"] = args["ResourceId"],
		["Value"] = args["Value"],
		["Key"] = args["Key"],
	}
	asserts.AssertTagDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UserBucketDetails = { ["S3Bucket"] = true, ["S3Key"] = true, nil }

function asserts.AssertUserBucketDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucketDetails to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserBucketDetails[k], "UserBucketDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucketDetails
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The S3 bucket from which the disk image was created.</p>
-- * S3Key [String] <p>The file name of the disk image.</p>
-- @return UserBucketDetails structure as a key-value pair table
function M.UserBucketDetails(args)
	assert(args, "You must provide an argument table when creating UserBucketDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3Bucket"] = args["S3Bucket"],
		["S3Key"] = args["S3Key"],
	}
	asserts.AssertUserBucketDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelImportTaskResult = { ["State"] = true, ["PreviousState"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertCancelImportTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelImportTaskResult to be of type 'table'")
	if struct["State"] then asserts.AssertString(struct["State"]) end
	if struct["PreviousState"] then asserts.AssertString(struct["PreviousState"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelImportTaskResult[k], "CancelImportTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelImportTaskResult
-- <p>Contains the output for CancelImportTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [String] <p>The current state of the task being canceled.</p>
-- * PreviousState [String] <p>The current state of the task being canceled.</p>
-- * ImportTaskId [String] <p>The ID of the task being canceled.</p>
-- @return CancelImportTaskResult structure as a key-value pair table
function M.CancelImportTaskResult(args)
	assert(args, "You must provide an argument table when creating CancelImportTaskResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["PreviousState"] = args["PreviousState"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertCancelImportTaskResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterImageResult = { ["ImageId"] = true, nil }

function asserts.AssertRegisterImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterImageResult[k], "RegisterImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageResult
-- <p>Contains the output of RegisterImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImageId [String] <p>The ID of the newly registered AMI.</p>
-- @return RegisterImageResult structure as a key-value pair table
function M.RegisterImageResult(args)
	assert(args, "You must provide an argument table when creating RegisterImageResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertRegisterImageResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FleetLaunchTemplateConfigRequest = { ["LaunchTemplateSpecification"] = true, ["Overrides"] = true, nil }

function asserts.AssertFleetLaunchTemplateConfigRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FleetLaunchTemplateConfigRequest to be of type 'table'")
	if struct["LaunchTemplateSpecification"] then asserts.AssertFleetLaunchTemplateSpecificationRequest(struct["LaunchTemplateSpecification"]) end
	if struct["Overrides"] then asserts.AssertFleetLaunchTemplateOverridesListRequest(struct["Overrides"]) end
	for k,_ in pairs(struct) do
		assert(keys.FleetLaunchTemplateConfigRequest[k], "FleetLaunchTemplateConfigRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FleetLaunchTemplateConfigRequest
-- <p>Describes a launch template and overrides.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateSpecification [FleetLaunchTemplateSpecificationRequest] <p>The launch template to use. You must specify either the launch template ID or launch template name in the request. </p>
-- * Overrides [FleetLaunchTemplateOverridesListRequest] <p>Any parameters that you specify override the same parameters in the launch template.</p>
-- @return FleetLaunchTemplateConfigRequest structure as a key-value pair table
function M.FleetLaunchTemplateConfigRequest(args)
	assert(args, "You must provide an argument table when creating FleetLaunchTemplateConfigRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateSpecification"] = args["LaunchTemplateSpecification"],
		["Overrides"] = args["Overrides"],
	}
	asserts.AssertFleetLaunchTemplateConfigRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNetworkAclResult = { ["NetworkAcl"] = true, nil }

function asserts.AssertCreateNetworkAclResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclResult to be of type 'table'")
	if struct["NetworkAcl"] then asserts.AssertNetworkAcl(struct["NetworkAcl"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclResult[k], "CreateNetworkAclResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAcl [NetworkAcl] <p>Information about the network ACL.</p>
-- @return CreateNetworkAclResult structure as a key-value pair table
function M.CreateNetworkAclResult(args)
	assert(args, "You must provide an argument table when creating CreateNetworkAclResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkAcl"] = args["NetworkAcl"],
	}
	asserts.AssertCreateNetworkAclResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumeStatusResult = { ["NextToken"] = true, ["VolumeStatuses"] = true, nil }

function asserts.AssertDescribeVolumeStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["VolumeStatuses"] then asserts.AssertVolumeStatusList(struct["VolumeStatuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeStatusResult[k], "DescribeVolumeStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusResult
-- <p>Contains the output of DescribeVolumeStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * VolumeStatuses [VolumeStatusList] <p>A list of volumes.</p>
-- @return DescribeVolumeStatusResult structure as a key-value pair table
function M.DescribeVolumeStatusResult(args)
	assert(args, "You must provide an argument table when creating DescribeVolumeStatusResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["VolumeStatuses"] = args["VolumeStatuses"],
	}
	asserts.AssertDescribeVolumeStatusResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVolumeResult = { ["VolumeModification"] = true, nil }

function asserts.AssertModifyVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeResult to be of type 'table'")
	if struct["VolumeModification"] then asserts.AssertVolumeModification(struct["VolumeModification"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeResult[k], "ModifyVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeModification [VolumeModification] <p>Information about the volume modification.</p>
-- @return ModifyVolumeResult structure as a key-value pair table
function M.ModifyVolumeResult(args)
	assert(args, "You must provide an argument table when creating ModifyVolumeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumeModification"] = args["VolumeModification"],
	}
	asserts.AssertModifyVolumeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateIamInstanceProfileSpecification = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertLaunchTemplateIamInstanceProfileSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateIamInstanceProfileSpecification to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateIamInstanceProfileSpecification[k], "LaunchTemplateIamInstanceProfileSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateIamInstanceProfileSpecification
-- <p>Describes an IAM instance profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [String] <p>The name of the instance profile.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
-- @return LaunchTemplateIamInstanceProfileSpecification structure as a key-value pair table
function M.LaunchTemplateIamInstanceProfileSpecification(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateIamInstanceProfileSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertLaunchTemplateIamInstanceProfileSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeExportTasksRequest = { ["ExportTaskIds"] = true, nil }

function asserts.AssertDescribeExportTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksRequest to be of type 'table'")
	if struct["ExportTaskIds"] then asserts.AssertExportTaskIdStringList(struct["ExportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeExportTasksRequest[k], "DescribeExportTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksRequest
-- <p>Contains the parameters for DescribeExportTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTaskIds [ExportTaskIdStringList] <p>One or more export task IDs.</p>
-- @return DescribeExportTasksRequest structure as a key-value pair table
function M.DescribeExportTasksRequest(args)
	assert(args, "You must provide an argument table when creating DescribeExportTasksRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExportTaskIds"] = args["ExportTaskIds"],
	}
	asserts.AssertDescribeExportTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ConfirmProductInstanceResult = { ["OwnerId"] = true, ["Return"] = true, nil }

function asserts.AssertConfirmProductInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceResult to be of type 'table'")
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConfirmProductInstanceResult[k], "ConfirmProductInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceResult
-- <p>Contains the output of ConfirmProductInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerId [String] <p>The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.</p>
-- * Return [Boolean] <p>The return value of the request. Returns <code>true</code> if the specified product code is owned by the requester and associated with the specified instance.</p>
-- @return ConfirmProductInstanceResult structure as a key-value pair table
function M.ConfirmProductInstanceResult(args)
	assert(args, "You must provide an argument table when creating ConfirmProductInstanceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OwnerId"] = args["OwnerId"],
		["Return"] = args["Return"],
	}
	asserts.AssertConfirmProductInstanceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateReservedInstancesListingResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertCreateReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateReservedInstancesListingResult[k], "CreateReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingResult
-- <p>Contains the output of CreateReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Standard Reserved Instance listing.</p>
-- @return CreateReservedInstancesListingResult structure as a key-value pair table
function M.CreateReservedInstancesListingResult(args)
	assert(args, "You must provide an argument table when creating CreateReservedInstancesListingResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesListings"] = args["ReservedInstancesListings"],
	}
	asserts.AssertCreateReservedInstancesListingResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportSnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["ClientData"] = true, ["ClientToken"] = true, ["RoleName"] = true, ["DiskContainer"] = true, nil }

function asserts.AssertImportSnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ClientData"] then asserts.AssertClientData(struct["ClientData"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then asserts.AssertString(struct["RoleName"]) end
	if struct["DiskContainer"] then asserts.AssertSnapshotDiskContainer(struct["DiskContainer"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotRequest[k], "ImportSnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotRequest
-- <p>Contains the parameters for ImportSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>The description string for the import snapshot task.</p>
-- * ClientData [ClientData] <p>The client-specific data.</p>
-- * ClientToken [String] <p>Token to enable idempotency for VM import requests.</p>
-- * RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
-- * DiskContainer [SnapshotDiskContainer] <p>Information about the disk container.</p>
-- @return ImportSnapshotRequest structure as a key-value pair table
function M.ImportSnapshotRequest(args)
	assert(args, "You must provide an argument table when creating ImportSnapshotRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["ClientData"] = args["ClientData"],
		["ClientToken"] = args["ClientToken"],
		["RoleName"] = args["RoleName"],
		["DiskContainer"] = args["DiskContainer"],
	}
	asserts.AssertImportSnapshotRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PortRange = { ["To"] = true, ["From"] = true, nil }

function asserts.AssertPortRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PortRange to be of type 'table'")
	if struct["To"] then asserts.AssertInteger(struct["To"]) end
	if struct["From"] then asserts.AssertInteger(struct["From"]) end
	for k,_ in pairs(struct) do
		assert(keys.PortRange[k], "PortRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PortRange
-- <p>Describes a range of ports.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * To [Integer] <p>The last port in the range.</p>
-- * From [Integer] <p>The first port in the range.</p>
-- @return PortRange structure as a key-value pair table
function M.PortRange(args)
	assert(args, "You must provide an argument table when creating PortRange")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["To"] = args["To"],
		["From"] = args["From"],
	}
	asserts.AssertPortRange(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Reservation = { ["Instances"] = true, ["ReservationId"] = true, ["RequesterId"] = true, ["Groups"] = true, ["OwnerId"] = true, nil }

function asserts.AssertReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Reservation to be of type 'table'")
	if struct["Instances"] then asserts.AssertInstanceList(struct["Instances"]) end
	if struct["ReservationId"] then asserts.AssertString(struct["ReservationId"]) end
	if struct["RequesterId"] then asserts.AssertString(struct["RequesterId"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Reservation[k], "Reservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Reservation
-- <p>Describes a reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Instances [InstanceList] <p>One or more instances.</p>
-- * ReservationId [String] <p>The ID of the reservation.</p>
-- * RequesterId [String] <p>The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).</p>
-- * Groups [GroupIdentifierList] <p>[EC2-Classic only] One or more security groups.</p>
-- * OwnerId [String] <p>The ID of the AWS account that owns the reservation.</p>
-- @return Reservation structure as a key-value pair table
function M.Reservation(args)
	assert(args, "You must provide an argument table when creating Reservation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Instances"] = args["Instances"],
		["ReservationId"] = args["ReservationId"],
		["RequesterId"] = args["RequesterId"],
		["Groups"] = args["Groups"],
		["OwnerId"] = args["OwnerId"],
	}
	asserts.AssertReservation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteLaunchTemplateVersionsResponseErrorItem = { ["ResponseError"] = true, ["LaunchTemplateName"] = true, ["VersionNumber"] = true, ["LaunchTemplateId"] = true, nil }

function asserts.AssertDeleteLaunchTemplateVersionsResponseErrorItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteLaunchTemplateVersionsResponseErrorItem to be of type 'table'")
	if struct["ResponseError"] then asserts.AssertResponseError(struct["ResponseError"]) end
	if struct["LaunchTemplateName"] then asserts.AssertString(struct["LaunchTemplateName"]) end
	if struct["VersionNumber"] then asserts.AssertLong(struct["VersionNumber"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteLaunchTemplateVersionsResponseErrorItem[k], "DeleteLaunchTemplateVersionsResponseErrorItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteLaunchTemplateVersionsResponseErrorItem
-- <p>Describes a launch template version that could not be deleted.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResponseError [ResponseError] <p>Information about the error.</p>
-- * LaunchTemplateName [String] <p>The name of the launch template.</p>
-- * VersionNumber [Long] <p>The version number of the launch template.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template.</p>
-- @return DeleteLaunchTemplateVersionsResponseErrorItem structure as a key-value pair table
function M.DeleteLaunchTemplateVersionsResponseErrorItem(args)
	assert(args, "You must provide an argument table when creating DeleteLaunchTemplateVersionsResponseErrorItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResponseError"] = args["ResponseError"],
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["VersionNumber"] = args["VersionNumber"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
	}
	asserts.AssertDeleteLaunchTemplateVersionsResponseErrorItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyFleetRequest = { ["ExcessCapacityTerminationPolicy"] = true, ["DryRun"] = true, ["TargetCapacitySpecification"] = true, ["FleetId"] = true, nil }

function asserts.AssertModifyFleetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyFleetRequest to be of type 'table'")
	assert(struct["FleetId"], "Expected key FleetId to exist in table")
	assert(struct["TargetCapacitySpecification"], "Expected key TargetCapacitySpecification to exist in table")
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertFleetExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TargetCapacitySpecification"] then asserts.AssertTargetCapacitySpecificationRequest(struct["TargetCapacitySpecification"]) end
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyFleetRequest[k], "ModifyFleetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyFleetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExcessCapacityTerminationPolicy [FleetExcessCapacityTerminationPolicy] <p>Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TargetCapacitySpecification [TargetCapacitySpecificationRequest] <p>The size of the EC2 Fleet.</p>
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- Required key: FleetId
-- Required key: TargetCapacitySpecification
-- @return ModifyFleetRequest structure as a key-value pair table
function M.ModifyFleetRequest(args)
	assert(args, "You must provide an argument table when creating ModifyFleetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExcessCapacityTerminationPolicy"] = args["ExcessCapacityTerminationPolicy"],
		["DryRun"] = args["DryRun"],
		["TargetCapacitySpecification"] = args["TargetCapacitySpecification"],
		["FleetId"] = args["FleetId"],
	}
	asserts.AssertModifyFleetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeConversionTasksRequest = { ["ConversionTaskIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeConversionTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeConversionTasksRequest to be of type 'table'")
	if struct["ConversionTaskIds"] then asserts.AssertConversionIdStringList(struct["ConversionTaskIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeConversionTasksRequest[k], "DescribeConversionTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeConversionTasksRequest
-- <p>Contains the parameters for DescribeConversionTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTaskIds [ConversionIdStringList] <p>One or more conversion task IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DescribeConversionTasksRequest structure as a key-value pair table
function M.DescribeConversionTasksRequest(args)
	assert(args, "You must provide an argument table when creating DescribeConversionTasksRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConversionTaskIds"] = args["ConversionTaskIds"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeConversionTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeImagesRequest = { ["Owners"] = true, ["ImageIds"] = true, ["DryRun"] = true, ["Filters"] = true, ["ExecutableUsers"] = true, nil }

function asserts.AssertDescribeImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImagesRequest to be of type 'table'")
	if struct["Owners"] then asserts.AssertOwnerStringList(struct["Owners"]) end
	if struct["ImageIds"] then asserts.AssertImageIdStringList(struct["ImageIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ExecutableUsers"] then asserts.AssertExecutableByStringList(struct["ExecutableUsers"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImagesRequest[k], "DescribeImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImagesRequest
-- <p>Contains the parameters for DescribeImages.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Owners [OwnerStringList] <p>Filters the images by the owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>). Omitting this option returns all images for which you have launch permissions, regardless of ownership.</p>
-- * ImageIds [ImageIdStringList] <p>One or more image IDs.</p> <p>Default: Describes all images available to you.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>architecture</code> - The image architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean value that indicates whether the Amazon EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name specified in the block device mapping (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p> </li> <li> <p> <code>block-device-mapping.snapshot-id</code> - The ID of the snapshot used for the EBS volume.</p> </li> <li> <p> <code>block-device-mapping.volume-size</code> - The volume size of the EBS volume, in GiB.</p> </li> <li> <p> <code>block-device-mapping.volume-type</code> - The volume type of the EBS volume (<code>gp2</code> | <code>io1</code> | <code>st1 </code>| <code>sc1</code> | <code>standard</code>).</p> </li> <li> <p> <code>description</code> - The description of the image (provided during image creation).</p> </li> <li> <p> <code>ena-support</code> - A Boolean that indicates whether enhanced networking with ENA is enabled.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>image-id</code> - The ID of the image.</p> </li> <li> <p> <code>image-type</code> - The image type (<code>machine</code> | <code>kernel</code> | <code>ramdisk</code>).</p> </li> <li> <p> <code>is-public</code> - A Boolean that indicates whether the image is public.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>manifest-location</code> - The location of the image manifest.</p> </li> <li> <p> <code>name</code> - The name of the AMI (provided during image creation).</p> </li> <li> <p> <code>owner-alias</code> - String value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the image owner.</p> </li> <li> <p> <code>platform</code> - The platform. To only list Windows-based AMIs, use <code>windows</code>.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>product-code.type</code> - The type of the product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>root-device-name</code> - The device name of the root device volume (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of the root device volume (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>state</code> - The state of the image (<code>available</code> | <code>pending</code> | <code>failed</code>).</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - The message for the state change.</p> </li> <li> <p> <code>sriov-net-support</code> - A value of <code>simple</code> indicates that enhanced networking with the Intel 82599 VF interface is enabled.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type (<code>paravirtual</code> | <code>hvm</code>).</p> </li> </ul>
-- * ExecutableUsers [ExecutableByStringList] <p>Scopes the images by users with explicit launch permissions. Specify an AWS account ID, <code>self</code> (the sender of the request), or <code>all</code> (public AMIs).</p>
-- @return DescribeImagesRequest structure as a key-value pair table
function M.DescribeImagesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeImagesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Owners"] = args["Owners"],
		["ImageIds"] = args["ImageIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["ExecutableUsers"] = args["ExecutableUsers"],
	}
	asserts.AssertDescribeImagesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TagSpecification = { ["ResourceType"] = true, ["Tags"] = true, nil }

function asserts.AssertTagSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TagSpecification to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.TagSpecification[k], "TagSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TagSpecification
-- <p>The tags to apply to a resource when the resource is being created.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceType] <p>The type of resource to tag. Currently, the resource types that support tagging on creation are <code>fleet</code>, <code>dedicated-host</code>, <code>instance</code>, <code>snapshot</code>, and <code>volume</code>. To tag a resource after it has been created, see <a>CreateTags</a>.</p>
-- * Tags [TagList] <p>The tags to apply to the resource.</p>
-- @return TagSpecification structure as a key-value pair table
function M.TagSpecification(args)
	assert(args, "You must provide an argument table when creating TagSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertTagSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcIpv6CidrBlockAssociation = { ["Ipv6CidrBlock"] = true, ["AssociationId"] = true, ["Ipv6CidrBlockState"] = true, nil }

function asserts.AssertVpcIpv6CidrBlockAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcIpv6CidrBlockAssociation to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["Ipv6CidrBlockState"] then asserts.AssertVpcCidrBlockState(struct["Ipv6CidrBlockState"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcIpv6CidrBlockAssociation[k], "VpcIpv6CidrBlockAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcIpv6CidrBlockAssociation
-- <p>Describes an IPv6 CIDR block associated with a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- * AssociationId [String] <p>The association ID for the IPv6 CIDR block.</p>
-- * Ipv6CidrBlockState [VpcCidrBlockState] <p>Information about the state of the CIDR block.</p>
-- @return VpcIpv6CidrBlockAssociation structure as a key-value pair table
function M.VpcIpv6CidrBlockAssociation(args)
	assert(args, "You must provide an argument table when creating VpcIpv6CidrBlockAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["AssociationId"] = args["AssociationId"],
		["Ipv6CidrBlockState"] = args["Ipv6CidrBlockState"],
	}
	asserts.AssertVpcIpv6CidrBlockAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIdentityIdFormatRequest = { ["PrincipalArn"] = true, ["Resource"] = true, nil }

function asserts.AssertDescribeIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	if struct["PrincipalArn"] then asserts.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdentityIdFormatRequest[k], "DescribeIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatRequest
-- <p>Contains the parameters for DescribeIdentityIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrincipalArn [String] <p>The ARN of the principal, which can be an IAM role, IAM user, or the root user.</p>
-- * Resource [String] <p>The type of resource: <code>bundle</code> | <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> | <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> | <code>export-task</code> | <code>flow-log</code> | <code>image</code> | <code>import-task</code> | <code>instance</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-acl-association</code> | <code>network-interface</code> | <code>network-interface-attachment</code> | <code>prefix-list</code> | <code>reservation</code> | <code>route-table</code> | <code>route-table-association</code> | <code>security-group</code> | <code>snapshot</code> | <code>subnet</code> | <code>subnet-cidr-block-association</code> | <code>volume</code> | <code>vpc</code> | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code> </p>
-- Required key: PrincipalArn
-- @return DescribeIdentityIdFormatRequest structure as a key-value pair table
function M.DescribeIdentityIdFormatRequest(args)
	assert(args, "You must provide an argument table when creating DescribeIdentityIdFormatRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrincipalArn"] = args["PrincipalArn"],
		["Resource"] = args["Resource"],
	}
	asserts.AssertDescribeIdentityIdFormatRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFpgaImagesRequest = { ["Owners"] = true, ["DryRun"] = true, ["FpgaImageIds"] = true, ["MaxResults"] = true, ["Filters"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFpgaImagesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImagesRequest to be of type 'table'")
	if struct["Owners"] then asserts.AssertOwnerStringList(struct["Owners"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["FpgaImageIds"] then asserts.AssertFpgaImageIdList(struct["FpgaImageIds"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImagesRequest[k], "DescribeFpgaImagesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImagesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Owners [OwnerStringList] <p>Filters the AFI by owner. Specify an AWS account ID, <code>self</code> (owner is the sender of the request), or an AWS owner alias (valid values are <code>amazon</code> | <code>aws-marketplace</code>).</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * FpgaImageIds [FpgaImageIdList] <p>One or more AFI IDs.</p>
-- * MaxResults [MaxResults] <p>The maximum number of results to return in a single call.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>create-time</code> - The creation time of the AFI.</p> </li> <li> <p> <code>fpga-image-id</code> - The FPGA image identifier (AFI ID).</p> </li> <li> <p> <code>fpga-image-global-id</code> - The global FPGA image identifier (AGFI ID).</p> </li> <li> <p> <code>name</code> - The name of the AFI.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the AFI owner.</p> </li> <li> <p> <code>product-code</code> - The product code.</p> </li> <li> <p> <code>shell-version</code> - The version of the AWS Shell that was used to create the bitstream.</p> </li> <li> <p> <code>state</code> - The state of the AFI (<code>pending</code> | <code>failed</code> | <code>available</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update.</p> </li> </ul>
-- * NextToken [NextToken] <p>The token to retrieve the next page of results.</p>
-- @return DescribeFpgaImagesRequest structure as a key-value pair table
function M.DescribeFpgaImagesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeFpgaImagesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Owners"] = args["Owners"],
		["DryRun"] = args["DryRun"],
		["FpgaImageIds"] = args["FpgaImageIds"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFpgaImagesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.WithdrawByoipCidrResult = { ["ByoipCidr"] = true, nil }

function asserts.AssertWithdrawByoipCidrResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected WithdrawByoipCidrResult to be of type 'table'")
	if struct["ByoipCidr"] then asserts.AssertByoipCidr(struct["ByoipCidr"]) end
	for k,_ in pairs(struct) do
		assert(keys.WithdrawByoipCidrResult[k], "WithdrawByoipCidrResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type WithdrawByoipCidrResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ByoipCidr [ByoipCidr] <p>Information about the address pool.</p>
-- @return WithdrawByoipCidrResult structure as a key-value pair table
function M.WithdrawByoipCidrResult(args)
	assert(args, "You must provide an argument table when creating WithdrawByoipCidrResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ByoipCidr"] = args["ByoipCidr"],
	}
	asserts.AssertWithdrawByoipCidrResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.KeyPair = { ["KeyMaterial"] = true, ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertKeyPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPair to be of type 'table'")
	if struct["KeyMaterial"] then asserts.AssertString(struct["KeyMaterial"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.KeyPair[k], "KeyPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPair
-- <p>Describes a key pair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyMaterial [String] <p>An unencrypted PEM encoded RSA private key.</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * KeyFingerprint [String] <p>The SHA-1 digest of the DER encoded private key.</p>
-- @return KeyPair structure as a key-value pair table
function M.KeyPair(args)
	assert(args, "You must provide an argument table when creating KeyPair")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyMaterial"] = args["KeyMaterial"],
		["KeyName"] = args["KeyName"],
		["KeyFingerprint"] = args["KeyFingerprint"],
	}
	asserts.AssertKeyPair(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PropagatingVgw = { ["GatewayId"] = true, nil }

function asserts.AssertPropagatingVgw(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PropagatingVgw to be of type 'table'")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PropagatingVgw[k], "PropagatingVgw contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PropagatingVgw
-- <p>Describes a virtual private gateway propagating route.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- @return PropagatingVgw structure as a key-value pair table
function M.PropagatingVgw(args)
	assert(args, "You must provide an argument table when creating PropagatingVgw")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GatewayId"] = args["GatewayId"],
	}
	asserts.AssertPropagatingVgw(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePrefixListsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["PrefixListIds"] = true, nil }

function asserts.AssertDescribePrefixListsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrefixListsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["PrefixListIds"] then asserts.AssertValueStringList(struct["PrefixListIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrefixListsRequest[k], "DescribePrefixListsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrefixListsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value specified is greater than 1000, we return only 1000 items.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>prefix-list-id</code>: The ID of a prefix list.</p> </li> <li> <p> <code>prefix-list-name</code>: The name of a prefix list.</p> </li> </ul>
-- * PrefixListIds [ValueStringList] <p>One or more prefix list IDs.</p>
-- @return DescribePrefixListsRequest structure as a key-value pair table
function M.DescribePrefixListsRequest(args)
	assert(args, "You must provide an argument table when creating DescribePrefixListsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["PrefixListIds"] = args["PrefixListIds"],
	}
	asserts.AssertDescribePrefixListsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcEndpointConnectionNotificationResult = { ["ConnectionNotification"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointConnectionNotificationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointConnectionNotificationResult to be of type 'table'")
	if struct["ConnectionNotification"] then asserts.AssertConnectionNotification(struct["ConnectionNotification"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointConnectionNotificationResult[k], "CreateVpcEndpointConnectionNotificationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointConnectionNotificationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConnectionNotification [ConnectionNotification] <p>Information about the notification.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
-- @return CreateVpcEndpointConnectionNotificationResult structure as a key-value pair table
function M.CreateVpcEndpointConnectionNotificationResult(args)
	assert(args, "You must provide an argument table when creating CreateVpcEndpointConnectionNotificationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConnectionNotification"] = args["ConnectionNotification"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateVpcEndpointConnectionNotificationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RequestLaunchTemplateData = { ["Monitoring"] = true, ["TagSpecifications"] = true, ["EbsOptimized"] = true, ["CpuOptions"] = true, ["ImageId"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["CreditSpecification"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, ["Placement"] = true, ["ElasticGpuSpecifications"] = true, ["CapacityReservationSpecification"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["SecurityGroupIds"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["UserData"] = true, ["InstanceMarketOptions"] = true, ["RamDiskId"] = true, ["DisableApiTermination"] = true, nil }

function asserts.AssertRequestLaunchTemplateData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestLaunchTemplateData to be of type 'table'")
	if struct["Monitoring"] then asserts.AssertLaunchTemplatesMonitoringRequest(struct["Monitoring"]) end
	if struct["TagSpecifications"] then asserts.AssertLaunchTemplateTagSpecificationRequestList(struct["TagSpecifications"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["CpuOptions"] then asserts.AssertLaunchTemplateCpuOptionsRequest(struct["CpuOptions"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertSecurityGroupStringList(struct["SecurityGroups"]) end
	if struct["CreditSpecification"] then asserts.AssertCreditSpecificationRequest(struct["CreditSpecification"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(struct["NetworkInterfaces"]) end
	if struct["Placement"] then asserts.AssertLaunchTemplatePlacementRequest(struct["Placement"]) end
	if struct["ElasticGpuSpecifications"] then asserts.AssertElasticGpuSpecificationList(struct["ElasticGpuSpecifications"]) end
	if struct["CapacityReservationSpecification"] then asserts.AssertLaunchTemplateCapacityReservationSpecificationRequest(struct["CapacityReservationSpecification"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["SecurityGroupIds"] then asserts.AssertSecurityGroupIdStringList(struct["SecurityGroupIds"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertLaunchTemplateBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertLaunchTemplateIamInstanceProfileSpecificationRequest(struct["IamInstanceProfile"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["InstanceMarketOptions"] then asserts.AssertLaunchTemplateInstanceMarketOptionsRequest(struct["InstanceMarketOptions"]) end
	if struct["RamDiskId"] then asserts.AssertString(struct["RamDiskId"]) end
	if struct["DisableApiTermination"] then asserts.AssertBoolean(struct["DisableApiTermination"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestLaunchTemplateData[k], "RequestLaunchTemplateData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestLaunchTemplateData
-- <p>The information to include in the launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Monitoring [LaunchTemplatesMonitoringRequest] <p>The monitoring for the instance.</p>
-- * TagSpecifications [LaunchTemplateTagSpecificationRequestList] <p>The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch. To tag a resource after it has been created, see <a>CreateTags</a>.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p>
-- * CpuOptions [LaunchTemplateCpuOptionsRequest] <p>The CPU options for the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU Options</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * ImageId [String] <p>The ID of the AMI, which you can get by using <a>DescribeImages</a>.</p>
-- * KeyName [String] <p>The name of the key pair. You can create a key pair using <a>CreateKeyPair</a> or <a>ImportKeyPair</a>.</p> <important> <p>If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.</p> </important>
-- * SecurityGroups [SecurityGroupStringList] <p>[EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.</p>
-- * CreditSpecification [CreditSpecificationRequest] <p>The credit option for CPU usage of the instance. Valid for T2 or T3 instances only.</p>
-- * InstanceType [InstanceType] <p>The instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * NetworkInterfaces [LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList] <p>One or more network interfaces.</p>
-- * Placement [LaunchTemplatePlacementRequest] <p>The placement for the instance.</p>
-- * ElasticGpuSpecifications [ElasticGpuSpecificationList] <p>An elastic GPU to associate with the instance.</p>
-- * CapacityReservationSpecification [LaunchTemplateCapacityReservationSpecificationRequest] <p>Information about the Capacity Reservation targeting option.</p>
-- * InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p> <p>Default: <code>stop</code> </p>
-- * SecurityGroupIds [SecurityGroupIdStringList] <p>One or more security group IDs. You can create a security group using <a>CreateSecurityGroup</a>. You cannot specify both a security group ID and security name in the same request.</p>
-- * BlockDeviceMappings [LaunchTemplateBlockDeviceMappingRequestList] <p>The block device mapping.</p> <important> <p>Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action.</p> </important>
-- * KernelId [String] <p>The ID of the kernel.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html">User Provided Kernels</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- * IamInstanceProfile [LaunchTemplateIamInstanceProfileSpecificationRequest] <p>The IAM instance profile.</p>
-- * UserData [String] <p>The Base64-encoded user data to make available to the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running Commands on Your Linux Instance at Launch</a> (Linux) and <a href="http://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows).</p>
-- * InstanceMarketOptions [LaunchTemplateInstanceMarketOptionsRequest] <p>The market (purchasing) option for the instances.</p>
-- * RamDiskId [String] <p>The ID of the RAM disk.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html">User Provided Kernels</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- * DisableApiTermination [Boolean] <p>If set to <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API. To change this attribute to <code>false</code> after launch, use <a>ModifyInstanceAttribute</a>.</p>
-- @return RequestLaunchTemplateData structure as a key-value pair table
function M.RequestLaunchTemplateData(args)
	assert(args, "You must provide an argument table when creating RequestLaunchTemplateData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Monitoring"] = args["Monitoring"],
		["TagSpecifications"] = args["TagSpecifications"],
		["EbsOptimized"] = args["EbsOptimized"],
		["CpuOptions"] = args["CpuOptions"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["SecurityGroups"] = args["SecurityGroups"],
		["CreditSpecification"] = args["CreditSpecification"],
		["InstanceType"] = args["InstanceType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
		["Placement"] = args["Placement"],
		["ElasticGpuSpecifications"] = args["ElasticGpuSpecifications"],
		["CapacityReservationSpecification"] = args["CapacityReservationSpecification"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["KernelId"] = args["KernelId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["UserData"] = args["UserData"],
		["InstanceMarketOptions"] = args["InstanceMarketOptions"],
		["RamDiskId"] = args["RamDiskId"],
		["DisableApiTermination"] = args["DisableApiTermination"],
	}
	asserts.AssertRequestLaunchTemplateData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PriceSchedule = { ["Active"] = true, ["CurrencyCode"] = true, ["Term"] = true, ["Price"] = true, nil }

function asserts.AssertPriceSchedule(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PriceSchedule to be of type 'table'")
	if struct["Active"] then asserts.AssertBoolean(struct["Active"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Term"] then asserts.AssertLong(struct["Term"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PriceSchedule[k], "PriceSchedule contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PriceSchedule
-- <p>Describes the price for a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Active [Boolean] <p>The current price schedule, as determined by the term remaining for the Reserved Instance in the listing.</p> <p>A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>
-- * Term [Long] <p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>
-- * Price [Double] <p>The fixed price for the term.</p>
-- @return PriceSchedule structure as a key-value pair table
function M.PriceSchedule(args)
	assert(args, "You must provide an argument table when creating PriceSchedule")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Active"] = args["Active"],
		["CurrencyCode"] = args["CurrencyCode"],
		["Term"] = args["Term"],
		["Price"] = args["Price"],
	}
	asserts.AssertPriceSchedule(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceNetworkInterfaceSpecification = { ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceSpecification to be of type 'table'")
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceSpecification[k], "InstanceNetworkInterfaceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceSpecification
-- <p>Describes a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment. If you are specifying a network interface in a <a>RunInstances</a> request, you must provide the device index.</p>
-- * Description [String] <p>The description of the network interface. Applies only if creating a network interface when launching an instance.</p>
-- * Ipv6AddressCount [Integer] <p>A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- * PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- * SubnetId [String] <p>The ID of the subnet associated with the network string. Applies only if creating a network interface when launching an instance.</p>
-- * DeleteOnTermination [Boolean] <p>If set to <code>true</code>, the interface is deleted when the instance is terminated. You can specify <code>true</code> only if creating a new network interface when launching an instance.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- * Groups [SecurityGroupIdStringList] <p>The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociatePublicIpAddress [Boolean] <p>Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a <a>RunInstances</a> request.</p>
-- @return InstanceNetworkInterfaceSpecification structure as a key-value pair table
function M.InstanceNetworkInterfaceSpecification(args)
	assert(args, "You must provide an argument table when creating InstanceNetworkInterfaceSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceIndex"] = args["DeviceIndex"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["SubnetId"] = args["SubnetId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociatePublicIpAddress"] = args["AssociatePublicIpAddress"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
	}
	asserts.AssertInstanceNetworkInterfaceSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceNetworkAclAssociationResult = { ["NewAssociationId"] = true, nil }

function asserts.AssertReplaceNetworkAclAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then asserts.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclAssociationResult[k], "ReplaceNetworkAclAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NewAssociationId [String] <p>The ID of the new association.</p>
-- @return ReplaceNetworkAclAssociationResult structure as a key-value pair table
function M.ReplaceNetworkAclAssociationResult(args)
	assert(args, "You must provide an argument table when creating ReplaceNetworkAclAssociationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NewAssociationId"] = args["NewAssociationId"],
	}
	asserts.AssertReplaceNetworkAclAssociationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnsuccessfulItemError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertUnsuccessfulItemError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulItemError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulItemError[k], "UnsuccessfulItemError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulItemError
-- <p>Information about the error that occurred. For more information about errors, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html">Error Codes</a>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The error message accompanying the error code.</p>
-- * Code [String] <p>The error code.</p>
-- Required key: Code
-- Required key: Message
-- @return UnsuccessfulItemError structure as a key-value pair table
function M.UnsuccessfulItemError(args)
	assert(args, "You must provide an argument table when creating UnsuccessfulItemError")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertUnsuccessfulItemError(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TargetCapacitySpecification = { ["OnDemandTargetCapacity"] = true, ["SpotTargetCapacity"] = true, ["TotalTargetCapacity"] = true, ["DefaultTargetCapacityType"] = true, nil }

function asserts.AssertTargetCapacitySpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetCapacitySpecification to be of type 'table'")
	if struct["OnDemandTargetCapacity"] then asserts.AssertInteger(struct["OnDemandTargetCapacity"]) end
	if struct["SpotTargetCapacity"] then asserts.AssertInteger(struct["SpotTargetCapacity"]) end
	if struct["TotalTargetCapacity"] then asserts.AssertInteger(struct["TotalTargetCapacity"]) end
	if struct["DefaultTargetCapacityType"] then asserts.AssertDefaultTargetCapacityType(struct["DefaultTargetCapacityType"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetCapacitySpecification[k], "TargetCapacitySpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetCapacitySpecification
-- <p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OnDemandTargetCapacity [Integer] <p>The number of On-Demand units to request.</p>
-- * SpotTargetCapacity [Integer] <p>The maximum number of Spot units to launch.</p>
-- * TotalTargetCapacity [Integer] <p>The number of units to request, filled using <code>DefaultTargetCapacityType</code>.</p>
-- * DefaultTargetCapacityType [DefaultTargetCapacityType] <p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or <code>On-Demand</code>.</p>
-- @return TargetCapacitySpecification structure as a key-value pair table
function M.TargetCapacitySpecification(args)
	assert(args, "You must provide an argument table when creating TargetCapacitySpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OnDemandTargetCapacity"] = args["OnDemandTargetCapacity"],
		["SpotTargetCapacity"] = args["SpotTargetCapacity"],
		["TotalTargetCapacity"] = args["TotalTargetCapacity"],
		["DefaultTargetCapacityType"] = args["DefaultTargetCapacityType"],
	}
	asserts.AssertTargetCapacitySpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyInstanceCreditSpecificationResult = { ["SuccessfulInstanceCreditSpecifications"] = true, ["UnsuccessfulInstanceCreditSpecifications"] = true, nil }

function asserts.AssertModifyInstanceCreditSpecificationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceCreditSpecificationResult to be of type 'table'")
	if struct["SuccessfulInstanceCreditSpecifications"] then asserts.AssertSuccessfulInstanceCreditSpecificationSet(struct["SuccessfulInstanceCreditSpecifications"]) end
	if struct["UnsuccessfulInstanceCreditSpecifications"] then asserts.AssertUnsuccessfulInstanceCreditSpecificationSet(struct["UnsuccessfulInstanceCreditSpecifications"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstanceCreditSpecificationResult[k], "ModifyInstanceCreditSpecificationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceCreditSpecificationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SuccessfulInstanceCreditSpecifications [SuccessfulInstanceCreditSpecificationSet] <p>Information about the instances whose credit option for CPU usage was successfully modified.</p>
-- * UnsuccessfulInstanceCreditSpecifications [UnsuccessfulInstanceCreditSpecificationSet] <p>Information about the instances whose credit option for CPU usage was not modified.</p>
-- @return ModifyInstanceCreditSpecificationResult structure as a key-value pair table
function M.ModifyInstanceCreditSpecificationResult(args)
	assert(args, "You must provide an argument table when creating ModifyInstanceCreditSpecificationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SuccessfulInstanceCreditSpecifications"] = args["SuccessfulInstanceCreditSpecifications"],
		["UnsuccessfulInstanceCreditSpecifications"] = args["UnsuccessfulInstanceCreditSpecifications"],
	}
	asserts.AssertModifyInstanceCreditSpecificationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RouteTable = { ["Associations"] = true, ["RouteTableId"] = true, ["VpcId"] = true, ["PropagatingVgws"] = true, ["Tags"] = true, ["Routes"] = true, nil }

function asserts.AssertRouteTable(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RouteTable to be of type 'table'")
	if struct["Associations"] then asserts.AssertRouteTableAssociationList(struct["Associations"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["PropagatingVgws"] then asserts.AssertPropagatingVgwList(struct["PropagatingVgws"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Routes"] then asserts.AssertRouteList(struct["Routes"]) end
	for k,_ in pairs(struct) do
		assert(keys.RouteTable[k], "RouteTable contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RouteTable
-- <p>Describes a route table.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Associations [RouteTableAssociationList] <p>The associations between the route table and one or more subnets.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * PropagatingVgws [PropagatingVgwList] <p>Any virtual private gateway (VGW) propagating routes.</p>
-- * Tags [TagList] <p>Any tags assigned to the route table.</p>
-- * Routes [RouteList] <p>The routes in the route table.</p>
-- @return RouteTable structure as a key-value pair table
function M.RouteTable(args)
	assert(args, "You must provide an argument table when creating RouteTable")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Associations"] = args["Associations"],
		["RouteTableId"] = args["RouteTableId"],
		["VpcId"] = args["VpcId"],
		["PropagatingVgws"] = args["PropagatingVgws"],
		["Tags"] = args["Tags"],
		["Routes"] = args["Routes"],
	}
	asserts.AssertRouteTable(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AllocateHostsResult = { ["HostIds"] = true, nil }

function asserts.AssertAllocateHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateHostsResult to be of type 'table'")
	if struct["HostIds"] then asserts.AssertResponseHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateHostsResult[k], "AllocateHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateHostsResult
-- <p>Contains the output of AllocateHosts.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIds [ResponseHostIdList] <p>The ID of the allocated Dedicated Host. This is used to launch an instance onto a specific host.</p>
-- @return AllocateHostsResult structure as a key-value pair table
function M.AllocateHostsResult(args)
	assert(args, "You must provide an argument table when creating AllocateHostsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostIds"] = args["HostIds"],
	}
	asserts.AssertAllocateHostsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateCustomerGatewayResult = { ["CustomerGateway"] = true, nil }

function asserts.AssertCreateCustomerGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayResult to be of type 'table'")
	if struct["CustomerGateway"] then asserts.AssertCustomerGateway(struct["CustomerGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCustomerGatewayResult[k], "CreateCustomerGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayResult
-- <p>Contains the output of CreateCustomerGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGateway [CustomerGateway] <p>Information about the customer gateway.</p>
-- @return CreateCustomerGatewayResult structure as a key-value pair table
function M.CreateCustomerGatewayResult(args)
	assert(args, "You must provide an argument table when creating CreateCustomerGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CustomerGateway"] = args["CustomerGateway"],
	}
	asserts.AssertCreateCustomerGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelConversionRequest = { ["ConversionTaskId"] = true, ["ReasonMessage"] = true, ["DryRun"] = true, nil }

function asserts.AssertCancelConversionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelConversionRequest to be of type 'table'")
	assert(struct["ConversionTaskId"], "Expected key ConversionTaskId to exist in table")
	if struct["ConversionTaskId"] then asserts.AssertString(struct["ConversionTaskId"]) end
	if struct["ReasonMessage"] then asserts.AssertString(struct["ReasonMessage"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelConversionRequest[k], "CancelConversionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelConversionRequest
-- <p>Contains the parameters for CancelConversionTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- * ReasonMessage [String] <p>The reason for canceling the conversion task.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: ConversionTaskId
-- @return CancelConversionRequest structure as a key-value pair table
function M.CancelConversionRequest(args)
	assert(args, "You must provide an argument table when creating CancelConversionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConversionTaskId"] = args["ConversionTaskId"],
		["ReasonMessage"] = args["ReasonMessage"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCancelConversionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesIamInstanceProfile = { ["Name"] = true, ["Arn"] = true, nil }

function asserts.AssertScheduledInstancesIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIamInstanceProfile to be of type 'table'")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesIamInstanceProfile[k], "ScheduledInstancesIamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIamInstanceProfile
-- <p>Describes an IAM instance profile for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [String] <p>The name.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN).</p>
-- @return ScheduledInstancesIamInstanceProfile structure as a key-value pair table
function M.ScheduledInstancesIamInstanceProfile(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesIamInstanceProfile")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertScheduledInstancesIamInstanceProfile(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifySpotFleetRequestResponse = { ["Return"] = true, nil }

function asserts.AssertModifySpotFleetRequestResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestResponse to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySpotFleetRequestResponse[k], "ModifySpotFleetRequestResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestResponse
-- <p>Contains the output of ModifySpotFleetRequest.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
-- @return ModifySpotFleetRequestResponse structure as a key-value pair table
function M.ModifySpotFleetRequestResponse(args)
	assert(args, "You must provide an argument table when creating ModifySpotFleetRequestResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifySpotFleetRequestResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifySpotFleetRequestRequest = { ["TargetCapacity"] = true, ["SpotFleetRequestId"] = true, ["ExcessCapacityTerminationPolicy"] = true, nil }

function asserts.AssertModifySpotFleetRequestRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySpotFleetRequestRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["TargetCapacity"] then asserts.AssertInteger(struct["TargetCapacity"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySpotFleetRequestRequest[k], "ModifySpotFleetRequestRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySpotFleetRequestRequest
-- <p>Contains the parameters for ModifySpotFleetRequest.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetCapacity [Integer] <p>The size of the fleet.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- * ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot Instances should be terminated if the target capacity of the Spot Fleet request is decreased below the current size of the Spot Fleet.</p>
-- Required key: SpotFleetRequestId
-- @return ModifySpotFleetRequestRequest structure as a key-value pair table
function M.ModifySpotFleetRequestRequest(args)
	assert(args, "You must provide an argument table when creating ModifySpotFleetRequestRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TargetCapacity"] = args["TargetCapacity"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["ExcessCapacityTerminationPolicy"] = args["ExcessCapacityTerminationPolicy"],
	}
	asserts.AssertModifySpotFleetRequestRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointServicePermissionsRequest = { ["NextToken"] = true, ["ServiceId"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicePermissionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicePermissionsRequest to be of type 'table'")
	assert(struct["ServiceId"], "Expected key ServiceId to exist in table")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicePermissionsRequest[k], "DescribeVpcEndpointServicePermissionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicePermissionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * ServiceId [String] <p>The ID of the service.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>principal</code> - The ARN of the principal.</p> </li> <li> <p> <code>principal-type</code> - The principal type (<code>All</code> | <code>Service</code> | <code>OrganizationUnit</code> | <code>Account</code> | <code>User</code> | <code>Role</code>).</p> </li> </ul>
-- Required key: ServiceId
-- @return DescribeVpcEndpointServicePermissionsRequest structure as a key-value pair table
function M.DescribeVpcEndpointServicePermissionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointServicePermissionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ServiceId"] = args["ServiceId"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpcEndpointServicePermissionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisableVgwRoutePropagationRequest = { ["GatewayId"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertDisableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVgwRoutePropagationRequest[k], "DisableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVgwRoutePropagationRequest
-- <p>Contains the parameters for DisableVgwRoutePropagation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- Required key: GatewayId
-- Required key: RouteTableId
-- @return DisableVgwRoutePropagationRequest structure as a key-value pair table
function M.DisableVgwRoutePropagationRequest(args)
	assert(args, "You must provide an argument table when creating DisableVgwRoutePropagationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GatewayId"] = args["GatewayId"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertDisableVgwRoutePropagationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeHostReservationsResult = { ["NextToken"] = true, ["HostReservationSet"] = true, nil }

function asserts.AssertDescribeHostReservationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["HostReservationSet"] then asserts.AssertHostReservationSet(struct["HostReservationSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationsResult[k], "DescribeHostReservationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * HostReservationSet [HostReservationSet] <p>Details about the reservation's configuration.</p>
-- @return DescribeHostReservationsResult structure as a key-value pair table
function M.DescribeHostReservationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeHostReservationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["HostReservationSet"] = args["HostReservationSet"],
	}
	asserts.AssertDescribeHostReservationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelSpotInstanceRequestsResult = { ["CancelledSpotInstanceRequests"] = true, nil }

function asserts.AssertCancelSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotInstanceRequestsResult to be of type 'table'")
	if struct["CancelledSpotInstanceRequests"] then asserts.AssertCancelledSpotInstanceRequestList(struct["CancelledSpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotInstanceRequestsResult[k], "CancelSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotInstanceRequestsResult
-- <p>Contains the output of CancelSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CancelledSpotInstanceRequests [CancelledSpotInstanceRequestList] <p>One or more Spot Instance requests.</p>
-- @return CancelSpotInstanceRequestsResult structure as a key-value pair table
function M.CancelSpotInstanceRequestsResult(args)
	assert(args, "You must provide an argument table when creating CancelSpotInstanceRequestsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CancelledSpotInstanceRequests"] = args["CancelledSpotInstanceRequests"],
	}
	asserts.AssertCancelSpotInstanceRequestsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RunInstancesRequest = { ["DryRun"] = true, ["TagSpecifications"] = true, ["MinCount"] = true, ["EbsOptimized"] = true, ["RamdiskId"] = true, ["Monitoring"] = true, ["PrivateIpAddress"] = true, ["CpuOptions"] = true, ["ImageId"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["CreditSpecification"] = true, ["ClientToken"] = true, ["SubnetId"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, ["AdditionalInfo"] = true, ["Placement"] = true, ["LaunchTemplate"] = true, ["CapacityReservationSpecification"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["SecurityGroupIds"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["UserData"] = true, ["Ipv6AddressCount"] = true, ["InstanceMarketOptions"] = true, ["ElasticGpuSpecification"] = true, ["MaxCount"] = true, ["Ipv6Addresses"] = true, ["DisableApiTermination"] = true, nil }

function asserts.AssertRunInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunInstancesRequest to be of type 'table'")
	assert(struct["MaxCount"], "Expected key MaxCount to exist in table")
	assert(struct["MinCount"], "Expected key MinCount to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["MinCount"] then asserts.AssertInteger(struct["MinCount"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["CpuOptions"] then asserts.AssertCpuOptionsRequest(struct["CpuOptions"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertSecurityGroupStringList(struct["SecurityGroups"]) end
	if struct["CreditSpecification"] then asserts.AssertCreditSpecificationRequest(struct["CreditSpecification"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["LaunchTemplate"] then asserts.AssertLaunchTemplateSpecification(struct["LaunchTemplate"]) end
	if struct["CapacityReservationSpecification"] then asserts.AssertCapacityReservationSpecification(struct["CapacityReservationSpecification"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["SecurityGroupIds"] then asserts.AssertSecurityGroupIdStringList(struct["SecurityGroupIds"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["InstanceMarketOptions"] then asserts.AssertInstanceMarketOptionsRequest(struct["InstanceMarketOptions"]) end
	if struct["ElasticGpuSpecification"] then asserts.AssertElasticGpuSpecifications(struct["ElasticGpuSpecification"]) end
	if struct["MaxCount"] then asserts.AssertInteger(struct["MaxCount"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["DisableApiTermination"] then asserts.AssertBoolean(struct["DisableApiTermination"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunInstancesRequest[k], "RunInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunInstancesRequest
-- <p>Contains the parameters for RunInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TagSpecifications [TagSpecificationList] <p>The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch. To tag a resource after it has been created, see <a>CreateTags</a>.</p>
-- * MinCount [Integer] <p>The minimum number of instances to launch. If you specify a minimum that is more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches no instances.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 General FAQ.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- * Monitoring [RunInstancesMonitoringEnabled] <p>The monitoring for the instance.</p>
-- * PrivateIpAddress [String] <p>[EC2-VPC] The primary IPv4 address. You must specify a value from the IPv4 address range of the subnet.</p> <p>Only one private IP address can be designated as primary. You can't specify this option if you've specified the option to designate a private IP address as the primary IP address in a network interface specification. You cannot specify this option if you're launching more than one instance in the request.</p>
-- * CpuOptions [CpuOptionsRequest] <p>The CPU options for the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU Options</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * ImageId [String] <p>The ID of the AMI, which you can get by calling <a>DescribeImages</a>. An AMI is required to launch an instance and must be specified here or in a launch template.</p>
-- * KeyName [String] <p>The name of the key pair. You can create a key pair using <a>CreateKeyPair</a> or <a>ImportKeyPair</a>.</p> <important> <p>If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.</p> </important>
-- * SecurityGroups [SecurityGroupStringList] <p>[EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- * CreditSpecification [CreditSpecificationRequest] <p>The credit option for CPU usage of the instance. Valid values are <code>standard</code> and <code>unlimited</code>. To change this attribute after launch, use <a>ModifyInstanceCreditSpecification</a>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html">Burstable Performance Instances</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Default: <code>standard</code> (T2 instances) or <code>unlimited</code> (T3 instances)</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p> <p>Constraints: Maximum 64 ASCII characters</p>
-- * SubnetId [String] <p>[EC2-VPC] The ID of the subnet to launch the instance into.</p>
-- * InstanceType [InstanceType] <p>The instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Default: <code>m1.small</code> </p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces.</p>
-- * AdditionalInfo [String] <p>Reserved.</p>
-- * Placement [Placement] <p>The placement for the instance.</p>
-- * LaunchTemplate [LaunchTemplateSpecification] <p>The launch template to use to launch the instances. Any parameters that you specify in <a>RunInstances</a> override the same parameters in the launch template. You can specify either the name or ID of a launch template, but not both.</p>
-- * CapacityReservationSpecification [CapacityReservationSpecification] <p>Information about the Capacity Reservation targeting option.</p>
-- * InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p> <p>Default: <code>stop</code> </p>
-- * SecurityGroupIds [SecurityGroupIdStringList] <p>One or more security group IDs. You can create a security group using <a>CreateSecurityGroup</a>.</p> <p>Default: Amazon EC2 uses the default security group.</p>
-- * BlockDeviceMappings [BlockDeviceMappingRequestList] <p>One or more block device mapping entries. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
-- * KernelId [String] <p>The ID of the kernel.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html"> PV-GRUB</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * UserData [String] <p>The user data to make available to the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html">Running Commands on Your Linux Instance at Launch</a> (Linux) and <a href="http://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data">Adding User Data</a> (Windows). If you are using a command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text.</p>
-- * Ipv6AddressCount [Integer] <p>[EC2-VPC] A number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>
-- * InstanceMarketOptions [InstanceMarketOptionsRequest] <p>The market (purchasing) option for the instances.</p> <p>For <a>RunInstances</a>, persistent Spot Instance requests are only supported when <b>InstanceInterruptionBehavior</b> is set to either <code>hibernate</code> or <code>stop</code>.</p>
-- * ElasticGpuSpecification [ElasticGpuSpecifications] <p>An elastic GPU to associate with the instance.</p>
-- * MaxCount [Integer] <p>The maximum number of instances to launch. If you specify more instances than Amazon EC2 can launch in the target Availability Zone, Amazon EC2 launches the largest possible number of instances above <code>MinCount</code>.</p> <p>Constraints: Between 1 and the maximum number you're allowed for the specified instance type. For more information about the default limits, and how to request an increase, see <a href="http://aws.amazon.com/ec2/faqs/#How_many_instances_can_I_run_in_Amazon_EC2">How many instances can I run in Amazon EC2</a> in the Amazon EC2 FAQ.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>[EC2-VPC] Specify one or more IPv6 addresses from the range of the subnet to associate with the primary network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>
-- * DisableApiTermination [Boolean] <p>If you set this parameter to <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute to <code>false</code> after launch, use <a>ModifyInstanceAttribute</a>. Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to <code>terminate</code>, you can terminate the instance by running the shutdown command from the instance.</p> <p>Default: <code>false</code> </p>
-- Required key: MaxCount
-- Required key: MinCount
-- @return RunInstancesRequest structure as a key-value pair table
function M.RunInstancesRequest(args)
	assert(args, "You must provide an argument table when creating RunInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["TagSpecifications"] = args["TagSpecifications"],
		["MinCount"] = args["MinCount"],
		["EbsOptimized"] = args["EbsOptimized"],
		["RamdiskId"] = args["RamdiskId"],
		["Monitoring"] = args["Monitoring"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["CpuOptions"] = args["CpuOptions"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["SecurityGroups"] = args["SecurityGroups"],
		["CreditSpecification"] = args["CreditSpecification"],
		["ClientToken"] = args["ClientToken"],
		["SubnetId"] = args["SubnetId"],
		["InstanceType"] = args["InstanceType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
		["AdditionalInfo"] = args["AdditionalInfo"],
		["Placement"] = args["Placement"],
		["LaunchTemplate"] = args["LaunchTemplate"],
		["CapacityReservationSpecification"] = args["CapacityReservationSpecification"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["KernelId"] = args["KernelId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["UserData"] = args["UserData"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["InstanceMarketOptions"] = args["InstanceMarketOptions"],
		["ElasticGpuSpecification"] = args["ElasticGpuSpecification"],
		["MaxCount"] = args["MaxCount"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["DisableApiTermination"] = args["DisableApiTermination"],
	}
	asserts.AssertRunInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpnConnectionRequest = { ["CustomerGatewayId"] = true, ["DryRun"] = true, ["Type"] = true, ["VpnGatewayId"] = true, ["Options"] = true, nil }

function asserts.AssertCreateVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["Options"] then asserts.AssertVpnConnectionOptionsSpecification(struct["Options"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionRequest[k], "CreateVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRequest
-- <p>Contains the parameters for CreateVpnConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Type [String] <p>The type of VPN connection (<code>ipsec.1</code>).</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * Options [VpnConnectionOptionsSpecification] <p>The options for the VPN connection.</p>
-- Required key: CustomerGatewayId
-- Required key: Type
-- Required key: VpnGatewayId
-- @return CreateVpnConnectionRequest structure as a key-value pair table
function M.CreateVpnConnectionRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpnConnectionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["DryRun"] = args["DryRun"],
		["Type"] = args["Type"],
		["VpnGatewayId"] = args["VpnGatewayId"],
		["Options"] = args["Options"],
	}
	asserts.AssertCreateVpnConnectionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyLaunchTemplateResult = { ["LaunchTemplate"] = true, nil }

function asserts.AssertModifyLaunchTemplateResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyLaunchTemplateResult to be of type 'table'")
	if struct["LaunchTemplate"] then asserts.AssertLaunchTemplate(struct["LaunchTemplate"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyLaunchTemplateResult[k], "ModifyLaunchTemplateResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyLaunchTemplateResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplate [LaunchTemplate] <p>Information about the launch template.</p>
-- @return ModifyLaunchTemplateResult structure as a key-value pair table
function M.ModifyLaunchTemplateResult(args)
	assert(args, "You must provide an argument table when creating ModifyLaunchTemplateResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplate"] = args["LaunchTemplate"],
	}
	asserts.AssertModifyLaunchTemplateResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ByoipCidr = { ["Cidr"] = true, ["State"] = true, ["Description"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertByoipCidr(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ByoipCidr to be of type 'table'")
	if struct["Cidr"] then asserts.AssertString(struct["Cidr"]) end
	if struct["State"] then asserts.AssertByoipCidrState(struct["State"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ByoipCidr[k], "ByoipCidr contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ByoipCidr
-- <p>Information about an address range that is provisioned for use with your AWS resources through bring your own IP addresses (BYOIP).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cidr [String] <p>The public IPv4 address range, in CIDR notation.</p>
-- * State [ByoipCidrState] <p>The state of the address pool.</p>
-- * Description [String] <p>The description of the address range.</p>
-- * StatusMessage [String] <p>Upon success, contains the ID of the address pool. Otherwise, contains an error message.</p>
-- @return ByoipCidr structure as a key-value pair table
function M.ByoipCidr(args)
	assert(args, "You must provide an argument table when creating ByoipCidr")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Cidr"] = args["Cidr"],
		["State"] = args["State"],
		["Description"] = args["Description"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertByoipCidr(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotFleetInstancesResponse = { ["ActiveInstances"] = true, ["SpotFleetRequestId"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetInstancesResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesResponse to be of type 'table'")
	assert(struct["ActiveInstances"], "Expected key ActiveInstances to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["ActiveInstances"] then asserts.AssertActiveInstanceSet(struct["ActiveInstances"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetInstancesResponse[k], "DescribeSpotFleetInstancesResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesResponse
-- <p>Contains the output of DescribeSpotFleetInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ActiveInstances [ActiveInstanceSet] <p>The running instances. This list is refreshed periodically and might be out of date.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required key: ActiveInstances
-- Required key: SpotFleetRequestId
-- @return DescribeSpotFleetInstancesResponse structure as a key-value pair table
function M.DescribeSpotFleetInstancesResponse(args)
	assert(args, "You must provide an argument table when creating DescribeSpotFleetInstancesResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ActiveInstances"] = args["ActiveInstances"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSpotFleetInstancesResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpnConnection = { ["Category"] = true, ["VpnConnectionId"] = true, ["Tags"] = true, ["CustomerGatewayConfiguration"] = true, ["Routes"] = true, ["State"] = true, ["VpnGatewayId"] = true, ["CustomerGatewayId"] = true, ["Type"] = true, ["Options"] = true, ["VgwTelemetry"] = true, nil }

function asserts.AssertVpnConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnection to be of type 'table'")
	if struct["Category"] then asserts.AssertString(struct["Category"]) end
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["CustomerGatewayConfiguration"] then asserts.AssertString(struct["CustomerGatewayConfiguration"]) end
	if struct["Routes"] then asserts.AssertVpnStaticRouteList(struct["Routes"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	if struct["Options"] then asserts.AssertVpnConnectionOptions(struct["Options"]) end
	if struct["VgwTelemetry"] then asserts.AssertVgwTelemetryList(struct["VgwTelemetry"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnection[k], "VpnConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnection
-- <p>Describes a VPN connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Category [String] <p>The category of the VPN connection. A value of <code>VPN</code> indicates an AWS VPN connection. A value of <code>VPN-Classic</code> indicates an AWS Classic VPN connection. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_VPN.html#vpn-categories">AWS Managed VPN Categories</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * Tags [TagList] <p>Any tags assigned to the VPN connection.</p>
-- * CustomerGatewayConfiguration [String] <p>The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the <a>CreateVpnConnection</a> response; however, it's present in the <a>DescribeVpnConnections</a> response only if the VPN connection is in the <code>pending</code> or <code>available</code> state.</p>
-- * Routes [VpnStaticRouteList] <p>The static routes associated with the VPN connection.</p>
-- * State [VpnState] <p>The current state of the VPN connection.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>
-- * CustomerGatewayId [String] <p>The ID of the customer gateway at your end of the VPN connection.</p>
-- * Type [GatewayType] <p>The type of VPN connection.</p>
-- * Options [VpnConnectionOptions] <p>The VPN connection options.</p>
-- * VgwTelemetry [VgwTelemetryList] <p>Information about the VPN tunnel.</p>
-- @return VpnConnection structure as a key-value pair table
function M.VpnConnection(args)
	assert(args, "You must provide an argument table when creating VpnConnection")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Category"] = args["Category"],
		["VpnConnectionId"] = args["VpnConnectionId"],
		["Tags"] = args["Tags"],
		["CustomerGatewayConfiguration"] = args["CustomerGatewayConfiguration"],
		["Routes"] = args["Routes"],
		["State"] = args["State"],
		["VpnGatewayId"] = args["VpnGatewayId"],
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["Type"] = args["Type"],
		["Options"] = args["Options"],
		["VgwTelemetry"] = args["VgwTelemetry"],
	}
	asserts.AssertVpnConnection(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PurchaseReservedInstancesOfferingResult = { ["ReservedInstancesId"] = true, nil }

function asserts.AssertPurchaseReservedInstancesOfferingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseReservedInstancesOfferingResult to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseReservedInstancesOfferingResult[k], "PurchaseReservedInstancesOfferingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseReservedInstancesOfferingResult
-- <p>Contains the output of PurchaseReservedInstancesOffering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The IDs of the purchased Reserved Instances.</p>
-- @return PurchaseReservedInstancesOfferingResult structure as a key-value pair table
function M.PurchaseReservedInstancesOfferingResult(args)
	assert(args, "You must provide an argument table when creating PurchaseReservedInstancesOfferingResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
	}
	asserts.AssertPurchaseReservedInstancesOfferingResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSubnetsResult = { ["Subnets"] = true, nil }

function asserts.AssertDescribeSubnetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsResult to be of type 'table'")
	if struct["Subnets"] then asserts.AssertSubnetList(struct["Subnets"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSubnetsResult[k], "DescribeSubnetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Subnets [SubnetList] <p>Information about one or more subnets.</p>
-- @return DescribeSubnetsResult structure as a key-value pair table
function M.DescribeSubnetsResult(args)
	assert(args, "You must provide an argument table when creating DescribeSubnetsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Subnets"] = args["Subnets"],
	}
	asserts.AssertDescribeSubnetsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisableVpcClassicLinkResult = { ["Return"] = true, nil }

function asserts.AssertDisableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkResult[k], "DisableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DisableVpcClassicLinkResult structure as a key-value pair table
function M.DisableVpcClassicLinkResult(args)
	assert(args, "You must provide an argument table when creating DisableVpcClassicLinkResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDisableVpcClassicLinkResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AcceptVpcPeeringConnectionResult = { ["VpcPeeringConnection"] = true, nil }

function asserts.AssertAcceptVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then asserts.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcPeeringConnectionResult[k], "AcceptVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
-- @return AcceptVpcPeeringConnectionResult structure as a key-value pair table
function M.AcceptVpcPeeringConnectionResult(args)
	assert(args, "You must provide an argument table when creating AcceptVpcPeeringConnectionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcPeeringConnection"] = args["VpcPeeringConnection"],
	}
	asserts.AssertAcceptVpcPeeringConnectionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyReservedInstancesRequest = { ["TargetConfigurations"] = true, ["ReservedInstancesIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertModifyReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyReservedInstancesRequest to be of type 'table'")
	assert(struct["ReservedInstancesIds"], "Expected key ReservedInstancesIds to exist in table")
	assert(struct["TargetConfigurations"], "Expected key TargetConfigurations to exist in table")
	if struct["TargetConfigurations"] then asserts.AssertReservedInstancesConfigurationList(struct["TargetConfigurations"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyReservedInstancesRequest[k], "ModifyReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyReservedInstancesRequest
-- <p>Contains the parameters for ModifyReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetConfigurations [ReservedInstancesConfigurationList] <p>The configuration settings for the Reserved Instances to modify.</p>
-- * ReservedInstancesIds [ReservedInstancesIdStringList] <p>The IDs of the Reserved Instances to modify.</p>
-- * ClientToken [String] <p>A unique, case-sensitive token you provide to ensure idempotency of your modification request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: ReservedInstancesIds
-- Required key: TargetConfigurations
-- @return ModifyReservedInstancesRequest structure as a key-value pair table
function M.ModifyReservedInstancesRequest(args)
	assert(args, "You must provide an argument table when creating ModifyReservedInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TargetConfigurations"] = args["TargetConfigurations"],
		["ReservedInstancesIds"] = args["ReservedInstancesIds"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertModifyReservedInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstanceReservationValue = { ["ReservedInstanceId"] = true, ["ReservationValue"] = true, nil }

function asserts.AssertReservedInstanceReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceReservationValue to be of type 'table'")
	if struct["ReservedInstanceId"] then asserts.AssertString(struct["ReservedInstanceId"]) end
	if struct["ReservationValue"] then asserts.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstanceReservationValue[k], "ReservedInstanceReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceReservationValue
-- <p>The total value of the Convertible Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstanceId [String] <p>The ID of the Convertible Reserved Instance that you are exchanging.</p>
-- * ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instance that you are exchanging.</p>
-- @return ReservedInstanceReservationValue structure as a key-value pair table
function M.ReservedInstanceReservationValue(args)
	assert(args, "You must provide an argument table when creating ReservedInstanceReservationValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstanceId"] = args["ReservedInstanceId"],
		["ReservationValue"] = args["ReservationValue"],
	}
	asserts.AssertReservedInstanceReservationValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreditSpecification = { ["CpuCredits"] = true, nil }

function asserts.AssertCreditSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreditSpecification to be of type 'table'")
	if struct["CpuCredits"] then asserts.AssertString(struct["CpuCredits"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreditSpecification[k], "CreditSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreditSpecification
-- <p>Describes the credit option for CPU usage of a T2 or T3 instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CpuCredits [String] <p>The credit option for CPU usage of a T2 or T3 instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>
-- @return CreditSpecification structure as a key-value pair table
function M.CreditSpecification(args)
	assert(args, "You must provide an argument table when creating CreditSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CpuCredits"] = args["CpuCredits"],
	}
	asserts.AssertCreditSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotFleetRequestsRequest = { ["SpotFleetRequestIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsRequest to be of type 'table'")
	if struct["SpotFleetRequestIds"] then asserts.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestsRequest[k], "DescribeSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsRequest
-- <p>Contains the parameters for DescribeSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot Fleet requests.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @return DescribeSpotFleetRequestsRequest structure as a key-value pair table
function M.DescribeSpotFleetRequestsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSpotFleetRequestsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestIds"] = args["SpotFleetRequestIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeSpotFleetRequestsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetConsoleOutputRequest = { ["InstanceId"] = true, ["DryRun"] = true, ["Latest"] = true, nil }

function asserts.AssertGetConsoleOutputRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Latest"] then asserts.AssertBoolean(struct["Latest"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleOutputRequest[k], "GetConsoleOutputRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputRequest
-- <p>Contains the parameters for GetConsoleOutput.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Latest [Boolean] <p>When enabled, retrieves the latest console output for the instance.</p> <p>Default: disabled (<code>false</code>)</p>
-- Required key: InstanceId
-- @return GetConsoleOutputRequest structure as a key-value pair table
function M.GetConsoleOutputRequest(args)
	assert(args, "You must provide an argument table when creating GetConsoleOutputRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
		["Latest"] = args["Latest"],
	}
	asserts.AssertGetConsoleOutputRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyInstanceCapacityReservationAttributesRequest = { ["InstanceId"] = true, ["CapacityReservationSpecification"] = true, ["DryRun"] = true, nil }

function asserts.AssertModifyInstanceCapacityReservationAttributesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceCapacityReservationAttributesRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["CapacityReservationSpecification"], "Expected key CapacityReservationSpecification to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["CapacityReservationSpecification"] then asserts.AssertCapacityReservationSpecification(struct["CapacityReservationSpecification"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstanceCapacityReservationAttributesRequest[k], "ModifyInstanceCapacityReservationAttributesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceCapacityReservationAttributesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance to be modified.</p>
-- * CapacityReservationSpecification [CapacityReservationSpecification] <p>Information about the Capacity Reservation targeting option.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- Required key: CapacityReservationSpecification
-- @return ModifyInstanceCapacityReservationAttributesRequest structure as a key-value pair table
function M.ModifyInstanceCapacityReservationAttributesRequest(args)
	assert(args, "You must provide an argument table when creating ModifyInstanceCapacityReservationAttributesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["CapacityReservationSpecification"] = args["CapacityReservationSpecification"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertModifyInstanceCapacityReservationAttributesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelCapacityReservationRequest = { ["CapacityReservationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCancelCapacityReservationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelCapacityReservationRequest to be of type 'table'")
	assert(struct["CapacityReservationId"], "Expected key CapacityReservationId to exist in table")
	if struct["CapacityReservationId"] then asserts.AssertString(struct["CapacityReservationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelCapacityReservationRequest[k], "CancelCapacityReservationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelCapacityReservationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationId [String] <p>The ID of the Capacity Reservation to be cancelled.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: CapacityReservationId
-- @return CancelCapacityReservationRequest structure as a key-value pair table
function M.CancelCapacityReservationRequest(args)
	assert(args, "You must provide an argument table when creating CancelCapacityReservationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationId"] = args["CapacityReservationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCancelCapacityReservationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyInstanceCreditSpecificationRequest = { ["InstanceCreditSpecifications"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertModifyInstanceCreditSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceCreditSpecificationRequest to be of type 'table'")
	assert(struct["InstanceCreditSpecifications"], "Expected key InstanceCreditSpecifications to exist in table")
	if struct["InstanceCreditSpecifications"] then asserts.AssertInstanceCreditSpecificationListRequest(struct["InstanceCreditSpecifications"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstanceCreditSpecificationRequest[k], "ModifyInstanceCreditSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceCreditSpecificationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCreditSpecifications [InstanceCreditSpecificationListRequest] <p>Information about the credit option for CPU usage.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>A unique, case-sensitive token that you provide to ensure idempotency of your modification request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: InstanceCreditSpecifications
-- @return ModifyInstanceCreditSpecificationRequest structure as a key-value pair table
function M.ModifyInstanceCreditSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating ModifyInstanceCreditSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceCreditSpecifications"] = args["InstanceCreditSpecifications"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertModifyInstanceCreditSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFlowLogsResult = { ["FlowLogs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFlowLogsResult to be of type 'table'")
	if struct["FlowLogs"] then asserts.AssertFlowLogSet(struct["FlowLogs"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFlowLogsResult[k], "DescribeFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFlowLogsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FlowLogs [FlowLogSet] <p>Information about the flow logs.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeFlowLogsResult structure as a key-value pair table
function M.DescribeFlowLogsResult(args)
	assert(args, "You must provide an argument table when creating DescribeFlowLogsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FlowLogs"] = args["FlowLogs"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFlowLogsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeStatusInfo = { ["Status"] = true, ["Details"] = true, nil }

function asserts.AssertVolumeStatusInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusInfo to be of type 'table'")
	if struct["Status"] then asserts.AssertVolumeStatusInfoStatus(struct["Status"]) end
	if struct["Details"] then asserts.AssertVolumeStatusDetailsList(struct["Details"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusInfo[k], "VolumeStatusInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusInfo
-- <p>Describes the status of a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [VolumeStatusInfoStatus] <p>The status of the volume.</p>
-- * Details [VolumeStatusDetailsList] <p>The details of the volume status.</p>
-- @return VolumeStatusInfo structure as a key-value pair table
function M.VolumeStatusInfo(args)
	assert(args, "You must provide an argument table when creating VolumeStatusInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Details"] = args["Details"],
	}
	asserts.AssertVolumeStatusInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ClassicLoadBalancer = { ["Name"] = true, nil }

function asserts.AssertClassicLoadBalancer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLoadBalancer to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLoadBalancer[k], "ClassicLoadBalancer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLoadBalancer
-- <p>Describes a Classic Load Balancer.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Name [String] <p>The name of the load balancer.</p>
-- Required key: Name
-- @return ClassicLoadBalancer structure as a key-value pair table
function M.ClassicLoadBalancer(args)
	assert(args, "You must provide an argument table when creating ClassicLoadBalancer")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Name"] = args["Name"],
	}
	asserts.AssertClassicLoadBalancer(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PeeringConnectionOptions = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertPeeringConnectionOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PeeringConnectionOptions to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.PeeringConnectionOptions[k], "PeeringConnectionOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PeeringConnectionOptions
-- <p>Describes the VPC peering connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>
-- * AllowDnsResolutionFromRemoteVpc [Boolean] <p>If true, the public DNS hostnames of instances in the specified VPC resolve to private IP addresses when queried from instances in the peer VPC.</p>
-- * AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC using ClassicLink to instances in a peer VPC.</p>
-- @return PeeringConnectionOptions structure as a key-value pair table
function M.PeeringConnectionOptions(args)
	assert(args, "You must provide an argument table when creating PeeringConnectionOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = args["AllowEgressFromLocalVpcToRemoteClassicLink"],
		["AllowDnsResolutionFromRemoteVpc"] = args["AllowDnsResolutionFromRemoteVpc"],
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = args["AllowEgressFromLocalClassicLinkToRemoteVpc"],
	}
	asserts.AssertPeeringConnectionOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Vpc = { ["VpcId"] = true, ["InstanceTenancy"] = true, ["Tags"] = true, ["CidrBlockAssociationSet"] = true, ["Ipv6CidrBlockAssociationSet"] = true, ["State"] = true, ["DhcpOptionsId"] = true, ["CidrBlock"] = true, ["IsDefault"] = true, nil }

function asserts.AssertVpc(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Vpc to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["CidrBlockAssociationSet"] then asserts.AssertVpcCidrBlockAssociationSet(struct["CidrBlockAssociationSet"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then asserts.AssertVpcIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["State"] then asserts.AssertVpcState(struct["State"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["IsDefault"] then asserts.AssertBoolean(struct["IsDefault"]) end
	for k,_ in pairs(struct) do
		assert(keys.Vpc[k], "Vpc contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Vpc
-- <p>Describes a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * InstanceTenancy [Tenancy] <p>The allowed tenancy of instances launched into the VPC.</p>
-- * Tags [TagList] <p>Any tags assigned to the VPC.</p>
-- * CidrBlockAssociationSet [VpcCidrBlockAssociationSet] <p>Information about the IPv4 CIDR blocks associated with the VPC.</p>
-- * Ipv6CidrBlockAssociationSet [VpcIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the VPC.</p>
-- * State [VpcState] <p>The current state of the VPC.</p>
-- * DhcpOptionsId [String] <p>The ID of the set of DHCP options you've associated with the VPC (or <code>default</code> if the default options are associated with the VPC).</p>
-- * CidrBlock [String] <p>The primary IPv4 CIDR block for the VPC.</p>
-- * IsDefault [Boolean] <p>Indicates whether the VPC is the default VPC.</p>
-- @return Vpc structure as a key-value pair table
function M.Vpc(args)
	assert(args, "You must provide an argument table when creating Vpc")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["Tags"] = args["Tags"],
		["CidrBlockAssociationSet"] = args["CidrBlockAssociationSet"],
		["Ipv6CidrBlockAssociationSet"] = args["Ipv6CidrBlockAssociationSet"],
		["State"] = args["State"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
		["CidrBlock"] = args["CidrBlock"],
		["IsDefault"] = args["IsDefault"],
	}
	asserts.AssertVpc(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointServicesResult = { ["ServiceDetails"] = true, ["NextToken"] = true, ["ServiceNames"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesResult to be of type 'table'")
	if struct["ServiceDetails"] then asserts.AssertServiceDetailSet(struct["ServiceDetails"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ServiceNames"] then asserts.AssertValueStringList(struct["ServiceNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicesResult[k], "DescribeVpcEndpointServicesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesResult
-- <p>Contains the output of DescribeVpcEndpointServices.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceDetails [ServiceDetailSet] <p>Information about the service.</p>
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * ServiceNames [ValueStringList] <p>A list of supported services.</p>
-- @return DescribeVpcEndpointServicesResult structure as a key-value pair table
function M.DescribeVpcEndpointServicesResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointServicesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceDetails"] = args["ServiceDetails"],
		["NextToken"] = args["NextToken"],
		["ServiceNames"] = args["ServiceNames"],
	}
	asserts.AssertDescribeVpcEndpointServicesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TerminateInstancesResult = { ["TerminatingInstances"] = true, nil }

function asserts.AssertTerminateInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesResult to be of type 'table'")
	if struct["TerminatingInstances"] then asserts.AssertInstanceStateChangeList(struct["TerminatingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateInstancesResult[k], "TerminateInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesResult
-- <p>Contains the output of TerminateInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TerminatingInstances [InstanceStateChangeList] <p>Information about one or more terminated instances.</p>
-- @return TerminateInstancesResult structure as a key-value pair table
function M.TerminateInstancesResult(args)
	assert(args, "You must provide an argument table when creating TerminateInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TerminatingInstances"] = args["TerminatingInstances"],
	}
	asserts.AssertTerminateInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceRouteTableAssociationRequest = { ["RouteTableId"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertReplaceRouteTableAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteTableAssociationRequest[k], "ReplaceRouteTableAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTableId [String] <p>The ID of the new route table to associate with the subnet.</p>
-- * AssociationId [String] <p>The association ID.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: AssociationId
-- Required key: RouteTableId
-- @return ReplaceRouteTableAssociationRequest structure as a key-value pair table
function M.ReplaceRouteTableAssociationRequest(args)
	assert(args, "You must provide an argument table when creating ReplaceRouteTableAssociationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["RouteTableId"] = args["RouteTableId"],
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertReplaceRouteTableAssociationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelBundleTaskResult = { ["BundleTask"] = true, nil }

function asserts.AssertCancelBundleTaskResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskResult to be of type 'table'")
	if struct["BundleTask"] then asserts.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelBundleTaskResult[k], "CancelBundleTaskResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskResult
-- <p>Contains the output of CancelBundleTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BundleTask [BundleTask] <p>Information about the bundle task.</p>
-- @return CancelBundleTaskResult structure as a key-value pair table
function M.CancelBundleTaskResult(args)
	assert(args, "You must provide an argument table when creating CancelBundleTaskResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BundleTask"] = args["BundleTask"],
	}
	asserts.AssertCancelBundleTaskResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcEndpointConnectionNotificationsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteVpcEndpointConnectionNotificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointConnectionNotificationsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointConnectionNotificationsResult[k], "DeleteVpcEndpointConnectionNotificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointConnectionNotificationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the notifications that could not be deleted successfully.</p>
-- @return DeleteVpcEndpointConnectionNotificationsResult structure as a key-value pair table
function M.DeleteVpcEndpointConnectionNotificationsResult(args)
	assert(args, "You must provide an argument table when creating DeleteVpcEndpointConnectionNotificationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertDeleteVpcEndpointConnectionNotificationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReportInstanceStatusRequest = { ["Status"] = true, ["ReasonCodes"] = true, ["DryRun"] = true, ["Description"] = true, ["Instances"] = true, ["StartTime"] = true, ["EndTime"] = true, nil }

function asserts.AssertReportInstanceStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReportInstanceStatusRequest to be of type 'table'")
	assert(struct["Instances"], "Expected key Instances to exist in table")
	assert(struct["ReasonCodes"], "Expected key ReasonCodes to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	if struct["Status"] then asserts.AssertReportStatusType(struct["Status"]) end
	if struct["ReasonCodes"] then asserts.AssertReasonCodesList(struct["ReasonCodes"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Instances"] then asserts.AssertInstanceIdStringList(struct["Instances"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReportInstanceStatusRequest[k], "ReportInstanceStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReportInstanceStatusRequest
-- <p>Contains the parameters for ReportInstanceStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [ReportStatusType] <p>The status of all instances listed.</p>
-- * ReasonCodes [ReasonCodesList] <p>One or more reason codes that describe the health state of your instance.</p> <ul> <li> <p> <code>instance-stuck-in-state</code>: My instance is stuck in a state.</p> </li> <li> <p> <code>unresponsive</code>: My instance is unresponsive.</p> </li> <li> <p> <code>not-accepting-credentials</code>: My instance is not accepting my credentials.</p> </li> <li> <p> <code>password-not-available</code>: A password is not available for my instance.</p> </li> <li> <p> <code>performance-network</code>: My instance is experiencing performance problems that I believe are network related.</p> </li> <li> <p> <code>performance-instance-store</code>: My instance is experiencing performance problems that I believe are related to the instance stores.</p> </li> <li> <p> <code>performance-ebs-volume</code>: My instance is experiencing performance problems that I believe are related to an EBS volume.</p> </li> <li> <p> <code>performance-other</code>: My instance is experiencing performance problems.</p> </li> <li> <p> <code>other</code>: [explain using the description parameter]</p> </li> </ul>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>Descriptive text about the health state of your instance.</p>
-- * Instances [InstanceIdStringList] <p>One or more instances.</p>
-- * StartTime [DateTime] <p>The time at which the reported instance health state began.</p>
-- * EndTime [DateTime] <p>The time at which the reported instance health state ended.</p>
-- Required key: Instances
-- Required key: ReasonCodes
-- Required key: Status
-- @return ReportInstanceStatusRequest structure as a key-value pair table
function M.ReportInstanceStatusRequest(args)
	assert(args, "You must provide an argument table when creating ReportInstanceStatusRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["ReasonCodes"] = args["ReasonCodes"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Instances"] = args["Instances"],
		["StartTime"] = args["StartTime"],
		["EndTime"] = args["EndTime"],
	}
	asserts.AssertReportInstanceStatusRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EbsInstanceBlockDeviceSpecification = { ["DeleteOnTermination"] = true, ["VolumeId"] = true, nil }

function asserts.AssertEbsInstanceBlockDeviceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDeviceSpecification to be of type 'table'")
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsInstanceBlockDeviceSpecification[k], "EbsInstanceBlockDeviceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDeviceSpecification
-- <p>Describes information used to set up an EBS volume specified in a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- * VolumeId [String] <p>The ID of the EBS volume.</p>
-- @return EbsInstanceBlockDeviceSpecification structure as a key-value pair table
function M.EbsInstanceBlockDeviceSpecification(args)
	assert(args, "You must provide an argument table when creating EbsInstanceBlockDeviceSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertEbsInstanceBlockDeviceSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumeAttributeResult = { ["AutoEnableIO"] = true, ["ProductCodes"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDescribeVolumeAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeAttributeResult to be of type 'table'")
	if struct["AutoEnableIO"] then asserts.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeAttributeResult[k], "DescribeVolumeAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeAttributeResult
-- <p>Contains the output of DescribeVolumeAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutoEnableIO [AttributeBooleanValue] <p>The state of <code>autoEnableIO</code> attribute.</p>
-- * ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- @return DescribeVolumeAttributeResult structure as a key-value pair table
function M.DescribeVolumeAttributeResult(args)
	assert(args, "You must provide an argument table when creating DescribeVolumeAttributeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutoEnableIO"] = args["AutoEnableIO"],
		["ProductCodes"] = args["ProductCodes"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDescribeVolumeAttributeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstancesId = { ["ReservedInstancesId"] = true, nil }

function asserts.AssertReservedInstancesId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesId to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesId[k], "ReservedInstancesId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesId
-- <p>Describes the ID of a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- @return ReservedInstancesId structure as a key-value pair table
function M.ReservedInstancesId(args)
	assert(args, "You must provide an argument table when creating ReservedInstancesId")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
	}
	asserts.AssertReservedInstancesId(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SecurityGroupIdentifier = { ["GroupName"] = true, ["GroupId"] = true, nil }

function asserts.AssertSecurityGroupIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroupIdentifier to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityGroupIdentifier[k], "SecurityGroupIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroupIdentifier
-- <p>Describes a security group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the security group.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return SecurityGroupIdentifier structure as a key-value pair table
function M.SecurityGroupIdentifier(args)
	assert(args, "You must provide an argument table when creating SecurityGroupIdentifier")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertSecurityGroupIdentifier(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EnableVolumeIORequest = { ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertEnableVolumeIORequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVolumeIORequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVolumeIORequest[k], "EnableVolumeIORequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVolumeIORequest
-- <p>Contains the parameters for EnableVolumeIO.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return EnableVolumeIORequest structure as a key-value pair table
function M.EnableVolumeIORequest(args)
	assert(args, "You must provide an argument table when creating EnableVolumeIORequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertEnableVolumeIORequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttributeValue = { ["Value"] = true, nil }

function asserts.AssertAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeValue to be of type 'table'")
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttributeValue[k], "AttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeValue
-- <p>Describes a value for a resource attribute that is a String.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [String] <p>The attribute value. The value is case-sensitive.</p>
-- @return AttributeValue structure as a key-value pair table
function M.AttributeValue(args)
	assert(args, "You must provide an argument table when creating AttributeValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Value"] = args["Value"],
	}
	asserts.AssertAttributeValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointsRequest = { ["VpcEndpointIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsRequest to be of type 'table'")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointsRequest[k], "DescribeVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsRequest
-- <p>Contains the parameters for DescribeVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointIds [ValueStringList] <p>One or more endpoint IDs.</p>
-- * NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>service-name</code>: The name of the service.</p> </li> <li> <p> <code>vpc-id</code>: The ID of the VPC in which the endpoint resides.</p> </li> <li> <p> <code>vpc-endpoint-id</code>: The ID of the endpoint.</p> </li> <li> <p> <code>vpc-endpoint-state</code>: The state of the endpoint. (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>)</p> </li> </ul>
-- @return DescribeVpcEndpointsRequest structure as a key-value pair table
function M.DescribeVpcEndpointsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcEndpointIds"] = args["VpcEndpointIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpcEndpointsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.HistoryRecord = { ["EventType"] = true, ["EventInformation"] = true, ["Timestamp"] = true, nil }

function asserts.AssertHistoryRecord(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HistoryRecord to be of type 'table'")
	assert(struct["EventInformation"], "Expected key EventInformation to exist in table")
	assert(struct["EventType"], "Expected key EventType to exist in table")
	assert(struct["Timestamp"], "Expected key Timestamp to exist in table")
	if struct["EventType"] then asserts.AssertEventType(struct["EventType"]) end
	if struct["EventInformation"] then asserts.AssertEventInformation(struct["EventInformation"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.HistoryRecord[k], "HistoryRecord contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HistoryRecord
-- <p>Describes an event in the history of the Spot Fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EventType [EventType] <p>The event type.</p> <ul> <li> <p> <code>error</code> - An error with the Spot Fleet request.</p> </li> <li> <p> <code>fleetRequestChange</code> - A change in the status or configuration of the Spot Fleet request.</p> </li> <li> <p> <code>instanceChange</code> - An instance was launched or terminated.</p> </li> <li> <p> <code>Information</code> - An informational event.</p> </li> </ul>
-- * EventInformation [EventInformation] <p>Information about the event.</p>
-- * Timestamp [DateTime] <p>The date and time of the event, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- Required key: EventInformation
-- Required key: EventType
-- Required key: Timestamp
-- @return HistoryRecord structure as a key-value pair table
function M.HistoryRecord(args)
	assert(args, "You must provide an argument table when creating HistoryRecord")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EventType"] = args["EventType"],
		["EventInformation"] = args["EventInformation"],
		["Timestamp"] = args["Timestamp"],
	}
	asserts.AssertHistoryRecord(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotOptions = { ["InstanceInterruptionBehavior"] = true, ["InstancePoolsToUseCount"] = true, ["AllocationStrategy"] = true, nil }

function asserts.AssertSpotOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotOptions to be of type 'table'")
	if struct["InstanceInterruptionBehavior"] then asserts.AssertSpotInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	if struct["InstancePoolsToUseCount"] then asserts.AssertInteger(struct["InstancePoolsToUseCount"]) end
	if struct["AllocationStrategy"] then asserts.AssertSpotAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotOptions[k], "SpotOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotOptions
-- <p>Describes the configuration of Spot Instances in an EC2 Fleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceInterruptionBehavior [SpotInstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
-- * InstancePoolsToUseCount [Integer] <p>The number of Spot pools across which to allocate your target Spot capacity. Valid only when <b>AllocationStrategy</b> is set to <code>lowestPrice</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.</p>
-- * AllocationStrategy [SpotAllocationStrategy] <p>Indicates how to allocate the target capacity across the Spot pools specified by the Spot Fleet request. The default is <code>lowest-price</code>.</p>
-- @return SpotOptions structure as a key-value pair table
function M.SpotOptions(args)
	assert(args, "You must provide an argument table when creating SpotOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
		["InstancePoolsToUseCount"] = args["InstancePoolsToUseCount"],
		["AllocationStrategy"] = args["AllocationStrategy"],
	}
	asserts.AssertSpotOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstanceRecurrence = { ["OccurrenceDaySet"] = true, ["Interval"] = true, ["Frequency"] = true, ["OccurrenceRelativeToEnd"] = true, ["OccurrenceUnit"] = true, nil }

function asserts.AssertScheduledInstanceRecurrence(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceRecurrence to be of type 'table'")
	if struct["OccurrenceDaySet"] then asserts.AssertOccurrenceDaySet(struct["OccurrenceDaySet"]) end
	if struct["Interval"] then asserts.AssertInteger(struct["Interval"]) end
	if struct["Frequency"] then asserts.AssertString(struct["Frequency"]) end
	if struct["OccurrenceRelativeToEnd"] then asserts.AssertBoolean(struct["OccurrenceRelativeToEnd"]) end
	if struct["OccurrenceUnit"] then asserts.AssertString(struct["OccurrenceUnit"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceRecurrence[k], "ScheduledInstanceRecurrence contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceRecurrence
-- <p>Describes the recurring schedule for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OccurrenceDaySet [OccurrenceDaySet] <p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).</p>
-- * Interval [Integer] <p>The interval quantity. The interval unit depends on the value of <code>frequency</code>. For example, every 2 weeks or every 2 months.</p>
-- * Frequency [String] <p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>
-- * OccurrenceRelativeToEnd [Boolean] <p>Indicates whether the occurrence is relative to the end of the specified week or month.</p>
-- * OccurrenceUnit [String] <p>The unit for <code>occurrenceDaySet</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).</p>
-- @return ScheduledInstanceRecurrence structure as a key-value pair table
function M.ScheduledInstanceRecurrence(args)
	assert(args, "You must provide an argument table when creating ScheduledInstanceRecurrence")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OccurrenceDaySet"] = args["OccurrenceDaySet"],
		["Interval"] = args["Interval"],
		["Frequency"] = args["Frequency"],
		["OccurrenceRelativeToEnd"] = args["OccurrenceRelativeToEnd"],
		["OccurrenceUnit"] = args["OccurrenceUnit"],
	}
	asserts.AssertScheduledInstanceRecurrence(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcRequest[k], "DeleteVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return DeleteVpcRequest structure as a key-value pair table
function M.DeleteVpcRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpcRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteVpcRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSnapshotsRequest = { ["OwnerIds"] = true, ["DryRun"] = true, ["SnapshotIds"] = true, ["MaxResults"] = true, ["Filters"] = true, ["RestorableByUserIds"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSnapshotsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsRequest to be of type 'table'")
	if struct["OwnerIds"] then asserts.AssertOwnerStringList(struct["OwnerIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotIds"] then asserts.AssertSnapshotIdStringList(struct["SnapshotIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["RestorableByUserIds"] then asserts.AssertRestorableByStringList(struct["RestorableByUserIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotsRequest[k], "DescribeSnapshotsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsRequest
-- <p>Contains the parameters for DescribeSnapshots.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerIds [OwnerStringList] <p>Returns the snapshots owned by the specified owner. Multiple owners can be specified.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SnapshotIds [SnapshotIdStringList] <p>One or more snapshot IDs.</p> <p>Default: Describes snapshots for which you have launch permissions.</p>
-- * MaxResults [Integer] <p>The maximum number of snapshot results returned by <code>DescribeSnapshots</code> in paginated output. When this parameter is used, <code>DescribeSnapshots</code> only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another <code>DescribeSnapshots</code> request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeSnapshots</code> returns all results. You cannot specify this parameter and the snapshot IDs parameter in the same request.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>description</code> - A description of the snapshot.</p> </li> <li> <p> <code>owner-alias</code> - Value from an Amazon-maintained list (<code>amazon</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console.</p> </li> <li> <p> <code>owner-id</code> - The ID of the AWS account that owns the snapshot.</p> </li> <li> <p> <code>progress</code> - The progress of the snapshot, as a percentage (for example, 80%).</p> </li> <li> <p> <code>snapshot-id</code> - The snapshot ID.</p> </li> <li> <p> <code>start-time</code> - The time stamp when the snapshot was initiated.</p> </li> <li> <p> <code>status</code> - The status of the snapshot (<code>pending</code> | <code>completed</code> | <code>error</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>volume-id</code> - The ID of the volume the snapshot is for.</p> </li> <li> <p> <code>volume-size</code> - The size of the volume, in GiB.</p> </li> </ul>
-- * RestorableByUserIds [RestorableByStringList] <p>One or more AWS accounts IDs that can create volumes from the snapshot.</p>
-- * NextToken [String] <p>The <code>NextToken</code> value returned from a previous paginated <code>DescribeSnapshots</code> request where <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the <code>NextToken</code> value. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeSnapshotsRequest structure as a key-value pair table
function M.DescribeSnapshotsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSnapshotsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OwnerIds"] = args["OwnerIds"],
		["DryRun"] = args["DryRun"],
		["SnapshotIds"] = args["SnapshotIds"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["RestorableByUserIds"] = args["RestorableByUserIds"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSnapshotsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PurchaseHostReservationResult = { ["TotalHourlyPrice"] = true, ["Purchase"] = true, ["CurrencyCode"] = true, ["TotalUpfrontPrice"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseHostReservationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationResult to be of type 'table'")
	if struct["TotalHourlyPrice"] then asserts.AssertString(struct["TotalHourlyPrice"]) end
	if struct["Purchase"] then asserts.AssertPurchaseSet(struct["Purchase"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["TotalUpfrontPrice"] then asserts.AssertString(struct["TotalUpfrontPrice"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseHostReservationResult[k], "PurchaseHostReservationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TotalHourlyPrice [String] <p>The total hourly price of the reservation calculated per hour.</p>
-- * Purchase [PurchaseSet] <p>Describes the details of the purchase.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * TotalUpfrontPrice [String] <p>The total amount charged to your account when you purchase the reservation.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- @return PurchaseHostReservationResult structure as a key-value pair table
function M.PurchaseHostReservationResult(args)
	assert(args, "You must provide an argument table when creating PurchaseHostReservationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TotalHourlyPrice"] = args["TotalHourlyPrice"],
		["Purchase"] = args["Purchase"],
		["CurrencyCode"] = args["CurrencyCode"],
		["TotalUpfrontPrice"] = args["TotalUpfrontPrice"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertPurchaseHostReservationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FleetLaunchTemplateConfig = { ["LaunchTemplateSpecification"] = true, ["Overrides"] = true, nil }

function asserts.AssertFleetLaunchTemplateConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FleetLaunchTemplateConfig to be of type 'table'")
	if struct["LaunchTemplateSpecification"] then asserts.AssertFleetLaunchTemplateSpecification(struct["LaunchTemplateSpecification"]) end
	if struct["Overrides"] then asserts.AssertFleetLaunchTemplateOverridesList(struct["Overrides"]) end
	for k,_ in pairs(struct) do
		assert(keys.FleetLaunchTemplateConfig[k], "FleetLaunchTemplateConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FleetLaunchTemplateConfig
-- <p>Describes a launch template and overrides.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateSpecification [FleetLaunchTemplateSpecification] <p>The launch template.</p>
-- * Overrides [FleetLaunchTemplateOverridesList] <p>Any parameters that you specify override the same parameters in the launch template.</p>
-- @return FleetLaunchTemplateConfig structure as a key-value pair table
function M.FleetLaunchTemplateConfig(args)
	assert(args, "You must provide an argument table when creating FleetLaunchTemplateConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateSpecification"] = args["LaunchTemplateSpecification"],
		["Overrides"] = args["Overrides"],
	}
	asserts.AssertFleetLaunchTemplateConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointConnectionNotificationResult = { ["ReturnValue"] = true, nil }

function asserts.AssertModifyVpcEndpointConnectionNotificationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointConnectionNotificationResult to be of type 'table'")
	if struct["ReturnValue"] then asserts.AssertBoolean(struct["ReturnValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointConnectionNotificationResult[k], "ModifyVpcEndpointConnectionNotificationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointConnectionNotificationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReturnValue [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return ModifyVpcEndpointConnectionNotificationResult structure as a key-value pair table
function M.ModifyVpcEndpointConnectionNotificationResult(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointConnectionNotificationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReturnValue"] = args["ReturnValue"],
	}
	asserts.AssertModifyVpcEndpointConnectionNotificationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.BundleInstanceRequest = { ["InstanceId"] = true, ["DryRun"] = true, ["Storage"] = true, nil }

function asserts.AssertBundleInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["Storage"], "Expected key Storage to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Storage"] then asserts.AssertStorage(struct["Storage"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleInstanceRequest[k], "BundleInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceRequest
-- <p>Contains the parameters for BundleInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance to bundle.</p> <p>Type: String</p> <p>Default: None</p> <p>Required: Yes</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Storage [Storage] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- Required key: InstanceId
-- Required key: Storage
-- @return BundleInstanceRequest structure as a key-value pair table
function M.BundleInstanceRequest(args)
	assert(args, "You must provide an argument table when creating BundleInstanceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
		["Storage"] = args["Storage"],
	}
	asserts.AssertBundleInstanceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportVolumeTaskDetails = { ["BytesConverted"] = true, ["Volume"] = true, ["Image"] = true, ["AvailabilityZone"] = true, ["Description"] = true, nil }

function asserts.AssertImportVolumeTaskDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeTaskDetails to be of type 'table'")
	if struct["BytesConverted"] then asserts.AssertLong(struct["BytesConverted"]) end
	if struct["Volume"] then asserts.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDescription(struct["Image"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeTaskDetails[k], "ImportVolumeTaskDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeTaskDetails
-- <p>Describes an import volume task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- * Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- * Image [DiskImageDescription] <p>The image.</p>
-- * AvailabilityZone [String] <p>The Availability Zone where the resulting volume will reside.</p>
-- * Description [String] <p>The description you provided when starting the import volume task.</p>
-- @return ImportVolumeTaskDetails structure as a key-value pair table
function M.ImportVolumeTaskDetails(args)
	assert(args, "You must provide an argument table when creating ImportVolumeTaskDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BytesConverted"] = args["BytesConverted"],
		["Volume"] = args["Volume"],
		["Image"] = args["Image"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Description"] = args["Description"],
	}
	asserts.AssertImportVolumeTaskDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportSnapshotResult = { ["SnapshotTaskDetail"] = true, ["Description"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportSnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportSnapshotResult to be of type 'table'")
	if struct["SnapshotTaskDetail"] then asserts.AssertSnapshotTaskDetail(struct["SnapshotTaskDetail"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportSnapshotResult[k], "ImportSnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportSnapshotResult
-- <p>Contains the output for ImportSnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotTaskDetail [SnapshotTaskDetail] <p>Information about the import snapshot task.</p>
-- * Description [String] <p>A description of the import snapshot task.</p>
-- * ImportTaskId [String] <p>The ID of the import snapshot task.</p>
-- @return ImportSnapshotResult structure as a key-value pair table
function M.ImportSnapshotResult(args)
	assert(args, "You must provide an argument table when creating ImportSnapshotResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SnapshotTaskDetail"] = args["SnapshotTaskDetail"],
		["Description"] = args["Description"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportSnapshotResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeStatusEvent = { ["EventId"] = true, ["EventType"] = true, ["NotBefore"] = true, ["Description"] = true, ["NotAfter"] = true, nil }

function asserts.AssertVolumeStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusEvent to be of type 'table'")
	if struct["EventId"] then asserts.AssertString(struct["EventId"]) end
	if struct["EventType"] then asserts.AssertString(struct["EventType"]) end
	if struct["NotBefore"] then asserts.AssertDateTime(struct["NotBefore"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NotAfter"] then asserts.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusEvent[k], "VolumeStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusEvent
-- <p>Describes a volume status event.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EventId [String] <p>The ID of this event.</p>
-- * EventType [String] <p>The type of this event.</p>
-- * NotBefore [DateTime] <p>The earliest start time of the event.</p>
-- * Description [String] <p>A description of the event.</p>
-- * NotAfter [DateTime] <p>The latest end time of the event.</p>
-- @return VolumeStatusEvent structure as a key-value pair table
function M.VolumeStatusEvent(args)
	assert(args, "You must provide an argument table when creating VolumeStatusEvent")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EventId"] = args["EventId"],
		["EventType"] = args["EventType"],
		["NotBefore"] = args["NotBefore"],
		["Description"] = args["Description"],
		["NotAfter"] = args["NotAfter"],
	}
	asserts.AssertVolumeStatusEvent(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RejectVpcPeeringConnectionResult = { ["Return"] = true, nil }

function asserts.AssertRejectVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcPeeringConnectionResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcPeeringConnectionResult[k], "RejectVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcPeeringConnectionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return RejectVpcPeeringConnectionResult structure as a key-value pair table
function M.RejectVpcPeeringConnectionResult(args)
	assert(args, "You must provide an argument table when creating RejectVpcPeeringConnectionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertRejectVpcPeeringConnectionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFlowLogsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFlowLogsResult[k], "DeleteFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be deleted successfully.</p>
-- @return DeleteFlowLogsResult structure as a key-value pair table
function M.DeleteFlowLogsResult(args)
	assert(args, "You must provide an argument table when creating DeleteFlowLogsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertDeleteFlowLogsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CapacityReservation = { ["CapacityReservationId"] = true, ["EndDateType"] = true, ["AvailabilityZone"] = true, ["EndDate"] = true, ["InstanceMatchCriteria"] = true, ["Tags"] = true, ["EphemeralStorage"] = true, ["CreateDate"] = true, ["AvailableInstanceCount"] = true, ["InstancePlatform"] = true, ["TotalInstanceCount"] = true, ["State"] = true, ["Tenancy"] = true, ["EbsOptimized"] = true, ["InstanceType"] = true, nil }

function asserts.AssertCapacityReservation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CapacityReservation to be of type 'table'")
	if struct["CapacityReservationId"] then asserts.AssertString(struct["CapacityReservationId"]) end
	if struct["EndDateType"] then asserts.AssertEndDateType(struct["EndDateType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["EndDate"] then asserts.AssertDateTime(struct["EndDate"]) end
	if struct["InstanceMatchCriteria"] then asserts.AssertInstanceMatchCriteria(struct["InstanceMatchCriteria"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["EphemeralStorage"] then asserts.AssertBoolean(struct["EphemeralStorage"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["AvailableInstanceCount"] then asserts.AssertInteger(struct["AvailableInstanceCount"]) end
	if struct["InstancePlatform"] then asserts.AssertCapacityReservationInstancePlatform(struct["InstancePlatform"]) end
	if struct["TotalInstanceCount"] then asserts.AssertInteger(struct["TotalInstanceCount"]) end
	if struct["State"] then asserts.AssertCapacityReservationState(struct["State"]) end
	if struct["Tenancy"] then asserts.AssertCapacityReservationTenancy(struct["Tenancy"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.CapacityReservation[k], "CapacityReservation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CapacityReservation
-- <p>Describes a Capacity Reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationId [String] <p>The ID of the Capacity Reservation.</p>
-- * EndDateType [EndDateType] <p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types:</p> <ul> <li> <p> <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it.</p> </li> <li> <p> <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time.</p> </li> </ul>
-- * AvailabilityZone [String] <p>The Availability Zone in which the capacity is reserved.</p>
-- * EndDate [DateTime] <p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to <code>expired</code> when it reaches its end date and time.</p>
-- * InstanceMatchCriteria [InstanceMatchCriteria] <p>Indicates the type of instance launches that the Capacity Reservation accepts. The options include:</p> <ul> <li> <p> <code>open</code> - The Capacity Reservation accepts all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes launch into the Capacity Reservation automatically without specifying any additional parameters.</p> </li> <li> <p> <code>targeted</code> - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. </p> </li> </ul>
-- * Tags [TagList] <p>Any tags assigned to the Capacity Reservation.</p>
-- * EphemeralStorage [Boolean] <p>Indicates whether the Capacity Reservation supports instances with temporary, block-level storage.</p>
-- * CreateDate [DateTime] <p>The date and time at which the Capacity Reservation was created.</p>
-- * AvailableInstanceCount [Integer] <p>The remaining capacity. Indicates the number of instances that can be launched in the Capacity Reservation.</p>
-- * InstancePlatform [CapacityReservationInstancePlatform] <p>The type of operating system for which the Capacity Reservation reserves capacity.</p>
-- * TotalInstanceCount [Integer] <p>The number of instances for which the Capacity Reservation reserves capacity.</p>
-- * State [CapacityReservationState] <p>The current state of the Capacity Reservation. A Capacity Reservation can be in one of the following states:</p> <ul> <li> <p> <code>active</code> - The Capacity Reservation is active and the capacity is available for your use.</p> </li> <li> <p> <code>cancelled</code> - The Capacity Reservation expired automatically at the date and time specified in your request. The reserved capacity is no longer available for your use.</p> </li> <li> <p> <code>expired</code> - The Capacity Reservation was manually cancelled. The reserved capacity is no longer available for your use.</p> </li> <li> <p> <code>pending</code> - The Capacity Reservation request was successful but the capacity provisioning is still pending.</p> </li> <li> <p> <code>failed</code> - The Capacity Reservation request has failed. A request might fail due to invalid request parameters, capacity constraints, or instance limit constraints. Failed requests are retained for 60 minutes.</p> </li> </ul>
-- * Tenancy [CapacityReservationTenancy] <p>Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:</p> <ul> <li> <p> <code>default</code> - The Capacity Reservation is created on hardware that is shared with other AWS accounts.</p> </li> <li> <p> <code>dedicated</code> - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account.</p> </li> </ul>
-- * EbsOptimized [Boolean] <p>Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.</p>
-- * InstanceType [String] <p>The type of instance for which the Capacity Reservation reserves capacity.</p>
-- @return CapacityReservation structure as a key-value pair table
function M.CapacityReservation(args)
	assert(args, "You must provide an argument table when creating CapacityReservation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationId"] = args["CapacityReservationId"],
		["EndDateType"] = args["EndDateType"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["EndDate"] = args["EndDate"],
		["InstanceMatchCriteria"] = args["InstanceMatchCriteria"],
		["Tags"] = args["Tags"],
		["EphemeralStorage"] = args["EphemeralStorage"],
		["CreateDate"] = args["CreateDate"],
		["AvailableInstanceCount"] = args["AvailableInstanceCount"],
		["InstancePlatform"] = args["InstancePlatform"],
		["TotalInstanceCount"] = args["TotalInstanceCount"],
		["State"] = args["State"],
		["Tenancy"] = args["Tenancy"],
		["EbsOptimized"] = args["EbsOptimized"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertCapacityReservation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeLaunchTemplateVersionsRequest = { ["DryRun"] = true, ["Versions"] = true, ["LaunchTemplateId"] = true, ["LaunchTemplateName"] = true, ["MaxResults"] = true, ["Filters"] = true, ["MinVersion"] = true, ["NextToken"] = true, ["MaxVersion"] = true, nil }

function asserts.AssertDescribeLaunchTemplateVersionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeLaunchTemplateVersionsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Versions"] then asserts.AssertVersionStringList(struct["Versions"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MinVersion"] then asserts.AssertString(struct["MinVersion"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxVersion"] then asserts.AssertString(struct["MaxVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeLaunchTemplateVersionsRequest[k], "DescribeLaunchTemplateVersionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeLaunchTemplateVersionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Versions [VersionStringList] <p>One or more versions of the launch template.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 1 and 200.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>create-time</code> - The time the launch template version was created.</p> </li> <li> <p> <code>ebs-optimized</code> - A boolean that indicates whether the instance is optimized for Amazon EBS I/O.</p> </li> <li> <p> <code>iam-instance-profile</code> - The ARN of the IAM instance profile.</p> </li> <li> <p> <code>image-id</code> - The ID of the AMI.</p> </li> <li> <p> <code>instance-type</code> - The instance type.</p> </li> <li> <p> <code>is-default-version</code> - A boolean that indicates whether the launch template version is the default version.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>ram-disk-id</code> - The RAM disk ID.</p> </li> </ul>
-- * MinVersion [String] <p>The version number after which to describe launch template versions.</p>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- * MaxVersion [String] <p>The version number up to which to describe launch template versions.</p>
-- @return DescribeLaunchTemplateVersionsRequest structure as a key-value pair table
function M.DescribeLaunchTemplateVersionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeLaunchTemplateVersionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Versions"] = args["Versions"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["MinVersion"] = args["MinVersion"],
		["NextToken"] = args["NextToken"],
		["MaxVersion"] = args["MaxVersion"],
	}
	asserts.AssertDescribeLaunchTemplateVersionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RejectVpcEndpointConnectionsRequest = { ["VpcEndpointIds"] = true, ["ServiceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertRejectVpcEndpointConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcEndpointConnectionsRequest to be of type 'table'")
	assert(struct["ServiceId"], "Expected key ServiceId to exist in table")
	assert(struct["VpcEndpointIds"], "Expected key VpcEndpointIds to exist in table")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcEndpointConnectionsRequest[k], "RejectVpcEndpointConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcEndpointConnectionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointIds [ValueStringList] <p>The IDs of one or more VPC endpoints.</p>
-- * ServiceId [String] <p>The ID of the service.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: ServiceId
-- Required key: VpcEndpointIds
-- @return RejectVpcEndpointConnectionsRequest structure as a key-value pair table
function M.RejectVpcEndpointConnectionsRequest(args)
	assert(args, "You must provide an argument table when creating RejectVpcEndpointConnectionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcEndpointIds"] = args["VpcEndpointIds"],
		["ServiceId"] = args["ServiceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertRejectVpcEndpointConnectionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FleetLaunchTemplateOverrides = { ["AvailabilityZone"] = true, ["MaxPrice"] = true, ["WeightedCapacity"] = true, ["Priority"] = true, ["SubnetId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertFleetLaunchTemplateOverrides(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FleetLaunchTemplateOverrides to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["MaxPrice"] then asserts.AssertString(struct["MaxPrice"]) end
	if struct["WeightedCapacity"] then asserts.AssertDouble(struct["WeightedCapacity"]) end
	if struct["Priority"] then asserts.AssertDouble(struct["Priority"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.FleetLaunchTemplateOverrides[k], "FleetLaunchTemplateOverrides contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FleetLaunchTemplateOverrides
-- <p>Describes overrides for a launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone in which to launch the instances.</p>
-- * MaxPrice [String] <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
-- * WeightedCapacity [Double] <p>The number of units provided by the specified instance type.</p>
-- * Priority [Double] <p>The priority for the launch template override. If <b>AllocationStrategy</b> is set to <code>prioritized</code>, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. Valid values are whole numbers starting at <code>0</code>. The lower the number, the higher the priority. If no number is set, the override has the lowest priority.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instances.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- @return FleetLaunchTemplateOverrides structure as a key-value pair table
function M.FleetLaunchTemplateOverrides(args)
	assert(args, "You must provide an argument table when creating FleetLaunchTemplateOverrides")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["MaxPrice"] = args["MaxPrice"],
		["WeightedCapacity"] = args["WeightedCapacity"],
		["Priority"] = args["Priority"],
		["SubnetId"] = args["SubnetId"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertFleetLaunchTemplateOverrides(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateCapacityReservationSpecificationResponse = { ["CapacityReservationTarget"] = true, ["CapacityReservationPreference"] = true, nil }

function asserts.AssertLaunchTemplateCapacityReservationSpecificationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateCapacityReservationSpecificationResponse to be of type 'table'")
	if struct["CapacityReservationTarget"] then asserts.AssertCapacityReservationTargetResponse(struct["CapacityReservationTarget"]) end
	if struct["CapacityReservationPreference"] then asserts.AssertCapacityReservationPreference(struct["CapacityReservationPreference"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateCapacityReservationSpecificationResponse[k], "LaunchTemplateCapacityReservationSpecificationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateCapacityReservationSpecificationResponse
-- <p>Information about the Capacity Reservation targeting option.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationTarget [CapacityReservationTargetResponse] <p>Information about the target Capacity Reservation.</p>
-- * CapacityReservationPreference [CapacityReservationPreference] <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>
-- @return LaunchTemplateCapacityReservationSpecificationResponse structure as a key-value pair table
function M.LaunchTemplateCapacityReservationSpecificationResponse(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateCapacityReservationSpecificationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationTarget"] = args["CapacityReservationTarget"],
		["CapacityReservationPreference"] = args["CapacityReservationPreference"],
	}
	asserts.AssertLaunchTemplateCapacityReservationSpecificationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateFlowLogsResult = { ["Unsuccessful"] = true, ["FlowLogIds"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateFlowLogsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFlowLogsResult[k], "CreateFlowLogsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the flow logs that could not be created successfully.</p>
-- * FlowLogIds [ValueStringList] <p>The IDs of the flow logs.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
-- @return CreateFlowLogsResult structure as a key-value pair table
function M.CreateFlowLogsResult(args)
	assert(args, "You must provide an argument table when creating CreateFlowLogsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Unsuccessful"] = args["Unsuccessful"],
		["FlowLogIds"] = args["FlowLogIds"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateFlowLogsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StopInstancesRequest = { ["Force"] = true, ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertStopInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopInstancesRequest[k], "StopInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesRequest
-- <p>Contains the parameters for StopInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Force [Boolean] <p>Forces the instances to stop. The instances do not have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures. This option is not recommended for Windows instances.</p> <p>Default: <code>false</code> </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return StopInstancesRequest structure as a key-value pair table
function M.StopInstancesRequest(args)
	assert(args, "You must provide an argument table when creating StopInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Force"] = args["Force"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertStopInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StopInstancesResult = { ["StoppingInstances"] = true, nil }

function asserts.AssertStopInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StopInstancesResult to be of type 'table'")
	if struct["StoppingInstances"] then asserts.AssertInstanceStateChangeList(struct["StoppingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.StopInstancesResult[k], "StopInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StopInstancesResult
-- <p>Contains the output of StopInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StoppingInstances [InstanceStateChangeList] <p>Information about one or more stopped instances.</p>
-- @return StopInstancesResult structure as a key-value pair table
function M.StopInstancesResult(args)
	assert(args, "You must provide an argument table when creating StopInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StoppingInstances"] = args["StoppingInstances"],
	}
	asserts.AssertStopInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesListingsRequest = { ["ReservedInstancesId"] = true, ["ReservedInstancesListingId"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesListingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsRequest to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesListingsRequest[k], "DescribeReservedInstancesListingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesListings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>One or more Reserved Instance IDs.</p>
-- * ReservedInstancesListingId [String] <p>One or more Reserved Instance listing IDs.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances.</p> </li> <li> <p> <code>reserved-instances-listing-id</code> - The ID of the Reserved Instances listing.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instance listing (<code>pending</code> | <code>active</code> | <code>cancelled</code> | <code>closed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> </ul>
-- @return DescribeReservedInstancesListingsRequest structure as a key-value pair table
function M.DescribeReservedInstancesListingsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesListingsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["ReservedInstancesListingId"] = args["ReservedInstancesListingId"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeReservedInstancesListingsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifySubnetAttributeRequest = { ["SubnetId"] = true, ["MapPublicIpOnLaunch"] = true, ["AssignIpv6AddressOnCreation"] = true, nil }

function asserts.AssertModifySubnetAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifySubnetAttributeRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["MapPublicIpOnLaunch"] then asserts.AssertAttributeBooleanValue(struct["MapPublicIpOnLaunch"]) end
	if struct["AssignIpv6AddressOnCreation"] then asserts.AssertAttributeBooleanValue(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifySubnetAttributeRequest[k], "ModifySubnetAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifySubnetAttributeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * MapPublicIpOnLaunch [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned a public IPv4 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives a public IPv4 address).</p>
-- * AssignIpv6AddressOnCreation [AttributeBooleanValue] <p>Specify <code>true</code> to indicate that network interfaces created in the specified subnet should be assigned an IPv6 address. This includes a network interface that's created when launching an instance into the subnet (the instance therefore receives an IPv6 address). </p> <p>If you enable the IPv6 addressing feature for your subnet, your network interface or instance only receives an IPv6 address if it's created using version <code>2016-11-15</code> or later of the Amazon EC2 API.</p>
-- Required key: SubnetId
-- @return ModifySubnetAttributeRequest structure as a key-value pair table
function M.ModifySubnetAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifySubnetAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["MapPublicIpOnLaunch"] = args["MapPublicIpOnLaunch"],
		["AssignIpv6AddressOnCreation"] = args["AssignIpv6AddressOnCreation"],
	}
	asserts.AssertModifySubnetAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateAddressRequest = { ["PublicIp"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisassociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateAddressRequest to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateAddressRequest[k], "DisassociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateAddressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- * AssociationId [String] <p>[EC2-VPC] The association ID. Required for EC2-VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DisassociateAddressRequest structure as a key-value pair table
function M.DisassociateAddressRequest(args)
	assert(args, "You must provide an argument table when creating DisassociateAddressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDisassociateAddressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ExportTask = { ["Description"] = true, ["InstanceExportDetails"] = true, ["ExportTaskId"] = true, ["State"] = true, ["StatusMessage"] = true, ["ExportToS3Task"] = true, nil }

function asserts.AssertExportTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportTask to be of type 'table'")
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["InstanceExportDetails"] then asserts.AssertInstanceExportDetails(struct["InstanceExportDetails"]) end
	if struct["ExportTaskId"] then asserts.AssertString(struct["ExportTaskId"]) end
	if struct["State"] then asserts.AssertExportTaskState(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ExportToS3Task"] then asserts.AssertExportToS3Task(struct["ExportToS3Task"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportTask[k], "ExportTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportTask
-- <p>Describes an instance export task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [String] <p>A description of the resource being exported.</p>
-- * InstanceExportDetails [InstanceExportDetails] <p>Information about the instance to export.</p>
-- * ExportTaskId [String] <p>The ID of the export task.</p>
-- * State [ExportTaskState] <p>The state of the export task.</p>
-- * StatusMessage [String] <p>The status message related to the export task.</p>
-- * ExportToS3Task [ExportToS3Task] <p>Information about the export task.</p>
-- @return ExportTask structure as a key-value pair table
function M.ExportTask(args)
	assert(args, "You must provide an argument table when creating ExportTask")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Description"] = args["Description"],
		["InstanceExportDetails"] = args["InstanceExportDetails"],
		["ExportTaskId"] = args["ExportTaskId"],
		["State"] = args["State"],
		["StatusMessage"] = args["StatusMessage"],
		["ExportToS3Task"] = args["ExportToS3Task"],
	}
	asserts.AssertExportTask(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportVolumeRequest = { ["Volume"] = true, ["Image"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["Description"] = true, nil }

function asserts.AssertImportVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeRequest to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Volume"] then asserts.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDetail(struct["Image"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeRequest[k], "ImportVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeRequest
-- <p>Contains the parameters for ImportVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Volume [VolumeDetail] <p>The volume size.</p>
-- * Image [DiskImageDetail] <p>The disk image.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the resulting EBS volume.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description of the volume.</p>
-- Required key: AvailabilityZone
-- Required key: Image
-- Required key: Volume
-- @return ImportVolumeRequest structure as a key-value pair table
function M.ImportVolumeRequest(args)
	assert(args, "You must provide an argument table when creating ImportVolumeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Volume"] = args["Volume"],
		["Image"] = args["Image"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
	}
	asserts.AssertImportVolumeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFleetsRequest = { ["FleetIds"] = true, ["DryRun"] = true, ["TerminateInstances"] = true, nil }

function asserts.AssertDeleteFleetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFleetsRequest to be of type 'table'")
	assert(struct["FleetIds"], "Expected key FleetIds to exist in table")
	assert(struct["TerminateInstances"], "Expected key TerminateInstances to exist in table")
	if struct["FleetIds"] then asserts.AssertFleetIdSet(struct["FleetIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TerminateInstances"] then asserts.AssertBoolean(struct["TerminateInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFleetsRequest[k], "DeleteFleetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFleetsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FleetIds [FleetIdSet] <p>The IDs of the EC2 Fleets.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TerminateInstances [Boolean] <p>Indicates whether to terminate instances for an EC2 Fleet if it is deleted successfully.</p>
-- Required key: FleetIds
-- Required key: TerminateInstances
-- @return DeleteFleetsRequest structure as a key-value pair table
function M.DeleteFleetsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteFleetsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FleetIds"] = args["FleetIds"],
		["DryRun"] = args["DryRun"],
		["TerminateInstances"] = args["TerminateInstances"],
	}
	asserts.AssertDeleteFleetsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CapacityReservationSpecificationResponse = { ["CapacityReservationTarget"] = true, ["CapacityReservationPreference"] = true, nil }

function asserts.AssertCapacityReservationSpecificationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CapacityReservationSpecificationResponse to be of type 'table'")
	if struct["CapacityReservationTarget"] then asserts.AssertCapacityReservationTargetResponse(struct["CapacityReservationTarget"]) end
	if struct["CapacityReservationPreference"] then asserts.AssertCapacityReservationPreference(struct["CapacityReservationPreference"]) end
	for k,_ in pairs(struct) do
		assert(keys.CapacityReservationSpecificationResponse[k], "CapacityReservationSpecificationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CapacityReservationSpecificationResponse
-- <p>Describes the instance's Capacity Reservation targeting preferences. The action returns the <code>capacityReservationPreference</code> response element if the instance is configured to run in On-Demand capacity, or if it is configured in run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). The action returns the <code>capacityReservationTarget</code> response element if the instance explicily targets a specific Capacity Reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationTarget [CapacityReservationTargetResponse] <p>Information about the targeted Capacity Reservation.</p>
-- * CapacityReservationPreference [CapacityReservationPreference] <p>Describes the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>
-- @return CapacityReservationSpecificationResponse structure as a key-value pair table
function M.CapacityReservationSpecificationResponse(args)
	assert(args, "You must provide an argument table when creating CapacityReservationSpecificationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationTarget"] = args["CapacityReservationTarget"],
		["CapacityReservationPreference"] = args["CapacityReservationPreference"],
	}
	asserts.AssertCapacityReservationSpecificationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpnGatewaysResult = { ["VpnGateways"] = true, nil }

function asserts.AssertDescribeVpnGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysResult to be of type 'table'")
	if struct["VpnGateways"] then asserts.AssertVpnGatewayList(struct["VpnGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnGatewaysResult[k], "DescribeVpnGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysResult
-- <p>Contains the output of DescribeVpnGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnGateways [VpnGatewayList] <p>Information about one or more virtual private gateways.</p>
-- @return DescribeVpnGatewaysResult structure as a key-value pair table
function M.DescribeVpnGatewaysResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpnGatewaysResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpnGateways"] = args["VpnGateways"],
	}
	asserts.AssertDescribeVpnGatewaysResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImageDiskContainer = { ["DeviceName"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["SnapshotId"] = true, ["UserBucket"] = true, nil }

function asserts.AssertImageDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImageDiskContainer to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["UserBucket"] then asserts.AssertUserBucket(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImageDiskContainer[k], "ImageDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImageDiskContainer
-- <p>Describes the disk container object for an import image task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The block device mapping for the disk.</p>
-- * Description [String] <p>The description of the disk image.</p>
-- * Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
-- * Url [String] <p>The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)</p>
-- * SnapshotId [String] <p>The ID of the EBS snapshot to be used for importing the snapshot.</p>
-- * UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
-- @return ImageDiskContainer structure as a key-value pair table
function M.ImageDiskContainer(args)
	assert(args, "You must provide an argument table when creating ImageDiskContainer")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceName"] = args["DeviceName"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
		["Url"] = args["Url"],
		["SnapshotId"] = args["SnapshotId"],
		["UserBucket"] = args["UserBucket"],
	}
	asserts.AssertImageDiskContainer(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotInstanceRequest = { ["Status"] = true, ["ActualBlockHourlyPrice"] = true, ["ValidUntil"] = true, ["LaunchGroup"] = true, ["InstanceInterruptionBehavior"] = true, ["Tags"] = true, ["InstanceId"] = true, ["Fault"] = true, ["BlockDurationMinutes"] = true, ["SpotInstanceRequestId"] = true, ["State"] = true, ["ProductDescription"] = true, ["AvailabilityZoneGroup"] = true, ["LaunchSpecification"] = true, ["ValidFrom"] = true, ["Type"] = true, ["CreateTime"] = true, ["SpotPrice"] = true, ["LaunchedAvailabilityZone"] = true, nil }

function asserts.AssertSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceRequest to be of type 'table'")
	if struct["Status"] then asserts.AssertSpotInstanceStatus(struct["Status"]) end
	if struct["ActualBlockHourlyPrice"] then asserts.AssertString(struct["ActualBlockHourlyPrice"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["LaunchGroup"] then asserts.AssertString(struct["LaunchGroup"]) end
	if struct["InstanceInterruptionBehavior"] then asserts.AssertInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Fault"] then asserts.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["State"] then asserts.AssertSpotInstanceState(struct["State"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["AvailabilityZoneGroup"] then asserts.AssertString(struct["AvailabilityZoneGroup"]) end
	if struct["LaunchSpecification"] then asserts.AssertLaunchSpecification(struct["LaunchSpecification"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["Type"] then asserts.AssertSpotInstanceType(struct["Type"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["LaunchedAvailabilityZone"] then asserts.AssertString(struct["LaunchedAvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceRequest[k], "SpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceRequest
-- <p>Describes a Spot Instance request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [SpotInstanceStatus] <p>The status code and status message describing the Spot Instance request.</p>
-- * ActualBlockHourlyPrice [String] <p>If you specified a duration and your Spot Instance request was fulfilled, this is the fixed hourly price in effect for the Spot Instance while it runs.</p>
-- * ValidUntil [DateTime] <p>The end date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached. The default end date is 7 days from the current date.</p>
-- * LaunchGroup [String] <p>The instance launch group. Launch groups are Spot Instances that launch together and terminate together.</p>
-- * InstanceInterruptionBehavior [InstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * InstanceId [String] <p>The instance ID, if an instance has been launched to fulfill the Spot Instance request.</p>
-- * Fault [SpotInstanceStateFault] <p>The fault codes for the Spot Instance request, if any.</p>
-- * BlockDurationMinutes [Integer] <p>The duration for the Spot Instance, in minutes.</p>
-- * SpotInstanceRequestId [String] <p>The ID of the Spot Instance request.</p>
-- * State [SpotInstanceState] <p>The state of the Spot Instance request. Spot status information helps track your Spot Instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Status</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
-- * ProductDescription [RIProductDescription] <p>The product description associated with the Spot Instance.</p>
-- * AvailabilityZoneGroup [String] <p>The Availability Zone group. If you specify the same Availability Zone group for all Spot Instance requests, all Spot Instances are launched in the same Availability Zone.</p>
-- * LaunchSpecification [LaunchSpecification] <p>Additional information for launching instances.</p>
-- * ValidFrom [DateTime] <p>The start date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The request becomes active at this date and time.</p>
-- * Type [SpotInstanceType] <p>The Spot Instance request type.</p>
-- * CreateTime [DateTime] <p>The date and time when the Spot Instance request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * SpotPrice [String] <p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>
-- * LaunchedAvailabilityZone [String] <p>The Availability Zone in which the request is launched.</p>
-- @return SpotInstanceRequest structure as a key-value pair table
function M.SpotInstanceRequest(args)
	assert(args, "You must provide an argument table when creating SpotInstanceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["ActualBlockHourlyPrice"] = args["ActualBlockHourlyPrice"],
		["ValidUntil"] = args["ValidUntil"],
		["LaunchGroup"] = args["LaunchGroup"],
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
		["Tags"] = args["Tags"],
		["InstanceId"] = args["InstanceId"],
		["Fault"] = args["Fault"],
		["BlockDurationMinutes"] = args["BlockDurationMinutes"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
		["State"] = args["State"],
		["ProductDescription"] = args["ProductDescription"],
		["AvailabilityZoneGroup"] = args["AvailabilityZoneGroup"],
		["LaunchSpecification"] = args["LaunchSpecification"],
		["ValidFrom"] = args["ValidFrom"],
		["Type"] = args["Type"],
		["CreateTime"] = args["CreateTime"],
		["SpotPrice"] = args["SpotPrice"],
		["LaunchedAvailabilityZone"] = args["LaunchedAvailabilityZone"],
	}
	asserts.AssertSpotInstanceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpnConnectionsRequest = { ["DryRun"] = true, ["VpnConnectionIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpnConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnConnectionsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnConnectionIds"] then asserts.AssertVpnConnectionIdStringList(struct["VpnConnectionIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnConnectionsRequest[k], "DescribeVpnConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnConnectionsRequest
-- <p>Contains the parameters for DescribeVpnConnections.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnConnectionIds [VpnConnectionIdStringList] <p>One or more VPN connection IDs.</p> <p>Default: Describes your VPN connections.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>customer-gateway-configuration</code> - The configuration information for the customer gateway.</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of a customer gateway associated with the VPN connection.</p> </li> <li> <p> <code>state</code> - The state of the VPN connection (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>option.static-routes-only</code> - Indicates whether the connection has static routes only. Used for devices that do not support Border Gateway Protocol (BGP).</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The destination CIDR block. This corresponds to the subnet used in a customer data center.</p> </li> <li> <p> <code>bgp-asn</code> - The BGP Autonomous System Number (ASN) associated with a BGP device.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>type</code> - The type of VPN connection. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-connection-id</code> - The ID of the VPN connection.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of a virtual private gateway associated with the VPN connection.</p> </li> </ul>
-- @return DescribeVpnConnectionsRequest structure as a key-value pair table
function M.DescribeVpnConnectionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpnConnectionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VpnConnectionIds"] = args["VpnConnectionIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpnConnectionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyHostsRequest = { ["HostIds"] = true, ["AutoPlacement"] = true, nil }

function asserts.AssertModifyHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsRequest to be of type 'table'")
	assert(struct["AutoPlacement"], "Expected key AutoPlacement to exist in table")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	if struct["AutoPlacement"] then asserts.AssertAutoPlacement(struct["AutoPlacement"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyHostsRequest[k], "ModifyHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts to modify.</p>
-- * AutoPlacement [AutoPlacement] <p>Specify whether to enable or disable auto-placement.</p>
-- Required key: AutoPlacement
-- Required key: HostIds
-- @return ModifyHostsRequest structure as a key-value pair table
function M.ModifyHostsRequest(args)
	assert(args, "You must provide an argument table when creating ModifyHostsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostIds"] = args["HostIds"],
		["AutoPlacement"] = args["AutoPlacement"],
	}
	asserts.AssertModifyHostsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkInterfacesRequest = { ["NetworkInterfaceIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeNetworkInterfacesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesRequest to be of type 'table'")
	if struct["NetworkInterfaceIds"] then asserts.AssertNetworkInterfaceIdList(struct["NetworkInterfaceIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacesRequest[k], "DescribeNetworkInterfacesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesRequest
-- <p>Contains the parameters for DescribeNetworkInterfaces.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceIds [NetworkInterfaceIdList] <p>One or more network interface IDs.</p> <p>Default: Describes all your network interfaces.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>addresses.private-ip-address</code> - The private IPv4 addresses associated with the network interface.</p> </li> <li> <p> <code>addresses.primary</code> - Whether the private IPv4 address is the primary IP address associated with the network interface. </p> </li> <li> <p> <code>addresses.association.public-ip</code> - The association ID returned when the network interface was associated with the Elastic IP address (IPv4).</p> </li> <li> <p> <code>addresses.association.owner-id</code> - The owner ID of the addresses associated with the network interface.</p> </li> <li> <p> <code>association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>association.public-dns-name</code> - The public DNS name for the network interface (IPv4).</p> </li> <li> <p> <code>attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>attachment.attach.time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>attachment.delete-on-termination</code> - Indicates whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>attachment.nat-gateway-id</code> - The ID of the NAT gateway to which the network interface is attached.</p> </li> <li> <p> <code>attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the network interface.</p> </li> <li> <p> <code>description</code> - The description of the network interface.</p> </li> <li> <p> <code>group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>ipv6-addresses.ipv6-address</code> - An IPv6 address associated with the network interface.</p> </li> <li> <p> <code>mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the network interface owner.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address or addresses of the network interface.</p> </li> <li> <p> <code>private-dns-name</code> - The private DNS name of the network interface (IPv4).</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>requester-managed</code> - Indicates whether the network interface is being managed by an AWS service (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>source-desk-check</code> - Indicates whether the network interface performs source/destination checking. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>status</code> - The status of the network interface. If the network interface is not attached to an instance, the status is <code>available</code>; if a network interface is attached to an instance the status is <code>in-use</code>.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network interface.</p> </li> </ul>
-- @return DescribeNetworkInterfacesRequest structure as a key-value pair table
function M.DescribeNetworkInterfacesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkInterfacesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfaceIds"] = args["NetworkInterfaceIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeNetworkInterfacesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResetImageAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertResetImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then asserts.AssertResetImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetImageAttributeRequest[k], "ResetImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetImageAttributeRequest
-- <p>Contains the parameters for ResetImageAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [ResetImageAttributeName] <p>The attribute to reset (currently you can only reset the launch permission attribute).</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- Required key: Attribute
-- Required key: ImageId
-- @return ResetImageAttributeRequest structure as a key-value pair table
function M.ResetImageAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ResetImageAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertResetImageAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAvailabilityZonesResult = { ["AvailabilityZones"] = true, nil }

function asserts.AssertDescribeAvailabilityZonesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesResult to be of type 'table'")
	if struct["AvailabilityZones"] then asserts.AssertAvailabilityZoneList(struct["AvailabilityZones"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailabilityZonesResult[k], "DescribeAvailabilityZonesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesResult
-- <p>Contains the output of DescribeAvailabiltyZones.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZones [AvailabilityZoneList] <p>Information about one or more Availability Zones.</p>
-- @return DescribeAvailabilityZonesResult structure as a key-value pair table
function M.DescribeAvailabilityZonesResult(args)
	assert(args, "You must provide an argument table when creating DescribeAvailabilityZonesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZones"] = args["AvailabilityZones"],
	}
	asserts.AssertDescribeAvailabilityZonesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SlotDateTimeRangeRequest = { ["LatestTime"] = true, ["EarliestTime"] = true, nil }

function asserts.AssertSlotDateTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotDateTimeRangeRequest to be of type 'table'")
	assert(struct["EarliestTime"], "Expected key EarliestTime to exist in table")
	assert(struct["LatestTime"], "Expected key LatestTime to exist in table")
	if struct["LatestTime"] then asserts.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then asserts.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SlotDateTimeRangeRequest[k], "SlotDateTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotDateTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule. The time period must span less than one day.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.</p>
-- * EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
-- Required key: EarliestTime
-- Required key: LatestTime
-- @return SlotDateTimeRangeRequest structure as a key-value pair table
function M.SlotDateTimeRangeRequest(args)
	assert(args, "You must provide an argument table when creating SlotDateTimeRangeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LatestTime"] = args["LatestTime"],
		["EarliestTime"] = args["EarliestTime"],
	}
	asserts.AssertSlotDateTimeRangeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RecurringCharge = { ["Amount"] = true, ["Frequency"] = true, nil }

function asserts.AssertRecurringCharge(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RecurringCharge to be of type 'table'")
	if struct["Amount"] then asserts.AssertDouble(struct["Amount"]) end
	if struct["Frequency"] then asserts.AssertRecurringChargeFrequency(struct["Frequency"]) end
	for k,_ in pairs(struct) do
		assert(keys.RecurringCharge[k], "RecurringCharge contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RecurringCharge
-- <p>Describes a recurring charge.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Amount [Double] <p>The amount of the recurring charge.</p>
-- * Frequency [RecurringChargeFrequency] <p>The frequency of the recurring charge.</p>
-- @return RecurringCharge structure as a key-value pair table
function M.RecurringCharge(args)
	assert(args, "You must provide an argument table when creating RecurringCharge")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Amount"] = args["Amount"],
		["Frequency"] = args["Frequency"],
	}
	asserts.AssertRecurringCharge(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceStateChange = { ["InstanceId"] = true, ["CurrentState"] = true, ["PreviousState"] = true, nil }

function asserts.AssertInstanceStateChange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStateChange to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["CurrentState"] then asserts.AssertInstanceState(struct["CurrentState"]) end
	if struct["PreviousState"] then asserts.AssertInstanceState(struct["PreviousState"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStateChange[k], "InstanceStateChange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStateChange
-- <p>Describes an instance state change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * CurrentState [InstanceState] <p>The current state of the instance.</p>
-- * PreviousState [InstanceState] <p>The previous state of the instance.</p>
-- @return InstanceStateChange structure as a key-value pair table
function M.InstanceStateChange(args)
	assert(args, "You must provide an argument table when creating InstanceStateChange")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["CurrentState"] = args["CurrentState"],
		["PreviousState"] = args["PreviousState"],
	}
	asserts.AssertInstanceStateChange(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ElasticGpuAssociation = { ["ElasticGpuAssociationState"] = true, ["ElasticGpuAssociationTime"] = true, ["ElasticGpuAssociationId"] = true, ["ElasticGpuId"] = true, nil }

function asserts.AssertElasticGpuAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ElasticGpuAssociation to be of type 'table'")
	if struct["ElasticGpuAssociationState"] then asserts.AssertString(struct["ElasticGpuAssociationState"]) end
	if struct["ElasticGpuAssociationTime"] then asserts.AssertString(struct["ElasticGpuAssociationTime"]) end
	if struct["ElasticGpuAssociationId"] then asserts.AssertString(struct["ElasticGpuAssociationId"]) end
	if struct["ElasticGpuId"] then asserts.AssertString(struct["ElasticGpuId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ElasticGpuAssociation[k], "ElasticGpuAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ElasticGpuAssociation
-- <p>Describes the association between an instance and an Elastic GPU.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ElasticGpuAssociationState [String] <p>The state of the association between the instance and the Elastic GPU.</p>
-- * ElasticGpuAssociationTime [String] <p>The time the Elastic GPU was associated with the instance.</p>
-- * ElasticGpuAssociationId [String] <p>The ID of the association.</p>
-- * ElasticGpuId [String] <p>The ID of the Elastic GPU.</p>
-- @return ElasticGpuAssociation structure as a key-value pair table
function M.ElasticGpuAssociation(args)
	assert(args, "You must provide an argument table when creating ElasticGpuAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ElasticGpuAssociationState"] = args["ElasticGpuAssociationState"],
		["ElasticGpuAssociationTime"] = args["ElasticGpuAssociationTime"],
		["ElasticGpuAssociationId"] = args["ElasticGpuAssociationId"],
		["ElasticGpuId"] = args["ElasticGpuId"],
	}
	asserts.AssertElasticGpuAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkInterfacesResult = { ["NextToken"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertDescribeNetworkInterfacesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["NetworkInterfaces"] then asserts.AssertNetworkInterfaceList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacesResult[k], "DescribeNetworkInterfacesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacesResult
-- <p>Contains the output of DescribeNetworkInterfaces.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * NetworkInterfaces [NetworkInterfaceList] <p>Information about one or more network interfaces.</p>
-- @return DescribeNetworkInterfacesResult structure as a key-value pair table
function M.DescribeNetworkInterfacesResult(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkInterfacesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertDescribeNetworkInterfacesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResetSnapshotAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertResetSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetSnapshotAttributeRequest[k], "ResetSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetSnapshotAttributeRequest
-- <p>Contains the parameters for ResetSnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [SnapshotAttributeName] <p>The attribute to reset. Currently, only the attribute for permission to create volumes can be reset.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- Required key: Attribute
-- Required key: SnapshotId
-- @return ResetSnapshotAttributeRequest structure as a key-value pair table
function M.ResetSnapshotAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ResetSnapshotAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertResetSnapshotAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumesModificationsResult = { ["VolumesModifications"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVolumesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsResult to be of type 'table'")
	if struct["VolumesModifications"] then asserts.AssertVolumeModificationList(struct["VolumesModifications"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesModificationsResult[k], "DescribeVolumesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumesModifications [VolumeModificationList] <p>A list of returned <a>VolumeModification</a> objects.</p>
-- * NextToken [String] <p>Token for pagination, null if there are no more results </p>
-- @return DescribeVolumesModificationsResult structure as a key-value pair table
function M.DescribeVolumesModificationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVolumesModificationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumesModifications"] = args["VolumesModifications"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeVolumesModificationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportKeyPairRequest = { ["PublicKeyMaterial"] = true, ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertImportKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	assert(struct["PublicKeyMaterial"], "Expected key PublicKeyMaterial to exist in table")
	if struct["PublicKeyMaterial"] then asserts.AssertBlob(struct["PublicKeyMaterial"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportKeyPairRequest[k], "ImportKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicKeyMaterial [Blob] <p>The public key. For API calls, the text must be base64-encoded. For command line tools, base64 encoding is performed for you.</p>
-- * KeyName [String] <p>A unique name for the key pair.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: KeyName
-- Required key: PublicKeyMaterial
-- @return ImportKeyPairRequest structure as a key-value pair table
function M.ImportKeyPairRequest(args)
	assert(args, "You must provide an argument table when creating ImportKeyPairRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicKeyMaterial"] = args["PublicKeyMaterial"],
		["KeyName"] = args["KeyName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertImportKeyPairRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotFleetLaunchSpecification = { ["WeightedCapacity"] = true, ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["TagSpecifications"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["SpotPrice"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertSpotFleetLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetLaunchSpecification to be of type 'table'")
	if struct["WeightedCapacity"] then asserts.AssertDouble(struct["WeightedCapacity"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertSpotFleetMonitoring(struct["Monitoring"]) end
	if struct["TagSpecifications"] then asserts.AssertSpotFleetTagSpecificationList(struct["TagSpecifications"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetLaunchSpecification[k], "SpotFleetLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetLaunchSpecification
-- <p>Describes the launch specification for one or more Spot Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * WeightedCapacity [Double] <p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms (instances or a performance characteristic such as vCPUs, memory, or I/O).</p> <p>If the target capacity divided by this value is not a whole number, we round the number of instances to the next whole number. If this value is not specified, the default is 1.</p>
-- * UserData [String] <p>The Base64-encoded user data to make available to the instances.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-a61dafcf, subnet-65ea5f08".</p>
-- * Monitoring [SpotFleetMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- * TagSpecifications [SpotFleetTagSpecificationList] <p>The tags to apply during creation.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- * SpotPrice [String] <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If this value is not specified, the default is the Spot price specified for the fleet. To determine the Spot price per unit hour, divide the Spot price by the value of <code>WeightedCapacity</code>.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * Placement [SpotPlacement] <p>The placement information.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * AddressingType [String] <p>Deprecated.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
-- @return SpotFleetLaunchSpecification structure as a key-value pair table
function M.SpotFleetLaunchSpecification(args)
	assert(args, "You must provide an argument table when creating SpotFleetLaunchSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["WeightedCapacity"] = args["WeightedCapacity"],
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Monitoring"] = args["Monitoring"],
		["TagSpecifications"] = args["TagSpecifications"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroups"] = args["SecurityGroups"],
		["SpotPrice"] = args["SpotPrice"],
		["RamdiskId"] = args["RamdiskId"],
		["KernelId"] = args["KernelId"],
		["Placement"] = args["Placement"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["AddressingType"] = args["AddressingType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertSpotFleetLaunchSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteNetworkAclRequest = { ["NetworkAclId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclRequest to be of type 'table'")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkAclRequest[k], "DeleteNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: NetworkAclId
-- @return DeleteNetworkAclRequest structure as a key-value pair table
function M.DeleteNetworkAclRequest(args)
	assert(args, "You must provide an argument table when creating DeleteNetworkAclRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkAclId"] = args["NetworkAclId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteNetworkAclRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePlacementGroupsRequest = { ["GroupNames"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribePlacementGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsRequest to be of type 'table'")
	if struct["GroupNames"] then asserts.AssertPlacementGroupStringList(struct["GroupNames"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePlacementGroupsRequest[k], "DescribePlacementGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsRequest
-- <p>Contains the parameters for DescribePlacementGroups.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupNames [PlacementGroupStringList] <p>One or more placement group names.</p> <p>Default: Describes all your placement groups, or only those otherwise specified.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-name</code> - The name of the placement group.</p> </li> <li> <p> <code>state</code> - The state of the placement group (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>strategy</code> - The strategy of the placement group (<code>cluster</code> | <code>spread</code>).</p> </li> </ul>
-- @return DescribePlacementGroupsRequest structure as a key-value pair table
function M.DescribePlacementGroupsRequest(args)
	assert(args, "You must provide an argument table when creating DescribePlacementGroupsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupNames"] = args["GroupNames"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribePlacementGroupsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceExportDetails = { ["InstanceId"] = true, ["TargetEnvironment"] = true, nil }

function asserts.AssertInstanceExportDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceExportDetails to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["TargetEnvironment"] then asserts.AssertExportEnvironment(struct["TargetEnvironment"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceExportDetails[k], "InstanceExportDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceExportDetails
-- <p>Describes an instance to export.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the resource being exported.</p>
-- * TargetEnvironment [ExportEnvironment] <p>The target virtualization environment.</p>
-- @return InstanceExportDetails structure as a key-value pair table
function M.InstanceExportDetails(args)
	assert(args, "You must provide an argument table when creating InstanceExportDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["TargetEnvironment"] = args["TargetEnvironment"],
	}
	asserts.AssertInstanceExportDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateCpuOptionsRequest = { ["CoreCount"] = true, ["ThreadsPerCore"] = true, nil }

function asserts.AssertLaunchTemplateCpuOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateCpuOptionsRequest to be of type 'table'")
	if struct["CoreCount"] then asserts.AssertInteger(struct["CoreCount"]) end
	if struct["ThreadsPerCore"] then asserts.AssertInteger(struct["ThreadsPerCore"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateCpuOptionsRequest[k], "LaunchTemplateCpuOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateCpuOptionsRequest
-- <p>The CPU options for the instance. Both the core count and threads per core must be specified in the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CoreCount [Integer] <p>The number of CPU cores for the instance.</p>
-- * ThreadsPerCore [Integer] <p>The number of threads per CPU core. To disable Intel Hyper-Threading Technology for the instance, specify a value of 1. Otherwise, specify the default value of 2.</p>
-- @return LaunchTemplateCpuOptionsRequest structure as a key-value pair table
function M.LaunchTemplateCpuOptionsRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateCpuOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CoreCount"] = args["CoreCount"],
		["ThreadsPerCore"] = args["ThreadsPerCore"],
	}
	asserts.AssertLaunchTemplateCpuOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LoadPermissionModifications = { ["Add"] = true, ["Remove"] = true, nil }

function asserts.AssertLoadPermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LoadPermissionModifications to be of type 'table'")
	if struct["Add"] then asserts.AssertLoadPermissionListRequest(struct["Add"]) end
	if struct["Remove"] then asserts.AssertLoadPermissionListRequest(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(keys.LoadPermissionModifications[k], "LoadPermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LoadPermissionModifications
-- <p>Describes modifications to the load permissions of an Amazon FPGA image (AFI).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Add [LoadPermissionListRequest] <p>The load permissions to add.</p>
-- * Remove [LoadPermissionListRequest] <p>The load permissions to remove.</p>
-- @return LoadPermissionModifications structure as a key-value pair table
function M.LoadPermissionModifications(args)
	assert(args, "You must provide an argument table when creating LoadPermissionModifications")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Add"] = args["Add"],
		["Remove"] = args["Remove"],
	}
	asserts.AssertLoadPermissionModifications(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkAclsRequest = { ["NetworkAclIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeNetworkAclsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsRequest to be of type 'table'")
	if struct["NetworkAclIds"] then asserts.AssertValueStringList(struct["NetworkAclIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkAclsRequest[k], "DescribeNetworkAclsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclIds [ValueStringList] <p>One or more network ACL IDs.</p> <p>Default: Describes all your network ACLs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.association-id</code> - The ID of an association ID for the ACL.</p> </li> <li> <p> <code>association.network-acl-id</code> - The ID of the network ACL involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>default</code> - Indicates whether the ACL is the default network ACL for the VPC.</p> </li> <li> <p> <code>entry.cidr</code> - The IPv4 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.icmp.code</code> - The ICMP code specified in the entry, if any.</p> </li> <li> <p> <code>entry.icmp.type</code> - The ICMP type specified in the entry, if any.</p> </li> <li> <p> <code>entry.ipv6-cidr</code> - The IPv6 CIDR range specified in the entry.</p> </li> <li> <p> <code>entry.port-range.from</code> - The start of the port range specified in the entry. </p> </li> <li> <p> <code>entry.port-range.to</code> - The end of the port range specified in the entry. </p> </li> <li> <p> <code>entry.protocol</code> - The protocol specified in the entry (<code>tcp</code> | <code>udp</code> | <code>icmp</code> or a protocol number).</p> </li> <li> <p> <code>entry.rule-action</code> - Allows or denies the matching traffic (<code>allow</code> | <code>deny</code>).</p> </li> <li> <p> <code>entry.rule-number</code> - The number of an entry (in other words, rule) in the set of ACL entries.</p> </li> <li> <p> <code>network-acl-id</code> - The ID of the network ACL.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the network ACL.</p> </li> </ul>
-- @return DescribeNetworkAclsRequest structure as a key-value pair table
function M.DescribeNetworkAclsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkAclsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkAclIds"] = args["NetworkAclIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeNetworkAclsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssignIpv6AddressesRequest = { ["Ipv6Addresses"] = true, ["Ipv6AddressCount"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertAssignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignIpv6AddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then asserts.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignIpv6AddressesRequest[k], "AssignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignIpv6AddressesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Addresses [Ipv6AddressList] <p>One or more specific IPv6 addresses to be assigned to the network interface. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to the network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required key: NetworkInterfaceId
-- @return AssignIpv6AddressesRequest structure as a key-value pair table
function M.AssignIpv6AddressesRequest(args)
	assert(args, "You must provide an argument table when creating AssignIpv6AddressesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
	}
	asserts.AssertAssignIpv6AddressesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePublicIpv4PoolsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["PoolIds"] = true, nil }

function asserts.AssertDescribePublicIpv4PoolsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePublicIpv4PoolsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertPoolMaxResults(struct["MaxResults"]) end
	if struct["PoolIds"] then asserts.AssertValueStringList(struct["PoolIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePublicIpv4PoolsRequest[k], "DescribePublicIpv4PoolsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePublicIpv4PoolsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next page of results.</p>
-- * MaxResults [PoolMaxResults] <p>The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
-- * PoolIds [ValueStringList] <p>The IDs of the address pools.</p>
-- @return DescribePublicIpv4PoolsRequest structure as a key-value pair table
function M.DescribePublicIpv4PoolsRequest(args)
	assert(args, "You must provide an argument table when creating DescribePublicIpv4PoolsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["PoolIds"] = args["PoolIds"],
	}
	asserts.AssertDescribePublicIpv4PoolsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateSecurityGroupRuleDescriptionsIngressRequest = { ["IpPermissions"] = true, ["GroupName"] = true, ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertUpdateSecurityGroupRuleDescriptionsIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateSecurityGroupRuleDescriptionsIngressRequest to be of type 'table'")
	assert(struct["IpPermissions"], "Expected key IpPermissions to exist in table")
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateSecurityGroupRuleDescriptionsIngressRequest[k], "UpdateSecurityGroupRuleDescriptionsIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateSecurityGroupRuleDescriptionsIngressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IpPermissions [IpPermissionList] <p>The IP permissions for the security group rule. </p>
-- * GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group. You must specify either the security group ID or the security group name in the request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupId [String] <p>The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.</p>
-- Required key: IpPermissions
-- @return UpdateSecurityGroupRuleDescriptionsIngressRequest structure as a key-value pair table
function M.UpdateSecurityGroupRuleDescriptionsIngressRequest(args)
	assert(args, "You must provide an argument table when creating UpdateSecurityGroupRuleDescriptionsIngressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IpPermissions"] = args["IpPermissions"],
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertUpdateSecurityGroupRuleDescriptionsIngressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PrincipalIdFormat = { ["Statuses"] = true, ["Arn"] = true, nil }

function asserts.AssertPrincipalIdFormat(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrincipalIdFormat to be of type 'table'")
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrincipalIdFormat[k], "PrincipalIdFormat contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrincipalIdFormat
-- <p>PrincipalIdFormat description</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Statuses [IdFormatList] <p>PrincipalIdFormatStatuses description</p>
-- * Arn [String] <p>PrincipalIdFormatARN description</p>
-- @return PrincipalIdFormat structure as a key-value pair table
function M.PrincipalIdFormat(args)
	assert(args, "You must provide an argument table when creating PrincipalIdFormat")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Statuses"] = args["Statuses"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertPrincipalIdFormat(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointsResult = { ["NextToken"] = true, ["VpcEndpoints"] = true, nil }

function asserts.AssertDescribeVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["VpcEndpoints"] then asserts.AssertVpcEndpointSet(struct["VpcEndpoints"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointsResult[k], "DescribeVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointsResult
-- <p>Contains the output of DescribeVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- * VpcEndpoints [VpcEndpointSet] <p>Information about the endpoints.</p>
-- @return DescribeVpcEndpointsResult structure as a key-value pair table
function M.DescribeVpcEndpointsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["VpcEndpoints"] = args["VpcEndpoints"],
	}
	asserts.AssertDescribeVpcEndpointsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateLaunchTemplateVersionResult = { ["LaunchTemplateVersion"] = true, nil }

function asserts.AssertCreateLaunchTemplateVersionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateLaunchTemplateVersionResult to be of type 'table'")
	if struct["LaunchTemplateVersion"] then asserts.AssertLaunchTemplateVersion(struct["LaunchTemplateVersion"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateLaunchTemplateVersionResult[k], "CreateLaunchTemplateVersionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateLaunchTemplateVersionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateVersion [LaunchTemplateVersion] <p>Information about the launch template version.</p>
-- @return CreateLaunchTemplateVersionResult structure as a key-value pair table
function M.CreateLaunchTemplateVersionResult(args)
	assert(args, "You must provide an argument table when creating CreateLaunchTemplateVersionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateVersion"] = args["LaunchTemplateVersion"],
	}
	asserts.AssertCreateLaunchTemplateVersionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FpgaImage = { ["OwnerAlias"] = true, ["UpdateTime"] = true, ["Name"] = true, ["ProductCodes"] = true, ["PciId"] = true, ["Tags"] = true, ["FpgaImageGlobalId"] = true, ["Public"] = true, ["State"] = true, ["ShellVersion"] = true, ["OwnerId"] = true, ["FpgaImageId"] = true, ["CreateTime"] = true, ["Description"] = true, nil }

function asserts.AssertFpgaImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImage to be of type 'table'")
	if struct["OwnerAlias"] then asserts.AssertString(struct["OwnerAlias"]) end
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["PciId"] then asserts.AssertPciId(struct["PciId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["FpgaImageGlobalId"] then asserts.AssertString(struct["FpgaImageGlobalId"]) end
	if struct["Public"] then asserts.AssertBoolean(struct["Public"]) end
	if struct["State"] then asserts.AssertFpgaImageState(struct["State"]) end
	if struct["ShellVersion"] then asserts.AssertString(struct["ShellVersion"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.FpgaImage[k], "FpgaImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImage
-- <p>Describes an Amazon FPGA image (AFI).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OwnerAlias [String] <p>The alias of the AFI owner. Possible values include <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.</p>
-- * UpdateTime [DateTime] <p>The time of the most recent update to the AFI.</p>
-- * Name [String] <p>The name of the AFI.</p>
-- * ProductCodes [ProductCodeList] <p>The product codes for the AFI.</p>
-- * PciId [PciId] <p>Information about the PCI bus.</p>
-- * Tags [TagList] <p>Any tags assigned to the AFI.</p>
-- * FpgaImageGlobalId [String] <p>The global FPGA image identifier (AGFI ID).</p>
-- * Public [Boolean] <p>Indicates whether the AFI is public.</p>
-- * State [FpgaImageState] <p>Information about the state of the AFI.</p>
-- * ShellVersion [String] <p>The version of the AWS Shell that was used to create the bitstream.</p>
-- * OwnerId [String] <p>The AWS account ID of the AFI owner.</p>
-- * FpgaImageId [String] <p>The FPGA image identifier (AFI ID).</p>
-- * CreateTime [DateTime] <p>The date and time the AFI was created.</p>
-- * Description [String] <p>The description of the AFI.</p>
-- @return FpgaImage structure as a key-value pair table
function M.FpgaImage(args)
	assert(args, "You must provide an argument table when creating FpgaImage")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OwnerAlias"] = args["OwnerAlias"],
		["UpdateTime"] = args["UpdateTime"],
		["Name"] = args["Name"],
		["ProductCodes"] = args["ProductCodes"],
		["PciId"] = args["PciId"],
		["Tags"] = args["Tags"],
		["FpgaImageGlobalId"] = args["FpgaImageGlobalId"],
		["Public"] = args["Public"],
		["State"] = args["State"],
		["ShellVersion"] = args["ShellVersion"],
		["OwnerId"] = args["OwnerId"],
		["FpgaImageId"] = args["FpgaImageId"],
		["CreateTime"] = args["CreateTime"],
		["Description"] = args["Description"],
	}
	asserts.AssertFpgaImage(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeKeyPairsRequest = { ["DryRun"] = true, ["Filters"] = true, ["KeyNames"] = true, nil }

function asserts.AssertDescribeKeyPairsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["KeyNames"] then asserts.AssertKeyNameStringList(struct["KeyNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeKeyPairsRequest[k], "DescribeKeyPairsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>fingerprint</code> - The fingerprint of the key pair.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair.</p> </li> </ul>
-- * KeyNames [KeyNameStringList] <p>One or more key pair names.</p> <p>Default: Describes all your key pairs.</p>
-- @return DescribeKeyPairsRequest structure as a key-value pair table
function M.DescribeKeyPairsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeKeyPairsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["KeyNames"] = args["KeyNames"],
	}
	asserts.AssertDescribeKeyPairsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SnapshotDetail = { ["Status"] = true, ["DeviceName"] = true, ["Description"] = true, ["Format"] = true, ["Url"] = true, ["DiskImageSize"] = true, ["Progress"] = true, ["SnapshotId"] = true, ["StatusMessage"] = true, ["UserBucket"] = true, nil }

function asserts.AssertSnapshotDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDetail to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["DiskImageSize"] then asserts.AssertDouble(struct["DiskImageSize"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["UserBucket"] then asserts.AssertUserBucketDetails(struct["UserBucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotDetail[k], "SnapshotDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDetail
-- <p>Describes the snapshot created from the imported disk.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status of the snapshot creation.</p>
-- * DeviceName [String] <p>The block device mapping for the snapshot.</p>
-- * Description [String] <p>A description for the snapshot.</p>
-- * Format [String] <p>The format of the disk image from which the snapshot is created.</p>
-- * Url [String] <p>The URL used to access the disk image.</p>
-- * DiskImageSize [Double] <p>The size of the disk in the snapshot, in GiB.</p>
-- * Progress [String] <p>The percentage of progress for the task.</p>
-- * SnapshotId [String] <p>The snapshot ID of the disk being imported.</p>
-- * StatusMessage [String] <p>A detailed status message for the snapshot creation.</p>
-- * UserBucket [UserBucketDetails] <p>The S3 bucket for the disk image.</p>
-- @return SnapshotDetail structure as a key-value pair table
function M.SnapshotDetail(args)
	assert(args, "You must provide an argument table when creating SnapshotDetail")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DeviceName"] = args["DeviceName"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
		["Url"] = args["Url"],
		["DiskImageSize"] = args["DiskImageSize"],
		["Progress"] = args["Progress"],
		["SnapshotId"] = args["SnapshotId"],
		["StatusMessage"] = args["StatusMessage"],
		["UserBucket"] = args["UserBucket"],
	}
	asserts.AssertSnapshotDetail(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchPermissionModifications = { ["Add"] = true, ["Remove"] = true, nil }

function asserts.AssertLaunchPermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchPermissionModifications to be of type 'table'")
	if struct["Add"] then asserts.AssertLaunchPermissionList(struct["Add"]) end
	if struct["Remove"] then asserts.AssertLaunchPermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchPermissionModifications[k], "LaunchPermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchPermissionModifications
-- <p>Describes a launch permission modification.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Add [LaunchPermissionList] <p>The AWS account ID to add to the list of launch permissions for the AMI.</p>
-- * Remove [LaunchPermissionList] <p>The AWS account ID to remove from the list of launch permissions for the AMI.</p>
-- @return LaunchPermissionModifications structure as a key-value pair table
function M.LaunchPermissionModifications(args)
	assert(args, "You must provide an argument table when creating LaunchPermissionModifications")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Add"] = args["Add"],
		["Remove"] = args["Remove"],
	}
	asserts.AssertLaunchPermissionModifications(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelBundleTaskRequest = { ["DryRun"] = true, ["BundleId"] = true, nil }

function asserts.AssertCancelBundleTaskRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelBundleTaskRequest to be of type 'table'")
	assert(struct["BundleId"], "Expected key BundleId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["BundleId"] then asserts.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelBundleTaskRequest[k], "CancelBundleTaskRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelBundleTaskRequest
-- <p>Contains the parameters for CancelBundleTask.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * BundleId [String] <p>The ID of the bundle task.</p>
-- Required key: BundleId
-- @return CancelBundleTaskRequest structure as a key-value pair table
function M.CancelBundleTaskRequest(args)
	assert(args, "You must provide an argument table when creating CancelBundleTaskRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["BundleId"] = args["BundleId"],
	}
	asserts.AssertCancelBundleTaskRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResponseError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertResponseError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResponseError to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertLaunchTemplateErrorCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResponseError[k], "ResponseError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResponseError
-- <p>Describes the error that's returned when you cannot delete a launch template version.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The error message, if applicable.</p>
-- * Code [LaunchTemplateErrorCode] <p>The error code.</p>
-- @return ResponseError structure as a key-value pair table
function M.ResponseError(args)
	assert(args, "You must provide an argument table when creating ResponseError")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertResponseError(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReleaseAddressRequest = { ["PublicIp"] = true, ["DryRun"] = true, ["AllocationId"] = true, nil }

function asserts.AssertReleaseAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseAddressRequest to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseAddressRequest[k], "ReleaseAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseAddressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>[EC2-Classic] The Elastic IP address. Required for EC2-Classic.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AllocationId [String] <p>[EC2-VPC] The allocation ID. Required for EC2-VPC.</p>
-- @return ReleaseAddressRequest structure as a key-value pair table
function M.ReleaseAddressRequest(args)
	assert(args, "You must provide an argument table when creating ReleaseAddressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["DryRun"] = args["DryRun"],
		["AllocationId"] = args["AllocationId"],
	}
	asserts.AssertReleaseAddressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcEndpointConnectionNotificationRequest = { ["ConnectionEvents"] = true, ["DryRun"] = true, ["ConnectionNotificationArn"] = true, ["ServiceId"] = true, ["ClientToken"] = true, ["VpcEndpointId"] = true, nil }

function asserts.AssertCreateVpcEndpointConnectionNotificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointConnectionNotificationRequest to be of type 'table'")
	assert(struct["ConnectionNotificationArn"], "Expected key ConnectionNotificationArn to exist in table")
	assert(struct["ConnectionEvents"], "Expected key ConnectionEvents to exist in table")
	if struct["ConnectionEvents"] then asserts.AssertValueStringList(struct["ConnectionEvents"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ConnectionNotificationArn"] then asserts.AssertString(struct["ConnectionNotificationArn"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointConnectionNotificationRequest[k], "CreateVpcEndpointConnectionNotificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointConnectionNotificationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConnectionEvents [ValueStringList] <p>One or more endpoint events for which to receive notifications. Valid values are <code>Accept</code>, <code>Connect</code>, <code>Delete</code>, and <code>Reject</code>.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ConnectionNotificationArn [String] <p>The ARN of the SNS topic for the notifications.</p>
-- * ServiceId [String] <p>The ID of the endpoint service.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- * VpcEndpointId [String] <p>The ID of the endpoint. </p>
-- Required key: ConnectionNotificationArn
-- Required key: ConnectionEvents
-- @return CreateVpcEndpointConnectionNotificationRequest structure as a key-value pair table
function M.CreateVpcEndpointConnectionNotificationRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpcEndpointConnectionNotificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConnectionEvents"] = args["ConnectionEvents"],
		["DryRun"] = args["DryRun"],
		["ConnectionNotificationArn"] = args["ConnectionNotificationArn"],
		["ServiceId"] = args["ServiceId"],
		["ClientToken"] = args["ClientToken"],
		["VpcEndpointId"] = args["VpcEndpointId"],
	}
	asserts.AssertCreateVpcEndpointConnectionNotificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceMonitoring = { ["InstanceId"] = true, ["Monitoring"] = true, nil }

function asserts.AssertInstanceMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceMonitoring to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Monitoring"] then asserts.AssertMonitoring(struct["Monitoring"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceMonitoring[k], "InstanceMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceMonitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Monitoring [Monitoring] <p>The monitoring for the instance.</p>
-- @return InstanceMonitoring structure as a key-value pair table
function M.InstanceMonitoring(args)
	assert(args, "You must provide an argument table when creating InstanceMonitoring")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Monitoring"] = args["Monitoring"],
	}
	asserts.AssertInstanceMonitoring(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeRegionsResult = { ["Regions"] = true, nil }

function asserts.AssertDescribeRegionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsResult to be of type 'table'")
	if struct["Regions"] then asserts.AssertRegionList(struct["Regions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRegionsResult[k], "DescribeRegionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsResult
-- <p>Contains the output of DescribeRegions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Regions [RegionList] <p>Information about one or more regions.</p>
-- @return DescribeRegionsResult structure as a key-value pair table
function M.DescribeRegionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeRegionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Regions"] = args["Regions"],
	}
	asserts.AssertDescribeRegionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NatGateway = { ["NatGatewayAddresses"] = true, ["ProvisionedBandwidth"] = true, ["VpcId"] = true, ["State"] = true, ["Tags"] = true, ["FailureMessage"] = true, ["FailureCode"] = true, ["NatGatewayId"] = true, ["SubnetId"] = true, ["DeleteTime"] = true, ["CreateTime"] = true, nil }

function asserts.AssertNatGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGateway to be of type 'table'")
	if struct["NatGatewayAddresses"] then asserts.AssertNatGatewayAddressList(struct["NatGatewayAddresses"]) end
	if struct["ProvisionedBandwidth"] then asserts.AssertProvisionedBandwidth(struct["ProvisionedBandwidth"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["State"] then asserts.AssertNatGatewayState(struct["State"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["FailureMessage"] then asserts.AssertString(struct["FailureMessage"]) end
	if struct["FailureCode"] then asserts.AssertString(struct["FailureCode"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteTime"] then asserts.AssertDateTime(struct["DeleteTime"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.NatGateway[k], "NatGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGateway
-- <p>Describes a NAT gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGatewayAddresses [NatGatewayAddressList] <p>Information about the IP addresses and network interface associated with the NAT gateway.</p>
-- * ProvisionedBandwidth [ProvisionedBandwidth] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * VpcId [String] <p>The ID of the VPC in which the NAT gateway is located.</p>
-- * State [NatGatewayState] <p>The state of the NAT gateway.</p> <ul> <li> <p> <code>pending</code>: The NAT gateway is being created and is not ready to process traffic.</p> </li> <li> <p> <code>failed</code>: The NAT gateway could not be created. Check the <code>failureCode</code> and <code>failureMessage</code> fields for the reason.</p> </li> <li> <p> <code>available</code>: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.</p> </li> <li> <p> <code>deleting</code>: The NAT gateway is in the process of being terminated and may still be processing traffic.</p> </li> <li> <p> <code>deleted</code>: The NAT gateway has been terminated and is no longer processing traffic.</p> </li> </ul>
-- * Tags [TagList] <p>The tags for the NAT gateway.</p>
-- * FailureMessage [String] <p>If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.</p> <ul> <li> <p>For InsufficientFreeAddressesInSubnet: "Subnet has insufficient free addresses to create this NAT gateway"</p> </li> <li> <p>For Gateway.NotAttached: "Network vpc-xxxxxxxx has no Internet gateway attached"</p> </li> <li> <p>For InvalidAllocationID.NotFound: "Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway"</p> </li> <li> <p>For Resource.AlreadyAssociated: "Elastic IP address eipalloc-xxxxxxxx is already associated"</p> </li> <li> <p>For InternalError: "Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again."</p> </li> <li> <p>For InvalidSubnetID.NotFound: "The specified subnet subnet-xxxxxxxx does not exist or could not be found."</p> </li> </ul>
-- * FailureCode [String] <p>If the NAT gateway could not be created, specifies the error code for the failure. (<code>InsufficientFreeAddressesInSubnet</code> | <code>Gateway.NotAttached</code> | <code>InvalidAllocationID.NotFound</code> | <code>Resource.AlreadyAssociated</code> | <code>InternalError</code> | <code>InvalidSubnetID.NotFound</code>)</p>
-- * NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- * SubnetId [String] <p>The ID of the subnet in which the NAT gateway is located.</p>
-- * DeleteTime [DateTime] <p>The date and time the NAT gateway was deleted, if applicable.</p>
-- * CreateTime [DateTime] <p>The date and time the NAT gateway was created.</p>
-- @return NatGateway structure as a key-value pair table
function M.NatGateway(args)
	assert(args, "You must provide an argument table when creating NatGateway")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NatGatewayAddresses"] = args["NatGatewayAddresses"],
		["ProvisionedBandwidth"] = args["ProvisionedBandwidth"],
		["VpcId"] = args["VpcId"],
		["State"] = args["State"],
		["Tags"] = args["Tags"],
		["FailureMessage"] = args["FailureMessage"],
		["FailureCode"] = args["FailureCode"],
		["NatGatewayId"] = args["NatGatewayId"],
		["SubnetId"] = args["SubnetId"],
		["DeleteTime"] = args["DeleteTime"],
		["CreateTime"] = args["CreateTime"],
	}
	asserts.AssertNatGateway(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SuccessfulInstanceCreditSpecificationItem = { ["InstanceId"] = true, nil }

function asserts.AssertSuccessfulInstanceCreditSpecificationItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SuccessfulInstanceCreditSpecificationItem to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SuccessfulInstanceCreditSpecificationItem[k], "SuccessfulInstanceCreditSpecificationItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SuccessfulInstanceCreditSpecificationItem
-- <p>Describes the T2 or T3 instance whose credit option for CPU usage was successfully modified.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- @return SuccessfulInstanceCreditSpecificationItem structure as a key-value pair table
function M.SuccessfulInstanceCreditSpecificationItem(args)
	assert(args, "You must provide an argument table when creating SuccessfulInstanceCreditSpecificationItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
	}
	asserts.AssertSuccessfulInstanceCreditSpecificationItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotPriceHistoryRequest = { ["NextToken"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["StartTime"] = true, ["InstanceTypes"] = true, ["MaxResults"] = true, ["ProductDescriptions"] = true, ["Filters"] = true, ["EndTime"] = true, nil }

function asserts.AssertDescribeSpotPriceHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["InstanceTypes"] then asserts.AssertInstanceTypeList(struct["InstanceTypes"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["ProductDescriptions"] then asserts.AssertProductDescriptionList(struct["ProductDescriptions"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["EndTime"] then asserts.AssertDateTime(struct["EndTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotPriceHistoryRequest[k], "DescribeSpotPriceHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryRequest
-- <p>Contains the parameters for DescribeSpotPriceHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * AvailabilityZone [String] <p>Filters the results by the specified Availability Zone.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * StartTime [DateTime] <p>The date and time, up to the past 90 days, from which to start retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * InstanceTypes [InstanceTypeList] <p>Filters the results by the specified instance types.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * ProductDescriptions [ProductDescriptionList] <p>Filters the results by the specified basic product descriptions.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone for which prices should be returned.</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>product-description</code> - The product description for the Spot price (<code>Linux/UNIX</code> | <code>SUSE Linux</code> | <code>Windows</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Windows (Amazon VPC)</code>).</p> </li> <li> <p> <code>spot-price</code> - The Spot price. The value must match exactly (or use wildcards; greater than or less than comparison is not supported).</p> </li> <li> <p> <code>timestamp</code> - The time stamp of the Spot price history, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). You can use wildcards (* and ?). Greater than or less than comparison is not supported.</p> </li> </ul>
-- * EndTime [DateTime] <p>The date and time, up to the current date, from which to stop retrieving the price history data, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @return DescribeSpotPriceHistoryRequest structure as a key-value pair table
function M.DescribeSpotPriceHistoryRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSpotPriceHistoryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["StartTime"] = args["StartTime"],
		["InstanceTypes"] = args["InstanceTypes"],
		["MaxResults"] = args["MaxResults"],
		["ProductDescriptions"] = args["ProductDescriptions"],
		["Filters"] = args["Filters"],
		["EndTime"] = args["EndTime"],
	}
	asserts.AssertDescribeSpotPriceHistoryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotDatafeedSubscription = { ["Fault"] = true, ["Prefix"] = true, ["Bucket"] = true, ["State"] = true, ["OwnerId"] = true, nil }

function asserts.AssertSpotDatafeedSubscription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotDatafeedSubscription to be of type 'table'")
	if struct["Fault"] then asserts.AssertSpotInstanceStateFault(struct["Fault"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["State"] then asserts.AssertDatafeedSubscriptionState(struct["State"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotDatafeedSubscription[k], "SpotDatafeedSubscription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotDatafeedSubscription
-- <p>Describes the data feed for a Spot Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Fault [SpotInstanceStateFault] <p>The fault codes for the Spot Instance request, if any.</p>
-- * Prefix [String] <p>The prefix that is prepended to data feed files.</p>
-- * Bucket [String] <p>The Amazon S3 bucket where the Spot Instance data feed is located.</p>
-- * State [DatafeedSubscriptionState] <p>The state of the Spot Instance data feed subscription.</p>
-- * OwnerId [String] <p>The AWS account ID of the account.</p>
-- @return SpotDatafeedSubscription structure as a key-value pair table
function M.SpotDatafeedSubscription(args)
	assert(args, "You must provide an argument table when creating SpotDatafeedSubscription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Fault"] = args["Fault"],
		["Prefix"] = args["Prefix"],
		["Bucket"] = args["Bucket"],
		["State"] = args["State"],
		["OwnerId"] = args["OwnerId"],
	}
	asserts.AssertSpotDatafeedSubscription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StorageLocation = { ["Bucket"] = true, ["Key"] = true, nil }

function asserts.AssertStorageLocation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StorageLocation to be of type 'table'")
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.StorageLocation[k], "StorageLocation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StorageLocation
-- <p>Describes a storage location in Amazon S3.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Bucket [String] <p>The name of the S3 bucket.</p>
-- * Key [String] <p>The key.</p>
-- @return StorageLocation structure as a key-value pair table
function M.StorageLocation(args)
	assert(args, "You must provide an argument table when creating StorageLocation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Bucket"] = args["Bucket"],
		["Key"] = args["Key"],
	}
	asserts.AssertStorageLocation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyHostsResult = { ["Successful"] = true, ["Unsuccessful"] = true, nil }

function asserts.AssertModifyHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyHostsResult to be of type 'table'")
	if struct["Successful"] then asserts.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyHostsResult[k], "ModifyHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyHostsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully modified.</p>
-- * Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.</p>
-- @return ModifyHostsResult structure as a key-value pair table
function M.ModifyHostsResult(args)
	assert(args, "You must provide an argument table when creating ModifyHostsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Successful"] = args["Successful"],
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertModifyHostsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateInternetGatewayRequest = { ["DryRun"] = true, nil }

function asserts.AssertCreateInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInternetGatewayRequest[k], "CreateInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return CreateInternetGatewayRequest structure as a key-value pair table
function M.CreateInternetGatewayRequest(args)
	assert(args, "You must provide an argument table when creating CreateInternetGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateInternetGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFleetError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertDeleteFleetError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFleetError to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertDeleteFleetErrorCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFleetError[k], "DeleteFleetError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFleetError
-- <p>Describes an EC2 Fleet error.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The description for the error code.</p>
-- * Code [DeleteFleetErrorCode] <p>The error code.</p>
-- @return DeleteFleetError structure as a key-value pair table
function M.DeleteFleetError(args)
	assert(args, "You must provide an argument table when creating DeleteFleetError")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertDeleteFleetError(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceNetworkInterfaceAssociation = { ["PublicIp"] = true, ["PublicDnsName"] = true, ["IpOwnerId"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["IpOwnerId"] then asserts.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceAssociation[k], "InstanceNetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The public IP address or Elastic IP address bound to the network interface.</p>
-- * PublicDnsName [String] <p>The public DNS name.</p>
-- * IpOwnerId [String] <p>The ID of the owner of the Elastic IP address.</p>
-- @return InstanceNetworkInterfaceAssociation structure as a key-value pair table
function M.InstanceNetworkInterfaceAssociation(args)
	assert(args, "You must provide an argument table when creating InstanceNetworkInterfaceAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["PublicDnsName"] = args["PublicDnsName"],
		["IpOwnerId"] = args["IpOwnerId"],
	}
	asserts.AssertInstanceNetworkInterfaceAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateSecurityGroupRuleDescriptionsIngressResult = { ["Return"] = true, nil }

function asserts.AssertUpdateSecurityGroupRuleDescriptionsIngressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateSecurityGroupRuleDescriptionsIngressResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateSecurityGroupRuleDescriptionsIngressResult[k], "UpdateSecurityGroupRuleDescriptionsIngressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateSecurityGroupRuleDescriptionsIngressResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, returns an error.</p>
-- @return UpdateSecurityGroupRuleDescriptionsIngressResult structure as a key-value pair table
function M.UpdateSecurityGroupRuleDescriptionsIngressResult(args)
	assert(args, "You must provide an argument table when creating UpdateSecurityGroupRuleDescriptionsIngressResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertUpdateSecurityGroupRuleDescriptionsIngressResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ElasticGpuSpecificationResponse = { ["Type"] = true, nil }

function asserts.AssertElasticGpuSpecificationResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ElasticGpuSpecificationResponse to be of type 'table'")
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.ElasticGpuSpecificationResponse[k], "ElasticGpuSpecificationResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ElasticGpuSpecificationResponse
-- <p>Describes an elastic GPU.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [String] <p>The elastic GPU type.</p>
-- @return ElasticGpuSpecificationResponse structure as a key-value pair table
function M.ElasticGpuSpecificationResponse(args)
	assert(args, "You must provide an argument table when creating ElasticGpuSpecificationResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
	}
	asserts.AssertElasticGpuSpecificationResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeStatusItem = { ["VolumeStatus"] = true, ["AvailabilityZone"] = true, ["Events"] = true, ["Actions"] = true, ["VolumeId"] = true, nil }

function asserts.AssertVolumeStatusItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusItem to be of type 'table'")
	if struct["VolumeStatus"] then asserts.AssertVolumeStatusInfo(struct["VolumeStatus"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Events"] then asserts.AssertVolumeStatusEventsList(struct["Events"]) end
	if struct["Actions"] then asserts.AssertVolumeStatusActionsList(struct["Actions"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusItem[k], "VolumeStatusItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusItem
-- <p>Describes the volume status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeStatus [VolumeStatusInfo] <p>The volume status.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the volume.</p>
-- * Events [VolumeStatusEventsList] <p>A list of events associated with the volume.</p>
-- * Actions [VolumeStatusActionsList] <p>The details of the operation.</p>
-- * VolumeId [String] <p>The volume ID.</p>
-- @return VolumeStatusItem structure as a key-value pair table
function M.VolumeStatusItem(args)
	assert(args, "You must provide an argument table when creating VolumeStatusItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumeStatus"] = args["VolumeStatus"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Events"] = args["Events"],
		["Actions"] = args["Actions"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertVolumeStatusItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcClassicLink = { ["ClassicLinkEnabled"] = true, ["VpcId"] = true, ["Tags"] = true, nil }

function asserts.AssertVpcClassicLink(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcClassicLink to be of type 'table'")
	if struct["ClassicLinkEnabled"] then asserts.AssertBoolean(struct["ClassicLinkEnabled"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcClassicLink[k], "VpcClassicLink contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcClassicLink
-- <p>Describes whether a VPC is enabled for ClassicLink.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ClassicLinkEnabled [Boolean] <p>Indicates whether the VPC is enabled for ClassicLink.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Tags [TagList] <p>Any tags assigned to the VPC.</p>
-- @return VpcClassicLink structure as a key-value pair table
function M.VpcClassicLink(args)
	assert(args, "You must provide an argument table when creating VpcClassicLink")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ClassicLinkEnabled"] = args["ClassicLinkEnabled"],
		["VpcId"] = args["VpcId"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertVpcClassicLink(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterfaceIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertNetworkInterfaceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceIpv6Address[k], "NetworkInterfaceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceIpv6Address
-- <p>Describes an IPv6 address associated with a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Address [String] <p>The IPv6 address.</p>
-- @return NetworkInterfaceIpv6Address structure as a key-value pair table
function M.NetworkInterfaceIpv6Address(args)
	assert(args, "You must provide an argument table when creating NetworkInterfaceIpv6Address")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6Address"] = args["Ipv6Address"],
	}
	asserts.AssertNetworkInterfaceIpv6Address(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisableVpcClassicLinkRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisableVpcClassicLinkRequest[k], "DisableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisableVpcClassicLinkRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return DisableVpcClassicLinkRequest structure as a key-value pair table
function M.DisableVpcClassicLinkRequest(args)
	assert(args, "You must provide an argument table when creating DisableVpcClassicLinkRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDisableVpcClassicLinkRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotFleetRequestConfigData = { ["Type"] = true, ["OnDemandTargetCapacity"] = true, ["FulfilledCapacity"] = true, ["LaunchTemplateConfigs"] = true, ["OnDemandFulfilledCapacity"] = true, ["TerminateInstancesWithExpiration"] = true, ["InstanceInterruptionBehavior"] = true, ["LaunchSpecifications"] = true, ["LoadBalancersConfig"] = true, ["InstancePoolsToUseCount"] = true, ["ReplaceUnhealthyInstances"] = true, ["IamFleetRole"] = true, ["ValidUntil"] = true, ["ClientToken"] = true, ["TargetCapacity"] = true, ["ValidFrom"] = true, ["ExcessCapacityTerminationPolicy"] = true, ["OnDemandAllocationStrategy"] = true, ["SpotPrice"] = true, ["AllocationStrategy"] = true, nil }

function asserts.AssertSpotFleetRequestConfigData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfigData to be of type 'table'")
	assert(struct["IamFleetRole"], "Expected key IamFleetRole to exist in table")
	assert(struct["TargetCapacity"], "Expected key TargetCapacity to exist in table")
	if struct["Type"] then asserts.AssertFleetType(struct["Type"]) end
	if struct["OnDemandTargetCapacity"] then asserts.AssertInteger(struct["OnDemandTargetCapacity"]) end
	if struct["FulfilledCapacity"] then asserts.AssertDouble(struct["FulfilledCapacity"]) end
	if struct["LaunchTemplateConfigs"] then asserts.AssertLaunchTemplateConfigList(struct["LaunchTemplateConfigs"]) end
	if struct["OnDemandFulfilledCapacity"] then asserts.AssertDouble(struct["OnDemandFulfilledCapacity"]) end
	if struct["TerminateInstancesWithExpiration"] then asserts.AssertBoolean(struct["TerminateInstancesWithExpiration"]) end
	if struct["InstanceInterruptionBehavior"] then asserts.AssertInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	if struct["LaunchSpecifications"] then asserts.AssertLaunchSpecsList(struct["LaunchSpecifications"]) end
	if struct["LoadBalancersConfig"] then asserts.AssertLoadBalancersConfig(struct["LoadBalancersConfig"]) end
	if struct["InstancePoolsToUseCount"] then asserts.AssertInteger(struct["InstancePoolsToUseCount"]) end
	if struct["ReplaceUnhealthyInstances"] then asserts.AssertBoolean(struct["ReplaceUnhealthyInstances"]) end
	if struct["IamFleetRole"] then asserts.AssertString(struct["IamFleetRole"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["TargetCapacity"] then asserts.AssertInteger(struct["TargetCapacity"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	if struct["OnDemandAllocationStrategy"] then asserts.AssertOnDemandAllocationStrategy(struct["OnDemandAllocationStrategy"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	if struct["AllocationStrategy"] then asserts.AssertAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetRequestConfigData[k], "SpotFleetRequestConfigData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfigData
-- <p>Describes the configuration of a Spot Fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [FleetType] <p>The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is <code>request</code>, the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. To maintain a certain target capacity, the Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: <code>maintain</code>.</p>
-- * OnDemandTargetCapacity [Integer] <p>The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>
-- * FulfilledCapacity [Double] <p>The number of units fulfilled by this request compared to the set target capacity. You cannot set this value.</p>
-- * LaunchTemplateConfigs [LaunchTemplateConfigList] <p>The launch template and overrides.</p>
-- * OnDemandFulfilledCapacity [Double] <p>The number of On-Demand units fulfilled by this request compared to the set target On-Demand capacity.</p>
-- * TerminateInstancesWithExpiration [Boolean] <p>Indicates whether running Spot Instances should be terminated when the Spot Fleet request expires.</p>
-- * InstanceInterruptionBehavior [InstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
-- * LaunchSpecifications [LaunchSpecsList] <p>The launch specifications for the Spot Fleet request.</p>
-- * LoadBalancersConfig [LoadBalancersConfig] <p>One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.</p> <p>With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.</p>
-- * InstancePoolsToUseCount [Integer] <p>The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot <b>AllocationStrategy</b> is set to <code>lowest-price</code>. Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.</p>
-- * ReplaceUnhealthyInstances [Boolean] <p>Indicates whether Spot Fleet should replace unhealthy instances.</p>
-- * IamFleetRole [String] <p>Grants the Spot Fleet permission to terminate Spot Instances on your behalf when you cancel its Spot Fleet request using <a>CancelSpotFleetRequests</a> or when the Spot Fleet request expires, if you set <code>terminateInstancesWithExpiration</code>.</p>
-- * ValidUntil [DateTime] <p>The end date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). At this point, no new Spot Instance requests are placed or able to fulfill the request. The default end date is 7 days from the current date.</p>
-- * ClientToken [String] <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of your listings. This helps to avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * TargetCapacity [Integer] <p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>
-- * ValidFrom [DateTime] <p>The start date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The default is to start fulfilling the request immediately.</p>
-- * ExcessCapacityTerminationPolicy [ExcessCapacityTerminationPolicy] <p>Indicates whether running Spot Instances should be terminated if the target capacity of the Spot Fleet request is decreased below the current size of the Spot Fleet.</p>
-- * OnDemandAllocationStrategy [OnDemandAllocationStrategy] <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify <code>lowestPrice</code>, Spot Fleet uses price to determine the order, launching the lowest price first. If you specify <code>prioritized</code>, Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to <code>lowestPrice</code>.</p>
-- * SpotPrice [String] <p>The maximum price per unit hour that you are willing to pay for a Spot Instance. The default is the On-Demand price.</p>
-- * AllocationStrategy [AllocationStrategy] <p>Indicates how to allocate the target capacity across the Spot pools specified by the Spot Fleet request. The default is <code>lowestPrice</code>.</p>
-- Required key: IamFleetRole
-- Required key: TargetCapacity
-- @return SpotFleetRequestConfigData structure as a key-value pair table
function M.SpotFleetRequestConfigData(args)
	assert(args, "You must provide an argument table when creating SpotFleetRequestConfigData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
		["OnDemandTargetCapacity"] = args["OnDemandTargetCapacity"],
		["FulfilledCapacity"] = args["FulfilledCapacity"],
		["LaunchTemplateConfigs"] = args["LaunchTemplateConfigs"],
		["OnDemandFulfilledCapacity"] = args["OnDemandFulfilledCapacity"],
		["TerminateInstancesWithExpiration"] = args["TerminateInstancesWithExpiration"],
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
		["LaunchSpecifications"] = args["LaunchSpecifications"],
		["LoadBalancersConfig"] = args["LoadBalancersConfig"],
		["InstancePoolsToUseCount"] = args["InstancePoolsToUseCount"],
		["ReplaceUnhealthyInstances"] = args["ReplaceUnhealthyInstances"],
		["IamFleetRole"] = args["IamFleetRole"],
		["ValidUntil"] = args["ValidUntil"],
		["ClientToken"] = args["ClientToken"],
		["TargetCapacity"] = args["TargetCapacity"],
		["ValidFrom"] = args["ValidFrom"],
		["ExcessCapacityTerminationPolicy"] = args["ExcessCapacityTerminationPolicy"],
		["OnDemandAllocationStrategy"] = args["OnDemandAllocationStrategy"],
		["SpotPrice"] = args["SpotPrice"],
		["AllocationStrategy"] = args["AllocationStrategy"],
	}
	asserts.AssertSpotFleetRequestConfigData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointServiceConfigurationResult = { ["Return"] = true, nil }

function asserts.AssertModifyVpcEndpointServiceConfigurationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointServiceConfigurationResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointServiceConfigurationResult[k], "ModifyVpcEndpointServiceConfigurationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointServiceConfigurationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return ModifyVpcEndpointServiceConfigurationResult structure as a key-value pair table
function M.ModifyVpcEndpointServiceConfigurationResult(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointServiceConfigurationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyVpcEndpointServiceConfigurationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MoveAddressToVpcRequest = { ["PublicIp"] = true, ["DryRun"] = true, nil }

function asserts.AssertMoveAddressToVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.MoveAddressToVpcRequest[k], "MoveAddressToVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: PublicIp
-- @return MoveAddressToVpcRequest structure as a key-value pair table
function M.MoveAddressToVpcRequest(args)
	assert(args, "You must provide an argument table when creating MoveAddressToVpcRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertMoveAddressToVpcRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstanceLimitPrice = { ["Amount"] = true, ["CurrencyCode"] = true, nil }

function asserts.AssertReservedInstanceLimitPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstanceLimitPrice to be of type 'table'")
	if struct["Amount"] then asserts.AssertDouble(struct["Amount"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstanceLimitPrice[k], "ReservedInstanceLimitPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstanceLimitPrice
-- <p>Describes the limit price of a Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Amount [Double] <p>Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>limitPrice</code> amount is specified. At this time, the only supported currency is <code>USD</code>.</p>
-- @return ReservedInstanceLimitPrice structure as a key-value pair table
function M.ReservedInstanceLimitPrice(args)
	assert(args, "You must provide an argument table when creating ReservedInstanceLimitPrice")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Amount"] = args["Amount"],
		["CurrencyCode"] = args["CurrencyCode"],
	}
	asserts.AssertReservedInstanceLimitPrice(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpnGatewaysRequest = { ["DryRun"] = true, ["VpnGatewayIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpnGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpnGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayIds"] then asserts.AssertVpnGatewayIdStringList(struct["VpnGatewayIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpnGatewaysRequest[k], "DescribeVpnGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpnGatewaysRequest
-- <p>Contains the parameters for DescribeVpnGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayIds [VpnGatewayIdStringList] <p>One or more virtual private gateway IDs.</p> <p>Default: Describes all your virtual private gateways.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>amazon-side-asn</code> - The Autonomous System Number (ASN) for the Amazon side of the gateway.</p> </li> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone for the virtual private gateway (if applicable).</p> </li> <li> <p> <code>state</code> - The state of the virtual private gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>type</code> - The type of virtual private gateway. Currently the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>vpn-gateway-id</code> - The ID of the virtual private gateway.</p> </li> </ul>
-- @return DescribeVpnGatewaysRequest structure as a key-value pair table
function M.DescribeVpnGatewaysRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpnGatewaysRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VpnGatewayIds"] = args["VpnGatewayIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpnGatewaysRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcAttributeResult = { ["EnableDnsSupport"] = true, ["VpcId"] = true, ["EnableDnsHostnames"] = true, nil }

function asserts.AssertDescribeVpcAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeResult to be of type 'table'")
	if struct["EnableDnsSupport"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["EnableDnsHostnames"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcAttributeResult[k], "DescribeVpcAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether DNS resolution is enabled for the VPC. If this attribute is <code>true</code>, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is <code>true</code>, instances in the VPC get DNS hostnames; otherwise, they do not.</p>
-- @return DescribeVpcAttributeResult structure as a key-value pair table
function M.DescribeVpcAttributeResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcAttributeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EnableDnsSupport"] = args["EnableDnsSupport"],
		["VpcId"] = args["VpcId"],
		["EnableDnsHostnames"] = args["EnableDnsHostnames"],
	}
	asserts.AssertDescribeVpcAttributeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceNetworkInterface = { ["Status"] = true, ["MacAddress"] = true, ["SourceDestCheck"] = true, ["VpcId"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["PrivateIpAddresses"] = true, ["PrivateDnsName"] = true, ["Attachment"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["OwnerId"] = true, ["PrivateIpAddress"] = true, ["SubnetId"] = true, ["Association"] = true, nil }

function asserts.AssertInstanceNetworkInterface(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterface to be of type 'table'")
	if struct["Status"] then asserts.AssertNetworkInterfaceStatus(struct["Status"]) end
	if struct["MacAddress"] then asserts.AssertString(struct["MacAddress"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertInstancePrivateIpAddressList(struct["PrivateIpAddresses"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["Attachment"] then asserts.AssertInstanceNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Association"] then asserts.AssertInstanceNetworkInterfaceAssociation(struct["Association"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterface[k], "InstanceNetworkInterface contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterface
-- <p>Describes a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [NetworkInterfaceStatus] <p>The status of the network interface.</p>
-- * MacAddress [String] <p>The MAC address.</p>
-- * SourceDestCheck [Boolean] <p>Indicates whether to validate network traffic to or from this network interface.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Description [String] <p>The description.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * PrivateIpAddresses [InstancePrivateIpAddressList] <p>One or more private IPv4 addresses associated with the network interface.</p>
-- * PrivateDnsName [String] <p>The private DNS name.</p>
-- * Attachment [InstanceNetworkInterfaceAttachment] <p>The network interface attachment.</p>
-- * Groups [GroupIdentifierList] <p>One or more security groups.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>One or more IPv6 addresses associated with the network interface.</p>
-- * OwnerId [String] <p>The ID of the AWS account that created the network interface.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address of the network interface within the subnet.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * Association [InstanceNetworkInterfaceAssociation] <p>The association information for an Elastic IPv4 associated with the network interface.</p>
-- @return InstanceNetworkInterface structure as a key-value pair table
function M.InstanceNetworkInterface(args)
	assert(args, "You must provide an argument table when creating InstanceNetworkInterface")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["MacAddress"] = args["MacAddress"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["VpcId"] = args["VpcId"],
		["Description"] = args["Description"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["OwnerId"] = args["OwnerId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["SubnetId"] = args["SubnetId"],
		["Association"] = args["Association"],
	}
	asserts.AssertInstanceNetworkInterface(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateKeyPairRequest = { ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateKeyPairRequest[k], "CreateKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateKeyPairRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>A unique name for the key pair.</p> <p>Constraints: Up to 255 ASCII characters</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: KeyName
-- @return CreateKeyPairRequest structure as a key-value pair table
function M.CreateKeyPairRequest(args)
	assert(args, "You must provide an argument table when creating CreateKeyPairRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyName"] = args["KeyName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateKeyPairRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVolumeRequest = { ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDeleteVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVolumeRequest[k], "DeleteVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVolumeRequest
-- <p>Contains the parameters for DeleteVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return DeleteVolumeRequest structure as a key-value pair table
function M.DeleteVolumeRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVolumeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDeleteVolumeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PurchaseScheduledInstancesRequest = { ["PurchaseRequests"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseScheduledInstancesRequest to be of type 'table'")
	assert(struct["PurchaseRequests"], "Expected key PurchaseRequests to exist in table")
	if struct["PurchaseRequests"] then asserts.AssertPurchaseRequestSet(struct["PurchaseRequests"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseScheduledInstancesRequest[k], "PurchaseScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseScheduledInstancesRequest
-- <p>Contains the parameters for PurchaseScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PurchaseRequests [PurchaseRequestSet] <p>One or more purchase requests.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that ensures the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: PurchaseRequests
-- @return PurchaseScheduledInstancesRequest structure as a key-value pair table
function M.PurchaseScheduledInstancesRequest(args)
	assert(args, "You must provide an argument table when creating PurchaseScheduledInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PurchaseRequests"] = args["PurchaseRequests"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertPurchaseScheduledInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetLaunchTemplateDataRequest = { ["InstanceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetLaunchTemplateDataRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetLaunchTemplateDataRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetLaunchTemplateDataRequest[k], "GetLaunchTemplateDataRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetLaunchTemplateDataRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- @return GetLaunchTemplateDataRequest structure as a key-value pair table
function M.GetLaunchTemplateDataRequest(args)
	assert(args, "You must provide an argument table when creating GetLaunchTemplateDataRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertGetLaunchTemplateDataRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeImportSnapshotTasksRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ImportTaskIds"] = true, nil }

function asserts.AssertDescribeImportSnapshotTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then asserts.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportSnapshotTasksRequest[k], "DescribeImportSnapshotTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksRequest
-- <p>Contains the parameters for DescribeImportSnapshotTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>A token that indicates the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>One or more filters.</p>
-- * ImportTaskIds [ImportTaskIdList] <p>A list of import snapshot task IDs.</p>
-- @return DescribeImportSnapshotTasksRequest structure as a key-value pair table
function M.DescribeImportSnapshotTasksRequest(args)
	assert(args, "You must provide an argument table when creating DescribeImportSnapshotTasksRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["ImportTaskIds"] = args["ImportTaskIds"],
	}
	asserts.AssertDescribeImportSnapshotTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateEgressOnlyInternetGatewayResult = { ["EgressOnlyInternetGateway"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["EgressOnlyInternetGateway"] then asserts.AssertEgressOnlyInternetGateway(struct["EgressOnlyInternetGateway"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateEgressOnlyInternetGatewayResult[k], "CreateEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateEgressOnlyInternetGatewayResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGateway [EgressOnlyInternetGateway] <p>Information about the egress-only internet gateway.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>
-- @return CreateEgressOnlyInternetGatewayResult structure as a key-value pair table
function M.CreateEgressOnlyInternetGatewayResult(args)
	assert(args, "You must provide an argument table when creating CreateEgressOnlyInternetGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EgressOnlyInternetGateway"] = args["EgressOnlyInternetGateway"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateEgressOnlyInternetGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ServiceTypeDetail = { ["ServiceType"] = true, nil }

function asserts.AssertServiceTypeDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ServiceTypeDetail to be of type 'table'")
	if struct["ServiceType"] then asserts.AssertServiceType(struct["ServiceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ServiceTypeDetail[k], "ServiceTypeDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ServiceTypeDetail
-- <p>Describes the type of service for a VPC endpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceType [ServiceType] <p>The type of service.</p>
-- @return ServiceTypeDetail structure as a key-value pair table
function M.ServiceTypeDetail(args)
	assert(args, "You must provide an argument table when creating ServiceTypeDetail")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceType"] = args["ServiceType"],
	}
	asserts.AssertServiceTypeDetail(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeClassicLinkInstancesResult = { ["Instances"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeClassicLinkInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesResult to be of type 'table'")
	if struct["Instances"] then asserts.AssertClassicLinkInstanceList(struct["Instances"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeClassicLinkInstancesResult[k], "DescribeClassicLinkInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Instances [ClassicLinkInstanceList] <p>Information about one or more linked EC2-Classic instances.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeClassicLinkInstancesResult structure as a key-value pair table
function M.DescribeClassicLinkInstancesResult(args)
	assert(args, "You must provide an argument table when creating DescribeClassicLinkInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Instances"] = args["Instances"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeClassicLinkInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CopyImageRequest = { ["SourceRegion"] = true, ["DryRun"] = true, ["Name"] = true, ["Encrypted"] = true, ["SourceImageId"] = true, ["KmsKeyId"] = true, ["ClientToken"] = true, ["Description"] = true, nil }

function asserts.AssertCopyImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	assert(struct["SourceImageId"], "Expected key SourceImageId to exist in table")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	if struct["SourceRegion"] then asserts.AssertString(struct["SourceRegion"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["SourceImageId"] then asserts.AssertString(struct["SourceImageId"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyImageRequest[k], "CopyImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyImageRequest
-- <p>Contains the parameters for CopyImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceRegion [String] <p>The name of the region that contains the AMI to copy.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Name [String] <p>The name of the new AMI in the destination region.</p>
-- * Encrypted [Boolean] <p>Specifies whether the destination snapshots of the copied image should be encrypted. You can encrypt a copy of an unencrypted snapshot, but you cannot create an unencrypted copy of an encrypted snapshot. The default CMK for EBS is used unless you specify a non-default AWS Key Management Service (AWS KMS) CMK using <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * SourceImageId [String] <p>The ID of the AMI to copy.</p>
-- * KmsKeyId [String] <p>An identifier for the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set. </p> <p>The CMK identifier may be provided in any of the following formats: </p> <ul> <li> <p>Key ID</p> </li> <li> <p>Key alias, in the form <code>alias/<i>ExampleAlias</i> </code> </p> </li> <li> <p>ARN using key ID. The ID ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. </p> </li> <li> <p>ARN using key alias. The alias ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>alias</code> namespace, and then the CMK alias. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:alias/<i>ExampleAlias</i>. </p> </li> </ul> <p>AWS parses <code>KmsKeyId</code> asynchronously, meaning that the action you call may appear to complete even though you provided an invalid identifier. This action will eventually report failure. </p> <p>The specified CMK must exist in the region that the snapshot is being copied to. </p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * Description [String] <p>A description for the new AMI in the destination region.</p>
-- Required key: Name
-- Required key: SourceImageId
-- Required key: SourceRegion
-- @return CopyImageRequest structure as a key-value pair table
function M.CopyImageRequest(args)
	assert(args, "You must provide an argument table when creating CopyImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SourceRegion"] = args["SourceRegion"],
		["DryRun"] = args["DryRun"],
		["Name"] = args["Name"],
		["Encrypted"] = args["Encrypted"],
		["SourceImageId"] = args["SourceImageId"],
		["KmsKeyId"] = args["KmsKeyId"],
		["ClientToken"] = args["ClientToken"],
		["Description"] = args["Description"],
	}
	asserts.AssertCopyImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNetworkAclRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateNetworkAclRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclRequest[k], "CreateNetworkAclRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return CreateNetworkAclRequest structure as a key-value pair table
function M.CreateNetworkAclRequest(args)
	assert(args, "You must provide an argument table when creating CreateNetworkAclRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateNetworkAclRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateRouteTableRequest = { ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDisassociateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateRouteTableRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateRouteTableRequest[k], "DisassociateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateRouteTableRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The association ID representing the current association between the route table and subnet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: AssociationId
-- @return DisassociateRouteTableRequest structure as a key-value pair table
function M.DisassociateRouteTableRequest(args)
	assert(args, "You must provide an argument table when creating DisassociateRouteTableRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDisassociateRouteTableRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAddressesRequest = { ["PublicIps"] = true, ["DryRun"] = true, ["AllocationIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then asserts.AssertPublicIpStringList(struct["PublicIps"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AllocationIds"] then asserts.AssertAllocationIdList(struct["AllocationIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAddressesRequest[k], "DescribeAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAddressesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIps [PublicIpStringList] <p>[EC2-Classic] One or more Elastic IP addresses.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AllocationIds [AllocationIdList] <p>[EC2-VPC] One or more allocation IDs.</p> <p>Default: Describes all your Elastic IP addresses.</p>
-- * Filters [FilterList] <p>One or more filters. Filter names and values are case-sensitive.</p> <ul> <li> <p> <code>allocation-id</code> - [EC2-VPC] The allocation ID for the address.</p> </li> <li> <p> <code>association-id</code> - [EC2-VPC] The association ID for the address.</p> </li> <li> <p> <code>domain</code> - Indicates whether the address is for use in EC2-Classic (<code>standard</code>) or in a VPC (<code>vpc</code>).</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-id</code> - [EC2-VPC] The ID of the network interface that the address is associated with, if any.</p> </li> <li> <p> <code>network-interface-owner-id</code> - The AWS account ID of the owner.</p> </li> <li> <p> <code>private-ip-address</code> - [EC2-VPC] The private IP address associated with the Elastic IP address.</p> </li> <li> <p> <code>public-ip</code> - The Elastic IP address.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> </ul>
-- @return DescribeAddressesRequest structure as a key-value pair table
function M.DescribeAddressesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAddressesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIps"] = args["PublicIps"],
		["DryRun"] = args["DryRun"],
		["AllocationIds"] = args["AllocationIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeAddressesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AllocateAddressResult = { ["PublicIp"] = true, ["Domain"] = true, ["AllocationId"] = true, ["PublicIpv4Pool"] = true, nil }

function asserts.AssertAllocateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressResult to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PublicIpv4Pool"] then asserts.AssertString(struct["PublicIpv4Pool"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateAddressResult[k], "AllocateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- * AllocationId [String] <p>[EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.</p>
-- * PublicIpv4Pool [String] <p>The ID of an address pool.</p>
-- @return AllocateAddressResult structure as a key-value pair table
function M.AllocateAddressResult(args)
	assert(args, "You must provide an argument table when creating AllocateAddressResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["Domain"] = args["Domain"],
		["AllocationId"] = args["AllocationId"],
		["PublicIpv4Pool"] = args["PublicIpv4Pool"],
	}
	asserts.AssertAllocateAddressResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotOptionsRequest = { ["InstanceInterruptionBehavior"] = true, ["InstancePoolsToUseCount"] = true, ["AllocationStrategy"] = true, nil }

function asserts.AssertSpotOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotOptionsRequest to be of type 'table'")
	if struct["InstanceInterruptionBehavior"] then asserts.AssertSpotInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	if struct["InstancePoolsToUseCount"] then asserts.AssertInteger(struct["InstancePoolsToUseCount"]) end
	if struct["AllocationStrategy"] then asserts.AssertSpotAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotOptionsRequest[k], "SpotOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotOptionsRequest
-- <p>Describes the configuration of Spot Instances in an EC2 Fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceInterruptionBehavior [SpotInstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
-- * InstancePoolsToUseCount [Integer] <p>The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot <b>AllocationStrategy</b> is set to <code>lowest-price</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.</p>
-- * AllocationStrategy [SpotAllocationStrategy] <p>Indicates how to allocate the target capacity across the Spot pools specified by the Spot Fleet request. The default is <code>lowestPrice</code>.</p>
-- @return SpotOptionsRequest structure as a key-value pair table
function M.SpotOptionsRequest(args)
	assert(args, "You must provide an argument table when creating SpotOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
		["InstancePoolsToUseCount"] = args["InstancePoolsToUseCount"],
		["AllocationStrategy"] = args["AllocationStrategy"],
	}
	asserts.AssertSpotOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FpgaImageState = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertFpgaImageState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FpgaImageState to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertFpgaImageStateCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.FpgaImageState[k], "FpgaImageState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FpgaImageState
-- <p>Describes the state of the bitstream generation process for an Amazon FPGA image (AFI).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>If the state is <code>failed</code>, this is the error message.</p>
-- * Code [FpgaImageStateCode] <p>The state. The following are the possible values:</p> <ul> <li> <p> <code>pending</code> - AFI bitstream generation is in progress.</p> </li> <li> <p> <code>available</code> - The AFI is available for use.</p> </li> <li> <p> <code>failed</code> - AFI bitstream generation failed.</p> </li> <li> <p> <code>unavailable</code> - The AFI is no longer available for use.</p> </li> </ul>
-- @return FpgaImageState structure as a key-value pair table
function M.FpgaImageState(args)
	assert(args, "You must provide an argument table when creating FpgaImageState")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertFpgaImageState(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFleetsRequest = { ["FleetIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["Filters"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeFleetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFleetsRequest to be of type 'table'")
	if struct["FleetIds"] then asserts.AssertFleetIdSet(struct["FleetIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFleetsRequest[k], "DescribeFleetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFleetsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FleetIds [FleetIdSet] <p>The ID of the EC2 Fleets.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>activity-status</code> - The progress of the EC2 Fleet ( <code>error</code> | <code>pending-fulfillment</code> | <code>pending-termination</code> | <code>fulfilled</code>).</p> </li> <li> <p> <code>excess-capacity-termination-policy</code> - Indicates whether to terminate running instances if the target capacity is decreased below the current EC2 Fleet size (<code>true</code> | <code>false</code>).</p> </li> <li> <p> <code>fleet-state</code> - The state of the EC2 Fleet (<code>submitted</code> | <code>active</code> | <code>deleted</code> | <code>failed</code> | <code>deleted-running</code> | <code>deleted-terminating</code> | <code>modifying</code>).</p> </li> <li> <p> <code>replace-unhealthy-instances</code> - Indicates whether EC2 Fleet should replace unhealthy instances (<code>true</code> | <code>false</code>).</p> </li> <li> <p> <code>type</code> - The type of request (<code>request</code> | <code>maintain</code>).</p> </li> </ul>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- @return DescribeFleetsRequest structure as a key-value pair table
function M.DescribeFleetsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeFleetsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FleetIds"] = args["FleetIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeFleetsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateCapacityReservationSpecificationRequest = { ["CapacityReservationTarget"] = true, ["CapacityReservationPreference"] = true, nil }

function asserts.AssertLaunchTemplateCapacityReservationSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateCapacityReservationSpecificationRequest to be of type 'table'")
	if struct["CapacityReservationTarget"] then asserts.AssertCapacityReservationTarget(struct["CapacityReservationTarget"]) end
	if struct["CapacityReservationPreference"] then asserts.AssertCapacityReservationPreference(struct["CapacityReservationPreference"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateCapacityReservationSpecificationRequest[k], "LaunchTemplateCapacityReservationSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateCapacityReservationSpecificationRequest
-- <p>Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the <code>CapacityReservationPreference</code> parameter to configure the instance to run in On-Demand capacity or to run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the <code>CapacityReservationTarget</code> parameter to explicitly target a specific Capacity Reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationTarget [CapacityReservationTarget] <p>Information about the target Capacity Reservation.</p>
-- * CapacityReservationPreference [CapacityReservationPreference] <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>
-- @return LaunchTemplateCapacityReservationSpecificationRequest structure as a key-value pair table
function M.LaunchTemplateCapacityReservationSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateCapacityReservationSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationTarget"] = args["CapacityReservationTarget"],
		["CapacityReservationPreference"] = args["CapacityReservationPreference"],
	}
	asserts.AssertLaunchTemplateCapacityReservationSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeElasticGpusResult = { ["NextToken"] = true, ["MaxResults"] = true, ["ElasticGpuSet"] = true, nil }

function asserts.AssertDescribeElasticGpusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeElasticGpusResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["ElasticGpuSet"] then asserts.AssertElasticGpuSet(struct["ElasticGpuSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeElasticGpusResult[k], "DescribeElasticGpusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeElasticGpusResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * MaxResults [Integer] <p>The total number of items to return. If the total number of items available is more than the value specified in max-items then a Next-Token will be provided in the output that you can use to resume pagination.</p>
-- * ElasticGpuSet [ElasticGpuSet] <p>Information about the Elastic GPUs.</p>
-- @return DescribeElasticGpusResult structure as a key-value pair table
function M.DescribeElasticGpusResult(args)
	assert(args, "You must provide an argument table when creating DescribeElasticGpusResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["ElasticGpuSet"] = args["ElasticGpuSet"],
	}
	asserts.AssertDescribeElasticGpusResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateCapacityReservationRequest = { ["EndDateType"] = true, ["InstanceCount"] = true, ["EndDate"] = true, ["InstanceMatchCriteria"] = true, ["AvailabilityZone"] = true, ["EphemeralStorage"] = true, ["TagSpecifications"] = true, ["InstancePlatform"] = true, ["Tenancy"] = true, ["ClientToken"] = true, ["EbsOptimized"] = true, ["DryRun"] = true, ["InstanceType"] = true, nil }

function asserts.AssertCreateCapacityReservationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCapacityReservationRequest to be of type 'table'")
	assert(struct["InstanceType"], "Expected key InstanceType to exist in table")
	assert(struct["InstancePlatform"], "Expected key InstancePlatform to exist in table")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	if struct["EndDateType"] then asserts.AssertEndDateType(struct["EndDateType"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["EndDate"] then asserts.AssertDateTime(struct["EndDate"]) end
	if struct["InstanceMatchCriteria"] then asserts.AssertInstanceMatchCriteria(struct["InstanceMatchCriteria"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["EphemeralStorage"] then asserts.AssertBoolean(struct["EphemeralStorage"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["InstancePlatform"] then asserts.AssertCapacityReservationInstancePlatform(struct["InstancePlatform"]) end
	if struct["Tenancy"] then asserts.AssertCapacityReservationTenancy(struct["Tenancy"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCapacityReservationRequest[k], "CreateCapacityReservationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCapacityReservationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EndDateType [EndDateType] <p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types:</p> <ul> <li> <p> <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an <code>EndDate</code> if the <code>EndDateType</code> is <code>unlimited</code>.</p> </li> <li> <p> <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time. You must provide an <code>EndDate</code> value if the <code>EndDateType</code> value is <code>limited</code>.</p> </li> </ul>
-- * InstanceCount [Integer] <p>The number of instances for which to reserve capacity.</p>
-- * EndDate [DateTime] <p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to <code>expired</code> when it reaches its end date and time.</p> <p>You must provide an <code>EndDate</code> value if <code>EndDateType</code> is <code>limited</code>. Omit <code>EndDate</code> if <code>EndDateType</code> is <code>unlimited</code>.</p> <p>If the <code>EndDateType</code> is <code>limited</code>, the Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.</p>
-- * InstanceMatchCriteria [InstanceMatchCriteria] <p>Indicates the type of instance launches that the Capacity Reservation accepts. The options include:</p> <ul> <li> <p> <code>open</code> - The Capacity Reservation automatically matches all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes run in the Capacity Reservation automatically without specifying any additional parameters.</p> </li> <li> <p> <code>targeted</code> - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. </p> </li> </ul> <p>Default: <code>open</code> </p>
-- * AvailabilityZone [String] <p>The Availability Zone in which to create the Capacity Reservation.</p>
-- * EphemeralStorage [Boolean] <p>Indicates whether the Capacity Reservation supports instances with temporary, block-level storage.</p>
-- * TagSpecifications [TagSpecificationList] <p>The tags to apply to the Capacity Reservation during launch.</p>
-- * InstancePlatform [CapacityReservationInstancePlatform] <p>The type of operating system for which to reserve capacity.</p>
-- * Tenancy [CapacityReservationTenancy] <p>Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:</p> <ul> <li> <p> <code>default</code> - The Capacity Reservation is created on hardware that is shared with other AWS accounts.</p> </li> <li> <p> <code>dedicated</code> - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account.</p> </li> </ul>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p> <p>Constraint: Maximum 64 ASCII characters.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceType [String] <p>The instance type for which to reserve capacity. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- Required key: InstanceType
-- Required key: InstancePlatform
-- Required key: AvailabilityZone
-- Required key: InstanceCount
-- @return CreateCapacityReservationRequest structure as a key-value pair table
function M.CreateCapacityReservationRequest(args)
	assert(args, "You must provide an argument table when creating CreateCapacityReservationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EndDateType"] = args["EndDateType"],
		["InstanceCount"] = args["InstanceCount"],
		["EndDate"] = args["EndDate"],
		["InstanceMatchCriteria"] = args["InstanceMatchCriteria"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["EphemeralStorage"] = args["EphemeralStorage"],
		["TagSpecifications"] = args["TagSpecifications"],
		["InstancePlatform"] = args["InstancePlatform"],
		["Tenancy"] = args["Tenancy"],
		["ClientToken"] = args["ClientToken"],
		["EbsOptimized"] = args["EbsOptimized"],
		["DryRun"] = args["DryRun"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertCreateCapacityReservationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, nil }

function asserts.AssertDescribeSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotDatafeedSubscriptionRequest[k], "DescribeSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DescribeSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DescribeSpotDatafeedSubscriptionRequest structure as a key-value pair table
function M.DescribeSpotDatafeedSubscriptionRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSpotDatafeedSubscriptionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeSpotDatafeedSubscriptionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CpuOptionsRequest = { ["CoreCount"] = true, ["ThreadsPerCore"] = true, nil }

function asserts.AssertCpuOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CpuOptionsRequest to be of type 'table'")
	if struct["CoreCount"] then asserts.AssertInteger(struct["CoreCount"]) end
	if struct["ThreadsPerCore"] then asserts.AssertInteger(struct["ThreadsPerCore"]) end
	for k,_ in pairs(struct) do
		assert(keys.CpuOptionsRequest[k], "CpuOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CpuOptionsRequest
-- <p>The CPU options for the instance. Both the core count and threads per core must be specified in the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CoreCount [Integer] <p>The number of CPU cores for the instance.</p>
-- * ThreadsPerCore [Integer] <p>The number of threads per CPU core. To disable Intel Hyper-Threading Technology for the instance, specify a value of <code>1</code>. Otherwise, specify the default value of <code>2</code>.</p>
-- @return CpuOptionsRequest structure as a key-value pair table
function M.CpuOptionsRequest(args)
	assert(args, "You must provide an argument table when creating CpuOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CoreCount"] = args["CoreCount"],
		["ThreadsPerCore"] = args["ThreadsPerCore"],
	}
	asserts.AssertCpuOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcEndpointServiceConfigurationsRequest = { ["DryRun"] = true, ["ServiceIds"] = true, nil }

function asserts.AssertDeleteVpcEndpointServiceConfigurationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointServiceConfigurationsRequest to be of type 'table'")
	assert(struct["ServiceIds"], "Expected key ServiceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ServiceIds"] then asserts.AssertValueStringList(struct["ServiceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointServiceConfigurationsRequest[k], "DeleteVpcEndpointServiceConfigurationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointServiceConfigurationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ServiceIds [ValueStringList] <p>The IDs of one or more services.</p>
-- Required key: ServiceIds
-- @return DeleteVpcEndpointServiceConfigurationsRequest structure as a key-value pair table
function M.DeleteVpcEndpointServiceConfigurationsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpcEndpointServiceConfigurationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["ServiceIds"] = args["ServiceIds"],
	}
	asserts.AssertDeleteVpcEndpointServiceConfigurationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateSpotMarketOptions = { ["SpotInstanceType"] = true, ["BlockDurationMinutes"] = true, ["ValidUntil"] = true, ["MaxPrice"] = true, ["InstanceInterruptionBehavior"] = true, nil }

function asserts.AssertLaunchTemplateSpotMarketOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateSpotMarketOptions to be of type 'table'")
	if struct["SpotInstanceType"] then asserts.AssertSpotInstanceType(struct["SpotInstanceType"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["MaxPrice"] then asserts.AssertString(struct["MaxPrice"]) end
	if struct["InstanceInterruptionBehavior"] then asserts.AssertInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateSpotMarketOptions[k], "LaunchTemplateSpotMarketOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateSpotMarketOptions
-- <p>The options for Spot Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceType [SpotInstanceType] <p>The Spot Instance request type.</p>
-- * BlockDurationMinutes [Integer] <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>
-- * ValidUntil [DateTime] <p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.</p>
-- * MaxPrice [String] <p>The maximum hourly price you're willing to pay for the Spot Instances.</p>
-- * InstanceInterruptionBehavior [InstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted.</p>
-- @return LaunchTemplateSpotMarketOptions structure as a key-value pair table
function M.LaunchTemplateSpotMarketOptions(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateSpotMarketOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotInstanceType"] = args["SpotInstanceType"],
		["BlockDurationMinutes"] = args["BlockDurationMinutes"],
		["ValidUntil"] = args["ValidUntil"],
		["MaxPrice"] = args["MaxPrice"],
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
	}
	asserts.AssertLaunchTemplateSpotMarketOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteNetworkAclEntryRequest = { ["NetworkAclId"] = true, ["Egress"] = true, ["DryRun"] = true, ["RuleNumber"] = true, nil }

function asserts.AssertDeleteNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkAclEntryRequest[k], "DeleteNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkAclEntryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * Egress [Boolean] <p>Indicates whether the rule is an egress rule.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * RuleNumber [Integer] <p>The rule number of the entry to delete.</p>
-- Required key: Egress
-- Required key: NetworkAclId
-- Required key: RuleNumber
-- @return DeleteNetworkAclEntryRequest structure as a key-value pair table
function M.DeleteNetworkAclEntryRequest(args)
	assert(args, "You must provide an argument table when creating DeleteNetworkAclEntryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkAclId"] = args["NetworkAclId"],
		["Egress"] = args["Egress"],
		["DryRun"] = args["DryRun"],
		["RuleNumber"] = args["RuleNumber"],
	}
	asserts.AssertDeleteNetworkAclEntryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, nil }

function asserts.AssertDeleteSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSpotDatafeedSubscriptionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSpotDatafeedSubscriptionRequest[k], "DeleteSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for DeleteSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return DeleteSpotDatafeedSubscriptionRequest structure as a key-value pair table
function M.DeleteSpotDatafeedSubscriptionRequest(args)
	assert(args, "You must provide an argument table when creating DeleteSpotDatafeedSubscriptionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteSpotDatafeedSubscriptionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.OnDemandOptionsRequest = { ["AllocationStrategy"] = true, nil }

function asserts.AssertOnDemandOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected OnDemandOptionsRequest to be of type 'table'")
	if struct["AllocationStrategy"] then asserts.AssertFleetOnDemandAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.OnDemandOptionsRequest[k], "OnDemandOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type OnDemandOptionsRequest
-- <p>The allocation strategy of On-Demand Instances in an EC2 Fleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllocationStrategy [FleetOnDemandAllocationStrategy] <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first. If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>
-- @return OnDemandOptionsRequest structure as a key-value pair table
function M.OnDemandOptionsRequest(args)
	assert(args, "You must provide an argument table when creating OnDemandOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AllocationStrategy"] = args["AllocationStrategy"],
	}
	asserts.AssertOnDemandOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeBundleTasksResult = { ["BundleTasks"] = true, nil }

function asserts.AssertDescribeBundleTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksResult to be of type 'table'")
	if struct["BundleTasks"] then asserts.AssertBundleTaskList(struct["BundleTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeBundleTasksResult[k], "DescribeBundleTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksResult
-- <p>Contains the output of DescribeBundleTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BundleTasks [BundleTaskList] <p>Information about one or more bundle tasks.</p>
-- @return DescribeBundleTasksResult structure as a key-value pair table
function M.DescribeBundleTasksResult(args)
	assert(args, "You must provide an argument table when creating DescribeBundleTasksResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BundleTasks"] = args["BundleTasks"],
	}
	asserts.AssertDescribeBundleTasksResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceIamInstanceProfileAssociationRequest = { ["AssociationId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertReplaceIamInstanceProfileAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceIamInstanceProfileAssociationRequest[k], "ReplaceIamInstanceProfileAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The ID of the existing IAM instance profile association.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required key: IamInstanceProfile
-- Required key: AssociationId
-- @return ReplaceIamInstanceProfileAssociationRequest structure as a key-value pair table
function M.ReplaceIamInstanceProfileAssociationRequest(args)
	assert(args, "You must provide an argument table when creating ReplaceIamInstanceProfileAssociationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
	}
	asserts.AssertReplaceIamInstanceProfileAssociationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFleetHistoryRequest = { ["DryRun"] = true, ["EventType"] = true, ["MaxResults"] = true, ["FleetId"] = true, ["StartTime"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFleetHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFleetHistoryRequest to be of type 'table'")
	assert(struct["FleetId"], "Expected key FleetId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["EventType"] then asserts.AssertFleetEventType(struct["EventType"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFleetHistoryRequest[k], "DescribeFleetHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFleetHistoryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * EventType [FleetEventType] <p>The type of events to describe. By default, all events are described.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- * StartTime [DateTime] <p>The start date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- Required key: FleetId
-- Required key: StartTime
-- @return DescribeFleetHistoryRequest structure as a key-value pair table
function M.DescribeFleetHistoryRequest(args)
	assert(args, "You must provide an argument table when creating DescribeFleetHistoryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["EventType"] = args["EventType"],
		["MaxResults"] = args["MaxResults"],
		["FleetId"] = args["FleetId"],
		["StartTime"] = args["StartTime"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFleetHistoryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVolumeAttributeRequest = { ["AutoEnableIO"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertModifyVolumeAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeAttributeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["AutoEnableIO"] then asserts.AssertAttributeBooleanValue(struct["AutoEnableIO"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeAttributeRequest[k], "ModifyVolumeAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeAttributeRequest
-- <p>Contains the parameters for ModifyVolumeAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AutoEnableIO [AttributeBooleanValue] <p>Indicates whether the volume should be auto-enabled for I/O operations.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return ModifyVolumeAttributeRequest structure as a key-value pair table
function M.ModifyVolumeAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVolumeAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AutoEnableIO"] = args["AutoEnableIO"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertModifyVolumeAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateRouteResult = { ["Return"] = true, nil }

function asserts.AssertCreateRouteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteResult[k], "CreateRouteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return CreateRouteResult structure as a key-value pair table
function M.CreateRouteResult(args)
	assert(args, "You must provide an argument table when creating CreateRouteResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertCreateRouteResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportInstanceLaunchSpecification = { ["AdditionalInfo"] = true, ["Monitoring"] = true, ["UserData"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["GroupNames"] = true, ["Architecture"] = true, ["SubnetId"] = true, ["Placement"] = true, ["InstanceType"] = true, ["PrivateIpAddress"] = true, ["GroupIds"] = true, nil }

function asserts.AssertImportInstanceLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceLaunchSpecification to be of type 'table'")
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["Monitoring"] then asserts.AssertBoolean(struct["Monitoring"]) end
	if struct["UserData"] then asserts.AssertUserData(struct["UserData"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["GroupNames"] then asserts.AssertSecurityGroupStringList(struct["GroupNames"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["GroupIds"] then asserts.AssertSecurityGroupIdStringList(struct["GroupIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceLaunchSpecification[k], "ImportInstanceLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceLaunchSpecification
-- <p>Describes the launch specification for VM import.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AdditionalInfo [String] <p>Reserved.</p>
-- * Monitoring [Boolean] <p>Indicates whether monitoring is enabled.</p>
-- * UserData [UserData] <p>The Base64-encoded user data to make available to the instance.</p>
-- * InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- * GroupNames [SecurityGroupStringList] <p>One or more security group names.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the instance.</p>
-- * SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which to launch the instance.</p>
-- * Placement [Placement] <p>The placement information for the instance.</p>
-- * InstanceType [InstanceType] <p>The instance type. For more information about the instance types that you can import, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmie_prereqs.html#vmimport-instance-types">Instance Types</a> in the VM Import/Export User Guide.</p>
-- * PrivateIpAddress [String] <p>[EC2-VPC] An available IP address from the IP address range of the subnet.</p>
-- * GroupIds [SecurityGroupIdStringList] <p>One or more security group IDs.</p>
-- @return ImportInstanceLaunchSpecification structure as a key-value pair table
function M.ImportInstanceLaunchSpecification(args)
	assert(args, "You must provide an argument table when creating ImportInstanceLaunchSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AdditionalInfo"] = args["AdditionalInfo"],
		["Monitoring"] = args["Monitoring"],
		["UserData"] = args["UserData"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["GroupNames"] = args["GroupNames"],
		["Architecture"] = args["Architecture"],
		["SubnetId"] = args["SubnetId"],
		["Placement"] = args["Placement"],
		["InstanceType"] = args["InstanceType"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["GroupIds"] = args["GroupIds"],
	}
	asserts.AssertImportInstanceLaunchSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDhcpOptionsRequest = { ["DryRun"] = true, ["DhcpConfigurations"] = true, nil }

function asserts.AssertCreateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpConfigurations"], "Expected key DhcpConfigurations to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpConfigurations"] then asserts.AssertNewDhcpConfigurationList(struct["DhcpConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDhcpOptionsRequest[k], "CreateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DhcpConfigurations [NewDhcpConfigurationList] <p>A DHCP configuration option.</p>
-- Required key: DhcpConfigurations
-- @return CreateDhcpOptionsRequest structure as a key-value pair table
function M.CreateDhcpOptionsRequest(args)
	assert(args, "You must provide an argument table when creating CreateDhcpOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["DhcpConfigurations"] = args["DhcpConfigurations"],
	}
	asserts.AssertCreateDhcpOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateVpcCidrBlockResult = { ["Ipv6CidrBlockAssociation"] = true, ["CidrBlockAssociation"] = true, ["VpcId"] = true, nil }

function asserts.AssertDisassociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["CidrBlockAssociation"] then asserts.AssertVpcCidrBlockAssociation(struct["CidrBlockAssociation"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateVpcCidrBlockResult[k], "DisassociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- * CidrBlockAssociation [VpcCidrBlockAssociation] <p>Information about the IPv4 CIDR block association.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return DisassociateVpcCidrBlockResult structure as a key-value pair table
function M.DisassociateVpcCidrBlockResult(args)
	assert(args, "You must provide an argument table when creating DisassociateVpcCidrBlockResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
		["CidrBlockAssociation"] = args["CidrBlockAssociation"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertDisassociateVpcCidrBlockResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpnConnectionRequest = { ["VpnConnectionId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpnConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnConnectionRequest to be of type 'table'")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnConnectionRequest[k], "DeleteVpnConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnConnectionRequest
-- <p>Contains the parameters for DeleteVpnConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpnConnectionId
-- @return DeleteVpnConnectionRequest structure as a key-value pair table
function M.DeleteVpnConnectionRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpnConnectionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpnConnectionId"] = args["VpnConnectionId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteVpnConnectionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpnGatewayResult = { ["VpnGateway"] = true, nil }

function asserts.AssertCreateVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayResult to be of type 'table'")
	if struct["VpnGateway"] then asserts.AssertVpnGateway(struct["VpnGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnGatewayResult[k], "CreateVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayResult
-- <p>Contains the output of CreateVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnGateway [VpnGateway] <p>Information about the virtual private gateway.</p>
-- @return CreateVpnGatewayResult structure as a key-value pair table
function M.CreateVpnGatewayResult(args)
	assert(args, "You must provide an argument table when creating CreateVpnGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpnGateway"] = args["VpnGateway"],
	}
	asserts.AssertCreateVpnGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ServiceDetail = { ["ServiceType"] = true, ["PrivateDnsName"] = true, ["ServiceName"] = true, ["VpcEndpointPolicySupported"] = true, ["Owner"] = true, ["AvailabilityZones"] = true, ["AcceptanceRequired"] = true, ["BaseEndpointDnsNames"] = true, nil }

function asserts.AssertServiceDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ServiceDetail to be of type 'table'")
	if struct["ServiceType"] then asserts.AssertServiceTypeDetailSet(struct["ServiceType"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["VpcEndpointPolicySupported"] then asserts.AssertBoolean(struct["VpcEndpointPolicySupported"]) end
	if struct["Owner"] then asserts.AssertString(struct["Owner"]) end
	if struct["AvailabilityZones"] then asserts.AssertValueStringList(struct["AvailabilityZones"]) end
	if struct["AcceptanceRequired"] then asserts.AssertBoolean(struct["AcceptanceRequired"]) end
	if struct["BaseEndpointDnsNames"] then asserts.AssertValueStringList(struct["BaseEndpointDnsNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.ServiceDetail[k], "ServiceDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ServiceDetail
-- <p>Describes a VPC endpoint service.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceType [ServiceTypeDetailSet] <p>The type of service.</p>
-- * PrivateDnsName [String] <p>The private DNS name for the service.</p>
-- * ServiceName [String] <p>The Amazon Resource Name (ARN) of the service.</p>
-- * VpcEndpointPolicySupported [Boolean] <p>Indicates whether the service supports endpoint policies.</p>
-- * Owner [String] <p>The AWS account ID of the service owner.</p>
-- * AvailabilityZones [ValueStringList] <p>The Availability Zones in which the service is available.</p>
-- * AcceptanceRequired [Boolean] <p>Indicates whether VPC endpoint connection requests to the service must be accepted by the service owner.</p>
-- * BaseEndpointDnsNames [ValueStringList] <p>The DNS names for the service.</p>
-- @return ServiceDetail structure as a key-value pair table
function M.ServiceDetail(args)
	assert(args, "You must provide an argument table when creating ServiceDetail")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceType"] = args["ServiceType"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["ServiceName"] = args["ServiceName"],
		["VpcEndpointPolicySupported"] = args["VpcEndpointPolicySupported"],
		["Owner"] = args["Owner"],
		["AvailabilityZones"] = args["AvailabilityZones"],
		["AcceptanceRequired"] = args["AcceptanceRequired"],
		["BaseEndpointDnsNames"] = args["BaseEndpointDnsNames"],
	}
	asserts.AssertServiceDetail(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyIdentityIdFormatRequest = { ["UseLongIds"] = true, ["PrincipalArn"] = true, ["Resource"] = true, nil }

function asserts.AssertModifyIdentityIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdentityIdFormatRequest to be of type 'table'")
	assert(struct["PrincipalArn"], "Expected key PrincipalArn to exist in table")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	if struct["PrincipalArn"] then asserts.AssertString(struct["PrincipalArn"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyIdentityIdFormatRequest[k], "ModifyIdentityIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdentityIdFormatRequest
-- <p>Contains the parameters of ModifyIdentityIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UseLongIds [Boolean] <p>Indicates whether the resource should use longer IDs (17-character IDs)</p>
-- * PrincipalArn [String] <p>The ARN of the principal, which can be an IAM user, IAM role, or the root user. Specify <code>all</code> to modify the ID format for all IAM users, IAM roles, and the root user of the account.</p>
-- * Resource [String] <p>The type of resource: <code>bundle</code> | <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> | <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> | <code>export-task</code> | <code>flow-log</code> | <code>image</code> | <code>import-task</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-acl-association</code> | <code>network-interface</code> | <code>network-interface-attachment</code> | <code>prefix-list</code> | <code>route-table</code> | <code>route-table-association</code> | <code>security-group</code> | <code>subnet</code> | <code>subnet-cidr-block-association</code> | <code>vpc</code> | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>.</p> <p>Alternatively, use the <code>all-current</code> option to include all resource types that are currently within their opt-in period for longer IDs.</p>
-- Required key: PrincipalArn
-- Required key: Resource
-- Required key: UseLongIds
-- @return ModifyIdentityIdFormatRequest structure as a key-value pair table
function M.ModifyIdentityIdFormatRequest(args)
	assert(args, "You must provide an argument table when creating ModifyIdentityIdFormatRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UseLongIds"] = args["UseLongIds"],
		["PrincipalArn"] = args["PrincipalArn"],
		["Resource"] = args["Resource"],
	}
	asserts.AssertModifyIdentityIdFormatRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachVolumeRequest = { ["Device"] = true, ["InstanceId"] = true, ["DryRun"] = true, ["VolumeId"] = true, nil }

function asserts.AssertAttachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVolumeRequest to be of type 'table'")
	assert(struct["Device"], "Expected key Device to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVolumeRequest[k], "AttachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVolumeRequest
-- <p>Contains the parameters for AttachVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Device [String] <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the EBS volume. The volume and instance must be within the same Availability Zone.</p>
-- Required key: Device
-- Required key: InstanceId
-- Required key: VolumeId
-- @return AttachVolumeRequest structure as a key-value pair table
function M.AttachVolumeRequest(args)
	assert(args, "You must provide an argument table when creating AttachVolumeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Device"] = args["Device"],
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertAttachVolumeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointServicePermissionsRequest = { ["ServiceId"] = true, ["DryRun"] = true, ["RemoveAllowedPrincipals"] = true, ["AddAllowedPrincipals"] = true, nil }

function asserts.AssertModifyVpcEndpointServicePermissionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointServicePermissionsRequest to be of type 'table'")
	assert(struct["ServiceId"], "Expected key ServiceId to exist in table")
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RemoveAllowedPrincipals"] then asserts.AssertValueStringList(struct["RemoveAllowedPrincipals"]) end
	if struct["AddAllowedPrincipals"] then asserts.AssertValueStringList(struct["AddAllowedPrincipals"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointServicePermissionsRequest[k], "ModifyVpcEndpointServicePermissionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointServicePermissionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceId [String] <p>The ID of the service.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * RemoveAllowedPrincipals [ValueStringList] <p>The Amazon Resource Names (ARN) of one or more principals. Permissions are revoked for principals in this list.</p>
-- * AddAllowedPrincipals [ValueStringList] <p>The Amazon Resource Names (ARN) of one or more principals. Permissions are granted to the principals in this list. To grant permissions to all principals, specify an asterisk (*).</p>
-- Required key: ServiceId
-- @return ModifyVpcEndpointServicePermissionsRequest structure as a key-value pair table
function M.ModifyVpcEndpointServicePermissionsRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointServicePermissionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceId"] = args["ServiceId"],
		["DryRun"] = args["DryRun"],
		["RemoveAllowedPrincipals"] = args["RemoveAllowedPrincipals"],
		["AddAllowedPrincipals"] = args["AddAllowedPrincipals"],
	}
	asserts.AssertModifyVpcEndpointServicePermissionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateEbsBlockDevice = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["KmsKeyId"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, ["Iops"] = true, nil }

function asserts.AssertLaunchTemplateEbsBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateEbsBlockDevice to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateEbsBlockDevice[k], "LaunchTemplateEbsBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateEbsBlockDevice
-- <p>Describes a block device for an EBS volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p>
-- * Encrypted [Boolean] <p>Indicates whether the EBS volume is encrypted.</p>
-- * VolumeType [VolumeType] <p>The volume type.</p>
-- * KmsKeyId [String] <p>The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. </p>
-- @return LaunchTemplateEbsBlockDevice structure as a key-value pair table
function M.LaunchTemplateEbsBlockDevice(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateEbsBlockDevice")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumeSize"] = args["VolumeSize"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["KmsKeyId"] = args["KmsKeyId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
	}
	asserts.AssertLaunchTemplateEbsBlockDevice(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeRegionsRequest = { ["DryRun"] = true, ["Filters"] = true, ["RegionNames"] = true, nil }

function asserts.AssertDescribeRegionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRegionsRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["RegionNames"] then asserts.AssertRegionNameStringList(struct["RegionNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRegionsRequest[k], "DescribeRegionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRegionsRequest
-- <p>Contains the parameters for DescribeRegions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>endpoint</code> - The endpoint of the region (for example, <code>ec2.us-east-1.amazonaws.com</code>).</p> </li> <li> <p> <code>region-name</code> - The name of the region (for example, <code>us-east-1</code>).</p> </li> </ul>
-- * RegionNames [RegionNameStringList] <p>The names of one or more regions.</p>
-- @return DescribeRegionsRequest structure as a key-value pair table
function M.DescribeRegionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeRegionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["RegionNames"] = args["RegionNames"],
	}
	asserts.AssertDescribeRegionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceStatusEvent = { ["Code"] = true, ["Description"] = true, ["NotBefore"] = true, ["NotAfter"] = true, nil }

function asserts.AssertInstanceStatusEvent(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusEvent to be of type 'table'")
	if struct["Code"] then asserts.AssertEventCode(struct["Code"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["NotBefore"] then asserts.AssertDateTime(struct["NotBefore"]) end
	if struct["NotAfter"] then asserts.AssertDateTime(struct["NotAfter"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusEvent[k], "InstanceStatusEvent contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusEvent
-- <p>Describes a scheduled event for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Code [EventCode] <p>The event code.</p>
-- * Description [String] <p>A description of the event.</p> <p>After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].</p>
-- * NotBefore [DateTime] <p>The earliest scheduled start time for the event.</p>
-- * NotAfter [DateTime] <p>The latest scheduled end time for the event.</p>
-- @return InstanceStatusEvent structure as a key-value pair table
function M.InstanceStatusEvent(args)
	assert(args, "You must provide an argument table when creating InstanceStatusEvent")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Code"] = args["Code"],
		["Description"] = args["Description"],
		["NotBefore"] = args["NotBefore"],
		["NotAfter"] = args["NotAfter"],
	}
	asserts.AssertInstanceStatusEvent(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceRouteTableAssociationResult = { ["NewAssociationId"] = true, nil }

function asserts.AssertReplaceRouteTableAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceRouteTableAssociationResult to be of type 'table'")
	if struct["NewAssociationId"] then asserts.AssertString(struct["NewAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceRouteTableAssociationResult[k], "ReplaceRouteTableAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceRouteTableAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NewAssociationId [String] <p>The ID of the new association.</p>
-- @return ReplaceRouteTableAssociationResult structure as a key-value pair table
function M.ReplaceRouteTableAssociationResult(args)
	assert(args, "You must provide an argument table when creating ReplaceRouteTableAssociationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NewAssociationId"] = args["NewAssociationId"],
	}
	asserts.AssertReplaceRouteTableAssociationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.BundleTask = { ["UpdateTime"] = true, ["InstanceId"] = true, ["Storage"] = true, ["BundleTaskError"] = true, ["State"] = true, ["StartTime"] = true, ["Progress"] = true, ["BundleId"] = true, nil }

function asserts.AssertBundleTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTask to be of type 'table'")
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Storage"] then asserts.AssertStorage(struct["Storage"]) end
	if struct["BundleTaskError"] then asserts.AssertBundleTaskError(struct["BundleTaskError"]) end
	if struct["State"] then asserts.AssertBundleTaskState(struct["State"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["BundleId"] then asserts.AssertString(struct["BundleId"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleTask[k], "BundleTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTask
-- <p>Describes a bundle task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UpdateTime [DateTime] <p>The time of the most recent update for the task.</p>
-- * InstanceId [String] <p>The ID of the instance associated with this bundle task.</p>
-- * Storage [Storage] <p>The Amazon S3 storage locations.</p>
-- * BundleTaskError [BundleTaskError] <p>If the task fails, a description of the error.</p>
-- * State [BundleTaskState] <p>The state of the task.</p>
-- * StartTime [DateTime] <p>The time this task started.</p>
-- * Progress [String] <p>The level of task completion, as a percent (for example, 20%).</p>
-- * BundleId [String] <p>The ID of the bundle task.</p>
-- @return BundleTask structure as a key-value pair table
function M.BundleTask(args)
	assert(args, "You must provide an argument table when creating BundleTask")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UpdateTime"] = args["UpdateTime"],
		["InstanceId"] = args["InstanceId"],
		["Storage"] = args["Storage"],
		["BundleTaskError"] = args["BundleTaskError"],
		["State"] = args["State"],
		["StartTime"] = args["StartTime"],
		["Progress"] = args["Progress"],
		["BundleId"] = args["BundleId"],
	}
	asserts.AssertBundleTask(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportImageResult = { ["Status"] = true, ["LicenseType"] = true, ["Description"] = true, ["Hypervisor"] = true, ["ImageId"] = true, ["Platform"] = true, ["Architecture"] = true, ["SnapshotDetails"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageResult to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then asserts.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageResult[k], "ImportImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageResult
-- <p>Contains the output for ImportImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status of the task.</p>
-- * LicenseType [String] <p>The license type of the virtual machine.</p>
-- * Description [String] <p>A description of the import task.</p>
-- * Hypervisor [String] <p>The target hypervisor of the import task.</p>
-- * ImageId [String] <p>The ID of the Amazon Machine Image (AMI) created by the import task.</p>
-- * Platform [String] <p>The operating system of the virtual machine.</p>
-- * Architecture [String] <p>The architecture of the virtual machine.</p>
-- * SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- * Progress [String] <p>The progress of the task.</p>
-- * StatusMessage [String] <p>A detailed status message of the import task.</p>
-- * ImportTaskId [String] <p>The task ID of the import image task.</p>
-- @return ImportImageResult structure as a key-value pair table
function M.ImportImageResult(args)
	assert(args, "You must provide an argument table when creating ImportImageResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["LicenseType"] = args["LicenseType"],
		["Description"] = args["Description"],
		["Hypervisor"] = args["Hypervisor"],
		["ImageId"] = args["ImageId"],
		["Platform"] = args["Platform"],
		["Architecture"] = args["Architecture"],
		["SnapshotDetails"] = args["SnapshotDetails"],
		["Progress"] = args["Progress"],
		["StatusMessage"] = args["StatusMessage"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportImageResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNetworkInterfaceResult = { ["NetworkInterface"] = true, nil }

function asserts.AssertCreateNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceResult to be of type 'table'")
	if struct["NetworkInterface"] then asserts.AssertNetworkInterface(struct["NetworkInterface"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfaceResult[k], "CreateNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceResult
-- <p>Contains the output of CreateNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterface [NetworkInterface] <p>Information about the network interface.</p>
-- @return CreateNetworkInterfaceResult structure as a key-value pair table
function M.CreateNetworkInterfaceResult(args)
	assert(args, "You must provide an argument table when creating CreateNetworkInterfaceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterface"] = args["NetworkInterface"],
	}
	asserts.AssertCreateNetworkInterfaceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LoadPermission = { ["Group"] = true, ["UserId"] = true, nil }

function asserts.AssertLoadPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LoadPermission to be of type 'table'")
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	for k,_ in pairs(struct) do
		assert(keys.LoadPermission[k], "LoadPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LoadPermission
-- <p>Describes a load permission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Group [PermissionGroup] <p>The name of the group.</p>
-- * UserId [String] <p>The AWS account ID.</p>
-- @return LoadPermission structure as a key-value pair table
function M.LoadPermission(args)
	assert(args, "You must provide an argument table when creating LoadPermission")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Group"] = args["Group"],
		["UserId"] = args["UserId"],
	}
	asserts.AssertLoadPermission(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyImageAttributeRequest = { ["ProductCodes"] = true, ["UserGroups"] = true, ["DryRun"] = true, ["Description"] = true, ["Attribute"] = true, ["UserIds"] = true, ["Value"] = true, ["ImageId"] = true, ["OperationType"] = true, ["LaunchPermission"] = true, nil }

function asserts.AssertModifyImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyImageAttributeRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["ProductCodes"] then asserts.AssertProductCodeStringList(struct["ProductCodes"]) end
	if struct["UserGroups"] then asserts.AssertUserGroupStringList(struct["UserGroups"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["Attribute"] then asserts.AssertString(struct["Attribute"]) end
	if struct["UserIds"] then asserts.AssertUserIdStringList(struct["UserIds"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["OperationType"] then asserts.AssertOperationType(struct["OperationType"]) end
	if struct["LaunchPermission"] then asserts.AssertLaunchPermissionModifications(struct["LaunchPermission"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyImageAttributeRequest[k], "ModifyImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyImageAttributeRequest
-- <p>Contains the parameters for ModifyImageAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeStringList] <p>One or more DevPay product codes. After you add a product code to an AMI, it can't be removed.</p>
-- * UserGroups [UserGroupStringList] <p>One or more user groups. This parameter can be used only when the <code>Attribute</code> parameter is <code>launchPermission</code>.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [AttributeValue] <p>A new description for the AMI.</p>
-- * Attribute [String] <p>The name of the attribute to modify. The valid values are <code>description</code>, <code>launchPermission</code>, and <code>productCodes</code>.</p>
-- * UserIds [UserIdStringList] <p>One or more AWS account IDs. This parameter can be used only when the <code>Attribute</code> parameter is <code>launchPermission</code>.</p>
-- * Value [String] <p>The value of the attribute being modified. This parameter can be used only when the <code>Attribute</code> parameter is <code>description</code> or <code>productCodes</code>.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * OperationType [OperationType] <p>The operation type. This parameter can be used only when the <code>Attribute</code> parameter is <code>launchPermission</code>.</p>
-- * LaunchPermission [LaunchPermissionModifications] <p>A new launch permission for the AMI.</p>
-- Required key: ImageId
-- @return ModifyImageAttributeRequest structure as a key-value pair table
function M.ModifyImageAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifyImageAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ProductCodes"] = args["ProductCodes"],
		["UserGroups"] = args["UserGroups"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Attribute"] = args["Attribute"],
		["UserIds"] = args["UserIds"],
		["Value"] = args["Value"],
		["ImageId"] = args["ImageId"],
		["OperationType"] = args["OperationType"],
		["LaunchPermission"] = args["LaunchPermission"],
	}
	asserts.AssertModifyImageAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotFleetRequestsResponse = { ["SpotFleetRequestConfigs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestsResponse to be of type 'table'")
	assert(struct["SpotFleetRequestConfigs"], "Expected key SpotFleetRequestConfigs to exist in table")
	if struct["SpotFleetRequestConfigs"] then asserts.AssertSpotFleetRequestConfigSet(struct["SpotFleetRequestConfigs"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestsResponse[k], "DescribeSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestsResponse
-- <p>Contains the output of DescribeSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestConfigs [SpotFleetRequestConfigSet] <p>Information about the configuration of your Spot Fleet.</p>
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- Required key: SpotFleetRequestConfigs
-- @return DescribeSpotFleetRequestsResponse structure as a key-value pair table
function M.DescribeSpotFleetRequestsResponse(args)
	assert(args, "You must provide an argument table when creating DescribeSpotFleetRequestsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestConfigs"] = args["SpotFleetRequestConfigs"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSpotFleetRequestsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyFpgaImageAttributeResult = { ["FpgaImageAttribute"] = true, nil }

function asserts.AssertModifyFpgaImageAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyFpgaImageAttributeResult to be of type 'table'")
	if struct["FpgaImageAttribute"] then asserts.AssertFpgaImageAttribute(struct["FpgaImageAttribute"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyFpgaImageAttributeResult[k], "ModifyFpgaImageAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyFpgaImageAttributeResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageAttribute [FpgaImageAttribute] <p>Information about the attribute.</p>
-- @return ModifyFpgaImageAttributeResult structure as a key-value pair table
function M.ModifyFpgaImageAttributeResult(args)
	assert(args, "You must provide an argument table when creating ModifyFpgaImageAttributeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageAttribute"] = args["FpgaImageAttribute"],
	}
	asserts.AssertModifyFpgaImageAttributeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointServicesRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ServiceNames"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicesRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ServiceNames"] then asserts.AssertValueStringList(struct["ServiceNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicesRequest[k], "DescribeVpcEndpointServicesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicesRequest
-- <p>Contains the parameters for DescribeVpcEndpointServices.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>service-name</code>: The name of the service.</p> </li> </ul>
-- * ServiceNames [ValueStringList] <p>One or more service names.</p>
-- @return DescribeVpcEndpointServicesRequest structure as a key-value pair table
function M.DescribeVpcEndpointServicesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointServicesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["ServiceNames"] = args["ServiceNames"],
	}
	asserts.AssertDescribeVpcEndpointServicesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NewDhcpConfiguration = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertNewDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NewDhcpConfiguration to be of type 'table'")
	if struct["Values"] then asserts.AssertValueStringList(struct["Values"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.NewDhcpConfiguration[k], "NewDhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NewDhcpConfiguration
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [ValueStringList] 
-- * Key [String] 
-- @return NewDhcpConfiguration structure as a key-value pair table
function M.NewDhcpConfiguration(args)
	assert(args, "You must provide an argument table when creating NewDhcpConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertNewDhcpConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcPeeringConnectionOptionsResult = { ["RequesterPeeringConnectionOptions"] = true, ["AccepterPeeringConnectionOptions"] = true, nil }

function asserts.AssertModifyVpcPeeringConnectionOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsResult to be of type 'table'")
	if struct["RequesterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptions(struct["RequesterPeeringConnectionOptions"]) end
	if struct["AccepterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptions(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcPeeringConnectionOptionsResult[k], "ModifyVpcPeeringConnectionOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RequesterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the requester VPC.</p>
-- * AccepterPeeringConnectionOptions [PeeringConnectionOptions] <p>Information about the VPC peering connection options for the accepter VPC.</p>
-- @return ModifyVpcPeeringConnectionOptionsResult structure as a key-value pair table
function M.ModifyVpcPeeringConnectionOptionsResult(args)
	assert(args, "You must provide an argument table when creating ModifyVpcPeeringConnectionOptionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["RequesterPeeringConnectionOptions"] = args["RequesterPeeringConnectionOptions"],
		["AccepterPeeringConnectionOptions"] = args["AccepterPeeringConnectionOptions"],
	}
	asserts.AssertModifyVpcPeeringConnectionOptionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StateReason = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StateReason to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.StateReason[k], "StateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StateReason
-- <p>Describes a state change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The message for the state change.</p> <ul> <li> <p> <code>Server.InsufficientInstanceCapacity</code>: There was insufficient capacity available to satisfy the launch request.</p> </li> <li> <p> <code>Server.InternalError</code>: An internal error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled retirement.</p> </li> <li> <p> <code>Server.SpotInstanceShutdown</code>: The instance was stopped because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Server.SpotInstanceTermination</code>: The instance was terminated because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down using the <code>shutdown -h</code> command from the instance.</p> </li> <li> <p> <code>Client.InstanceTerminated</code>: The instance was terminated or rebooted during AMI creation.</p> </li> <li> <p> <code>Client.InternalError</code>: A client error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not found.</p> </li> <li> <p> <code>Client.UserInitiatedShutdown</code>: The instance was shut down using the Amazon EC2 API.</p> </li> <li> <p> <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your account limits.</p> </li> </ul>
-- * Code [String] <p>The reason code for the state change.</p>
-- @return StateReason structure as a key-value pair table
function M.StateReason(args)
	assert(args, "You must provide an argument table when creating StateReason")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertStateReason(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcPeeringConnectionStateReason = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertVpcPeeringConnectionStateReason(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionStateReason to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertVpcPeeringConnectionStateReasonCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionStateReason[k], "VpcPeeringConnectionStateReason contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionStateReason
-- <p>Describes the status of a VPC peering connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>A message that provides more information about the status, if applicable.</p>
-- * Code [VpcPeeringConnectionStateReasonCode] <p>The status of the VPC peering connection.</p>
-- @return VpcPeeringConnectionStateReason structure as a key-value pair table
function M.VpcPeeringConnectionStateReason(args)
	assert(args, "You must provide an argument table when creating VpcPeeringConnectionStateReason")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertVpcPeeringConnectionStateReason(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IamInstanceProfile = { ["Id"] = true, ["Arn"] = true, nil }

function asserts.AssertIamInstanceProfile(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfile to be of type 'table'")
	if struct["Id"] then asserts.AssertString(struct["Id"]) end
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfile[k], "IamInstanceProfile contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfile
-- <p>Describes an IAM instance profile.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Id [String] <p>The ID of the instance profile.</p>
-- * Arn [String] <p>The Amazon Resource Name (ARN) of the instance profile.</p>
-- @return IamInstanceProfile structure as a key-value pair table
function M.IamInstanceProfile(args)
	assert(args, "You must provide an argument table when creating IamInstanceProfile")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Id"] = args["Id"],
		["Arn"] = args["Arn"],
	}
	asserts.AssertIamInstanceProfile(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointServiceConfigurationsResult = { ["NextToken"] = true, ["ServiceConfigurations"] = true, nil }

function asserts.AssertDescribeVpcEndpointServiceConfigurationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServiceConfigurationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ServiceConfigurations"] then asserts.AssertServiceConfigurationSet(struct["ServiceConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServiceConfigurationsResult[k], "DescribeVpcEndpointServiceConfigurationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServiceConfigurationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ServiceConfigurations [ServiceConfigurationSet] <p>Information about one or more services.</p>
-- @return DescribeVpcEndpointServiceConfigurationsResult structure as a key-value pair table
function M.DescribeVpcEndpointServiceConfigurationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointServiceConfigurationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ServiceConfigurations"] = args["ServiceConfigurations"],
	}
	asserts.AssertDescribeVpcEndpointServiceConfigurationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IpRange = { ["Description"] = true, ["CidrIp"] = true, nil }

function asserts.AssertIpRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpRange to be of type 'table'")
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	for k,_ in pairs(struct) do
		assert(keys.IpRange[k], "IpRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpRange
-- <p>Describes an IPv4 range.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [String] <p>A description for the security group rule that references this IPv4 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
-- * CidrIp [String] <p>The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.</p>
-- @return IpRange structure as a key-value pair table
function M.IpRange(args)
	assert(args, "You must provide an argument table when creating IpRange")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Description"] = args["Description"],
		["CidrIp"] = args["CidrIp"],
	}
	asserts.AssertIpRange(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplatesMonitoringRequest = { ["Enabled"] = true, nil }

function asserts.AssertLaunchTemplatesMonitoringRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplatesMonitoringRequest to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplatesMonitoringRequest[k], "LaunchTemplatesMonitoringRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplatesMonitoringRequest
-- <p>Describes the monitoring for the instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Specify <code>true</code> to enable detailed monitoring. Otherwise, basic monitoring is enabled.</p>
-- @return LaunchTemplatesMonitoringRequest structure as a key-value pair table
function M.LaunchTemplatesMonitoringRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplatesMonitoringRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertLaunchTemplatesMonitoringRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceCount = { ["State"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertInstanceCount(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCount to be of type 'table'")
	if struct["State"] then asserts.AssertListingState(struct["State"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCount[k], "InstanceCount contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCount
-- <p>Describes a Reserved Instance listing state.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [ListingState] <p>The states of the listed Reserved Instances.</p>
-- * InstanceCount [Integer] <p>The number of listed Reserved Instances in the state specified by the <code>state</code>.</p>
-- @return InstanceCount structure as a key-value pair table
function M.InstanceCount(args)
	assert(args, "You must provide an argument table when creating InstanceCount")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["InstanceCount"] = args["InstanceCount"],
	}
	asserts.AssertInstanceCount(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CapacityReservationTarget = { ["CapacityReservationId"] = true, nil }

function asserts.AssertCapacityReservationTarget(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CapacityReservationTarget to be of type 'table'")
	if struct["CapacityReservationId"] then asserts.AssertString(struct["CapacityReservationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CapacityReservationTarget[k], "CapacityReservationTarget contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CapacityReservationTarget
-- <p>Describes a target Capacity Reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationId [String] <p>The ID of the Capacity Reservation.</p>
-- @return CapacityReservationTarget structure as a key-value pair table
function M.CapacityReservationTarget(args)
	assert(args, "You must provide an argument table when creating CapacityReservationTarget")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationId"] = args["CapacityReservationId"],
	}
	asserts.AssertCapacityReservationTarget(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TargetConfigurationRequest = { ["InstanceCount"] = true, ["OfferingId"] = true, nil }

function asserts.AssertTargetConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfigurationRequest to be of type 'table'")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetConfigurationRequest[k], "TargetConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfigurationRequest
-- <p>Details about the target configuration.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- * OfferingId [String] <p>The Convertible Reserved Instance offering ID.</p>
-- Required key: OfferingId
-- @return TargetConfigurationRequest structure as a key-value pair table
function M.TargetConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating TargetConfigurationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceCount"] = args["InstanceCount"],
		["OfferingId"] = args["OfferingId"],
	}
	asserts.AssertTargetConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcEndpoint = { ["PolicyDocument"] = true, ["VpcId"] = true, ["NetworkInterfaceIds"] = true, ["SubnetIds"] = true, ["PrivateDnsEnabled"] = true, ["State"] = true, ["ServiceName"] = true, ["RouteTableIds"] = true, ["Groups"] = true, ["VpcEndpointId"] = true, ["VpcEndpointType"] = true, ["CreationTimestamp"] = true, ["DnsEntries"] = true, nil }

function asserts.AssertVpcEndpoint(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcEndpoint to be of type 'table'")
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["NetworkInterfaceIds"] then asserts.AssertValueStringList(struct["NetworkInterfaceIds"]) end
	if struct["SubnetIds"] then asserts.AssertValueStringList(struct["SubnetIds"]) end
	if struct["PrivateDnsEnabled"] then asserts.AssertBoolean(struct["PrivateDnsEnabled"]) end
	if struct["State"] then asserts.AssertState(struct["State"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierSet(struct["Groups"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	if struct["VpcEndpointType"] then asserts.AssertVpcEndpointType(struct["VpcEndpointType"]) end
	if struct["CreationTimestamp"] then asserts.AssertDateTime(struct["CreationTimestamp"]) end
	if struct["DnsEntries"] then asserts.AssertDnsEntrySet(struct["DnsEntries"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcEndpoint[k], "VpcEndpoint contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcEndpoint
-- <p>Describes a VPC endpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PolicyDocument [String] <p>The policy document associated with the endpoint, if applicable.</p>
-- * VpcId [String] <p>The ID of the VPC to which the endpoint is associated.</p>
-- * NetworkInterfaceIds [ValueStringList] <p>(Interface endpoint) One or more network interfaces for the endpoint.</p>
-- * SubnetIds [ValueStringList] <p>(Interface endpoint) One or more subnets in which the endpoint is located.</p>
-- * PrivateDnsEnabled [Boolean] <p>(Interface endpoint) Indicates whether the VPC is associated with a private hosted zone.</p>
-- * State [State] <p>The state of the VPC endpoint.</p>
-- * ServiceName [String] <p>The name of the service to which the endpoint is associated.</p>
-- * RouteTableIds [ValueStringList] <p>(Gateway endpoint) One or more route tables associated with the endpoint.</p>
-- * Groups [GroupIdentifierSet] <p>(Interface endpoint) Information about the security groups associated with the network interface.</p>
-- * VpcEndpointId [String] <p>The ID of the VPC endpoint.</p>
-- * VpcEndpointType [VpcEndpointType] <p>The type of endpoint.</p>
-- * CreationTimestamp [DateTime] <p>The date and time the VPC endpoint was created.</p>
-- * DnsEntries [DnsEntrySet] <p>(Interface endpoint) The DNS entries for the endpoint.</p>
-- @return VpcEndpoint structure as a key-value pair table
function M.VpcEndpoint(args)
	assert(args, "You must provide an argument table when creating VpcEndpoint")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PolicyDocument"] = args["PolicyDocument"],
		["VpcId"] = args["VpcId"],
		["NetworkInterfaceIds"] = args["NetworkInterfaceIds"],
		["SubnetIds"] = args["SubnetIds"],
		["PrivateDnsEnabled"] = args["PrivateDnsEnabled"],
		["State"] = args["State"],
		["ServiceName"] = args["ServiceName"],
		["RouteTableIds"] = args["RouteTableIds"],
		["Groups"] = args["Groups"],
		["VpcEndpointId"] = args["VpcEndpointId"],
		["VpcEndpointType"] = args["VpcEndpointType"],
		["CreationTimestamp"] = args["CreationTimestamp"],
		["DnsEntries"] = args["DnsEntries"],
	}
	asserts.AssertVpcEndpoint(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateAddressResult = { ["AssociationId"] = true, nil }

function asserts.AssertAssociateAddressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressResult to be of type 'table'")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateAddressResult[k], "AssociateAddressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>[EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.</p>
-- @return AssociateAddressResult structure as a key-value pair table
function M.AssociateAddressResult(args)
	assert(args, "You must provide an argument table when creating AssociateAddressResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertAssociateAddressResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeLaunchTemplatesResult = { ["NextToken"] = true, ["LaunchTemplates"] = true, nil }

function asserts.AssertDescribeLaunchTemplatesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeLaunchTemplatesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["LaunchTemplates"] then asserts.AssertLaunchTemplateSet(struct["LaunchTemplates"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeLaunchTemplatesResult[k], "DescribeLaunchTemplatesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeLaunchTemplatesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * LaunchTemplates [LaunchTemplateSet] <p>Information about the launch templates.</p>
-- @return DescribeLaunchTemplatesResult structure as a key-value pair table
function M.DescribeLaunchTemplatesResult(args)
	assert(args, "You must provide an argument table when creating DescribeLaunchTemplatesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["LaunchTemplates"] = args["LaunchTemplates"],
	}
	asserts.AssertDescribeLaunchTemplatesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InternetGatewayAttachment = { ["State"] = true, ["VpcId"] = true, nil }

function asserts.AssertInternetGatewayAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGatewayAttachment to be of type 'table'")
	if struct["State"] then asserts.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InternetGatewayAttachment[k], "InternetGatewayAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGatewayAttachment
-- <p>Describes the attachment of a VPC to an internet gateway or an egress-only internet gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [AttachmentStatus] <p>The current state of the attachment. For an internet gateway, the state is <code>available</code> when attached to a VPC; otherwise, this value is not returned.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return InternetGatewayAttachment structure as a key-value pair table
function M.InternetGatewayAttachment(args)
	assert(args, "You must provide an argument table when creating InternetGatewayAttachment")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertInternetGatewayAttachment(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelSpotFleetRequestsSuccessItem = { ["PreviousSpotFleetRequestState"] = true, ["CurrentSpotFleetRequestState"] = true, ["SpotFleetRequestId"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsSuccessItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsSuccessItem to be of type 'table'")
	assert(struct["CurrentSpotFleetRequestState"], "Expected key CurrentSpotFleetRequestState to exist in table")
	assert(struct["PreviousSpotFleetRequestState"], "Expected key PreviousSpotFleetRequestState to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["PreviousSpotFleetRequestState"] then asserts.AssertBatchState(struct["PreviousSpotFleetRequestState"]) end
	if struct["CurrentSpotFleetRequestState"] then asserts.AssertBatchState(struct["CurrentSpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsSuccessItem[k], "CancelSpotFleetRequestsSuccessItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsSuccessItem
-- <p>Describes a Spot Fleet request that was successfully canceled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PreviousSpotFleetRequestState [BatchState] <p>The previous state of the Spot Fleet request.</p>
-- * CurrentSpotFleetRequestState [BatchState] <p>The current state of the Spot Fleet request.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- Required key: CurrentSpotFleetRequestState
-- Required key: PreviousSpotFleetRequestState
-- Required key: SpotFleetRequestId
-- @return CancelSpotFleetRequestsSuccessItem structure as a key-value pair table
function M.CancelSpotFleetRequestsSuccessItem(args)
	assert(args, "You must provide an argument table when creating CancelSpotFleetRequestsSuccessItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PreviousSpotFleetRequestState"] = args["PreviousSpotFleetRequestState"],
		["CurrentSpotFleetRequestState"] = args["CurrentSpotFleetRequestState"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
	}
	asserts.AssertCancelSpotFleetRequestsSuccessItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeImportImageTasksRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ImportTaskIds"] = true, nil }

function asserts.AssertDescribeImportImageTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportImageTasksRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ImportTaskIds"] then asserts.AssertImportTaskIdList(struct["ImportTaskIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportImageTasksRequest[k], "DescribeImportImageTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportImageTasksRequest
-- <p>Contains the parameters for DescribeImportImageTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>A token that indicates the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>Filter tasks using the <code>task-state</code> filter and one of the following values: active, completed, deleting, deleted.</p>
-- * ImportTaskIds [ImportTaskIdList] <p>A list of import image task IDs.</p>
-- @return DescribeImportImageTasksRequest structure as a key-value pair table
function M.DescribeImportImageTasksRequest(args)
	assert(args, "You must provide an argument table when creating DescribeImportImageTasksRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["ImportTaskIds"] = args["ImportTaskIds"],
	}
	asserts.AssertDescribeImportImageTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcClassicLinkDnsSupportResult = { ["Vpcs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertClassicLinkDnsSupportList(struct["Vpcs"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkDnsSupportResult[k], "DescribeVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpcs [ClassicLinkDnsSupportList] <p>Information about the ClassicLink DNS support status of the VPCs.</p>
-- * NextToken [NextToken] <p>The token to use when requesting the next set of items.</p>
-- @return DescribeVpcClassicLinkDnsSupportResult structure as a key-value pair table
function M.DescribeVpcClassicLinkDnsSupportResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcClassicLinkDnsSupportResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Vpcs"] = args["Vpcs"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeVpcClassicLinkDnsSupportResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CidrBlock = { ["CidrBlock"] = true, nil }

function asserts.AssertCidrBlock(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CidrBlock to be of type 'table'")
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CidrBlock[k], "CidrBlock contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CidrBlock
-- <p>Describes an IPv4 CIDR block.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CidrBlock [String] <p>The IPv4 CIDR block.</p>
-- @return CidrBlock structure as a key-value pair table
function M.CidrBlock(args)
	assert(args, "You must provide an argument table when creating CidrBlock")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertCidrBlock(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RegisterImageRequest = { ["VirtualizationType"] = true, ["DryRun"] = true, ["Description"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["BillingProducts"] = true, ["ImageLocation"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["RootDeviceName"] = true, ["Name"] = true, nil }

function asserts.AssertRegisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RegisterImageRequest to be of type 'table'")
	assert(struct["Name"], "Expected key Name to exist in table")
	if struct["VirtualizationType"] then asserts.AssertString(struct["VirtualizationType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingRequestList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["BillingProducts"] then asserts.AssertBillingProductList(struct["BillingProducts"]) end
	if struct["ImageLocation"] then asserts.AssertString(struct["ImageLocation"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.RegisterImageRequest[k], "RegisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RegisterImageRequest
-- <p>Contains the parameters for RegisterImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VirtualizationType [String] <p>The type of virtualization (<code>hvm</code> | <code>paravirtual</code>).</p> <p>Default: <code>paravirtual</code> </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for your AMI.</p>
-- * EnaSupport [Boolean] <p>Set to <code>true</code> to enable enhanced networking with ENA for the AMI and any instances that you launch from the AMI.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- * SriovNetSupport [String] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.</p> <p>There is no way to disable <code>sriovNetSupport</code> at this time.</p> <p>This option is supported only for HVM AMIs. Specifying this option with a PV AMI can make instances launched from the AMI unreachable.</p>
-- * BlockDeviceMappings [BlockDeviceMappingRequestList] <p>One or more block device mapping entries.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the AMI.</p> <p>Default: For Amazon EBS-backed AMIs, <code>i386</code>. For instance store-backed AMIs, the architecture specified in the manifest file.</p>
-- * BillingProducts [BillingProductList] <p>The billing product codes. Your account must be authorized to specify billing product codes. Otherwise, you can use the AWS Marketplace to bill for the use of an AMI.</p>
-- * ImageLocation [String] <p>The full path to your AMI manifest in Amazon S3 storage.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * RootDeviceName [String] <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
-- * Name [String] <p>A name for your AMI.</p> <p>Constraints: 3-128 alphanumeric characters, parentheses (()), square brackets ([]), spaces ( ), periods (.), slashes (/), dashes (-), single quotes ('), at-signs (@), or underscores(_)</p>
-- Required key: Name
-- @return RegisterImageRequest structure as a key-value pair table
function M.RegisterImageRequest(args)
	assert(args, "You must provide an argument table when creating RegisterImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VirtualizationType"] = args["VirtualizationType"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Architecture"] = args["Architecture"],
		["BillingProducts"] = args["BillingProducts"],
		["ImageLocation"] = args["ImageLocation"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
		["RootDeviceName"] = args["RootDeviceName"],
		["Name"] = args["Name"],
	}
	asserts.AssertRegisterImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IcmpTypeCode = { ["Code"] = true, ["Type"] = true, nil }

function asserts.AssertIcmpTypeCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IcmpTypeCode to be of type 'table'")
	if struct["Code"] then asserts.AssertInteger(struct["Code"]) end
	if struct["Type"] then asserts.AssertInteger(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.IcmpTypeCode[k], "IcmpTypeCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IcmpTypeCode
-- <p>Describes the ICMP type and code.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Code [Integer] <p>The ICMP code. A value of -1 means all codes for the specified ICMP type.</p>
-- * Type [Integer] <p>The ICMP type. A value of -1 means all types.</p>
-- @return IcmpTypeCode structure as a key-value pair table
function M.IcmpTypeCode(args)
	assert(args, "You must provide an argument table when creating IcmpTypeCode")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Code"] = args["Code"],
		["Type"] = args["Type"],
	}
	asserts.AssertIcmpTypeCode(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInternetGatewaysRequest = { ["DryRun"] = true, ["InternetGatewayIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayIds"] then asserts.AssertValueStringList(struct["InternetGatewayIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInternetGatewaysRequest[k], "DescribeInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayIds [ValueStringList] <p>One or more internet gateway IDs.</p> <p>Default: Describes all your internet gateways.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>attachment.state</code> - The current state of the attachment between the gateway and the VPC (<code>available</code>). Present only if a VPC is attached.</p> </li> <li> <p> <code>attachment.vpc-id</code> - The ID of an attached VPC.</p> </li> <li> <p> <code>internet-gateway-id</code> - The ID of the Internet gateway.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> </ul>
-- @return DescribeInternetGatewaysRequest structure as a key-value pair table
function M.DescribeInternetGatewaysRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInternetGatewaysRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["InternetGatewayIds"] = args["InternetGatewayIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInternetGatewaysRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcPeeringConnectionResult = { ["VpcPeeringConnection"] = true, nil }

function asserts.AssertCreateVpcPeeringConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcPeeringConnectionResult to be of type 'table'")
	if struct["VpcPeeringConnection"] then asserts.AssertVpcPeeringConnection(struct["VpcPeeringConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcPeeringConnectionResult[k], "CreateVpcPeeringConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcPeeringConnectionResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnection [VpcPeeringConnection] <p>Information about the VPC peering connection.</p>
-- @return CreateVpcPeeringConnectionResult structure as a key-value pair table
function M.CreateVpcPeeringConnectionResult(args)
	assert(args, "You must provide an argument table when creating CreateVpcPeeringConnectionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcPeeringConnection"] = args["VpcPeeringConnection"],
	}
	asserts.AssertCreateVpcPeeringConnectionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterfaceAttachmentChanges = { ["DeleteOnTermination"] = true, ["AttachmentId"] = true, nil }

function asserts.AssertNetworkInterfaceAttachmentChanges(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAttachmentChanges to be of type 'table'")
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAttachmentChanges[k], "NetworkInterfaceAttachmentChanges contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAttachmentChanges
-- <p>Describes an attachment change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @return NetworkInterfaceAttachmentChanges structure as a key-value pair table
function M.NetworkInterfaceAttachmentChanges(args)
	assert(args, "You must provide an argument table when creating NetworkInterfaceAttachmentChanges")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["AttachmentId"] = args["AttachmentId"],
	}
	asserts.AssertNetworkInterfaceAttachmentChanges(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNetworkInterfaceRequest = { ["DryRun"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["SecondaryPrivateIpAddressCount"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertCreateNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfaceRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfaceRequest[k], "CreateNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfaceRequest
-- <p>Contains the parameters for CreateNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the network interface.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses. If your subnet has the <code>AssignIpv6AddressOnCreation</code> attribute set to <code>true</code>, you can specify <code>0</code> to override this setting.</p>
-- * PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses.</p>
-- * SubnetId [String] <p>The ID of the subnet to associate with the network interface.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses to assign to a network interface. When you specify a number of secondary IPv4 addresses, Amazon EC2 selects these IP addresses within the subnet's IPv4 CIDR range. You can't specify this option and specify more than one private IP address using <code>privateIpAddresses</code>.</p> <p>The number of IP addresses you can assign to a network interface varies by instance type. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI">IP Addresses Per ENI Per Instance Type</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- * Groups [SecurityGroupIdStringList] <p>The IDs of one or more security groups.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- * PrivateIpAddress [String] <p>The primary private IPv4 address of the network interface. If you don't specify an IPv4 address, Amazon EC2 selects one for you from the subnet's IPv4 CIDR range. If you specify an IP address, you cannot indicate any IP addresses specified in <code>privateIpAddresses</code> as primary (only one IP address can be designated as primary).</p>
-- Required key: SubnetId
-- @return CreateNetworkInterfaceRequest structure as a key-value pair table
function M.CreateNetworkInterfaceRequest(args)
	assert(args, "You must provide an argument table when creating CreateNetworkInterfaceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["SubnetId"] = args["SubnetId"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertCreateNetworkInterfaceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeImportSnapshotTasksResult = { ["NextToken"] = true, ["ImportSnapshotTasks"] = true, nil }

function asserts.AssertDescribeImportSnapshotTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImportSnapshotTasksResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ImportSnapshotTasks"] then asserts.AssertImportSnapshotTaskList(struct["ImportSnapshotTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImportSnapshotTasksResult[k], "DescribeImportSnapshotTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImportSnapshotTasksResult
-- <p>Contains the output for DescribeImportSnapshotTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ImportSnapshotTasks [ImportSnapshotTaskList] <p>A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.</p>
-- @return DescribeImportSnapshotTasksResult structure as a key-value pair table
function M.DescribeImportSnapshotTasksResult(args)
	assert(args, "You must provide an argument table when creating DescribeImportSnapshotTasksResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ImportSnapshotTasks"] = args["ImportSnapshotTasks"],
	}
	asserts.AssertDescribeImportSnapshotTasksResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeStaleSecurityGroupsResult = { ["StaleSecurityGroupSet"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeStaleSecurityGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsResult to be of type 'table'")
	if struct["StaleSecurityGroupSet"] then asserts.AssertStaleSecurityGroupSet(struct["StaleSecurityGroupSet"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStaleSecurityGroupsResult[k], "DescribeStaleSecurityGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StaleSecurityGroupSet [StaleSecurityGroupSet] <p>Information about the stale security groups.</p>
-- * NextToken [String] <p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>
-- @return DescribeStaleSecurityGroupsResult structure as a key-value pair table
function M.DescribeStaleSecurityGroupsResult(args)
	assert(args, "You must provide an argument table when creating DescribeStaleSecurityGroupsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StaleSecurityGroupSet"] = args["StaleSecurityGroupSet"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeStaleSecurityGroupsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservationValue = { ["RemainingUpfrontValue"] = true, ["HourlyPrice"] = true, ["RemainingTotalValue"] = true, nil }

function asserts.AssertReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservationValue to be of type 'table'")
	if struct["RemainingUpfrontValue"] then asserts.AssertString(struct["RemainingUpfrontValue"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["RemainingTotalValue"] then asserts.AssertString(struct["RemainingTotalValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservationValue[k], "ReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservationValue
-- <p>The cost associated with the Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RemainingUpfrontValue [String] <p>The remaining upfront cost of the reservation.</p>
-- * HourlyPrice [String] <p>The hourly rate of the reservation.</p>
-- * RemainingTotalValue [String] <p>The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).</p>
-- @return ReservationValue structure as a key-value pair table
function M.ReservationValue(args)
	assert(args, "You must provide an argument table when creating ReservationValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["RemainingUpfrontValue"] = args["RemainingUpfrontValue"],
		["HourlyPrice"] = args["HourlyPrice"],
		["RemainingTotalValue"] = args["RemainingTotalValue"],
	}
	asserts.AssertReservationValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCapacityReservationsResult = { ["NextToken"] = true, ["CapacityReservations"] = true, nil }

function asserts.AssertDescribeCapacityReservationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCapacityReservationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["CapacityReservations"] then asserts.AssertCapacityReservationSet(struct["CapacityReservations"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCapacityReservationsResult[k], "DescribeCapacityReservationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCapacityReservationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * CapacityReservations [CapacityReservationSet] <p>Information about the Capacity Reservations.</p>
-- @return DescribeCapacityReservationsResult structure as a key-value pair table
function M.DescribeCapacityReservationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeCapacityReservationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["CapacityReservations"] = args["CapacityReservations"],
	}
	asserts.AssertDescribeCapacityReservationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeImageAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertDescribeImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeImageAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["Attribute"] then asserts.AssertImageAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeImageAttributeRequest[k], "DescribeImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeImageAttributeRequest
-- <p>Contains the parameters for DescribeImageAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [ImageAttributeName] <p>The AMI attribute.</p> <p> <b>Note</b>: Depending on your account privileges, the <code>blockDeviceMapping</code> attribute may return a <code>Client.AuthFailure</code> error. If this happens, use <a>DescribeImages</a> to get information about the block device mapping for the AMI.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- Required key: Attribute
-- Required key: ImageId
-- @return DescribeImageAttributeRequest structure as a key-value pair table
function M.DescribeImageAttributeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeImageAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertDescribeImageAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEgressOnlyInternetGatewaysResult = { ["NextToken"] = true, ["EgressOnlyInternetGateways"] = true, nil }

function asserts.AssertDescribeEgressOnlyInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["EgressOnlyInternetGateways"] then asserts.AssertEgressOnlyInternetGatewayList(struct["EgressOnlyInternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEgressOnlyInternetGatewaysResult[k], "DescribeEgressOnlyInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- * EgressOnlyInternetGateways [EgressOnlyInternetGatewayList] <p>Information about the egress-only internet gateways.</p>
-- @return DescribeEgressOnlyInternetGatewaysResult structure as a key-value pair table
function M.DescribeEgressOnlyInternetGatewaysResult(args)
	assert(args, "You must provide an argument table when creating DescribeEgressOnlyInternetGatewaysResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["EgressOnlyInternetGateways"] = args["EgressOnlyInternetGateways"],
	}
	asserts.AssertDescribeEgressOnlyInternetGatewaysResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceNetworkInterfaceAttachment = { ["Status"] = true, ["DeviceIndex"] = true, ["DeleteOnTermination"] = true, ["AttachmentId"] = true, ["AttachTime"] = true, nil }

function asserts.AssertInstanceNetworkInterfaceAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceNetworkInterfaceAttachment to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceNetworkInterfaceAttachment[k], "InstanceNetworkInterfaceAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceNetworkInterfaceAttachment
-- <p>Describes a network interface attachment.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [AttachmentStatus] <p>The attachment state.</p>
-- * DeviceIndex [Integer] <p>The index of the device on the instance for the network interface attachment.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- * AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- @return InstanceNetworkInterfaceAttachment structure as a key-value pair table
function M.InstanceNetworkInterfaceAttachment(args)
	assert(args, "You must provide an argument table when creating InstanceNetworkInterfaceAttachment")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DeviceIndex"] = args["DeviceIndex"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["AttachmentId"] = args["AttachmentId"],
		["AttachTime"] = args["AttachTime"],
	}
	asserts.AssertInstanceNetworkInterfaceAttachment(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSubnetsRequest = { ["SubnetIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSubnetsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSubnetsRequest to be of type 'table'")
	if struct["SubnetIds"] then asserts.AssertSubnetIdStringList(struct["SubnetIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSubnetsRequest[k], "DescribeSubnetsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSubnetsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetIds [SubnetIdStringList] <p>One or more subnet IDs.</p> <p>Default: Describes all your subnets.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availabilityZone</code> - The Availability Zone for the subnet. You can also use <code>availability-zone</code> as the filter name.</p> </li> <li> <p> <code>available-ip-address-count</code> - The number of IPv4 addresses in the subnet that are available.</p> </li> <li> <p> <code>cidrBlock</code> - The IPv4 CIDR block of the subnet. The CIDR block you specify must exactly match the subnet's CIDR block for information to be returned for the subnet. You can also use <code>cidr</code> or <code>cidr-block</code> as the filter names.</p> </li> <li> <p> <code>defaultForAz</code> - Indicates whether this is the default subnet for the Availability Zone. You can also use <code>default-for-az</code> as the filter name.</p> </li> <li> <p> <code>ipv6-cidr-block-association.ipv6-cidr-block</code> - An IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.association-id</code> - An association ID for an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>ipv6-cidr-block-association.state</code> - The state of an IPv6 CIDR block associated with the subnet.</p> </li> <li> <p> <code>state</code> - The state of the subnet (<code>pending</code> | <code>available</code>).</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the subnet.</p> </li> </ul>
-- @return DescribeSubnetsRequest structure as a key-value pair table
function M.DescribeSubnetsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSubnetsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetIds"] = args["SubnetIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeSubnetsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSubnetRequest = { ["VpcId"] = true, ["Ipv6CidrBlock"] = true, ["DryRun"] = true, ["AvailabilityZone"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSubnetRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSubnetRequest[k], "CreateSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSubnetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range for the subnet, in CIDR notation. The subnet size must use a /64 prefix length.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the subnet.</p> <p>Default: AWS selects one for you. If you create more than one subnet in your VPC, we may not necessarily select a different zone for each subnet.</p>
-- * CidrBlock [String] <p>The IPv4 network range for the subnet, in CIDR notation. For example, <code>10.0.0.0/24</code>.</p>
-- Required key: CidrBlock
-- Required key: VpcId
-- @return CreateSubnetRequest structure as a key-value pair table
function M.CreateSubnetRequest(args)
	assert(args, "You must provide an argument table when creating CreateSubnetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["DryRun"] = args["DryRun"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertCreateSubnetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ConfirmProductInstanceRequest = { ["InstanceId"] = true, ["ProductCode"] = true, ["DryRun"] = true, nil }

function asserts.AssertConfirmProductInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConfirmProductInstanceRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["ProductCode"], "Expected key ProductCode to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["ProductCode"] then asserts.AssertString(struct["ProductCode"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConfirmProductInstanceRequest[k], "ConfirmProductInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConfirmProductInstanceRequest
-- <p>Contains the parameters for ConfirmProductInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * ProductCode [String] <p>The product code. This must be a product code that you own.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- Required key: ProductCode
-- @return ConfirmProductInstanceRequest structure as a key-value pair table
function M.ConfirmProductInstanceRequest(args)
	assert(args, "You must provide an argument table when creating ConfirmProductInstanceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["ProductCode"] = args["ProductCode"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertConfirmProductInstanceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcEndpointServiceConfigurationResult = { ["ServiceConfiguration"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointServiceConfigurationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointServiceConfigurationResult to be of type 'table'")
	if struct["ServiceConfiguration"] then asserts.AssertServiceConfiguration(struct["ServiceConfiguration"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointServiceConfigurationResult[k], "CreateVpcEndpointServiceConfigurationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointServiceConfigurationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceConfiguration [ServiceConfiguration] <p>Information about the service configuration.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
-- @return CreateVpcEndpointServiceConfigurationResult structure as a key-value pair table
function M.CreateVpcEndpointServiceConfigurationResult(args)
	assert(args, "You must provide an argument table when creating CreateVpcEndpointServiceConfigurationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceConfiguration"] = args["ServiceConfiguration"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateVpcEndpointServiceConfigurationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeStaleSecurityGroupsRequest = { ["VpcId"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeStaleSecurityGroupsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeStaleSecurityGroupsRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeStaleSecurityGroupsRequest[k], "DescribeStaleSecurityGroupsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeStaleSecurityGroupsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- Required key: VpcId
-- @return DescribeStaleSecurityGroupsRequest structure as a key-value pair table
function M.DescribeStaleSecurityGroupsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeStaleSecurityGroupsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeStaleSecurityGroupsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointServiceConfigurationsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["ServiceIds"] = true, nil }

function asserts.AssertDescribeVpcEndpointServiceConfigurationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServiceConfigurationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ServiceIds"] then asserts.AssertValueStringList(struct["ServiceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServiceConfigurationsRequest[k], "DescribeVpcEndpointServiceConfigurationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServiceConfigurationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>service-name</code> - The name of the service.</p> </li> <li> <p> <code>service-id</code> - The ID of the service.</p> </li> <li> <p> <code>service-state</code> - The state of the service (<code>Pending</code> | <code>Available</code> | <code>Deleting</code> | <code>Deleted</code> | <code>Failed</code>). </p> </li> </ul>
-- * ServiceIds [ValueStringList] <p>The IDs of one or more services.</p>
-- @return DescribeVpcEndpointServiceConfigurationsRequest structure as a key-value pair table
function M.DescribeVpcEndpointServiceConfigurationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointServiceConfigurationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["ServiceIds"] = args["ServiceIds"],
	}
	asserts.AssertDescribeVpcEndpointServiceConfigurationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateFleetRequest = { ["Type"] = true, ["DryRun"] = true, ["LaunchTemplateConfigs"] = true, ["TagSpecifications"] = true, ["TerminateInstancesWithExpiration"] = true, ["ReplaceUnhealthyInstances"] = true, ["OnDemandOptions"] = true, ["ValidUntil"] = true, ["ClientToken"] = true, ["SpotOptions"] = true, ["ValidFrom"] = true, ["ExcessCapacityTerminationPolicy"] = true, ["TargetCapacitySpecification"] = true, nil }

function asserts.AssertCreateFleetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFleetRequest to be of type 'table'")
	assert(struct["LaunchTemplateConfigs"], "Expected key LaunchTemplateConfigs to exist in table")
	assert(struct["TargetCapacitySpecification"], "Expected key TargetCapacitySpecification to exist in table")
	if struct["Type"] then asserts.AssertFleetType(struct["Type"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LaunchTemplateConfigs"] then asserts.AssertFleetLaunchTemplateConfigListRequest(struct["LaunchTemplateConfigs"]) end
	if struct["TagSpecifications"] then asserts.AssertTagSpecificationList(struct["TagSpecifications"]) end
	if struct["TerminateInstancesWithExpiration"] then asserts.AssertBoolean(struct["TerminateInstancesWithExpiration"]) end
	if struct["ReplaceUnhealthyInstances"] then asserts.AssertBoolean(struct["ReplaceUnhealthyInstances"]) end
	if struct["OnDemandOptions"] then asserts.AssertOnDemandOptionsRequest(struct["OnDemandOptions"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["SpotOptions"] then asserts.AssertSpotOptionsRequest(struct["SpotOptions"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertFleetExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	if struct["TargetCapacitySpecification"] then asserts.AssertTargetCapacitySpecificationRequest(struct["TargetCapacitySpecification"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFleetRequest[k], "CreateFleetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFleetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [FleetType] <p>The type of request. Indicates whether the EC2 Fleet only <code>requests</code> the target capacity, or also attempts to <code>maintain</code> it. If you request a certain target capacity, EC2 Fleet only places the required requests. It does not attempt to replenish instances if capacity is diminished, and does not submit requests in alternative capacity pools if capacity is unavailable. To maintain a certain target capacity, EC2 Fleet places the required requests to meet this target capacity. It also automatically replenishes any interrupted Spot Instances. Default: <code>maintain</code>.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * LaunchTemplateConfigs [FleetLaunchTemplateConfigListRequest] <p>The configuration for the EC2 Fleet.</p>
-- * TagSpecifications [TagSpecificationList] <p>The key-value pair for tagging the EC2 Fleet request on creation. The value for <code>ResourceType</code> must be <code>fleet</code>, otherwise the fleet request fails. To tag instances at launch, specify the tags in the <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template">launch template</a>. For information about tagging after launch, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources">Tagging Your Resources</a>. </p>
-- * TerminateInstancesWithExpiration [Boolean] <p>Indicates whether running instances should be terminated when the EC2 Fleet expires.</p>
-- * ReplaceUnhealthyInstances [Boolean] <p>Indicates whether EC2 Fleet should replace unhealthy instances.</p>
-- * OnDemandOptions [OnDemandOptionsRequest] <p>The allocation strategy of On-Demand Instances in an EC2 Fleet.</p>
-- * ValidUntil [DateTime] <p>The end date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). At this point, no new EC2 Fleet requests are placed or able to fulfill the request. The default end date is 7 days from the current date.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * SpotOptions [SpotOptionsRequest] <p>Describes the configuration of Spot Instances in an EC2 Fleet.</p>
-- * ValidFrom [DateTime] <p>The start date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The default is to start fulfilling the request immediately.</p>
-- * ExcessCapacityTerminationPolicy [FleetExcessCapacityTerminationPolicy] <p>Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>
-- * TargetCapacitySpecification [TargetCapacitySpecificationRequest] <p>The <code>TotalTargetCapacity</code>, <code>OnDemandTargetCapacity</code>, <code>SpotTargetCapacity</code>, and <code>DefaultCapacityType</code> structure.</p>
-- Required key: LaunchTemplateConfigs
-- Required key: TargetCapacitySpecification
-- @return CreateFleetRequest structure as a key-value pair table
function M.CreateFleetRequest(args)
	assert(args, "You must provide an argument table when creating CreateFleetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
		["DryRun"] = args["DryRun"],
		["LaunchTemplateConfigs"] = args["LaunchTemplateConfigs"],
		["TagSpecifications"] = args["TagSpecifications"],
		["TerminateInstancesWithExpiration"] = args["TerminateInstancesWithExpiration"],
		["ReplaceUnhealthyInstances"] = args["ReplaceUnhealthyInstances"],
		["OnDemandOptions"] = args["OnDemandOptions"],
		["ValidUntil"] = args["ValidUntil"],
		["ClientToken"] = args["ClientToken"],
		["SpotOptions"] = args["SpotOptions"],
		["ValidFrom"] = args["ValidFrom"],
		["ExcessCapacityTerminationPolicy"] = args["ExcessCapacityTerminationPolicy"],
		["TargetCapacitySpecification"] = args["TargetCapacitySpecification"],
	}
	asserts.AssertCreateFleetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateVpcCidrBlockRequest = { ["CidrBlock"] = true, ["VpcId"] = true, ["AmazonProvidedIpv6CidrBlock"] = true, nil }

function asserts.AssertAssociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["AmazonProvidedIpv6CidrBlock"] then asserts.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateVpcCidrBlockRequest[k], "AssociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CidrBlock [String] <p>An IPv4 CIDR block to associate with the VPC.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IPv6 addresses, or the size of the CIDR block.</p>
-- Required key: VpcId
-- @return AssociateVpcCidrBlockRequest structure as a key-value pair table
function M.AssociateVpcCidrBlockRequest(args)
	assert(args, "You must provide an argument table when creating AssociateVpcCidrBlockRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CidrBlock"] = args["CidrBlock"],
		["VpcId"] = args["VpcId"],
		["AmazonProvidedIpv6CidrBlock"] = args["AmazonProvidedIpv6CidrBlock"],
	}
	asserts.AssertAssociateVpcCidrBlockRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ElasticGpus = { ["AvailabilityZone"] = true, ["ElasticGpuHealth"] = true, ["InstanceId"] = true, ["ElasticGpuType"] = true, ["ElasticGpuState"] = true, ["ElasticGpuId"] = true, nil }

function asserts.AssertElasticGpus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ElasticGpus to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["ElasticGpuHealth"] then asserts.AssertElasticGpuHealth(struct["ElasticGpuHealth"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["ElasticGpuType"] then asserts.AssertString(struct["ElasticGpuType"]) end
	if struct["ElasticGpuState"] then asserts.AssertElasticGpuState(struct["ElasticGpuState"]) end
	if struct["ElasticGpuId"] then asserts.AssertString(struct["ElasticGpuId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ElasticGpus[k], "ElasticGpus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ElasticGpus
-- <p>Describes an Elastic GPU.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone in the which the Elastic GPU resides.</p>
-- * ElasticGpuHealth [ElasticGpuHealth] <p>The status of the Elastic GPU.</p>
-- * InstanceId [String] <p>The ID of the instance to which the Elastic GPU is attached.</p>
-- * ElasticGpuType [String] <p>The type of Elastic GPU.</p>
-- * ElasticGpuState [ElasticGpuState] <p>The state of the Elastic GPU.</p>
-- * ElasticGpuId [String] <p>The ID of the Elastic GPU.</p>
-- @return ElasticGpus structure as a key-value pair table
function M.ElasticGpus(args)
	assert(args, "You must provide an argument table when creating ElasticGpus")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["ElasticGpuHealth"] = args["ElasticGpuHealth"],
		["InstanceId"] = args["InstanceId"],
		["ElasticGpuType"] = args["ElasticGpuType"],
		["ElasticGpuState"] = args["ElasticGpuState"],
		["ElasticGpuId"] = args["ElasticGpuId"],
	}
	asserts.AssertElasticGpus(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ExportToS3Task = { ["S3Bucket"] = true, ["S3Key"] = true, ["DiskImageFormat"] = true, ["ContainerFormat"] = true, nil }

function asserts.AssertExportToS3Task(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3Task to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	if struct["DiskImageFormat"] then asserts.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["ContainerFormat"] then asserts.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportToS3Task[k], "ExportToS3Task contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3Task
-- <p>Describes the format and location for an instance export task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- * S3Key [String] <p>The encryption key for your S3 bucket.</p>
-- * DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- * ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
-- @return ExportToS3Task structure as a key-value pair table
function M.ExportToS3Task(args)
	assert(args, "You must provide an argument table when creating ExportToS3Task")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3Bucket"] = args["S3Bucket"],
		["S3Key"] = args["S3Key"],
		["DiskImageFormat"] = args["DiskImageFormat"],
		["ContainerFormat"] = args["ContainerFormat"],
	}
	asserts.AssertExportToS3Task(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotInstanceStatus = { ["Message"] = true, ["Code"] = true, ["UpdateTime"] = true, nil }

function asserts.AssertSpotInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStatus to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	if struct["UpdateTime"] then asserts.AssertDateTime(struct["UpdateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceStatus[k], "SpotInstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStatus
-- <p>Describes the status of a Spot Instance request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The description for the status code.</p>
-- * Code [String] <p>The status code. For a list of status codes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand">Spot Status Codes</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>
-- * UpdateTime [DateTime] <p>The date and time of the most recent status update, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @return SpotInstanceStatus structure as a key-value pair table
function M.SpotInstanceStatus(args)
	assert(args, "You must provide an argument table when creating SpotInstanceStatus")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
		["UpdateTime"] = args["UpdateTime"],
	}
	asserts.AssertSpotInstanceStatus(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuthorizeSecurityGroupIngressRequest = { ["DryRun"] = true, ["GroupName"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertAuthorizeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizeSecurityGroupIngressRequest[k], "AuthorizeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupIngressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group. You must specify either the security group ID or the security group name in the request.</p>
-- * CidrIp [String] <p>The CIDR IPv4 address range. You can't specify this parameter when specifying a source security group.</p>
-- * IpPermissions [IpPermissionList] <p>One or more sets of IP permissions. Can be used to specify multiple rules in a single command.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. For the ICMP/ICMPv6 type number, use <code>-1</code> to specify all types. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
-- * SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead.</p>
-- * SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. Creates rules that grant full ICMP, UDP, and TCP access. To create a rule with a specific IP protocol and port range, use a set of IP permissions instead. For EC2-VPC, the source security group must be in the same VPC.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code number. For the ICMP/ICMPv6 code number, use <code>-1</code> to specify all codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
-- * IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). (VPC only) Use <code>-1</code> to specify all protocols. If you specify <code>-1</code>, or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6), traffic on all ports is allowed, regardless of any ports you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For protocol <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed.</p>
-- * GroupId [String] <p>The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.</p>
-- @return AuthorizeSecurityGroupIngressRequest structure as a key-value pair table
function M.AuthorizeSecurityGroupIngressRequest(args)
	assert(args, "You must provide an argument table when creating AuthorizeSecurityGroupIngressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["GroupName"] = args["GroupName"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertAuthorizeSecurityGroupIngressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAccountAttributesRequest = { ["DryRun"] = true, ["AttributeNames"] = true, nil }

function asserts.AssertDescribeAccountAttributesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AttributeNames"] then asserts.AssertAccountAttributeNameStringList(struct["AttributeNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAttributesRequest[k], "DescribeAccountAttributesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesRequest
-- <p>Contains the parameters for DescribeAccountAttributes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AttributeNames [AccountAttributeNameStringList] <p>One or more account attribute names.</p>
-- @return DescribeAccountAttributesRequest structure as a key-value pair table
function M.DescribeAccountAttributesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAccountAttributesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["AttributeNames"] = args["AttributeNames"],
	}
	asserts.AssertDescribeAccountAttributesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcPeeringConnection = { ["Status"] = true, ["Tags"] = true, ["RequesterVpcInfo"] = true, ["VpcPeeringConnectionId"] = true, ["ExpirationTime"] = true, ["AccepterVpcInfo"] = true, nil }

function asserts.AssertVpcPeeringConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnection to be of type 'table'")
	if struct["Status"] then asserts.AssertVpcPeeringConnectionStateReason(struct["Status"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["RequesterVpcInfo"] then asserts.AssertVpcPeeringConnectionVpcInfo(struct["RequesterVpcInfo"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["ExpirationTime"] then asserts.AssertDateTime(struct["ExpirationTime"]) end
	if struct["AccepterVpcInfo"] then asserts.AssertVpcPeeringConnectionVpcInfo(struct["AccepterVpcInfo"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnection[k], "VpcPeeringConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnection
-- <p>Describes a VPC peering connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [VpcPeeringConnectionStateReason] <p>The status of the VPC peering connection.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * RequesterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the requester VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- * ExpirationTime [DateTime] <p>The time that an unaccepted VPC peering connection will expire.</p>
-- * AccepterVpcInfo [VpcPeeringConnectionVpcInfo] <p>Information about the accepter VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>
-- @return VpcPeeringConnection structure as a key-value pair table
function M.VpcPeeringConnection(args)
	assert(args, "You must provide an argument table when creating VpcPeeringConnection")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Tags"] = args["Tags"],
		["RequesterVpcInfo"] = args["RequesterVpcInfo"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["ExpirationTime"] = args["ExpirationTime"],
		["AccepterVpcInfo"] = args["AccepterVpcInfo"],
	}
	asserts.AssertVpcPeeringConnection(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SecurityGroup = { ["IpPermissionsEgress"] = true, ["Description"] = true, ["Tags"] = true, ["IpPermissions"] = true, ["GroupName"] = true, ["VpcId"] = true, ["OwnerId"] = true, ["GroupId"] = true, nil }

function asserts.AssertSecurityGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SecurityGroup to be of type 'table'")
	if struct["IpPermissionsEgress"] then asserts.AssertIpPermissionList(struct["IpPermissionsEgress"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.SecurityGroup[k], "SecurityGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SecurityGroup
-- <p>Describes a security group</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IpPermissionsEgress [IpPermissionList] <p>[EC2-VPC] One or more outbound rules associated with the security group.</p>
-- * Description [String] <p>A description of the security group.</p>
-- * Tags [TagList] <p>Any tags assigned to the security group.</p>
-- * IpPermissions [IpPermissionList] <p>One or more inbound rules associated with the security group.</p>
-- * GroupName [String] <p>The name of the security group.</p>
-- * VpcId [String] <p>[EC2-VPC] The ID of the VPC for the security group.</p>
-- * OwnerId [String] <p>The AWS account ID of the owner of the security group.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return SecurityGroup structure as a key-value pair table
function M.SecurityGroup(args)
	assert(args, "You must provide an argument table when creating SecurityGroup")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IpPermissionsEgress"] = args["IpPermissionsEgress"],
		["Description"] = args["Description"],
		["Tags"] = args["Tags"],
		["IpPermissions"] = args["IpPermissions"],
		["GroupName"] = args["GroupName"],
		["VpcId"] = args["VpcId"],
		["OwnerId"] = args["OwnerId"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertSecurityGroup(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeScheduledInstanceAvailabilityResult = { ["NextToken"] = true, ["ScheduledInstanceAvailabilitySet"] = true, nil }

function asserts.AssertDescribeScheduledInstanceAvailabilityResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceAvailabilitySet"] then asserts.AssertScheduledInstanceAvailabilitySet(struct["ScheduledInstanceAvailabilitySet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstanceAvailabilityResult[k], "DescribeScheduledInstanceAvailabilityResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityResult
-- <p>Contains the output of DescribeScheduledInstanceAvailability.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ScheduledInstanceAvailabilitySet [ScheduledInstanceAvailabilitySet] <p>Information about the available Scheduled Instances.</p>
-- @return DescribeScheduledInstanceAvailabilityResult structure as a key-value pair table
function M.DescribeScheduledInstanceAvailabilityResult(args)
	assert(args, "You must provide an argument table when creating DescribeScheduledInstanceAvailabilityResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ScheduledInstanceAvailabilitySet"] = args["ScheduledInstanceAvailabilitySet"],
	}
	asserts.AssertDescribeScheduledInstanceAvailabilityResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIamInstanceProfileAssociationsRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, ["AssociationIds"] = true, nil }

function asserts.AssertDescribeIamInstanceProfileAssociationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["AssociationIds"] then asserts.AssertAssociationIdList(struct["AssociationIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIamInstanceProfileAssociationsRequest[k], "DescribeIamInstanceProfileAssociationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token to request the next page of results.</p>
-- * MaxResults [MaxResults] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>state</code> - The state of the association (<code>associating</code> | <code>associated</code> | <code>disassociating</code> | <code>disassociated</code>).</p> </li> </ul>
-- * AssociationIds [AssociationIdList] <p>One or more IAM instance profile associations.</p>
-- @return DescribeIamInstanceProfileAssociationsRequest structure as a key-value pair table
function M.DescribeIamInstanceProfileAssociationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeIamInstanceProfileAssociationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["AssociationIds"] = args["AssociationIds"],
	}
	asserts.AssertDescribeIamInstanceProfileAssociationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MonitorInstancesResult = { ["InstanceMonitorings"] = true, nil }

function asserts.AssertMonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then asserts.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(keys.MonitorInstancesResult[k], "MonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesResult
-- <p>Contains the output of MonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
-- @return MonitorInstancesResult structure as a key-value pair table
function M.MonitorInstancesResult(args)
	assert(args, "You must provide an argument table when creating MonitorInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceMonitorings"] = args["InstanceMonitorings"],
	}
	asserts.AssertMonitorInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ConversionTask = { ["ImportInstance"] = true, ["ImportVolume"] = true, ["Tags"] = true, ["ConversionTaskId"] = true, ["State"] = true, ["ExpirationTime"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertConversionTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConversionTask to be of type 'table'")
	if struct["ImportInstance"] then asserts.AssertImportInstanceTaskDetails(struct["ImportInstance"]) end
	if struct["ImportVolume"] then asserts.AssertImportVolumeTaskDetails(struct["ImportVolume"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["ConversionTaskId"] then asserts.AssertString(struct["ConversionTaskId"]) end
	if struct["State"] then asserts.AssertConversionTaskState(struct["State"]) end
	if struct["ExpirationTime"] then asserts.AssertString(struct["ExpirationTime"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConversionTask[k], "ConversionTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConversionTask
-- <p>Describes a conversion task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImportInstance [ImportInstanceTaskDetails] <p>If the task is for importing an instance, this contains information about the import instance task.</p>
-- * ImportVolume [ImportVolumeTaskDetails] <p>If the task is for importing a volume, this contains information about the import volume task.</p>
-- * Tags [TagList] <p>Any tags assigned to the task.</p>
-- * ConversionTaskId [String] <p>The ID of the conversion task.</p>
-- * State [ConversionTaskState] <p>The state of the conversion task.</p>
-- * ExpirationTime [String] <p>The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.</p>
-- * StatusMessage [String] <p>The status message related to the conversion task.</p>
-- @return ConversionTask structure as a key-value pair table
function M.ConversionTask(args)
	assert(args, "You must provide an argument table when creating ConversionTask")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ImportInstance"] = args["ImportInstance"],
		["ImportVolume"] = args["ImportVolume"],
		["Tags"] = args["Tags"],
		["ConversionTaskId"] = args["ConversionTaskId"],
		["State"] = args["State"],
		["ExpirationTime"] = args["ExpirationTime"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertConversionTask(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcEndpointResult = { ["VpcEndpoint"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointResult to be of type 'table'")
	if struct["VpcEndpoint"] then asserts.AssertVpcEndpoint(struct["VpcEndpoint"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointResult[k], "CreateVpcEndpointResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointResult
-- <p>Contains the output of CreateVpcEndpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpoint [VpcEndpoint] <p>Information about the endpoint.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>
-- @return CreateVpcEndpointResult structure as a key-value pair table
function M.CreateVpcEndpointResult(args)
	assert(args, "You must provide an argument table when creating CreateVpcEndpointResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcEndpoint"] = args["VpcEndpoint"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateVpcEndpointResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotPriceHistoryResult = { ["NextToken"] = true, ["SpotPriceHistory"] = true, nil }

function asserts.AssertDescribeSpotPriceHistoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotPriceHistoryResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["SpotPriceHistory"] then asserts.AssertSpotPriceHistoryList(struct["SpotPriceHistory"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotPriceHistoryResult[k], "DescribeSpotPriceHistoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotPriceHistoryResult
-- <p>Contains the output of DescribeSpotPriceHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is null or an empty string when there are no more results to return.</p>
-- * SpotPriceHistory [SpotPriceHistoryList] <p>The historical Spot prices.</p>
-- @return DescribeSpotPriceHistoryResult structure as a key-value pair table
function M.DescribeSpotPriceHistoryResult(args)
	assert(args, "You must provide an argument table when creating DescribeSpotPriceHistoryResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["SpotPriceHistory"] = args["SpotPriceHistory"],
	}
	asserts.AssertDescribeSpotPriceHistoryResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceNetworkAclAssociationRequest = { ["NetworkAclId"] = true, ["AssociationId"] = true, ["DryRun"] = true, nil }

function asserts.AssertReplaceNetworkAclAssociationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclAssociationRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclAssociationRequest[k], "ReplaceNetworkAclAssociationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclAssociationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAclId [String] <p>The ID of the new network ACL to associate with the subnet.</p>
-- * AssociationId [String] <p>The ID of the current association between the original network ACL and the subnet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: AssociationId
-- Required key: NetworkAclId
-- @return ReplaceNetworkAclAssociationRequest structure as a key-value pair table
function M.ReplaceNetworkAclAssociationRequest(args)
	assert(args, "You must provide an argument table when creating ReplaceNetworkAclAssociationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkAclId"] = args["NetworkAclId"],
		["AssociationId"] = args["AssociationId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertReplaceNetworkAclAssociationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeScheduledInstanceAvailabilityRequest = { ["DryRun"] = true, ["Filters"] = true, ["MinSlotDurationInHours"] = true, ["MaxResults"] = true, ["FirstSlotStartTimeRange"] = true, ["Recurrence"] = true, ["MaxSlotDurationInHours"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeScheduledInstanceAvailabilityRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstanceAvailabilityRequest to be of type 'table'")
	assert(struct["FirstSlotStartTimeRange"], "Expected key FirstSlotStartTimeRange to exist in table")
	assert(struct["Recurrence"], "Expected key Recurrence to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MinSlotDurationInHours"] then asserts.AssertInteger(struct["MinSlotDurationInHours"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["FirstSlotStartTimeRange"] then asserts.AssertSlotDateTimeRangeRequest(struct["FirstSlotStartTimeRange"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrenceRequest(struct["Recurrence"]) end
	if struct["MaxSlotDurationInHours"] then asserts.AssertInteger(struct["MaxSlotDurationInHours"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstanceAvailabilityRequest[k], "DescribeScheduledInstanceAvailabilityRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstanceAvailabilityRequest
-- <p>Contains the parameters for DescribeScheduledInstanceAvailability.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- * MinSlotDurationInHours [Integer] <p>The minimum available duration, in hours. The minimum required duration is 1,200 hours per year. For example, the minimum daily schedule is 4 hours, the minimum weekly schedule is 24 hours, and the minimum monthly schedule is 100 hours.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 300. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * FirstSlotStartTimeRange [SlotDateTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- * Recurrence [ScheduledInstanceRecurrenceRequest] <p>The schedule recurrence.</p>
-- * MaxSlotDurationInHours [Integer] <p>The maximum available duration, in hours. This value must be greater than <code>MinSlotDurationInHours</code> and less than 1,720.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- Required key: FirstSlotStartTimeRange
-- Required key: Recurrence
-- @return DescribeScheduledInstanceAvailabilityRequest structure as a key-value pair table
function M.DescribeScheduledInstanceAvailabilityRequest(args)
	assert(args, "You must provide an argument table when creating DescribeScheduledInstanceAvailabilityRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["MinSlotDurationInHours"] = args["MinSlotDurationInHours"],
		["MaxResults"] = args["MaxResults"],
		["FirstSlotStartTimeRange"] = args["FirstSlotStartTimeRange"],
		["Recurrence"] = args["Recurrence"],
		["MaxSlotDurationInHours"] = args["MaxSlotDurationInHours"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeScheduledInstanceAvailabilityRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RevokeSecurityGroupEgressRequest = { ["DryRun"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertRevokeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RevokeSecurityGroupEgressRequest[k], "RevokeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupEgressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * CidrIp [String] <p>Not supported. Use a set of IP permissions to specify the CIDR.</p>
-- * IpPermissions [IpPermissionList] <p>One or more sets of IP permissions. You can't specify a destination security group and a CIDR IP address range in the same set of permissions.</p>
-- * FromPort [Integer] <p>Not supported. Use a set of IP permissions to specify the port.</p>
-- * SourceSecurityGroupOwnerId [String] <p>Not supported. Use a set of IP permissions to specify a destination security group.</p>
-- * SourceSecurityGroupName [String] <p>Not supported. Use a set of IP permissions to specify a destination security group.</p>
-- * ToPort [Integer] <p>Not supported. Use a set of IP permissions to specify the port.</p>
-- * IpProtocol [String] <p>Not supported. Use a set of IP permissions to specify the protocol name or number.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- Required key: GroupId
-- @return RevokeSecurityGroupEgressRequest structure as a key-value pair table
function M.RevokeSecurityGroupEgressRequest(args)
	assert(args, "You must provide an argument table when creating RevokeSecurityGroupEgressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertRevokeSecurityGroupEgressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNatGatewaysResult = { ["NextToken"] = true, ["NatGateways"] = true, nil }

function asserts.AssertDescribeNatGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNatGatewaysResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["NatGateways"] then asserts.AssertNatGatewayList(struct["NatGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNatGatewaysResult[k], "DescribeNatGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNatGatewaysResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * NatGateways [NatGatewayList] <p>Information about the NAT gateways.</p>
-- @return DescribeNatGatewaysResult structure as a key-value pair table
function M.DescribeNatGatewaysResult(args)
	assert(args, "You must provide an argument table when creating DescribeNatGatewaysResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["NatGateways"] = args["NatGateways"],
	}
	asserts.AssertDescribeNatGatewaysResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceIamInstanceProfileAssociationResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertReplaceIamInstanceProfileAssociationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceIamInstanceProfileAssociationResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceIamInstanceProfileAssociationResult[k], "ReplaceIamInstanceProfileAssociationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceIamInstanceProfileAssociationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
-- @return ReplaceIamInstanceProfileAssociationResult structure as a key-value pair table
function M.ReplaceIamInstanceProfileAssociationResult(args)
	assert(args, "You must provide an argument table when creating ReplaceIamInstanceProfileAssociationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IamInstanceProfileAssociation"] = args["IamInstanceProfileAssociation"],
	}
	asserts.AssertReplaceIamInstanceProfileAssociationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ProvisionedBandwidth = { ["Status"] = true, ["Provisioned"] = true, ["RequestTime"] = true, ["Requested"] = true, ["ProvisionTime"] = true, nil }

function asserts.AssertProvisionedBandwidth(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProvisionedBandwidth to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Provisioned"] then asserts.AssertString(struct["Provisioned"]) end
	if struct["RequestTime"] then asserts.AssertDateTime(struct["RequestTime"]) end
	if struct["Requested"] then asserts.AssertString(struct["Requested"]) end
	if struct["ProvisionTime"] then asserts.AssertDateTime(struct["ProvisionTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProvisionedBandwidth[k], "ProvisionedBandwidth contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProvisionedBandwidth
-- <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * Provisioned [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * RequestTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * Requested [String] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- * ProvisionTime [DateTime] <p>Reserved. If you need to sustain traffic greater than the <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html">documented limits</a>, contact us through the <a href="https://console.aws.amazon.com/support/home?">Support Center</a>.</p>
-- @return ProvisionedBandwidth structure as a key-value pair table
function M.ProvisionedBandwidth(args)
	assert(args, "You must provide an argument table when creating ProvisionedBandwidth")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Provisioned"] = args["Provisioned"],
		["RequestTime"] = args["RequestTime"],
		["Requested"] = args["Requested"],
		["ProvisionTime"] = args["ProvisionTime"],
	}
	asserts.AssertProvisionedBandwidth(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePlacementGroupsResult = { ["PlacementGroups"] = true, nil }

function asserts.AssertDescribePlacementGroupsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePlacementGroupsResult to be of type 'table'")
	if struct["PlacementGroups"] then asserts.AssertPlacementGroupList(struct["PlacementGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePlacementGroupsResult[k], "DescribePlacementGroupsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePlacementGroupsResult
-- <p>Contains the output of DescribePlacementGroups.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PlacementGroups [PlacementGroupList] <p>One or more placement groups.</p>
-- @return DescribePlacementGroupsResult structure as a key-value pair table
function M.DescribePlacementGroupsResult(args)
	assert(args, "You must provide an argument table when creating DescribePlacementGroupsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PlacementGroups"] = args["PlacementGroups"],
	}
	asserts.AssertDescribePlacementGroupsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnmonitorInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertUnmonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnmonitorInstancesRequest[k], "UnmonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesRequest
-- <p>Contains the parameters for UnmonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return UnmonitorInstancesRequest structure as a key-value pair table
function M.UnmonitorInstancesRequest(args)
	assert(args, "You must provide an argument table when creating UnmonitorInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertUnmonitorInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NatGatewayAddress = { ["PublicIp"] = true, ["NetworkInterfaceId"] = true, ["AllocationId"] = true, ["PrivateIp"] = true, nil }

function asserts.AssertNatGatewayAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NatGatewayAddress to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIp"] then asserts.AssertString(struct["PrivateIp"]) end
	for k,_ in pairs(struct) do
		assert(keys.NatGatewayAddress[k], "NatGatewayAddress contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NatGatewayAddress
-- <p>Describes the IP addresses and network interface associated with a NAT gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address associated with the NAT gateway.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface associated with the NAT gateway.</p>
-- * AllocationId [String] <p>The allocation ID of the Elastic IP address that's associated with the NAT gateway.</p>
-- * PrivateIp [String] <p>The private IP address associated with the Elastic IP address.</p>
-- @return NatGatewayAddress structure as a key-value pair table
function M.NatGatewayAddress(args)
	assert(args, "You must provide an argument table when creating NatGatewayAddress")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AllocationId"] = args["AllocationId"],
		["PrivateIp"] = args["PrivateIp"],
	}
	asserts.AssertNatGatewayAddress(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.BundleInstanceResult = { ["BundleTask"] = true, nil }

function asserts.AssertBundleInstanceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleInstanceResult to be of type 'table'")
	if struct["BundleTask"] then asserts.AssertBundleTask(struct["BundleTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleInstanceResult[k], "BundleInstanceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleInstanceResult
-- <p>Contains the output of BundleInstance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * BundleTask [BundleTask] <p>Information about the bundle task.</p>
-- @return BundleInstanceResult structure as a key-value pair table
function M.BundleInstanceResult(args)
	assert(args, "You must provide an argument table when creating BundleInstanceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["BundleTask"] = args["BundleTask"],
	}
	asserts.AssertBundleInstanceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AccountAttributeValue = { ["AttributeValue"] = true, nil }

function asserts.AssertAccountAttributeValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttributeValue to be of type 'table'")
	if struct["AttributeValue"] then asserts.AssertString(struct["AttributeValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.AccountAttributeValue[k], "AccountAttributeValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttributeValue
-- <p>Describes a value of an account attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttributeValue [String] <p>The value of the attribute.</p>
-- @return AccountAttributeValue structure as a key-value pair table
function M.AccountAttributeValue(args)
	assert(args, "You must provide an argument table when creating AccountAttributeValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AttributeValue"] = args["AttributeValue"],
	}
	asserts.AssertAccountAttributeValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeHostReservationsRequest = { ["Filter"] = true, ["HostReservationIdSet"] = true, ["NextToken"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeHostReservationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationsRequest to be of type 'table'")
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["HostReservationIdSet"] then asserts.AssertHostReservationIdSet(struct["HostReservationIdSet"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationsRequest[k], "DescribeHostReservationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family (for example, <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> <li> <p> <code>state</code> - The state of the reservation (<code>payment-pending</code> | <code>payment-failed</code> | <code>active</code> | <code>retired</code>).</p> </li> </ul>
-- * HostReservationIdSet [HostReservationIdSet] <p>One or more host reservation IDs.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
-- @return DescribeHostReservationsRequest structure as a key-value pair table
function M.DescribeHostReservationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeHostReservationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Filter"] = args["Filter"],
		["HostReservationIdSet"] = args["HostReservationIdSet"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeHostReservationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeScheduledInstancesRequest = { ["ScheduledInstanceIds"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["SlotStartTimeRange"] = true, ["Filters"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeScheduledInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesRequest to be of type 'table'")
	if struct["ScheduledInstanceIds"] then asserts.AssertScheduledInstanceIdRequestSet(struct["ScheduledInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["SlotStartTimeRange"] then asserts.AssertSlotStartTimeRangeRequest(struct["SlotStartTimeRange"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstancesRequest[k], "DescribeScheduledInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesRequest
-- <p>Contains the parameters for DescribeScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ScheduledInstanceIds [ScheduledInstanceIdRequestSet] <p>One or more Scheduled Instance IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. This value can be between 5 and 300. The default value is 100. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * SlotStartTimeRange [SlotStartTimeRangeRequest] <p>The time period for the first schedule to start.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone (for example, <code>us-west-2a</code>).</p> </li> <li> <p> <code>instance-type</code> - The instance type (for example, <code>c4.large</code>).</p> </li> <li> <p> <code>network-platform</code> - The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p> </li> <li> <p> <code>platform</code> - The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p> </li> </ul>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- @return DescribeScheduledInstancesRequest structure as a key-value pair table
function M.DescribeScheduledInstancesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeScheduledInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ScheduledInstanceIds"] = args["ScheduledInstanceIds"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["SlotStartTimeRange"] = args["SlotStartTimeRange"],
		["Filters"] = args["Filters"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeScheduledInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetConsoleScreenshotRequest = { ["InstanceId"] = true, ["WakeUp"] = true, ["DryRun"] = true, nil }

function asserts.AssertGetConsoleScreenshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["WakeUp"] then asserts.AssertBoolean(struct["WakeUp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleScreenshotRequest[k], "GetConsoleScreenshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotRequest
-- <p>Contains the parameters for the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * WakeUp [Boolean] <p>When set to <code>true</code>, acts as keystroke input and wakes up an instance that's in standby or "sleep" mode.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: InstanceId
-- @return GetConsoleScreenshotRequest structure as a key-value pair table
function M.GetConsoleScreenshotRequest(args)
	assert(args, "You must provide an argument table when creating GetConsoleScreenshotRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["WakeUp"] = args["WakeUp"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertGetConsoleScreenshotRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkAclAssociation = { ["SubnetId"] = true, ["NetworkAclId"] = true, ["NetworkAclAssociationId"] = true, nil }

function asserts.AssertNetworkAclAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkAclAssociation to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["NetworkAclAssociationId"] then asserts.AssertString(struct["NetworkAclAssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkAclAssociation[k], "NetworkAclAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkAclAssociation
-- <p>Describes an association between a network ACL and a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * NetworkAclAssociationId [String] <p>The ID of the association between a network ACL and a subnet.</p>
-- @return NetworkAclAssociation structure as a key-value pair table
function M.NetworkAclAssociation(args)
	assert(args, "You must provide an argument table when creating NetworkAclAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["NetworkAclId"] = args["NetworkAclId"],
		["NetworkAclAssociationId"] = args["NetworkAclAssociationId"],
	}
	asserts.AssertNetworkAclAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeExportTasksResult = { ["ExportTasks"] = true, nil }

function asserts.AssertDescribeExportTasksResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeExportTasksResult to be of type 'table'")
	if struct["ExportTasks"] then asserts.AssertExportTaskList(struct["ExportTasks"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeExportTasksResult[k], "DescribeExportTasksResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeExportTasksResult
-- <p>Contains the output for DescribeExportTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExportTasks [ExportTaskList] <p>Information about the export tasks.</p>
-- @return DescribeExportTasksResult structure as a key-value pair table
function M.DescribeExportTasksResult(args)
	assert(args, "You must provide an argument table when creating DescribeExportTasksResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExportTasks"] = args["ExportTasks"],
	}
	asserts.AssertDescribeExportTasksResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelSpotFleetRequestsRequest = { ["SpotFleetRequestIds"] = true, ["DryRun"] = true, ["TerminateInstances"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsRequest to be of type 'table'")
	assert(struct["SpotFleetRequestIds"], "Expected key SpotFleetRequestIds to exist in table")
	assert(struct["TerminateInstances"], "Expected key TerminateInstances to exist in table")
	if struct["SpotFleetRequestIds"] then asserts.AssertValueStringList(struct["SpotFleetRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TerminateInstances"] then asserts.AssertBoolean(struct["TerminateInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsRequest[k], "CancelSpotFleetRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsRequest
-- <p>Contains the parameters for CancelSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestIds [ValueStringList] <p>The IDs of the Spot Fleet requests.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TerminateInstances [Boolean] <p>Indicates whether to terminate instances for a Spot Fleet request if it is canceled successfully.</p>
-- Required key: SpotFleetRequestIds
-- Required key: TerminateInstances
-- @return CancelSpotFleetRequestsRequest structure as a key-value pair table
function M.CancelSpotFleetRequestsRequest(args)
	assert(args, "You must provide an argument table when creating CancelSpotFleetRequestsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestIds"] = args["SpotFleetRequestIds"],
		["DryRun"] = args["DryRun"],
		["TerminateInstances"] = args["TerminateInstances"],
	}
	asserts.AssertCancelSpotFleetRequestsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DiskImage = { ["Volume"] = true, ["Image"] = true, ["Description"] = true, nil }

function asserts.AssertDiskImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DiskImage to be of type 'table'")
	if struct["Volume"] then asserts.AssertVolumeDetail(struct["Volume"]) end
	if struct["Image"] then asserts.AssertDiskImageDetail(struct["Image"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DiskImage[k], "DiskImage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DiskImage
-- <p>Describes a disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Volume [VolumeDetail] <p>Information about the volume.</p>
-- * Image [DiskImageDetail] <p>Information about the disk image.</p>
-- * Description [String] <p>A description of the disk image.</p>
-- @return DiskImage structure as a key-value pair table
function M.DiskImage(args)
	assert(args, "You must provide an argument table when creating DiskImage")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Volume"] = args["Volume"],
		["Image"] = args["Image"],
		["Description"] = args["Description"],
	}
	asserts.AssertDiskImage(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateEbsBlockDeviceRequest = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["KmsKeyId"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, ["Iops"] = true, nil }

function asserts.AssertLaunchTemplateEbsBlockDeviceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateEbsBlockDeviceRequest to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateEbsBlockDeviceRequest[k], "LaunchTemplateEbsBlockDeviceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateEbsBlockDeviceRequest
-- <p>The parameters for a block device for an EBS volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- * Encrypted [Boolean] <p>Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.</p>
-- * VolumeType [VolumeType] <p>The volume type.</p>
-- * KmsKeyId [String] <p>The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For io1, this represents the number of IOPS that are provisioned for the volume. For gp2, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see Amazon EBS Volume Types in the Amazon Elastic Compute Cloud User Guide.</p> <p>Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.</p>
-- @return LaunchTemplateEbsBlockDeviceRequest structure as a key-value pair table
function M.LaunchTemplateEbsBlockDeviceRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateEbsBlockDeviceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumeSize"] = args["VolumeSize"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["KmsKeyId"] = args["KmsKeyId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
	}
	asserts.AssertLaunchTemplateEbsBlockDeviceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachInternetGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertAttachInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachInternetGatewayRequest[k], "AttachInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayId [String] <p>The ID of the internet gateway.</p>
-- Required key: InternetGatewayId
-- Required key: VpcId
-- @return AttachInternetGatewayRequest structure as a key-value pair table
function M.AttachInternetGatewayRequest(args)
	assert(args, "You must provide an argument table when creating AttachInternetGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertAttachInternetGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachClassicLinkVpcRequest = { ["InstanceId"] = true, ["VpcId"] = true, ["DryRun"] = true, ["Groups"] = true, nil }

function asserts.AssertAttachClassicLinkVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcRequest to be of type 'table'")
	assert(struct["Groups"], "Expected key Groups to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Groups"] then asserts.AssertGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachClassicLinkVpcRequest[k], "AttachClassicLinkVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of an EC2-Classic instance to link to the ClassicLink-enabled VPC.</p>
-- * VpcId [String] <p>The ID of a ClassicLink-enabled VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Groups [GroupIdStringList] <p>The ID of one or more of the VPC's security groups. You cannot specify security groups from a different VPC.</p>
-- Required key: Groups
-- Required key: InstanceId
-- Required key: VpcId
-- @return AttachClassicLinkVpcRequest structure as a key-value pair table
function M.AttachClassicLinkVpcRequest(args)
	assert(args, "You must provide an argument table when creating AttachClassicLinkVpcRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["Groups"] = args["Groups"],
	}
	asserts.AssertAttachClassicLinkVpcRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.HistoryRecordEntry = { ["EventType"] = true, ["EventInformation"] = true, ["Timestamp"] = true, nil }

function asserts.AssertHistoryRecordEntry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HistoryRecordEntry to be of type 'table'")
	if struct["EventType"] then asserts.AssertFleetEventType(struct["EventType"]) end
	if struct["EventInformation"] then asserts.AssertEventInformation(struct["EventInformation"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.HistoryRecordEntry[k], "HistoryRecordEntry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HistoryRecordEntry
-- <p>Describes an event in the history of an EC2 Fleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EventType [FleetEventType] <p>The event type.</p>
-- * EventInformation [EventInformation] <p>Information about the event.</p>
-- * Timestamp [DateTime] <p>The date and time of the event, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @return HistoryRecordEntry structure as a key-value pair table
function M.HistoryRecordEntry(args)
	assert(args, "You must provide an argument table when creating HistoryRecordEntry")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EventType"] = args["EventType"],
		["EventInformation"] = args["EventInformation"],
		["Timestamp"] = args["Timestamp"],
	}
	asserts.AssertHistoryRecordEntry(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Storage = { ["S3"] = true, nil }

function asserts.AssertStorage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Storage to be of type 'table'")
	if struct["S3"] then asserts.AssertS3Storage(struct["S3"]) end
	for k,_ in pairs(struct) do
		assert(keys.Storage[k], "Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Storage
-- <p>Describes the storage location for an instance store-backed AMI.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3 [S3Storage] <p>An Amazon S3 storage location.</p>
-- @return Storage structure as a key-value pair table
function M.Storage(args)
	assert(args, "You must provide an argument table when creating Storage")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3"] = args["S3"],
	}
	asserts.AssertStorage(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeMovingAddressesRequest = { ["PublicIps"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeMovingAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeMovingAddressesRequest to be of type 'table'")
	if struct["PublicIps"] then asserts.AssertValueStringList(struct["PublicIps"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeMovingAddressesRequest[k], "DescribeMovingAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeMovingAddressesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIps [ValueStringList] <p>One or more Elastic IP addresses.</p>
-- * NextToken [String] <p>The token for the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value outside of this range, an error is returned.</p> <p>Default: If no value is provided, the default is 1000.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>moving-status</code> - The status of the Elastic IP address (<code>MovingToVpc</code> | <code>RestoringToClassic</code>).</p> </li> </ul>
-- @return DescribeMovingAddressesRequest structure as a key-value pair table
function M.DescribeMovingAddressesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeMovingAddressesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIps"] = args["PublicIps"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeMovingAddressesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateInstanceMarketOptionsRequest = { ["SpotOptions"] = true, ["MarketType"] = true, nil }

function asserts.AssertLaunchTemplateInstanceMarketOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateInstanceMarketOptionsRequest to be of type 'table'")
	if struct["SpotOptions"] then asserts.AssertLaunchTemplateSpotMarketOptionsRequest(struct["SpotOptions"]) end
	if struct["MarketType"] then asserts.AssertMarketType(struct["MarketType"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateInstanceMarketOptionsRequest[k], "LaunchTemplateInstanceMarketOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateInstanceMarketOptionsRequest
-- <p>The market (purchasing) option for the instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotOptions [LaunchTemplateSpotMarketOptionsRequest] <p>The options for Spot Instances.</p>
-- * MarketType [MarketType] <p>The market type.</p>
-- @return LaunchTemplateInstanceMarketOptionsRequest structure as a key-value pair table
function M.LaunchTemplateInstanceMarketOptionsRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateInstanceMarketOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotOptions"] = args["SpotOptions"],
		["MarketType"] = args["MarketType"],
	}
	asserts.AssertLaunchTemplateInstanceMarketOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Subnet = { ["AvailabilityZone"] = true, ["Tags"] = true, ["AvailableIpAddressCount"] = true, ["DefaultForAz"] = true, ["Ipv6CidrBlockAssociationSet"] = true, ["VpcId"] = true, ["State"] = true, ["MapPublicIpOnLaunch"] = true, ["SubnetId"] = true, ["CidrBlock"] = true, ["AssignIpv6AddressOnCreation"] = true, nil }

function asserts.AssertSubnet(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Subnet to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["AvailableIpAddressCount"] then asserts.AssertInteger(struct["AvailableIpAddressCount"]) end
	if struct["DefaultForAz"] then asserts.AssertBoolean(struct["DefaultForAz"]) end
	if struct["Ipv6CidrBlockAssociationSet"] then asserts.AssertSubnetIpv6CidrBlockAssociationSet(struct["Ipv6CidrBlockAssociationSet"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["State"] then asserts.AssertSubnetState(struct["State"]) end
	if struct["MapPublicIpOnLaunch"] then asserts.AssertBoolean(struct["MapPublicIpOnLaunch"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	if struct["AssignIpv6AddressOnCreation"] then asserts.AssertBoolean(struct["AssignIpv6AddressOnCreation"]) end
	for k,_ in pairs(struct) do
		assert(keys.Subnet[k], "Subnet contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Subnet
-- <p>Describes a subnet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone of the subnet.</p>
-- * Tags [TagList] <p>Any tags assigned to the subnet.</p>
-- * AvailableIpAddressCount [Integer] <p>The number of unused private IPv4 addresses in the subnet. The IPv4 addresses for any stopped instances are considered unavailable.</p>
-- * DefaultForAz [Boolean] <p>Indicates whether this is the default subnet for the Availability Zone.</p>
-- * Ipv6CidrBlockAssociationSet [SubnetIpv6CidrBlockAssociationSet] <p>Information about the IPv6 CIDR blocks associated with the subnet.</p>
-- * VpcId [String] <p>The ID of the VPC the subnet is in.</p>
-- * State [SubnetState] <p>The current state of the subnet.</p>
-- * MapPublicIpOnLaunch [Boolean] <p>Indicates whether instances launched in this subnet receive a public IPv4 address.</p>
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * CidrBlock [String] <p>The IPv4 CIDR block assigned to the subnet.</p>
-- * AssignIpv6AddressOnCreation [Boolean] <p>Indicates whether a network interface created in this subnet (including a network interface created by <a>RunInstances</a>) receives an IPv6 address.</p>
-- @return Subnet structure as a key-value pair table
function M.Subnet(args)
	assert(args, "You must provide an argument table when creating Subnet")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Tags"] = args["Tags"],
		["AvailableIpAddressCount"] = args["AvailableIpAddressCount"],
		["DefaultForAz"] = args["DefaultForAz"],
		["Ipv6CidrBlockAssociationSet"] = args["Ipv6CidrBlockAssociationSet"],
		["VpcId"] = args["VpcId"],
		["State"] = args["State"],
		["MapPublicIpOnLaunch"] = args["MapPublicIpOnLaunch"],
		["SubnetId"] = args["SubnetId"],
		["CidrBlock"] = args["CidrBlock"],
		["AssignIpv6AddressOnCreation"] = args["AssignIpv6AddressOnCreation"],
	}
	asserts.AssertSubnet(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CopySnapshotRequest = { ["DryRun"] = true, ["Description"] = true, ["Encrypted"] = true, ["PresignedUrl"] = true, ["SourceRegion"] = true, ["KmsKeyId"] = true, ["SourceSnapshotId"] = true, ["DestinationRegion"] = true, nil }

function asserts.AssertCopySnapshotRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotRequest to be of type 'table'")
	assert(struct["SourceRegion"], "Expected key SourceRegion to exist in table")
	assert(struct["SourceSnapshotId"], "Expected key SourceSnapshotId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["PresignedUrl"] then asserts.AssertString(struct["PresignedUrl"]) end
	if struct["SourceRegion"] then asserts.AssertString(struct["SourceRegion"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SourceSnapshotId"] then asserts.AssertString(struct["SourceSnapshotId"]) end
	if struct["DestinationRegion"] then asserts.AssertString(struct["DestinationRegion"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopySnapshotRequest[k], "CopySnapshotRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotRequest
-- <p>Contains the parameters for CopySnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the EBS snapshot.</p>
-- * Encrypted [Boolean] <p>Specifies whether the destination snapshot should be encrypted. You can encrypt a copy of an unencrypted snapshot, but you cannot use it to create an unencrypted copy of an encrypted snapshot. Your default CMK for EBS is used unless you specify a non-default AWS Key Management Service (AWS KMS) CMK using <code>KmsKeyId</code>. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * PresignedUrl [String] <p>When you copy an encrypted source snapshot using the Amazon EC2 Query API, you must supply a pre-signed URL. This parameter is optional for unencrypted snapshots. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Query-Requests.html">Query Requests</a>.</p> <p>The <code>PresignedUrl</code> should use the snapshot source endpoint, the <code>CopySnapshot</code> action, and include the <code>SourceRegion</code>, <code>SourceSnapshotId</code>, and <code>DestinationRegion</code> parameters. The <code>PresignedUrl</code> must be signed using AWS Signature Version 4. Because EBS snapshots are stored in Amazon S3, the signing algorithm for this parameter uses the same logic that is described in <a href="http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">Authenticating Requests by Using Query Parameters (AWS Signature Version 4)</a> in the <i>Amazon Simple Storage Service API Reference</i>. An invalid or improperly signed <code>PresignedUrl</code> will cause the copy operation to fail asynchronously, and the snapshot will move to an <code>error</code> state.</p>
-- * SourceRegion [String] <p>The ID of the region that contains the snapshot to be copied.</p>
-- * KmsKeyId [String] <p>An identifier for the AWS Key Management Service (AWS KMS) customer master key (CMK) to use when creating the encrypted volume. This parameter is only required if you want to use a non-default CMK; if this parameter is not specified, the default CMK for EBS is used. If a <code>KmsKeyId</code> is specified, the <code>Encrypted</code> flag must also be set. </p> <p>The CMK identifier may be provided in any of the following formats: </p> <ul> <li> <p>Key ID</p> </li> <li> <p>Key alias</p> </li> <li> <p>ARN using key ID. The ID ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>key</code> namespace, and then the CMK ID. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:key/<i>abcd1234-a123-456a-a12b-a123b4cd56ef</i>. </p> </li> <li> <p>ARN using key alias. The alias ARN contains the <code>arn:aws:kms</code> namespace, followed by the region of the CMK, the AWS account ID of the CMK owner, the <code>alias</code> namespace, and then the CMK alias. For example, arn:aws:kms:<i>us-east-1</i>:<i>012345678910</i>:alias/<i>ExampleAlias</i>. </p> </li> </ul> <p>AWS parses <code>KmsKeyId</code> asynchronously, meaning that the action you call may appear to complete even though you provided an invalid identifier. The action will eventually fail. </p>
-- * SourceSnapshotId [String] <p>The ID of the EBS snapshot to copy.</p>
-- * DestinationRegion [String] <p>The destination region to use in the <code>PresignedUrl</code> parameter of a snapshot copy operation. This parameter is only valid for specifying the destination region in a <code>PresignedUrl</code> parameter, where it is required.</p> <p>The snapshot copy is sent to the regional endpoint that you sent the HTTP request to (for example, <code>ec2.us-east-1.amazonaws.com</code>). With the AWS CLI, this is specified using the <code>--region</code> parameter or the default region in your AWS configuration file.</p>
-- Required key: SourceRegion
-- Required key: SourceSnapshotId
-- @return CopySnapshotRequest structure as a key-value pair table
function M.CopySnapshotRequest(args)
	assert(args, "You must provide an argument table when creating CopySnapshotRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["Encrypted"] = args["Encrypted"],
		["PresignedUrl"] = args["PresignedUrl"],
		["SourceRegion"] = args["SourceRegion"],
		["KmsKeyId"] = args["KmsKeyId"],
		["SourceSnapshotId"] = args["SourceSnapshotId"],
		["DestinationRegion"] = args["DestinationRegion"],
	}
	asserts.AssertCopySnapshotRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcPeeringConnectionOptionsRequest = { ["DryRun"] = true, ["RequesterPeeringConnectionOptions"] = true, ["VpcPeeringConnectionId"] = true, ["AccepterPeeringConnectionOptions"] = true, nil }

function asserts.AssertModifyVpcPeeringConnectionOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcPeeringConnectionOptionsRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RequesterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptionsRequest(struct["RequesterPeeringConnectionOptions"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["AccepterPeeringConnectionOptions"] then asserts.AssertPeeringConnectionOptionsRequest(struct["AccepterPeeringConnectionOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcPeeringConnectionOptionsRequest[k], "ModifyVpcPeeringConnectionOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcPeeringConnectionOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * RequesterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the requester VPC.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- * AccepterPeeringConnectionOptions [PeeringConnectionOptionsRequest] <p>The VPC peering connection options for the accepter VPC.</p>
-- Required key: VpcPeeringConnectionId
-- @return ModifyVpcPeeringConnectionOptionsRequest structure as a key-value pair table
function M.ModifyVpcPeeringConnectionOptionsRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVpcPeeringConnectionOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["RequesterPeeringConnectionOptions"] = args["RequesterPeeringConnectionOptions"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["AccepterPeeringConnectionOptions"] = args["AccepterPeeringConnectionOptions"],
	}
	asserts.AssertModifyVpcPeeringConnectionOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RequestSpotInstancesResult = { ["SpotInstanceRequests"] = true, nil }

function asserts.AssertRequestSpotInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotInstancesResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then asserts.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotInstancesResult[k], "RequestSpotInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotInstancesResult
-- <p>Contains the output of RequestSpotInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot Instance requests.</p>
-- @return RequestSpotInstancesResult structure as a key-value pair table
function M.RequestSpotInstancesResult(args)
	assert(args, "You must provide an argument table when creating RequestSpotInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotInstanceRequests"] = args["SpotInstanceRequests"],
	}
	asserts.AssertRequestSpotInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpnGatewayRequest = { ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertDeleteVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpnGatewayRequest to be of type 'table'")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpnGatewayRequest[k], "DeleteVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpnGatewayRequest
-- <p>Contains the parameters for DeleteVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required key: VpnGatewayId
-- @return DeleteVpnGatewayRequest structure as a key-value pair table
function M.DeleteVpnGatewayRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpnGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VpnGatewayId"] = args["VpnGatewayId"],
	}
	asserts.AssertDeleteVpnGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceAttribute = { ["ProductCodes"] = true, ["SourceDestCheck"] = true, ["UserData"] = true, ["InstanceId"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["Groups"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["RootDeviceName"] = true, ["DisableApiTermination"] = true, ["InstanceType"] = true, nil }

function asserts.AssertInstanceAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceAttribute to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["UserData"] then asserts.AssertAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then asserts.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["KernelId"] then asserts.AssertAttributeValue(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertAttributeValue(struct["RamdiskId"]) end
	if struct["RootDeviceName"] then asserts.AssertAttributeValue(struct["RootDeviceName"]) end
	if struct["DisableApiTermination"] then asserts.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then asserts.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceAttribute[k], "InstanceAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceAttribute
-- <p>Describes an instance attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- * SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means that checking is enabled, and <code>false</code> means that checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- * UserData [AttributeValue] <p>The user data.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * EnaSupport [AttributeBooleanValue] <p>Indicates whether enhanced networking with ENA is enabled.</p>
-- * SriovNetSupport [AttributeValue] <p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * InstanceInitiatedShutdownBehavior [AttributeValue] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- * BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>The block device mapping of the instance.</p>
-- * EbsOptimized [AttributeBooleanValue] <p>Indicates whether the instance is optimized for Amazon EBS I/O.</p>
-- * Groups [GroupIdentifierList] <p>The security groups associated with the instance.</p>
-- * KernelId [AttributeValue] <p>The kernel ID.</p>
-- * RamdiskId [AttributeValue] <p>The RAM disk ID.</p>
-- * RootDeviceName [AttributeValue] <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
-- * DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.</p>
-- * InstanceType [AttributeValue] <p>The instance type.</p>
-- @return InstanceAttribute structure as a key-value pair table
function M.InstanceAttribute(args)
	assert(args, "You must provide an argument table when creating InstanceAttribute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ProductCodes"] = args["ProductCodes"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["UserData"] = args["UserData"],
		["InstanceId"] = args["InstanceId"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["Groups"] = args["Groups"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
		["RootDeviceName"] = args["RootDeviceName"],
		["DisableApiTermination"] = args["DisableApiTermination"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertInstanceAttribute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplatePlacementRequest = { ["HostId"] = true, ["AvailabilityZone"] = true, ["SpreadDomain"] = true, ["GroupName"] = true, ["Tenancy"] = true, ["Affinity"] = true, nil }

function asserts.AssertLaunchTemplatePlacementRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplatePlacementRequest to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["SpreadDomain"] then asserts.AssertString(struct["SpreadDomain"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["Affinity"] then asserts.AssertString(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplatePlacementRequest[k], "LaunchTemplatePlacementRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplatePlacementRequest
-- <p>The placement for the instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostId [String] <p>The ID of the Dedicated Host for the instance.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the instance.</p>
-- * SpreadDomain [String] <p>Reserved for future use.</p>
-- * GroupName [String] <p>The name of the placement group for the instance.</p>
-- * Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.</p>
-- * Affinity [String] <p>The affinity setting for an instance on a Dedicated Host.</p>
-- @return LaunchTemplatePlacementRequest structure as a key-value pair table
function M.LaunchTemplatePlacementRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplatePlacementRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostId"] = args["HostId"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["SpreadDomain"] = args["SpreadDomain"],
		["GroupName"] = args["GroupName"],
		["Tenancy"] = args["Tenancy"],
		["Affinity"] = args["Affinity"],
	}
	asserts.AssertLaunchTemplatePlacementRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceCreditSpecification = { ["InstanceId"] = true, ["CpuCredits"] = true, nil }

function asserts.AssertInstanceCreditSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCreditSpecification to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["CpuCredits"] then asserts.AssertString(struct["CpuCredits"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCreditSpecification[k], "InstanceCreditSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCreditSpecification
-- <p>Describes the credit option for CPU usage of a T2 or T3 instance. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * CpuCredits [String] <p>The credit option for CPU usage of the instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>
-- @return InstanceCreditSpecification structure as a key-value pair table
function M.InstanceCreditSpecification(args)
	assert(args, "You must provide an argument table when creating InstanceCreditSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["CpuCredits"] = args["CpuCredits"],
	}
	asserts.AssertInstanceCreditSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateLaunchTemplateRequest = { ["VersionDescription"] = true, ["LaunchTemplateName"] = true, ["LaunchTemplateData"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateLaunchTemplateRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateLaunchTemplateRequest to be of type 'table'")
	assert(struct["LaunchTemplateName"], "Expected key LaunchTemplateName to exist in table")
	assert(struct["LaunchTemplateData"], "Expected key LaunchTemplateData to exist in table")
	if struct["VersionDescription"] then asserts.AssertVersionDescription(struct["VersionDescription"]) end
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["LaunchTemplateData"] then asserts.AssertRequestLaunchTemplateData(struct["LaunchTemplateData"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateLaunchTemplateRequest[k], "CreateLaunchTemplateRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateLaunchTemplateRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VersionDescription [VersionDescription] <p>A description for the first version of the launch template.</p>
-- * LaunchTemplateName [LaunchTemplateName] <p>A name for the launch template.</p>
-- * LaunchTemplateData [RequestLaunchTemplateData] <p>The information for the launch template.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: LaunchTemplateName
-- Required key: LaunchTemplateData
-- @return CreateLaunchTemplateRequest structure as a key-value pair table
function M.CreateLaunchTemplateRequest(args)
	assert(args, "You must provide an argument table when creating CreateLaunchTemplateRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VersionDescription"] = args["VersionDescription"],
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["LaunchTemplateData"] = args["LaunchTemplateData"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateLaunchTemplateRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteEgressOnlyInternetGatewayResult = { ["ReturnCode"] = true, nil }

function asserts.AssertDeleteEgressOnlyInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteEgressOnlyInternetGatewayResult to be of type 'table'")
	if struct["ReturnCode"] then asserts.AssertBoolean(struct["ReturnCode"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteEgressOnlyInternetGatewayResult[k], "DeleteEgressOnlyInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteEgressOnlyInternetGatewayResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReturnCode [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DeleteEgressOnlyInternetGatewayResult structure as a key-value pair table
function M.DeleteEgressOnlyInternetGatewayResult(args)
	assert(args, "You must provide an argument table when creating DeleteEgressOnlyInternetGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReturnCode"] = args["ReturnCode"],
	}
	asserts.AssertDeleteEgressOnlyInternetGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteNatGatewayRequest = { ["NatGatewayId"] = true, nil }

function asserts.AssertDeleteNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayRequest to be of type 'table'")
	assert(struct["NatGatewayId"], "Expected key NatGatewayId to exist in table")
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNatGatewayRequest[k], "DeleteNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- Required key: NatGatewayId
-- @return DeleteNatGatewayRequest structure as a key-value pair table
function M.DeleteNatGatewayRequest(args)
	assert(args, "You must provide an argument table when creating DeleteNatGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NatGatewayId"] = args["NatGatewayId"],
	}
	asserts.AssertDeleteNatGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PublicIpv4PoolRange = { ["AddressCount"] = true, ["LastAddress"] = true, ["AvailableAddressCount"] = true, ["FirstAddress"] = true, nil }

function asserts.AssertPublicIpv4PoolRange(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PublicIpv4PoolRange to be of type 'table'")
	if struct["AddressCount"] then asserts.AssertInteger(struct["AddressCount"]) end
	if struct["LastAddress"] then asserts.AssertString(struct["LastAddress"]) end
	if struct["AvailableAddressCount"] then asserts.AssertInteger(struct["AvailableAddressCount"]) end
	if struct["FirstAddress"] then asserts.AssertString(struct["FirstAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.PublicIpv4PoolRange[k], "PublicIpv4PoolRange contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PublicIpv4PoolRange
-- <p>Describes an address range of an IPv4 address pool.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AddressCount [Integer] <p>The number of addresses in the range.</p>
-- * LastAddress [String] <p>The last IP address in the range.</p>
-- * AvailableAddressCount [Integer] <p>The number of available addresses in the range.</p>
-- * FirstAddress [String] <p>The first IP address in the range.</p>
-- @return PublicIpv4PoolRange structure as a key-value pair table
function M.PublicIpv4PoolRange(args)
	assert(args, "You must provide an argument table when creating PublicIpv4PoolRange")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AddressCount"] = args["AddressCount"],
		["LastAddress"] = args["LastAddress"],
		["AvailableAddressCount"] = args["AvailableAddressCount"],
		["FirstAddress"] = args["FirstAddress"],
	}
	asserts.AssertPublicIpv4PoolRange(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CopySnapshotResult = { ["SnapshotId"] = true, nil }

function asserts.AssertCopySnapshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopySnapshotResult to be of type 'table'")
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopySnapshotResult[k], "CopySnapshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopySnapshotResult
-- <p>Contains the output of CopySnapshot.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SnapshotId [String] <p>The ID of the new snapshot.</p>
-- @return CopySnapshotResult structure as a key-value pair table
function M.CopySnapshotResult(args)
	assert(args, "You must provide an argument table when creating CopySnapshotResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertCopySnapshotResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceBlockDeviceMappingSpecification = { ["VirtualName"] = true, ["DeviceName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertInstanceBlockDeviceMappingSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceBlockDeviceMappingSpecification to be of type 'table'")
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertEbsInstanceBlockDeviceSpecification(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceBlockDeviceMappingSpecification[k], "InstanceBlockDeviceMappingSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceBlockDeviceMappingSpecification
-- <p>Describes a block device mapping entry.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VirtualName [String] <p>The virtual device name.</p>
-- * DeviceName [String] <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * NoDevice [String] <p>suppress the specified device included in the block device mapping.</p>
-- * Ebs [EbsInstanceBlockDeviceSpecification] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
-- @return InstanceBlockDeviceMappingSpecification structure as a key-value pair table
function M.InstanceBlockDeviceMappingSpecification(args)
	assert(args, "You must provide an argument table when creating InstanceBlockDeviceMappingSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VirtualName"] = args["VirtualName"],
		["DeviceName"] = args["DeviceName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertInstanceBlockDeviceMappingSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePrincipalIdFormatResult = { ["Principals"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribePrincipalIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrincipalIdFormatResult to be of type 'table'")
	if struct["Principals"] then asserts.AssertPrincipalIdFormatList(struct["Principals"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrincipalIdFormatResult[k], "DescribePrincipalIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrincipalIdFormatResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Principals [PrincipalIdFormatList] <p>Information about the ID format settings for the ARN.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is null when there are no more results to return.</p>
-- @return DescribePrincipalIdFormatResult structure as a key-value pair table
function M.DescribePrincipalIdFormatResult(args)
	assert(args, "You must provide an argument table when creating DescribePrincipalIdFormatResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Principals"] = args["Principals"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribePrincipalIdFormatResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartInstancesRequest = { ["AdditionalInfo"] = true, ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertStartInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["AdditionalInfo"] then asserts.AssertString(struct["AdditionalInfo"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartInstancesRequest[k], "StartInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesRequest
-- <p>Contains the parameters for StartInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AdditionalInfo [String] <p>Reserved.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return StartInstancesRequest structure as a key-value pair table
function M.StartInstancesRequest(args)
	assert(args, "You must provide an argument table when creating StartInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AdditionalInfo"] = args["AdditionalInfo"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertStartInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIdFormatResult = { ["Statuses"] = true, nil }

function asserts.AssertDescribeIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatResult to be of type 'table'")
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdFormatResult[k], "DescribeIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatResult
-- <p>Contains the output of DescribeIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Statuses [IdFormatList] <p>Information about the ID format for the resource.</p>
-- @return DescribeIdFormatResult structure as a key-value pair table
function M.DescribeIdFormatResult(args)
	assert(args, "You must provide an argument table when creating DescribeIdFormatResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Statuses"] = args["Statuses"],
	}
	asserts.AssertDescribeIdFormatResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcTenancyRequest = { ["DryRun"] = true, ["VpcId"] = true, ["InstanceTenancy"] = true, nil }

function asserts.AssertModifyVpcTenancyRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcTenancyRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["InstanceTenancy"], "Expected key InstanceTenancy to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["InstanceTenancy"] then asserts.AssertVpcTenancy(struct["InstanceTenancy"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcTenancyRequest[k], "ModifyVpcTenancyRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcTenancyRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * InstanceTenancy [VpcTenancy] <p>The instance tenancy attribute for the VPC. </p>
-- Required key: VpcId
-- Required key: InstanceTenancy
-- @return ModifyVpcTenancyRequest structure as a key-value pair table
function M.ModifyVpcTenancyRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVpcTenancyRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VpcId"] = args["VpcId"],
		["InstanceTenancy"] = args["InstanceTenancy"],
	}
	asserts.AssertModifyVpcTenancyRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelReservedInstancesListingResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertCancelReservedInstancesListingResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelReservedInstancesListingResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelReservedInstancesListingResult[k], "CancelReservedInstancesListingResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelReservedInstancesListingResult
-- <p>Contains the output of CancelReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListings [ReservedInstancesListingList] <p>The Reserved Instance listing.</p>
-- @return CancelReservedInstancesListingResult structure as a key-value pair table
function M.CancelReservedInstancesListingResult(args)
	assert(args, "You must provide an argument table when creating CancelReservedInstancesListingResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesListings"] = args["ReservedInstancesListings"],
	}
	asserts.AssertCancelReservedInstancesListingResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RestoreAddressToClassicResult = { ["PublicIp"] = true, ["Status"] = true, nil }

function asserts.AssertRestoreAddressToClassicResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicResult to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["Status"] then asserts.AssertStatus(struct["Status"]) end
	for k,_ in pairs(struct) do
		assert(keys.RestoreAddressToClassicResult[k], "RestoreAddressToClassicResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * Status [Status] <p>The move status for the IP address.</p>
-- @return RestoreAddressToClassicResult structure as a key-value pair table
function M.RestoreAddressToClassicResult(args)
	assert(args, "You must provide an argument table when creating RestoreAddressToClassicResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["Status"] = args["Status"],
	}
	asserts.AssertRestoreAddressToClassicResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PrefixListId = { ["Description"] = true, ["PrefixListId"] = true, nil }

function asserts.AssertPrefixListId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixListId to be of type 'table'")
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["PrefixListId"] then asserts.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrefixListId[k], "PrefixListId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixListId
-- <p>Describes a prefix list ID.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Description [String] <p>A description for the security group rule that references this prefix list ID.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
-- * PrefixListId [String] <p>The ID of the prefix.</p>
-- @return PrefixListId structure as a key-value pair table
function M.PrefixListId(args)
	assert(args, "You must provide an argument table when creating PrefixListId")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Description"] = args["Description"],
		["PrefixListId"] = args["PrefixListId"],
	}
	asserts.AssertPrefixListId(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Placement = { ["HostId"] = true, ["AvailabilityZone"] = true, ["SpreadDomain"] = true, ["GroupName"] = true, ["Tenancy"] = true, ["Affinity"] = true, nil }

function asserts.AssertPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Placement to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["SpreadDomain"] then asserts.AssertString(struct["SpreadDomain"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["Affinity"] then asserts.AssertString(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.Placement[k], "Placement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Placement
-- <p>Describes the placement of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostId [String] <p>The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the <a>ImportInstance</a> command.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- * SpreadDomain [String] <p>Reserved for future use.</p>
-- * GroupName [String] <p>The name of the placement group the instance is in.</p>
-- * Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for the <a>ImportInstance</a> command.</p>
-- * Affinity [String] <p>The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the <a>ImportInstance</a> command.</p>
-- @return Placement structure as a key-value pair table
function M.Placement(args)
	assert(args, "You must provide an argument table when creating Placement")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostId"] = args["HostId"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["SpreadDomain"] = args["SpreadDomain"],
		["GroupName"] = args["GroupName"],
		["Tenancy"] = args["Tenancy"],
		["Affinity"] = args["Affinity"],
	}
	asserts.AssertPlacement(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesBlockDeviceMapping = { ["VirtualName"] = true, ["DeviceName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertScheduledInstancesBlockDeviceMapping(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesBlockDeviceMapping to be of type 'table'")
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertScheduledInstancesEbs(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesBlockDeviceMapping[k], "ScheduledInstancesBlockDeviceMapping contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesBlockDeviceMapping
-- <p>Describes a block device mapping for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VirtualName [String] <p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>
-- * DeviceName [String] <p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>
-- * NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- * Ebs [ScheduledInstancesEbs] <p>Parameters used to set up EBS volumes automatically when the instance is launched.</p>
-- @return ScheduledInstancesBlockDeviceMapping structure as a key-value pair table
function M.ScheduledInstancesBlockDeviceMapping(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesBlockDeviceMapping")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VirtualName"] = args["VirtualName"],
		["DeviceName"] = args["DeviceName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertScheduledInstancesBlockDeviceMapping(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UserBucket = { ["S3Bucket"] = true, ["S3Key"] = true, nil }

function asserts.AssertUserBucket(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserBucket to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["S3Key"] then asserts.AssertString(struct["S3Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserBucket[k], "UserBucket contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserBucket
-- <p>Describes the S3 bucket for the disk image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The name of the S3 bucket where the disk image is located.</p>
-- * S3Key [String] <p>The file name of the disk image.</p>
-- @return UserBucket structure as a key-value pair table
function M.UserBucket(args)
	assert(args, "You must provide an argument table when creating UserBucket")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3Bucket"] = args["S3Bucket"],
		["S3Key"] = args["S3Key"],
	}
	asserts.AssertUserBucket(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVolumePermissionModifications = { ["Add"] = true, ["Remove"] = true, nil }

function asserts.AssertCreateVolumePermissionModifications(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermissionModifications to be of type 'table'")
	if struct["Add"] then asserts.AssertCreateVolumePermissionList(struct["Add"]) end
	if struct["Remove"] then asserts.AssertCreateVolumePermissionList(struct["Remove"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumePermissionModifications[k], "CreateVolumePermissionModifications contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermissionModifications
-- <p>Describes modifications to the permissions for a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Add [CreateVolumePermissionList] <p>Adds a specific AWS account ID or group to a volume's list of create volume permissions.</p>
-- * Remove [CreateVolumePermissionList] <p>Removes a specific AWS account ID or group from a volume's list of create volume permissions.</p>
-- @return CreateVolumePermissionModifications structure as a key-value pair table
function M.CreateVolumePermissionModifications(args)
	assert(args, "You must provide an argument table when creating CreateVolumePermissionModifications")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Add"] = args["Add"],
		["Remove"] = args["Remove"],
	}
	asserts.AssertCreateVolumePermissionModifications(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EbsBlockDevice = { ["VolumeSize"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["Iops"] = true, ["KmsKeyId"] = true, ["DeleteOnTermination"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertEbsBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsBlockDevice to be of type 'table'")
	if struct["VolumeSize"] then asserts.AssertInteger(struct["VolumeSize"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsBlockDevice[k], "EbsBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsBlockDevice
-- <p>Describes a block device for an EBS volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeSize [Integer] <p>The size of the volume, in GiB.</p> <p>Constraints: 1-16384 for General Purpose SSD (<code>gp2</code>), 4-16384 for Provisioned IOPS SSD (<code>io1</code>), 500-16384 for Throughput Optimized HDD (<code>st1</code>), 500-16384 for Cold HDD (<code>sc1</code>), and 1-1024 for Magnetic (<code>standard</code>) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>
-- * Encrypted [Boolean] <p>Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. </p> <p>If you are creating a volume from a snapshot, you cannot specify an encryption value. This is because only blank volumes can be encrypted on creation. If you are creating a snapshot from an existing EBS volume, you cannot specify an encryption value that differs from that of the EBS volume. We recommend that you omit the encryption value from the block device mappings when creating an image from an instance.</p>
-- * VolumeType [VolumeType] <p>The volume type: <code>gp2</code>, <code>io1</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code>.</p> <p>Default: <code>standard</code> </p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For <code>io1</code>, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code>, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- * KmsKeyId [String] <p>Identifier (key ID, key alias, ID ARN, or alias ARN) for a user-managed CMK under which the EBS volume is encrypted.</p> <p>This parameter is only supported on <code>BlockDeviceMapping</code> objects called by <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html">RunInstances</a>, <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html">RequestSpotFleet</a>, and <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html">RequestSpotInstances</a>.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- * SnapshotId [String] <p>The ID of the snapshot.</p>
-- @return EbsBlockDevice structure as a key-value pair table
function M.EbsBlockDevice(args)
	assert(args, "You must provide an argument table when creating EbsBlockDevice")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumeSize"] = args["VolumeSize"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["Iops"] = args["Iops"],
		["KmsKeyId"] = args["KmsKeyId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertEbsBlockDevice(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TargetConfiguration = { ["InstanceCount"] = true, ["OfferingId"] = true, nil }

function asserts.AssertTargetConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetConfiguration to be of type 'table'")
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetConfiguration[k], "TargetConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetConfiguration
-- <p>Information about the Convertible Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceCount [Integer] <p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>
-- * OfferingId [String] <p>The ID of the Convertible Reserved Instance offering.</p>
-- @return TargetConfiguration structure as a key-value pair table
function M.TargetConfiguration(args)
	assert(args, "You must provide an argument table when creating TargetConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceCount"] = args["InstanceCount"],
		["OfferingId"] = args["OfferingId"],
	}
	asserts.AssertTargetConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResponseLaunchTemplateData = { ["Monitoring"] = true, ["TagSpecifications"] = true, ["EbsOptimized"] = true, ["CpuOptions"] = true, ["ImageId"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["CreditSpecification"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, ["Placement"] = true, ["ElasticGpuSpecifications"] = true, ["CapacityReservationSpecification"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["SecurityGroupIds"] = true, ["BlockDeviceMappings"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["UserData"] = true, ["InstanceMarketOptions"] = true, ["RamDiskId"] = true, ["DisableApiTermination"] = true, nil }

function asserts.AssertResponseLaunchTemplateData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResponseLaunchTemplateData to be of type 'table'")
	if struct["Monitoring"] then asserts.AssertLaunchTemplatesMonitoring(struct["Monitoring"]) end
	if struct["TagSpecifications"] then asserts.AssertLaunchTemplateTagSpecificationList(struct["TagSpecifications"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["CpuOptions"] then asserts.AssertLaunchTemplateCpuOptions(struct["CpuOptions"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertValueStringList(struct["SecurityGroups"]) end
	if struct["CreditSpecification"] then asserts.AssertCreditSpecification(struct["CreditSpecification"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	if struct["Placement"] then asserts.AssertLaunchTemplatePlacement(struct["Placement"]) end
	if struct["ElasticGpuSpecifications"] then asserts.AssertElasticGpuSpecificationResponseList(struct["ElasticGpuSpecifications"]) end
	if struct["CapacityReservationSpecification"] then asserts.AssertLaunchTemplateCapacityReservationSpecificationResponse(struct["CapacityReservationSpecification"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertShutdownBehavior(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["SecurityGroupIds"] then asserts.AssertValueStringList(struct["SecurityGroupIds"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertLaunchTemplateBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertLaunchTemplateIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["InstanceMarketOptions"] then asserts.AssertLaunchTemplateInstanceMarketOptions(struct["InstanceMarketOptions"]) end
	if struct["RamDiskId"] then asserts.AssertString(struct["RamDiskId"]) end
	if struct["DisableApiTermination"] then asserts.AssertBoolean(struct["DisableApiTermination"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResponseLaunchTemplateData[k], "ResponseLaunchTemplateData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResponseLaunchTemplateData
-- <p>The information for a launch template. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Monitoring [LaunchTemplatesMonitoring] <p>The monitoring for the instance.</p>
-- * TagSpecifications [LaunchTemplateTagSpecificationList] <p>The tags.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for Amazon EBS I/O. </p>
-- * CpuOptions [LaunchTemplateCpuOptions] <p>The CPU options for the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimizing CPU Options</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * ImageId [String] <p>The ID of the AMI that was used to launch the instance.</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * SecurityGroups [ValueStringList] <p>The security group names.</p>
-- * CreditSpecification [CreditSpecification] <p>The credit option for CPU usage of the instance.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * NetworkInterfaces [LaunchTemplateInstanceNetworkInterfaceSpecificationList] <p>The network interfaces.</p>
-- * Placement [LaunchTemplatePlacement] <p>The placement of the instance.</p>
-- * ElasticGpuSpecifications [ElasticGpuSpecificationResponseList] <p>The elastic GPU specification.</p>
-- * CapacityReservationSpecification [LaunchTemplateCapacityReservationSpecificationResponse] <p>Information about the Capacity Reservation targeting option.</p>
-- * InstanceInitiatedShutdownBehavior [ShutdownBehavior] <p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- * SecurityGroupIds [ValueStringList] <p>The security group IDs.</p>
-- * BlockDeviceMappings [LaunchTemplateBlockDeviceMappingList] <p>The block device mappings.</p>
-- * KernelId [String] <p>The ID of the kernel, if applicable.</p>
-- * IamInstanceProfile [LaunchTemplateIamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * UserData [String] <p>The user data for the instance. </p>
-- * InstanceMarketOptions [LaunchTemplateInstanceMarketOptions] <p>The market (purchasing) option for the instances.</p>
-- * RamDiskId [String] <p>The ID of the RAM disk, if applicable.</p>
-- * DisableApiTermination [Boolean] <p>If set to <code>true</code>, indicates that the instance cannot be terminated using the Amazon EC2 console, command line tool, or API.</p>
-- @return ResponseLaunchTemplateData structure as a key-value pair table
function M.ResponseLaunchTemplateData(args)
	assert(args, "You must provide an argument table when creating ResponseLaunchTemplateData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Monitoring"] = args["Monitoring"],
		["TagSpecifications"] = args["TagSpecifications"],
		["EbsOptimized"] = args["EbsOptimized"],
		["CpuOptions"] = args["CpuOptions"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["SecurityGroups"] = args["SecurityGroups"],
		["CreditSpecification"] = args["CreditSpecification"],
		["InstanceType"] = args["InstanceType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
		["Placement"] = args["Placement"],
		["ElasticGpuSpecifications"] = args["ElasticGpuSpecifications"],
		["CapacityReservationSpecification"] = args["CapacityReservationSpecification"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["KernelId"] = args["KernelId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["UserData"] = args["UserData"],
		["InstanceMarketOptions"] = args["InstanceMarketOptions"],
		["RamDiskId"] = args["RamDiskId"],
		["DisableApiTermination"] = args["DisableApiTermination"],
	}
	asserts.AssertResponseLaunchTemplateData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteLaunchTemplateVersionsResult = { ["UnsuccessfullyDeletedLaunchTemplateVersions"] = true, ["SuccessfullyDeletedLaunchTemplateVersions"] = true, nil }

function asserts.AssertDeleteLaunchTemplateVersionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteLaunchTemplateVersionsResult to be of type 'table'")
	if struct["UnsuccessfullyDeletedLaunchTemplateVersions"] then asserts.AssertDeleteLaunchTemplateVersionsResponseErrorSet(struct["UnsuccessfullyDeletedLaunchTemplateVersions"]) end
	if struct["SuccessfullyDeletedLaunchTemplateVersions"] then asserts.AssertDeleteLaunchTemplateVersionsResponseSuccessSet(struct["SuccessfullyDeletedLaunchTemplateVersions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteLaunchTemplateVersionsResult[k], "DeleteLaunchTemplateVersionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteLaunchTemplateVersionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UnsuccessfullyDeletedLaunchTemplateVersions [DeleteLaunchTemplateVersionsResponseErrorSet] <p>Information about the launch template versions that could not be deleted.</p>
-- * SuccessfullyDeletedLaunchTemplateVersions [DeleteLaunchTemplateVersionsResponseSuccessSet] <p>Information about the launch template versions that were successfully deleted.</p>
-- @return DeleteLaunchTemplateVersionsResult structure as a key-value pair table
function M.DeleteLaunchTemplateVersionsResult(args)
	assert(args, "You must provide an argument table when creating DeleteLaunchTemplateVersionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UnsuccessfullyDeletedLaunchTemplateVersions"] = args["UnsuccessfullyDeletedLaunchTemplateVersions"],
		["SuccessfullyDeletedLaunchTemplateVersions"] = args["SuccessfullyDeletedLaunchTemplateVersions"],
	}
	asserts.AssertDeleteLaunchTemplateVersionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcEndpointServiceConfigurationRequest = { ["AcceptanceRequired"] = true, ["NetworkLoadBalancerArns"] = true, ["DryRun"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateVpcEndpointServiceConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointServiceConfigurationRequest to be of type 'table'")
	assert(struct["NetworkLoadBalancerArns"], "Expected key NetworkLoadBalancerArns to exist in table")
	if struct["AcceptanceRequired"] then asserts.AssertBoolean(struct["AcceptanceRequired"]) end
	if struct["NetworkLoadBalancerArns"] then asserts.AssertValueStringList(struct["NetworkLoadBalancerArns"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointServiceConfigurationRequest[k], "CreateVpcEndpointServiceConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointServiceConfigurationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AcceptanceRequired [Boolean] <p>Indicate whether requests from service consumers to create an endpoint to your service must be accepted. To accept a request, use <a>AcceptVpcEndpointConnections</a>.</p>
-- * NetworkLoadBalancerArns [ValueStringList] <p>The Amazon Resource Names (ARNs) of one or more Network Load Balancers for your service.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- Required key: NetworkLoadBalancerArns
-- @return CreateVpcEndpointServiceConfigurationRequest structure as a key-value pair table
function M.CreateVpcEndpointServiceConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpcEndpointServiceConfigurationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AcceptanceRequired"] = args["AcceptanceRequired"],
		["NetworkLoadBalancerArns"] = args["NetworkLoadBalancerArns"],
		["DryRun"] = args["DryRun"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateVpcEndpointServiceConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.WithdrawByoipCidrRequest = { ["Cidr"] = true, ["DryRun"] = true, nil }

function asserts.AssertWithdrawByoipCidrRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected WithdrawByoipCidrRequest to be of type 'table'")
	assert(struct["Cidr"], "Expected key Cidr to exist in table")
	if struct["Cidr"] then asserts.AssertString(struct["Cidr"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.WithdrawByoipCidrRequest[k], "WithdrawByoipCidrRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type WithdrawByoipCidrRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cidr [String] <p>The public IPv4 address range, in CIDR notation.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Cidr
-- @return WithdrawByoipCidrRequest structure as a key-value pair table
function M.WithdrawByoipCidrRequest(args)
	assert(args, "You must provide an argument table when creating WithdrawByoipCidrRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Cidr"] = args["Cidr"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertWithdrawByoipCidrRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UserData = { ["Data"] = true, nil }

function asserts.AssertUserData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserData to be of type 'table'")
	if struct["Data"] then asserts.AssertString(struct["Data"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserData[k], "UserData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserData
-- <p>Describes the user data for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Data [String] <p>The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>
-- @return UserData structure as a key-value pair table
function M.UserData(args)
	assert(args, "You must provide an argument table when creating UserData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Data"] = args["Data"],
	}
	asserts.AssertUserData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportInstanceVolumeDetailItem = { ["Status"] = true, ["AvailabilityZone"] = true, ["Description"] = true, ["Image"] = true, ["Volume"] = true, ["BytesConverted"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertImportInstanceVolumeDetailItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportInstanceVolumeDetailItem to be of type 'table'")
	assert(struct["AvailabilityZone"], "Expected key AvailabilityZone to exist in table")
	assert(struct["BytesConverted"], "Expected key BytesConverted to exist in table")
	assert(struct["Image"], "Expected key Image to exist in table")
	assert(struct["Status"], "Expected key Status to exist in table")
	assert(struct["Volume"], "Expected key Volume to exist in table")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Image"] then asserts.AssertDiskImageDescription(struct["Image"]) end
	if struct["Volume"] then asserts.AssertDiskImageVolumeDescription(struct["Volume"]) end
	if struct["BytesConverted"] then asserts.AssertLong(struct["BytesConverted"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportInstanceVolumeDetailItem[k], "ImportInstanceVolumeDetailItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportInstanceVolumeDetailItem
-- <p>Describes an import volume task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>The status of the import of this particular disk image.</p>
-- * AvailabilityZone [String] <p>The Availability Zone where the resulting instance will reside.</p>
-- * Description [String] <p>A description of the task.</p>
-- * Image [DiskImageDescription] <p>The image.</p>
-- * Volume [DiskImageVolumeDescription] <p>The volume.</p>
-- * BytesConverted [Long] <p>The number of bytes converted so far.</p>
-- * StatusMessage [String] <p>The status information or errors related to the disk image.</p>
-- Required key: AvailabilityZone
-- Required key: BytesConverted
-- Required key: Image
-- Required key: Status
-- Required key: Volume
-- @return ImportInstanceVolumeDetailItem structure as a key-value pair table
function M.ImportInstanceVolumeDetailItem(args)
	assert(args, "You must provide an argument table when creating ImportInstanceVolumeDetailItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Description"] = args["Description"],
		["Image"] = args["Image"],
		["Volume"] = args["Volume"],
		["BytesConverted"] = args["BytesConverted"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertImportInstanceVolumeDetailItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesModificationsRequest = { ["NextToken"] = true, ["ReservedInstancesModificationIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModificationIds"] then asserts.AssertReservedInstancesModificationIdStringList(struct["ReservedInstancesModificationIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesModificationsRequest[k], "DescribeReservedInstancesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsRequest
-- <p>Contains the parameters for DescribeReservedInstancesModifications.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * ReservedInstancesModificationIds [ReservedInstancesModificationIdStringList] <p>IDs for the submitted modification request.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>client-token</code> - The idempotency token for the modification request.</p> </li> <li> <p> <code>create-date</code> - The time when the modification request was created.</p> </li> <li> <p> <code>effective-date</code> - The time when the modification becomes effective.</p> </li> <li> <p> <code>modification-result.reserved-instances-id</code> - The ID for the Reserved Instances created as part of the modification request. This ID is only available when the status of the modification is <code>fulfilled</code>.</p> </li> <li> <p> <code>modification-result.target-configuration.availability-zone</code> - The Availability Zone for the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-count </code> - The number of new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.instance-type</code> - The instance type of the new Reserved Instances.</p> </li> <li> <p> <code>modification-result.target-configuration.platform</code> - The network platform of the new Reserved Instances (<code>EC2-Classic</code> | <code>EC2-VPC</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instances modified.</p> </li> <li> <p> <code>reserved-instances-modification-id</code> - The ID of the modification request.</p> </li> <li> <p> <code>status</code> - The status of the Reserved Instances modification request (<code>processing</code> | <code>fulfilled</code> | <code>failed</code>).</p> </li> <li> <p> <code>status-message</code> - The reason for the status.</p> </li> <li> <p> <code>update-date</code> - The time when the modification request was last updated.</p> </li> </ul>
-- @return DescribeReservedInstancesModificationsRequest structure as a key-value pair table
function M.DescribeReservedInstancesModificationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesModificationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ReservedInstancesModificationIds"] = args["ReservedInstancesModificationIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeReservedInstancesModificationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIdFormatRequest = { ["Resource"] = true, nil }

function asserts.AssertDescribeIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdFormatRequest to be of type 'table'")
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdFormatRequest[k], "DescribeIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdFormatRequest
-- <p>Contains the parameters for DescribeIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Resource [String] <p>The type of resource: <code>bundle</code> | <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> | <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> | <code>export-task</code> | <code>flow-log</code> | <code>image</code> | <code>import-task</code> | <code>instance</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-acl-association</code> | <code>network-interface</code> | <code>network-interface-attachment</code> | <code>prefix-list</code> | <code>reservation</code> | <code>route-table</code> | <code>route-table-association</code> | <code>security-group</code> | <code>snapshot</code> | <code>subnet</code> | <code>subnet-cidr-block-association</code> | <code>volume</code> | <code>vpc</code> | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code> </p>
-- @return DescribeIdFormatRequest structure as a key-value pair table
function M.DescribeIdFormatRequest(args)
	assert(args, "You must provide an argument table when creating DescribeIdFormatRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Resource"] = args["Resource"],
	}
	asserts.AssertDescribeIdFormatRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSecurityGroupRequest = { ["GroupName"] = true, ["VpcId"] = true, ["DryRun"] = true, ["Description"] = true, nil }

function asserts.AssertCreateSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSecurityGroupRequest to be of type 'table'")
	assert(struct["Description"], "Expected key Description to exist in table")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSecurityGroupRequest[k], "CreateSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSecurityGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the security group.</p> <p>Constraints: Up to 255 characters in length. Cannot start with <code>sg-</code>.</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- * VpcId [String] <p>[EC2-VPC] The ID of the VPC. Required for EC2-VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the security group. This is informational only.</p> <p>Constraints: Up to 255 characters in length</p> <p>Constraints for EC2-Classic: ASCII characters</p> <p>Constraints for EC2-VPC: a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>
-- Required key: Description
-- Required key: GroupName
-- @return CreateSecurityGroupRequest structure as a key-value pair table
function M.CreateSecurityGroupRequest(args)
	assert(args, "You must provide an argument table when creating CreateSecurityGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
	}
	asserts.AssertCreateSecurityGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.BundleTaskError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertBundleTaskError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected BundleTaskError to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.BundleTaskError[k], "BundleTaskError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type BundleTaskError
-- <p>Describes an error for <a>BundleInstance</a>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The error message.</p>
-- * Code [String] <p>The error code.</p>
-- @return BundleTaskError structure as a key-value pair table
function M.BundleTaskError(args)
	assert(args, "You must provide an argument table when creating BundleTaskError")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertBundleTaskError(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateFlowLogsRequest = { ["LogDestinationType"] = true, ["DryRun"] = true, ["ResourceType"] = true, ["LogGroupName"] = true, ["TrafficType"] = true, ["ResourceIds"] = true, ["DeliverLogsPermissionArn"] = true, ["ClientToken"] = true, ["LogDestination"] = true, nil }

function asserts.AssertCreateFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFlowLogsRequest to be of type 'table'")
	assert(struct["ResourceIds"], "Expected key ResourceIds to exist in table")
	assert(struct["ResourceType"], "Expected key ResourceType to exist in table")
	assert(struct["TrafficType"], "Expected key TrafficType to exist in table")
	if struct["LogDestinationType"] then asserts.AssertLogDestinationType(struct["LogDestinationType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ResourceType"] then asserts.AssertFlowLogsResourceType(struct["ResourceType"]) end
	if struct["LogGroupName"] then asserts.AssertString(struct["LogGroupName"]) end
	if struct["TrafficType"] then asserts.AssertTrafficType(struct["TrafficType"]) end
	if struct["ResourceIds"] then asserts.AssertValueStringList(struct["ResourceIds"]) end
	if struct["DeliverLogsPermissionArn"] then asserts.AssertString(struct["DeliverLogsPermissionArn"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["LogDestination"] then asserts.AssertString(struct["LogDestination"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFlowLogsRequest[k], "CreateFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFlowLogsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LogDestinationType [LogDestinationType] <p>Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3. To publish flow log data to CloudWatch Logs, specify <code>cloud-watch-logs</code>. To publish flow log data to Amazon S3, specify <code>s3</code>.</p> <p>Default: <code>cloud-watch-logs</code> </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ResourceType [FlowLogsResourceType] <p>The type of resource on which to create the flow log.</p>
-- * LogGroupName [String] <p>The name of the log group.</p>
-- * TrafficType [TrafficType] <p>The type of traffic to log.</p>
-- * ResourceIds [ValueStringList] <p>One or more subnet, network interface, or VPC IDs.</p> <p>Constraints: Maximum of 1000 resources</p>
-- * DeliverLogsPermissionArn [String] <p>The ARN for the IAM role that's used to post flow logs to a log group.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- * LogDestination [String] <p>Specifies the destination to which the flow log data is to be published. Flow log data can be published to an CloudWatch Logs log group or an Amazon S3 bucket. The value specified for this parameter depends on the value specified for LogDestinationType.</p> <p>If LogDestinationType is not specified or <code>cloud-watch-logs</code>, specify the Amazon Resource Name (ARN) of the CloudWatch Logs log group.</p> <p>If LogDestinationType is <code>s3</code>, specify the ARN of the Amazon S3 bucket. You can also specify a subfolder in the bucket. To specify a subfolder in the bucket, use the following ARN format: <code>bucket_ARN/subfolder_name/</code>. For example, to specify a subfolder named <code>my-logs</code> in a bucket named <code>my-bucket</code>, use the following ARN: <code>arn:aws:s3:::my-bucket/my-logs/</code>. You cannot use <code>AWSLogs</code> as a subfolder name. This is a reserved term.</p>
-- Required key: ResourceIds
-- Required key: ResourceType
-- Required key: TrafficType
-- @return CreateFlowLogsRequest structure as a key-value pair table
function M.CreateFlowLogsRequest(args)
	assert(args, "You must provide an argument table when creating CreateFlowLogsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LogDestinationType"] = args["LogDestinationType"],
		["DryRun"] = args["DryRun"],
		["ResourceType"] = args["ResourceType"],
		["LogGroupName"] = args["LogGroupName"],
		["TrafficType"] = args["TrafficType"],
		["ResourceIds"] = args["ResourceIds"],
		["DeliverLogsPermissionArn"] = args["DeliverLogsPermissionArn"],
		["ClientToken"] = args["ClientToken"],
		["LogDestination"] = args["LogDestination"],
	}
	asserts.AssertCreateFlowLogsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ElasticGpuSpecification = { ["Type"] = true, nil }

function asserts.AssertElasticGpuSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ElasticGpuSpecification to be of type 'table'")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.ElasticGpuSpecification[k], "ElasticGpuSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ElasticGpuSpecification
-- <p>A specification for an Elastic GPU.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [String] <p>The type of Elastic GPU.</p>
-- Required key: Type
-- @return ElasticGpuSpecification structure as a key-value pair table
function M.ElasticGpuSpecification(args)
	assert(args, "You must provide an argument table when creating ElasticGpuSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
	}
	asserts.AssertElasticGpuSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EnableVgwRoutePropagationRequest = { ["GatewayId"] = true, ["RouteTableId"] = true, nil }

function asserts.AssertEnableVgwRoutePropagationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVgwRoutePropagationRequest to be of type 'table'")
	assert(struct["GatewayId"], "Expected key GatewayId to exist in table")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVgwRoutePropagationRequest[k], "EnableVgwRoutePropagationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVgwRoutePropagationRequest
-- <p>Contains the parameters for EnableVgwRoutePropagation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GatewayId [String] <p>The ID of the virtual private gateway.</p>
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- Required key: GatewayId
-- Required key: RouteTableId
-- @return EnableVgwRoutePropagationRequest structure as a key-value pair table
function M.EnableVgwRoutePropagationRequest(args)
	assert(args, "You must provide an argument table when creating EnableVgwRoutePropagationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GatewayId"] = args["GatewayId"],
		["RouteTableId"] = args["RouteTableId"],
	}
	asserts.AssertEnableVgwRoutePropagationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IamInstanceProfileAssociation = { ["InstanceId"] = true, ["Timestamp"] = true, ["State"] = true, ["AssociationId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertIamInstanceProfileAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IamInstanceProfileAssociation to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["State"] then asserts.AssertIamInstanceProfileAssociationState(struct["State"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.IamInstanceProfileAssociation[k], "IamInstanceProfileAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IamInstanceProfileAssociation
-- <p>Describes an association between an IAM instance profile and an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Timestamp [DateTime] <p>The time the IAM instance profile was associated with the instance.</p>
-- * State [IamInstanceProfileAssociationState] <p>The state of the association.</p>
-- * AssociationId [String] <p>The ID of the association.</p>
-- * IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile.</p>
-- @return IamInstanceProfileAssociation structure as a key-value pair table
function M.IamInstanceProfileAssociation(args)
	assert(args, "You must provide an argument table when creating IamInstanceProfileAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Timestamp"] = args["Timestamp"],
		["State"] = args["State"],
		["AssociationId"] = args["AssociationId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
	}
	asserts.AssertIamInstanceProfileAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstance = { ["AvailabilityZone"] = true, ["ScheduledInstanceId"] = true, ["HourlyPrice"] = true, ["CreateDate"] = true, ["Recurrence"] = true, ["Platform"] = true, ["TermEndDate"] = true, ["InstanceCount"] = true, ["SlotDurationInHours"] = true, ["PreviousSlotEndTime"] = true, ["TermStartDate"] = true, ["NetworkPlatform"] = true, ["TotalScheduledInstanceHours"] = true, ["NextSlotStartTime"] = true, ["InstanceType"] = true, nil }

function asserts.AssertScheduledInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstance to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["ScheduledInstanceId"] then asserts.AssertString(struct["ScheduledInstanceId"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["TermEndDate"] then asserts.AssertDateTime(struct["TermEndDate"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["SlotDurationInHours"] then asserts.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["PreviousSlotEndTime"] then asserts.AssertDateTime(struct["PreviousSlotEndTime"]) end
	if struct["TermStartDate"] then asserts.AssertDateTime(struct["TermStartDate"]) end
	if struct["NetworkPlatform"] then asserts.AssertString(struct["NetworkPlatform"]) end
	if struct["TotalScheduledInstanceHours"] then asserts.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["NextSlotStartTime"] then asserts.AssertDateTime(struct["NextSlotStartTime"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstance[k], "ScheduledInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstance
-- <p>Describes a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * ScheduledInstanceId [String] <p>The Scheduled Instance ID.</p>
-- * HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- * CreateDate [DateTime] <p>The date when the Scheduled Instance was purchased.</p>
-- * Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- * Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- * TermEndDate [DateTime] <p>The end date for the Scheduled Instance.</p>
-- * InstanceCount [Integer] <p>The number of instances.</p>
-- * SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- * PreviousSlotEndTime [DateTime] <p>The time that the previous schedule ended or will end.</p>
-- * TermStartDate [DateTime] <p>The start date for the Scheduled Instance.</p>
-- * NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- * TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- * NextSlotStartTime [DateTime] <p>The time for the next schedule to start.</p>
-- * InstanceType [String] <p>The instance type.</p>
-- @return ScheduledInstance structure as a key-value pair table
function M.ScheduledInstance(args)
	assert(args, "You must provide an argument table when creating ScheduledInstance")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["ScheduledInstanceId"] = args["ScheduledInstanceId"],
		["HourlyPrice"] = args["HourlyPrice"],
		["CreateDate"] = args["CreateDate"],
		["Recurrence"] = args["Recurrence"],
		["Platform"] = args["Platform"],
		["TermEndDate"] = args["TermEndDate"],
		["InstanceCount"] = args["InstanceCount"],
		["SlotDurationInHours"] = args["SlotDurationInHours"],
		["PreviousSlotEndTime"] = args["PreviousSlotEndTime"],
		["TermStartDate"] = args["TermStartDate"],
		["NetworkPlatform"] = args["NetworkPlatform"],
		["TotalScheduledInstanceHours"] = args["TotalScheduledInstanceHours"],
		["NextSlotStartTime"] = args["NextSlotStartTime"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertScheduledInstance(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyInstanceCapacityReservationAttributesResult = { ["Return"] = true, nil }

function asserts.AssertModifyInstanceCapacityReservationAttributesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceCapacityReservationAttributesResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstanceCapacityReservationAttributesResult[k], "ModifyInstanceCapacityReservationAttributesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceCapacityReservationAttributesResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return ModifyInstanceCapacityReservationAttributesResult structure as a key-value pair table
function M.ModifyInstanceCapacityReservationAttributesResult(args)
	assert(args, "You must provide an argument table when creating ModifyInstanceCapacityReservationAttributesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyInstanceCapacityReservationAttributesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.HostInstance = { ["InstanceId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertHostInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostInstance[k], "HostInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostInstance
-- <p>Describes an instance running on a Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>the IDs of instances that are running on the Dedicated Host.</p>
-- * InstanceType [String] <p>The instance type size (for example, <code>m3.medium</code>) of the running instance.</p>
-- @return HostInstance structure as a key-value pair table
function M.HostInstance(args)
	assert(args, "You must provide an argument table when creating HostInstance")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertHostInstance(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Monitoring = { ["State"] = true, nil }

function asserts.AssertMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Monitoring to be of type 'table'")
	if struct["State"] then asserts.AssertMonitoringState(struct["State"]) end
	for k,_ in pairs(struct) do
		assert(keys.Monitoring[k], "Monitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Monitoring
-- <p>Describes the monitoring of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [MonitoringState] <p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>
-- @return Monitoring structure as a key-value pair table
function M.Monitoring(args)
	assert(args, "You must provide an argument table when creating Monitoring")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
	}
	asserts.AssertMonitoring(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RejectVpcEndpointConnectionsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertRejectVpcEndpointConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RejectVpcEndpointConnectionsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.RejectVpcEndpointConnectionsResult[k], "RejectVpcEndpointConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RejectVpcEndpointConnectionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the endpoints that were not rejected, if applicable.</p>
-- @return RejectVpcEndpointConnectionsResult structure as a key-value pair table
function M.RejectVpcEndpointConnectionsResult(args)
	assert(args, "You must provide an argument table when creating RejectVpcEndpointConnectionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertRejectVpcEndpointConnectionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CapacityReservationTargetResponse = { ["CapacityReservationId"] = true, nil }

function asserts.AssertCapacityReservationTargetResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CapacityReservationTargetResponse to be of type 'table'")
	if struct["CapacityReservationId"] then asserts.AssertString(struct["CapacityReservationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CapacityReservationTargetResponse[k], "CapacityReservationTargetResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CapacityReservationTargetResponse
-- <p>Describes a target Capacity Reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationId [String] <p>The ID of the Capacity Reservation.</p>
-- @return CapacityReservationTargetResponse structure as a key-value pair table
function M.CapacityReservationTargetResponse(args)
	assert(args, "You must provide an argument table when creating CapacityReservationTargetResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationId"] = args["CapacityReservationId"],
	}
	asserts.AssertCapacityReservationTargetResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotMarketOptions = { ["SpotInstanceType"] = true, ["BlockDurationMinutes"] = true, ["ValidUntil"] = true, ["MaxPrice"] = true, ["InstanceInterruptionBehavior"] = true, nil }

function asserts.AssertSpotMarketOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotMarketOptions to be of type 'table'")
	if struct["SpotInstanceType"] then asserts.AssertSpotInstanceType(struct["SpotInstanceType"]) end
	if struct["BlockDurationMinutes"] then asserts.AssertInteger(struct["BlockDurationMinutes"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["MaxPrice"] then asserts.AssertString(struct["MaxPrice"]) end
	if struct["InstanceInterruptionBehavior"] then asserts.AssertInstanceInterruptionBehavior(struct["InstanceInterruptionBehavior"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotMarketOptions[k], "SpotMarketOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotMarketOptions
-- <p>The options for Spot Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceType [SpotInstanceType] <p>The Spot Instance request type. For <a>RunInstances</a>, persistent Spot Instance requests are only supported when <b>InstanceInterruptionBehavior</b> is set to either <code>hibernate</code> or <code>stop</code>.</p>
-- * BlockDurationMinutes [Integer] <p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>
-- * ValidUntil [DateTime] <p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date.</p>
-- * MaxPrice [String] <p>The maximum hourly price you're willing to pay for the Spot Instances. The default is the On-Demand price.</p>
-- * InstanceInterruptionBehavior [InstanceInterruptionBehavior] <p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>
-- @return SpotMarketOptions structure as a key-value pair table
function M.SpotMarketOptions(args)
	assert(args, "You must provide an argument table when creating SpotMarketOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotInstanceType"] = args["SpotInstanceType"],
		["BlockDurationMinutes"] = args["BlockDurationMinutes"],
		["ValidUntil"] = args["ValidUntil"],
		["MaxPrice"] = args["MaxPrice"],
		["InstanceInterruptionBehavior"] = args["InstanceInterruptionBehavior"],
	}
	asserts.AssertSpotMarketOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachVpnGatewayResult = { ["VpcAttachment"] = true, nil }

function asserts.AssertAttachVpnGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayResult to be of type 'table'")
	if struct["VpcAttachment"] then asserts.AssertVpcAttachment(struct["VpcAttachment"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVpnGatewayResult[k], "AttachVpnGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayResult
-- <p>Contains the output of AttachVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcAttachment [VpcAttachment] <p>Information about the attachment.</p>
-- @return AttachVpnGatewayResult structure as a key-value pair table
function M.AttachVpnGatewayResult(args)
	assert(args, "You must provide an argument table when creating AttachVpnGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcAttachment"] = args["VpcAttachment"],
	}
	asserts.AssertAttachVpnGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeletePlacementGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeletePlacementGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeletePlacementGroupRequest to be of type 'table'")
	assert(struct["GroupName"], "Expected key GroupName to exist in table")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeletePlacementGroupRequest[k], "DeletePlacementGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeletePlacementGroupRequest
-- <p>Contains the parameters for DeletePlacementGroup.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the placement group.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: GroupName
-- @return DeletePlacementGroupRequest structure as a key-value pair table
function M.DeletePlacementGroupRequest(args)
	assert(args, "You must provide an argument table when creating DeletePlacementGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeletePlacementGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointServicePermissionsResult = { ["ReturnValue"] = true, nil }

function asserts.AssertModifyVpcEndpointServicePermissionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointServicePermissionsResult to be of type 'table'")
	if struct["ReturnValue"] then asserts.AssertBoolean(struct["ReturnValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointServicePermissionsResult[k], "ModifyVpcEndpointServicePermissionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointServicePermissionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReturnValue [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return ModifyVpcEndpointServicePermissionsResult structure as a key-value pair table
function M.ModifyVpcEndpointServicePermissionsResult(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointServicePermissionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReturnValue"] = args["ReturnValue"],
	}
	asserts.AssertModifyVpcEndpointServicePermissionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNatGatewayResult = { ["NatGateway"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayResult to be of type 'table'")
	if struct["NatGateway"] then asserts.AssertNatGateway(struct["NatGateway"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNatGatewayResult[k], "CreateNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGateway [NatGateway] <p>Information about the NAT gateway.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.</p>
-- @return CreateNatGatewayResult structure as a key-value pair table
function M.CreateNatGatewayResult(args)
	assert(args, "You must provide an argument table when creating CreateNatGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NatGateway"] = args["NatGateway"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateNatGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateLaunchTemplateVersionRequest = { ["VersionDescription"] = true, ["DryRun"] = true, ["LaunchTemplateId"] = true, ["LaunchTemplateName"] = true, ["SourceVersion"] = true, ["LaunchTemplateData"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateLaunchTemplateVersionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateLaunchTemplateVersionRequest to be of type 'table'")
	assert(struct["LaunchTemplateData"], "Expected key LaunchTemplateData to exist in table")
	if struct["VersionDescription"] then asserts.AssertVersionDescription(struct["VersionDescription"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["SourceVersion"] then asserts.AssertString(struct["SourceVersion"]) end
	if struct["LaunchTemplateData"] then asserts.AssertRequestLaunchTemplateData(struct["LaunchTemplateData"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateLaunchTemplateVersionRequest[k], "CreateLaunchTemplateVersionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateLaunchTemplateVersionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VersionDescription [VersionDescription] <p>A description for the version of the launch template.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template. You must specify either the launch template ID or launch template name in the request.</p>
-- * SourceVersion [String] <p>The version number of the launch template version on which to base the new version. The new version inherits the same launch parameters as the source version, except for parameters that you specify in LaunchTemplateData.</p>
-- * LaunchTemplateData [RequestLaunchTemplateData] <p>The information for the launch template.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: LaunchTemplateData
-- @return CreateLaunchTemplateVersionRequest structure as a key-value pair table
function M.CreateLaunchTemplateVersionRequest(args)
	assert(args, "You must provide an argument table when creating CreateLaunchTemplateVersionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VersionDescription"] = args["VersionDescription"],
		["DryRun"] = args["DryRun"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["SourceVersion"] = args["SourceVersion"],
		["LaunchTemplateData"] = args["LaunchTemplateData"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateLaunchTemplateVersionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateSubnetCidrBlockRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateSubnetCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateSubnetCidrBlockRequest[k], "DisassociateSubnetCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required key: AssociationId
-- @return DisassociateSubnetCidrBlockRequest structure as a key-value pair table
function M.DisassociateSubnetCidrBlockRequest(args)
	assert(args, "You must provide an argument table when creating DisassociateSubnetCidrBlockRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertDisassociateSubnetCidrBlockRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InternetGateway = { ["Tags"] = true, ["Attachments"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InternetGateway to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Attachments"] then asserts.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.InternetGateway[k], "InternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InternetGateway
-- <p>Describes an internet gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tags [TagList] <p>Any tags assigned to the internet gateway.</p>
-- * Attachments [InternetGatewayAttachmentList] <p>Any VPCs attached to the internet gateway.</p>
-- * InternetGatewayId [String] <p>The ID of the internet gateway.</p>
-- @return InternetGateway structure as a key-value pair table
function M.InternetGateway(args)
	assert(args, "You must provide an argument table when creating InternetGateway")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Tags"] = args["Tags"],
		["Attachments"] = args["Attachments"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertInternetGateway(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNetworkInterfacePermissionRequest = { ["NetworkInterfaceId"] = true, ["Permission"] = true, ["DryRun"] = true, ["AwsService"] = true, ["AwsAccountId"] = true, nil }

function asserts.AssertCreateNetworkInterfacePermissionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfacePermissionRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	assert(struct["Permission"], "Expected key Permission to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Permission"] then asserts.AssertInterfacePermissionType(struct["Permission"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AwsService"] then asserts.AssertString(struct["AwsService"]) end
	if struct["AwsAccountId"] then asserts.AssertString(struct["AwsAccountId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfacePermissionRequest[k], "CreateNetworkInterfacePermissionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfacePermissionRequest
-- <p>Contains the parameters for CreateNetworkInterfacePermission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * Permission [InterfacePermissionType] <p>The type of permission to grant.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AwsService [String] <p>The AWS service. Currently not supported.</p>
-- * AwsAccountId [String] <p>The AWS account ID.</p>
-- Required key: NetworkInterfaceId
-- Required key: Permission
-- @return CreateNetworkInterfacePermissionRequest structure as a key-value pair table
function M.CreateNetworkInterfacePermissionRequest(args)
	assert(args, "You must provide an argument table when creating CreateNetworkInterfacePermissionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["Permission"] = args["Permission"],
		["DryRun"] = args["DryRun"],
		["AwsService"] = args["AwsService"],
		["AwsAccountId"] = args["AwsAccountId"],
	}
	asserts.AssertCreateNetworkInterfacePermissionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AccountAttribute = { ["AttributeName"] = true, ["AttributeValues"] = true, nil }

function asserts.AssertAccountAttribute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AccountAttribute to be of type 'table'")
	if struct["AttributeName"] then asserts.AssertString(struct["AttributeName"]) end
	if struct["AttributeValues"] then asserts.AssertAccountAttributeValueList(struct["AttributeValues"]) end
	for k,_ in pairs(struct) do
		assert(keys.AccountAttribute[k], "AccountAttribute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AccountAttribute
-- <p>Describes an account attribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttributeName [String] <p>The name of the account attribute.</p>
-- * AttributeValues [AccountAttributeValueList] <p>One or more values for the account attribute.</p>
-- @return AccountAttribute structure as a key-value pair table
function M.AccountAttribute(args)
	assert(args, "You must provide an argument table when creating AccountAttribute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AttributeName"] = args["AttributeName"],
		["AttributeValues"] = args["AttributeValues"],
	}
	asserts.AssertAccountAttribute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeDhcpOptionsResult = { ["DhcpOptions"] = true, nil }

function asserts.AssertDescribeDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then asserts.AssertDhcpOptionsList(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeDhcpOptionsResult[k], "DescribeDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeDhcpOptionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DhcpOptions [DhcpOptionsList] <p>Information about one or more DHCP options sets.</p>
-- @return DescribeDhcpOptionsResult structure as a key-value pair table
function M.DescribeDhcpOptionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeDhcpOptionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DhcpOptions"] = args["DhcpOptions"],
	}
	asserts.AssertDescribeDhcpOptionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetReservedInstancesExchangeQuoteResult = { ["CurrencyCode"] = true, ["ReservedInstanceValueSet"] = true, ["PaymentDue"] = true, ["TargetConfigurationValueSet"] = true, ["IsValidExchange"] = true, ["ValidationFailureReason"] = true, ["OutputReservedInstancesWillExpireAt"] = true, ["ReservedInstanceValueRollup"] = true, ["TargetConfigurationValueRollup"] = true, nil }

function asserts.AssertGetReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["CurrencyCode"] then asserts.AssertString(struct["CurrencyCode"]) end
	if struct["ReservedInstanceValueSet"] then asserts.AssertReservedInstanceReservationValueSet(struct["ReservedInstanceValueSet"]) end
	if struct["PaymentDue"] then asserts.AssertString(struct["PaymentDue"]) end
	if struct["TargetConfigurationValueSet"] then asserts.AssertTargetReservationValueSet(struct["TargetConfigurationValueSet"]) end
	if struct["IsValidExchange"] then asserts.AssertBoolean(struct["IsValidExchange"]) end
	if struct["ValidationFailureReason"] then asserts.AssertString(struct["ValidationFailureReason"]) end
	if struct["OutputReservedInstancesWillExpireAt"] then asserts.AssertDateTime(struct["OutputReservedInstancesWillExpireAt"]) end
	if struct["ReservedInstanceValueRollup"] then asserts.AssertReservationValue(struct["ReservedInstanceValueRollup"]) end
	if struct["TargetConfigurationValueRollup"] then asserts.AssertReservationValue(struct["TargetConfigurationValueRollup"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetReservedInstancesExchangeQuoteResult[k], "GetReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteResult
-- <p>Contains the output of GetReservedInstancesExchangeQuote.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CurrencyCode [String] <p>The currency of the transaction.</p>
-- * ReservedInstanceValueSet [ReservedInstanceReservationValueSet] <p>The configuration of your Convertible Reserved Instances.</p>
-- * PaymentDue [String] <p>The total true upfront charge for the exchange.</p>
-- * TargetConfigurationValueSet [TargetReservationValueSet] <p>The values of the target Convertible Reserved Instances.</p>
-- * IsValidExchange [Boolean] <p>If <code>true</code>, the exchange is valid. If <code>false</code>, the exchange cannot be completed.</p>
-- * ValidationFailureReason [String] <p>Describes the reason why the exchange cannot be completed.</p>
-- * OutputReservedInstancesWillExpireAt [DateTime] <p>The new end date of the reservation term.</p>
-- * ReservedInstanceValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
-- * TargetConfigurationValueRollup [ReservationValue] <p>The cost associated with the Reserved Instance.</p>
-- @return GetReservedInstancesExchangeQuoteResult structure as a key-value pair table
function M.GetReservedInstancesExchangeQuoteResult(args)
	assert(args, "You must provide an argument table when creating GetReservedInstancesExchangeQuoteResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CurrencyCode"] = args["CurrencyCode"],
		["ReservedInstanceValueSet"] = args["ReservedInstanceValueSet"],
		["PaymentDue"] = args["PaymentDue"],
		["TargetConfigurationValueSet"] = args["TargetConfigurationValueSet"],
		["IsValidExchange"] = args["IsValidExchange"],
		["ValidationFailureReason"] = args["ValidationFailureReason"],
		["OutputReservedInstancesWillExpireAt"] = args["OutputReservedInstancesWillExpireAt"],
		["ReservedInstanceValueRollup"] = args["ReservedInstanceValueRollup"],
		["TargetConfigurationValueRollup"] = args["TargetConfigurationValueRollup"],
	}
	asserts.AssertGetReservedInstancesExchangeQuoteResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteTagsRequest = { ["DryRun"] = true, ["Resources"] = true, ["Tags"] = true, nil }

function asserts.AssertDeleteTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then asserts.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteTagsRequest[k], "DeleteTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteTagsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Resources [ResourceIdList] <p>The IDs of one or more resources, separated by spaces.</p>
-- * Tags [TagList] <p>One or more tags to delete. Specify a tag key and an optional tag value to delete specific tags. If you specify a tag key without a tag value, we delete any tag with this key regardless of its value. If you specify a tag key with an empty string as the tag value, we delete the tag only if its value is an empty string.</p> <p>If you omit this parameter, we delete all user-defined tags for the specified resources. We do not delete AWS-generated tags (tags that have the <code>aws:</code> prefix).</p>
-- Required key: Resources
-- @return DeleteTagsRequest structure as a key-value pair table
function M.DeleteTagsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteTagsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Resources"] = args["Resources"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertDeleteTagsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeBundleTasksRequest = { ["DryRun"] = true, ["Filters"] = true, ["BundleIds"] = true, nil }

function asserts.AssertDescribeBundleTasksRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeBundleTasksRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["BundleIds"] then asserts.AssertBundleIdStringList(struct["BundleIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeBundleTasksRequest[k], "DescribeBundleTasksRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeBundleTasksRequest
-- <p>Contains the parameters for DescribeBundleTasks.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bundle-id</code> - The ID of the bundle task.</p> </li> <li> <p> <code>error-code</code> - If the task failed, the error code returned.</p> </li> <li> <p> <code>error-message</code> - If the task failed, the error message returned.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>progress</code> - The level of task completion, as a percentage (for example, 20%).</p> </li> <li> <p> <code>s3-bucket</code> - The Amazon S3 bucket to store the AMI.</p> </li> <li> <p> <code>s3-prefix</code> - The beginning of the AMI name.</p> </li> <li> <p> <code>start-time</code> - The time the task started (for example, 2013-09-15T17:15:20.000Z).</p> </li> <li> <p> <code>state</code> - The state of the task (<code>pending</code> | <code>waiting-for-shutdown</code> | <code>bundling</code> | <code>storing</code> | <code>cancelling</code> | <code>complete</code> | <code>failed</code>).</p> </li> <li> <p> <code>update-time</code> - The time of the most recent update for the task.</p> </li> </ul>
-- * BundleIds [BundleIdStringList] <p>One or more bundle task IDs.</p> <p>Default: Describes all your bundle tasks.</p>
-- @return DescribeBundleTasksRequest structure as a key-value pair table
function M.DescribeBundleTasksRequest(args)
	assert(args, "You must provide an argument table when creating DescribeBundleTasksRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["BundleIds"] = args["BundleIds"],
	}
	asserts.AssertDescribeBundleTasksRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcAttributeRequest = { ["VpcId"] = true, ["EnableDnsSupport"] = true, ["EnableDnsHostnames"] = true, nil }

function asserts.AssertModifyVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcAttributeRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["EnableDnsSupport"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsSupport"]) end
	if struct["EnableDnsHostnames"] then asserts.AssertAttributeBooleanValue(struct["EnableDnsHostnames"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcAttributeRequest[k], "ModifyVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcAttributeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * EnableDnsSupport [AttributeBooleanValue] <p>Indicates whether the DNS resolution is supported for the VPC. If enabled, queries to the Amazon provided DNS server at the 169.254.169.253 IP address, or the reserved IP address at the base of the VPC network range "plus two" succeed. If disabled, the Amazon provided DNS service in the VPC that resolves public DNS hostnames to IP addresses is not enabled.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute.</p>
-- * EnableDnsHostnames [AttributeBooleanValue] <p>Indicates whether the instances launched in the VPC get DNS hostnames. If enabled, instances in the VPC get DNS hostnames; otherwise, they do not.</p> <p>You cannot modify the DNS resolution and DNS hostnames attributes in the same request. Use separate requests for each attribute. You can only enable DNS hostnames if you've enabled DNS support.</p>
-- Required key: VpcId
-- @return ModifyVpcAttributeRequest structure as a key-value pair table
function M.ModifyVpcAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVpcAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["EnableDnsSupport"] = args["EnableDnsSupport"],
		["EnableDnsHostnames"] = args["EnableDnsHostnames"],
	}
	asserts.AssertModifyVpcAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertScheduledInstancesIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertIpv6Address(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesIpv6Address[k], "ScheduledInstancesIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Address [Ipv6Address] <p>The IPv6 address.</p>
-- @return ScheduledInstancesIpv6Address structure as a key-value pair table
function M.ScheduledInstancesIpv6Address(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesIpv6Address")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6Address"] = args["Ipv6Address"],
	}
	asserts.AssertScheduledInstancesIpv6Address(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesResult = { ["ReservedInstances"] = true, nil }

function asserts.AssertDescribeReservedInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesResult to be of type 'table'")
	if struct["ReservedInstances"] then asserts.AssertReservedInstancesList(struct["ReservedInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesResult[k], "DescribeReservedInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesResult
-- <p>Contains the output for DescribeReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstances [ReservedInstancesList] <p>A list of Reserved Instances.</p>
-- @return DescribeReservedInstancesResult structure as a key-value pair table
function M.DescribeReservedInstancesResult(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstances"] = args["ReservedInstances"],
	}
	asserts.AssertDescribeReservedInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAccountAttributesResult = { ["AccountAttributes"] = true, nil }

function asserts.AssertDescribeAccountAttributesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAccountAttributesResult to be of type 'table'")
	if struct["AccountAttributes"] then asserts.AssertAccountAttributeList(struct["AccountAttributes"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAccountAttributesResult[k], "DescribeAccountAttributesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAccountAttributesResult
-- <p>Contains the output of DescribeAccountAttributes.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AccountAttributes [AccountAttributeList] <p>Information about one or more account attributes.</p>
-- @return DescribeAccountAttributesResult structure as a key-value pair table
function M.DescribeAccountAttributesResult(args)
	assert(args, "You must provide an argument table when creating DescribeAccountAttributesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AccountAttributes"] = args["AccountAttributes"],
	}
	asserts.AssertDescribeAccountAttributesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UserIdGroupPair = { ["VpcId"] = true, ["Description"] = true, ["PeeringStatus"] = true, ["UserId"] = true, ["GroupName"] = true, ["VpcPeeringConnectionId"] = true, ["GroupId"] = true, nil }

function asserts.AssertUserIdGroupPair(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UserIdGroupPair to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["PeeringStatus"] then asserts.AssertString(struct["PeeringStatus"]) end
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UserIdGroupPair[k], "UserIdGroupPair contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UserIdGroupPair
-- <p>Describes a security group and AWS account ID pair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC for the referenced security group, if applicable.</p>
-- * Description [String] <p>A description for the security group rule that references this user ID group pair.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
-- * PeeringStatus [String] <p>The status of a VPC peering connection, if applicable.</p>
-- * UserId [String] <p>The ID of an AWS account.</p> <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p> <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.</p>
-- * GroupName [String] <p>The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID. </p> <p>For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection, if applicable.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return UserIdGroupPair structure as a key-value pair table
function M.UserIdGroupPair(args)
	assert(args, "You must provide an argument table when creating UserIdGroupPair")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["Description"] = args["Description"],
		["PeeringStatus"] = args["PeeringStatus"],
		["UserId"] = args["UserId"],
		["GroupName"] = args["GroupName"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertUserIdGroupPair(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeregisterImageRequest = { ["DryRun"] = true, ["ImageId"] = true, nil }

function asserts.AssertDeregisterImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeregisterImageRequest to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeregisterImageRequest[k], "DeregisterImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeregisterImageRequest
-- <p>Contains the parameters for DeregisterImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- Required key: ImageId
-- @return DeregisterImageRequest structure as a key-value pair table
function M.DeregisterImageRequest(args)
	assert(args, "You must provide an argument table when creating DeregisterImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertDeregisterImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInternetGatewaysResult = { ["InternetGateways"] = true, nil }

function asserts.AssertDescribeInternetGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInternetGatewaysResult to be of type 'table'")
	if struct["InternetGateways"] then asserts.AssertInternetGatewayList(struct["InternetGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInternetGatewaysResult[k], "DescribeInternetGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInternetGatewaysResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InternetGateways [InternetGatewayList] <p>Information about one or more internet gateways.</p>
-- @return DescribeInternetGatewaysResult structure as a key-value pair table
function M.DescribeInternetGatewaysResult(args)
	assert(args, "You must provide an argument table when creating DescribeInternetGatewaysResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InternetGateways"] = args["InternetGateways"],
	}
	asserts.AssertDescribeInternetGatewaysResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSecurityGroupReferencesRequest = { ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertDescribeSecurityGroupReferencesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSecurityGroupReferencesRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertGroupIds(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSecurityGroupReferencesRequest[k], "DescribeSecurityGroupReferencesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSecurityGroupReferencesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupId [GroupIds] <p>One or more security group IDs in your account.</p>
-- Required key: GroupId
-- @return DescribeSecurityGroupReferencesRequest structure as a key-value pair table
function M.DescribeSecurityGroupReferencesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSecurityGroupReferencesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertDescribeSecurityGroupReferencesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportImageRequest = { ["LicenseType"] = true, ["DryRun"] = true, ["Description"] = true, ["ClientData"] = true, ["Hypervisor"] = true, ["DiskContainers"] = true, ["Platform"] = true, ["Architecture"] = true, ["ClientToken"] = true, ["RoleName"] = true, nil }

function asserts.AssertImportImageRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageRequest to be of type 'table'")
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["ClientData"] then asserts.AssertClientData(struct["ClientData"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["DiskContainers"] then asserts.AssertImageDiskContainerList(struct["DiskContainers"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["RoleName"] then asserts.AssertString(struct["RoleName"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageRequest[k], "ImportImageRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageRequest
-- <p>Contains the parameters for ImportImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LicenseType [String] <p>The license type to be used for the Amazon Machine Image (AMI) after importing.</p> <p> <b>Note:</b> You may only use BYOL if you have existing licenses with rights to use these licenses in a third party cloud like AWS. For more information, see <a href="http://docs.aws.amazon.com/vm-import/latest/userguide/vmimport-image-import.html#prerequisites-image">Prerequisites</a> in the VM Import/Export User Guide.</p> <p>Valid values: <code>AWS</code> | <code>BYOL</code> </p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description string for the import image task.</p>
-- * ClientData [ClientData] <p>The client-specific data.</p>
-- * Hypervisor [String] <p>The target hypervisor platform.</p> <p>Valid values: <code>xen</code> </p>
-- * DiskContainers [ImageDiskContainerList] <p>Information about the disk containers.</p>
-- * Platform [String] <p>The operating system of the virtual machine.</p> <p>Valid values: <code>Windows</code> | <code>Linux</code> </p>
-- * Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- * ClientToken [String] <p>The token to enable idempotency for VM import requests.</p>
-- * RoleName [String] <p>The name of the role to use when not using the default role, 'vmimport'.</p>
-- @return ImportImageRequest structure as a key-value pair table
function M.ImportImageRequest(args)
	assert(args, "You must provide an argument table when creating ImportImageRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LicenseType"] = args["LicenseType"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["ClientData"] = args["ClientData"],
		["Hypervisor"] = args["Hypervisor"],
		["DiskContainers"] = args["DiskContainers"],
		["Platform"] = args["Platform"],
		["Architecture"] = args["Architecture"],
		["ClientToken"] = args["ClientToken"],
		["RoleName"] = args["RoleName"],
	}
	asserts.AssertImportImageRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesOfferingsResult = { ["NextToken"] = true, ["ReservedInstancesOfferings"] = true, nil }

function asserts.AssertDescribeReservedInstancesOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesOfferings"] then asserts.AssertReservedInstancesOfferingList(struct["ReservedInstancesOfferings"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesOfferingsResult[k], "DescribeReservedInstancesOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsResult
-- <p>Contains the output of DescribeReservedInstancesOfferings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ReservedInstancesOfferings [ReservedInstancesOfferingList] <p>A list of Reserved Instances offerings.</p>
-- @return DescribeReservedInstancesOfferingsResult structure as a key-value pair table
function M.DescribeReservedInstancesOfferingsResult(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesOfferingsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ReservedInstancesOfferings"] = args["ReservedInstancesOfferings"],
	}
	asserts.AssertDescribeReservedInstancesOfferingsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVolumePermission = { ["UserId"] = true, ["Group"] = true, nil }

function asserts.AssertCreateVolumePermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVolumePermission to be of type 'table'")
	if struct["UserId"] then asserts.AssertString(struct["UserId"]) end
	if struct["Group"] then asserts.AssertPermissionGroup(struct["Group"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVolumePermission[k], "CreateVolumePermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVolumePermission
-- <p>Describes the user or group to be added or removed from the permissions for a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserId [String] <p>The specific AWS account ID that is to be added or removed from a volume's list of create volume permissions.</p>
-- * Group [PermissionGroup] <p>The specific group that is to be added or removed from a volume's list of create volume permissions.</p>
-- @return CreateVolumePermission structure as a key-value pair table
function M.CreateVolumePermission(args)
	assert(args, "You must provide an argument table when creating CreateVolumePermission")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UserId"] = args["UserId"],
		["Group"] = args["Group"],
	}
	asserts.AssertCreateVolumePermission(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesLaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroupIds"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertScheduledInstancesLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesLaunchSpecification to be of type 'table'")
	assert(struct["ImageId"], "Expected key ImageId to exist in table")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertScheduledInstancesMonitoring(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertScheduledInstancesBlockDeviceMappingSet(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroupIds"] then asserts.AssertScheduledInstancesSecurityGroupIdSet(struct["SecurityGroupIds"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertScheduledInstancesPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertScheduledInstancesIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertScheduledInstancesNetworkInterfaceSet(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesLaunchSpecification[k], "ScheduledInstancesLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesLaunchSpecification
-- <p>Describes the launch specification for a Scheduled Instance.</p> <p>If you are launching the Scheduled Instance in EC2-VPC, you must specify the ID of the subnet. You can specify the subnet using either <code>SubnetId</code> or <code>NetworkInterface</code>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserData [String] <p>The base64-encoded MIME user data.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instances.</p>
-- * Monitoring [ScheduledInstancesMonitoring] <p>Enable or disable monitoring for the instances.</p>
-- * ImageId [String] <p>The ID of the Amazon Machine Image (AMI).</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * BlockDeviceMappings [ScheduledInstancesBlockDeviceMappingSet] <p>One or more block device mapping entries.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroupIds [ScheduledInstancesSecurityGroupIdSet] <p>The IDs of one or more security groups.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * Placement [ScheduledInstancesPlacement] <p>The placement information.</p>
-- * IamInstanceProfile [ScheduledInstancesIamInstanceProfile] <p>The IAM instance profile.</p>
-- * InstanceType [String] <p>The instance type.</p>
-- * NetworkInterfaces [ScheduledInstancesNetworkInterfaceSet] <p>One or more network interfaces.</p>
-- Required key: ImageId
-- @return ScheduledInstancesLaunchSpecification structure as a key-value pair table
function M.ScheduledInstancesLaunchSpecification(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesLaunchSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Monitoring"] = args["Monitoring"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["RamdiskId"] = args["RamdiskId"],
		["KernelId"] = args["KernelId"],
		["Placement"] = args["Placement"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertScheduledInstancesLaunchSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceCapacity = { ["AvailableCapacity"] = true, ["InstanceType"] = true, ["TotalCapacity"] = true, nil }

function asserts.AssertInstanceCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceCapacity to be of type 'table'")
	if struct["AvailableCapacity"] then asserts.AssertInteger(struct["AvailableCapacity"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["TotalCapacity"] then asserts.AssertInteger(struct["TotalCapacity"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceCapacity[k], "InstanceCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceCapacity
-- <p>Information about the instance type that the Dedicated Host supports.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailableCapacity [Integer] <p>The number of instances that can still be launched onto the Dedicated Host.</p>
-- * InstanceType [String] <p>The instance type size supported by the Dedicated Host.</p>
-- * TotalCapacity [Integer] <p>The total number of instances that can be launched onto the Dedicated Host.</p>
-- @return InstanceCapacity structure as a key-value pair table
function M.InstanceCapacity(args)
	assert(args, "You must provide an argument table when creating InstanceCapacity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailableCapacity"] = args["AvailableCapacity"],
		["InstanceType"] = args["InstanceType"],
		["TotalCapacity"] = args["TotalCapacity"],
	}
	asserts.AssertInstanceCapacity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstancesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["InstanceIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstancesRequest[k], "DescribeInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstancesRequest
-- <p>Contains the parameters for DescribeInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.</p>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>affinity</code> - The affinity setting for an instance running on a Dedicated Host (<code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>architecture</code> - The instance architecture (<code>i386</code> | <code>x86_64</code>).</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>block-device-mapping.attach-time</code> - The attach time for an EBS volume mapped to the instance, for example, <code>2010-09-15T17:15:20.000Z</code>.</p> </li> <li> <p> <code>block-device-mapping.delete-on-termination</code> - A Boolean that indicates whether the EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>block-device-mapping.device-name</code> - The device name specified in the block device mapping (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p> </li> <li> <p> <code>block-device-mapping.status</code> - The status for the EBS volume (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>block-device-mapping.volume-id</code> - The volume ID of the EBS volume.</p> </li> <li> <p> <code>client-token</code> - The idempotency token you provided when you launched the instance.</p> </li> <li> <p> <code>dns-name</code> - The public DNS name of the instance.</p> </li> <li> <p> <code>group-id</code> - The ID of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>group-name</code> - The name of the security group for the instance. EC2-Classic only.</p> </li> <li> <p> <code>host-id</code> - The ID of the Dedicated Host on which the instance is running, if applicable.</p> </li> <li> <p> <code>hypervisor</code> - The hypervisor type of the instance (<code>ovm</code> | <code>xen</code>).</p> </li> <li> <p> <code>iam-instance-profile.arn</code> - The instance profile associated with the instance. Specified as an ARN.</p> </li> <li> <p> <code>image-id</code> - The ID of the image used to launch the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>instance-lifecycle</code> - Indicates whether this is a Spot Instance or a Scheduled Instance (<code>spot</code> | <code>scheduled</code>).</p> </li> <li> <p> <code>instance-state-code</code> - The state of the instance, as a 16-bit unsigned integer. The high byte is used for internal purposes and should be ignored. The low byte is set based on the state represented. The valid values are: 0 (pending), 16 (running), 32 (shutting-down), 48 (terminated), 64 (stopping), and 80 (stopped).</p> </li> <li> <p> <code>instance-state-name</code> - The state of the instance (<code>pending</code> | <code>running</code> | <code>shutting-down</code> | <code>terminated</code> | <code>stopping</code> | <code>stopped</code>).</p> </li> <li> <p> <code>instance-type</code> - The type of instance (for example, <code>t2.micro</code>).</p> </li> <li> <p> <code>instance.group-id</code> - The ID of the security group for the instance. </p> </li> <li> <p> <code>instance.group-name</code> - The name of the security group for the instance. </p> </li> <li> <p> <code>ip-address</code> - The public IPv4 address of the instance.</p> </li> <li> <p> <code>kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>key-name</code> - The name of the key pair used when the instance was launched.</p> </li> <li> <p> <code>launch-index</code> - When launching multiple instances, this is the index for the instance in the launch group (for example, 0, 1, 2, and so on). </p> </li> <li> <p> <code>launch-time</code> - The time when the instance was launched.</p> </li> <li> <p> <code>monitoring-state</code> - Indicates whether detailed monitoring is enabled (<code>disabled</code> | <code>enabled</code>).</p> </li> <li> <p> <code>network-interface.addresses.private-ip-address</code> - The private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Specifies whether the IPv4 address of the network interface is the primary private IPv4 address.</p> </li> <li> <p> <code>network-interface.addresses.association.public-ip</code> - The ID of the association of an Elastic IP address (IPv4) with a network interface.</p> </li> <li> <p> <code>network-interface.addresses.association.ip-owner-id</code> - The owner ID of the private IPv4 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.public-ip</code> - The address of the Elastic IP address (IPv4) bound to the network interface.</p> </li> <li> <p> <code>network-interface.association.ip-owner-id</code> - The owner of the Elastic IP address (IPv4) associated with the network interface.</p> </li> <li> <p> <code>network-interface.association.allocation-id</code> - The allocation ID returned when you allocated the Elastic IP address (IPv4) for your network interface.</p> </li> <li> <p> <code>network-interface.association.association-id</code> - The association ID returned when the network interface was associated with an IPv4 address.</p> </li> <li> <p> <code>network-interface.attachment.attachment-id</code> - The ID of the interface attachment.</p> </li> <li> <p> <code>network-interface.attachment.instance-id</code> - The ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.instance-owner-id</code> - The owner ID of the instance to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.device-index</code> - The device index to which the network interface is attached.</p> </li> <li> <p> <code>network-interface.attachment.status</code> - The status of the attachment (<code>attaching</code> | <code>attached</code> | <code>detaching</code> | <code>detached</code>).</p> </li> <li> <p> <code>network-interface.attachment.attach-time</code> - The time that the network interface was attached to an instance.</p> </li> <li> <p> <code>network-interface.attachment.delete-on-termination</code> - Specifies whether the attachment is deleted when an instance is terminated.</p> </li> <li> <p> <code>network-interface.availability-zone</code> - The Availability Zone for the network interface.</p> </li> <li> <p> <code>network-interface.description</code> - The description of the network interface.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.group-name</code> - The name of a security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.ipv6-addresses.ipv6-address</code> - The IPv6 address associated with the network interface.</p> </li> <li> <p> <code>network-interface.mac-address</code> - The MAC address of the network interface.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.owner-id</code> - The ID of the owner of the network interface.</p> </li> <li> <p> <code>network-interface.private-dns-name</code> - The private DNS name of the network interface.</p> </li> <li> <p> <code>network-interface.requester-id</code> - The requester ID for the network interface.</p> </li> <li> <p> <code>network-interface.requester-managed</code> - Indicates whether the network interface is being managed by AWS.</p> </li> <li> <p> <code>network-interface.status</code> - The status of the network interface (<code>available</code>) | <code>in-use</code>).</p> </li> <li> <p> <code>network-interface.source-dest-check</code> - Whether the network interface performs source/destination checking. A value of <code>true</code> means that checking is enabled, and <code>false</code> means that checking is disabled. The value must be <code>false</code> for the network interface to perform network address translation (NAT) in your VPC.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the network interface.</p> </li> <li> <p> <code>network-interface.vpc-id</code> - The ID of the VPC for the network interface.</p> </li> <li> <p> <code>owner-id</code> - The AWS account ID of the instance owner.</p> </li> <li> <p> <code>placement-group-name</code> - The name of the placement group for the instance.</p> </li> <li> <p> <code>platform</code> - The platform. Use <code>windows</code> if you have Windows instances; otherwise, leave blank.</p> </li> <li> <p> <code>private-dns-name</code> - The private IPv4 DNS name of the instance.</p> </li> <li> <p> <code>private-ip-address</code> - The private IPv4 address of the instance.</p> </li> <li> <p> <code>product-code</code> - The product code associated with the AMI used to launch the instance.</p> </li> <li> <p> <code>product-code.type</code> - The type of product code (<code>devpay</code> | <code>marketplace</code>).</p> </li> <li> <p> <code>ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>reason</code> - The reason for the current state of the instance (for example, shows "User Initiated [date]" when you stop or terminate the instance). Similar to the state-reason-code filter.</p> </li> <li> <p> <code>requester-id</code> - The ID of the entity that launched the instance on your behalf (for example, AWS Management Console, Auto Scaling, and so on).</p> </li> <li> <p> <code>reservation-id</code> - The ID of the instance's reservation. A reservation ID is created any time you launch an instance. A reservation ID has a one-to-one relationship with an instance launch request, but can be associated with more than one instance if you launch multiple instances using the same launch request. For example, if you launch one instance, you get one reservation ID. If you launch ten instances using the same launch request, you also get one reservation ID.</p> </li> <li> <p> <code>root-device-name</code> - The device name of the root device volume (for example, <code>/dev/sda1</code>).</p> </li> <li> <p> <code>root-device-type</code> - The type of the root device volume (<code>ebs</code> | <code>instance-store</code>).</p> </li> <li> <p> <code>source-dest-check</code> - Indicates whether the instance performs source/destination checking. A value of <code>true</code> means that checking is enabled, and <code>false</code> means that checking is disabled. The value must be <code>false</code> for the instance to perform network address translation (NAT) in your VPC. </p> </li> <li> <p> <code>spot-instance-request-id</code> - The ID of the Spot Instance request.</p> </li> <li> <p> <code>state-reason-code</code> - The reason code for the state change.</p> </li> <li> <p> <code>state-reason-message</code> - A message that describes the state change.</p> </li> <li> <p> <code>subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources that have a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>tenancy</code> - The tenancy of an instance (<code>dedicated</code> | <code>default</code> | <code>host</code>).</p> </li> <li> <p> <code>virtualization-type</code> - The virtualization type of the instance (<code>paravirtual</code> | <code>hvm</code>).</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC that the instance is running in.</p> </li> </ul>
-- @return DescribeInstancesRequest structure as a key-value pair table
function M.DescribeInstancesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CapacityReservationSpecification = { ["CapacityReservationTarget"] = true, ["CapacityReservationPreference"] = true, nil }

function asserts.AssertCapacityReservationSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CapacityReservationSpecification to be of type 'table'")
	if struct["CapacityReservationTarget"] then asserts.AssertCapacityReservationTarget(struct["CapacityReservationTarget"]) end
	if struct["CapacityReservationPreference"] then asserts.AssertCapacityReservationPreference(struct["CapacityReservationPreference"]) end
	for k,_ in pairs(struct) do
		assert(keys.CapacityReservationSpecification[k], "CapacityReservationSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CapacityReservationSpecification
-- <p>Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the <code>CapacityReservationPreference</code> parameter to configure the instance to run as an On-Demand Instance or to run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the <code>CapacityReservationTarget</code> parameter to explicitly target a specific Capacity Reservation.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationTarget [CapacityReservationTarget] <p>Information about the target Capacity Reservation.</p>
-- * CapacityReservationPreference [CapacityReservationPreference] <p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs as an On-Demand Instance.</p> </li> </ul>
-- @return CapacityReservationSpecification structure as a key-value pair table
function M.CapacityReservationSpecification(args)
	assert(args, "You must provide an argument table when creating CapacityReservationSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationTarget"] = args["CapacityReservationTarget"],
		["CapacityReservationPreference"] = args["CapacityReservationPreference"],
	}
	asserts.AssertCapacityReservationSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstancesModificationResult = { ["ReservedInstancesId"] = true, ["TargetConfiguration"] = true, nil }

function asserts.AssertReservedInstancesModificationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesModificationResult to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["TargetConfiguration"] then asserts.AssertReservedInstancesConfiguration(struct["TargetConfiguration"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesModificationResult[k], "ReservedInstancesModificationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesModificationResult
-- <p>Describes the modification request/s.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.</p>
-- * TargetConfiguration [ReservedInstancesConfiguration] <p>The target Reserved Instances configurations supplied as part of the modification request.</p>
-- @return ReservedInstancesModificationResult structure as a key-value pair table
function M.ReservedInstancesModificationResult(args)
	assert(args, "You must provide an argument table when creating ReservedInstancesModificationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["TargetConfiguration"] = args["TargetConfiguration"],
	}
	asserts.AssertReservedInstancesModificationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateRouteTableRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertCreateRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteTableRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteTableRequest[k], "CreateRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteTableRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return CreateRouteTableRequest structure as a key-value pair table
function M.CreateRouteTableRequest(args)
	assert(args, "You must provide an argument table when creating CreateRouteTableRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateRouteTableRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotDatafeedSubscriptionResult = { ["SpotDatafeedSubscription"] = true, nil }

function asserts.AssertDescribeSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then asserts.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotDatafeedSubscriptionResult[k], "DescribeSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotDatafeedSubscriptionResult
-- <p>Contains the output of DescribeSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot Instance data feed subscription.</p>
-- @return DescribeSpotDatafeedSubscriptionResult structure as a key-value pair table
function M.DescribeSpotDatafeedSubscriptionResult(args)
	assert(args, "You must provide an argument table when creating DescribeSpotDatafeedSubscriptionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotDatafeedSubscription"] = args["SpotDatafeedSubscription"],
	}
	asserts.AssertDescribeSpotDatafeedSubscriptionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AdvertiseByoipCidrRequest = { ["Cidr"] = true, ["DryRun"] = true, nil }

function asserts.AssertAdvertiseByoipCidrRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AdvertiseByoipCidrRequest to be of type 'table'")
	assert(struct["Cidr"], "Expected key Cidr to exist in table")
	if struct["Cidr"] then asserts.AssertString(struct["Cidr"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AdvertiseByoipCidrRequest[k], "AdvertiseByoipCidrRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AdvertiseByoipCidrRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cidr [String] <p>The IPv4 address range, in CIDR notation.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Cidr
-- @return AdvertiseByoipCidrRequest structure as a key-value pair table
function M.AdvertiseByoipCidrRequest(args)
	assert(args, "You must provide an argument table when creating AdvertiseByoipCidrRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Cidr"] = args["Cidr"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertAdvertiseByoipCidrRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCustomerGatewaysRequest = { ["CustomerGatewayIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeCustomerGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysRequest to be of type 'table'")
	if struct["CustomerGatewayIds"] then asserts.AssertCustomerGatewayIdStringList(struct["CustomerGatewayIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCustomerGatewaysRequest[k], "DescribeCustomerGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysRequest
-- <p>Contains the parameters for DescribeCustomerGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGatewayIds [CustomerGatewayIdStringList] <p>One or more customer gateway IDs.</p> <p>Default: Describes all your customer gateways.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>bgp-asn</code> - The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p> </li> <li> <p> <code>customer-gateway-id</code> - The ID of the customer gateway.</p> </li> <li> <p> <code>ip-address</code> - The IP address of the customer gateway's Internet-routable external interface.</p> </li> <li> <p> <code>state</code> - The state of the customer gateway (<code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code>).</p> </li> <li> <p> <code>type</code> - The type of customer gateway. Currently, the only supported type is <code>ipsec.1</code>.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> </ul>
-- @return DescribeCustomerGatewaysRequest structure as a key-value pair table
function M.DescribeCustomerGatewaysRequest(args)
	assert(args, "You must provide an argument table when creating DescribeCustomerGatewaysRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CustomerGatewayIds"] = args["CustomerGatewayIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeCustomerGatewaysRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelledSpotInstanceRequest = { ["State"] = true, ["SpotInstanceRequestId"] = true, nil }

function asserts.AssertCancelledSpotInstanceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelledSpotInstanceRequest to be of type 'table'")
	if struct["State"] then asserts.AssertCancelSpotInstanceRequestState(struct["State"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelledSpotInstanceRequest[k], "CancelledSpotInstanceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelledSpotInstanceRequest
-- <p>Describes a request to cancel a Spot Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [CancelSpotInstanceRequestState] <p>The state of the Spot Instance request.</p>
-- * SpotInstanceRequestId [String] <p>The ID of the Spot Instance request.</p>
-- @return CancelledSpotInstanceRequest structure as a key-value pair table
function M.CancelledSpotInstanceRequest(args)
	assert(args, "You must provide an argument table when creating CancelledSpotInstanceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
	}
	asserts.AssertCancelledSpotInstanceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeprovisionByoipCidrRequest = { ["Cidr"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeprovisionByoipCidrRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeprovisionByoipCidrRequest to be of type 'table'")
	assert(struct["Cidr"], "Expected key Cidr to exist in table")
	if struct["Cidr"] then asserts.AssertString(struct["Cidr"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeprovisionByoipCidrRequest[k], "DeprovisionByoipCidrRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeprovisionByoipCidrRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cidr [String] <p>The public IPv4 address range, in CIDR notation. The prefix must be the same prefix that you specified when you provisioned the address range.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Cidr
-- @return DeprovisionByoipCidrRequest structure as a key-value pair table
function M.DeprovisionByoipCidrRequest(args)
	assert(args, "You must provide an argument table when creating DeprovisionByoipCidrRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Cidr"] = args["Cidr"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeprovisionByoipCidrRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstanceAvailability = { ["AvailabilityZone"] = true, ["TotalScheduledInstanceHours"] = true, ["HourlyPrice"] = true, ["MinTermDurationInDays"] = true, ["AvailableInstanceCount"] = true, ["SlotDurationInHours"] = true, ["Recurrence"] = true, ["MaxTermDurationInDays"] = true, ["FirstSlotStartTime"] = true, ["Platform"] = true, ["NetworkPlatform"] = true, ["InstanceType"] = true, ["PurchaseToken"] = true, nil }

function asserts.AssertScheduledInstanceAvailability(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstanceAvailability to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["TotalScheduledInstanceHours"] then asserts.AssertInteger(struct["TotalScheduledInstanceHours"]) end
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["MinTermDurationInDays"] then asserts.AssertInteger(struct["MinTermDurationInDays"]) end
	if struct["AvailableInstanceCount"] then asserts.AssertInteger(struct["AvailableInstanceCount"]) end
	if struct["SlotDurationInHours"] then asserts.AssertInteger(struct["SlotDurationInHours"]) end
	if struct["Recurrence"] then asserts.AssertScheduledInstanceRecurrence(struct["Recurrence"]) end
	if struct["MaxTermDurationInDays"] then asserts.AssertInteger(struct["MaxTermDurationInDays"]) end
	if struct["FirstSlotStartTime"] then asserts.AssertDateTime(struct["FirstSlotStartTime"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["NetworkPlatform"] then asserts.AssertString(struct["NetworkPlatform"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["PurchaseToken"] then asserts.AssertString(struct["PurchaseToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstanceAvailability[k], "ScheduledInstanceAvailability contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstanceAvailability
-- <p>Describes a schedule that is available for your Scheduled Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * TotalScheduledInstanceHours [Integer] <p>The total number of hours for a single instance for the entire term.</p>
-- * HourlyPrice [String] <p>The hourly price for a single instance.</p>
-- * MinTermDurationInDays [Integer] <p>The minimum term. The only possible value is 365 days.</p>
-- * AvailableInstanceCount [Integer] <p>The number of available instances.</p>
-- * SlotDurationInHours [Integer] <p>The number of hours in the schedule.</p>
-- * Recurrence [ScheduledInstanceRecurrence] <p>The schedule recurrence.</p>
-- * MaxTermDurationInDays [Integer] <p>The maximum term. The only possible value is 365 days.</p>
-- * FirstSlotStartTime [DateTime] <p>The time period for the first schedule to start.</p>
-- * Platform [String] <p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>
-- * NetworkPlatform [String] <p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>
-- * InstanceType [String] <p>The instance type. You can specify one of the C3, C4, M4, or R3 instance types.</p>
-- * PurchaseToken [String] <p>The purchase token. This token expires in two hours.</p>
-- @return ScheduledInstanceAvailability structure as a key-value pair table
function M.ScheduledInstanceAvailability(args)
	assert(args, "You must provide an argument table when creating ScheduledInstanceAvailability")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["TotalScheduledInstanceHours"] = args["TotalScheduledInstanceHours"],
		["HourlyPrice"] = args["HourlyPrice"],
		["MinTermDurationInDays"] = args["MinTermDurationInDays"],
		["AvailableInstanceCount"] = args["AvailableInstanceCount"],
		["SlotDurationInHours"] = args["SlotDurationInHours"],
		["Recurrence"] = args["Recurrence"],
		["MaxTermDurationInDays"] = args["MaxTermDurationInDays"],
		["FirstSlotStartTime"] = args["FirstSlotStartTime"],
		["Platform"] = args["Platform"],
		["NetworkPlatform"] = args["NetworkPlatform"],
		["InstanceType"] = args["InstanceType"],
		["PurchaseToken"] = args["PurchaseToken"],
	}
	asserts.AssertScheduledInstanceAvailability(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFleetsResult = { ["Fleets"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeFleetsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFleetsResult to be of type 'table'")
	if struct["Fleets"] then asserts.AssertFleetSet(struct["Fleets"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFleetsResult[k], "DescribeFleetsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFleetsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Fleets [FleetSet] <p>Information about the EC2 Fleets.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- @return DescribeFleetsResult structure as a key-value pair table
function M.DescribeFleetsResult(args)
	assert(args, "You must provide an argument table when creating DescribeFleetsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Fleets"] = args["Fleets"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeFleetsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSnapshotsResult = { ["NextToken"] = true, ["Snapshots"] = true, nil }

function asserts.AssertDescribeSnapshotsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["Snapshots"] then asserts.AssertSnapshotList(struct["Snapshots"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotsResult[k], "DescribeSnapshotsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotsResult
-- <p>Contains the output of DescribeSnapshots.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeSnapshots</code> request. When the results of a <code>DescribeSnapshots</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * Snapshots [SnapshotList] <p>Information about the snapshots.</p>
-- @return DescribeSnapshotsResult structure as a key-value pair table
function M.DescribeSnapshotsResult(args)
	assert(args, "You must provide an argument table when creating DescribeSnapshotsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["Snapshots"] = args["Snapshots"],
	}
	asserts.AssertDescribeSnapshotsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GroupIdentifier = { ["GroupName"] = true, ["GroupId"] = true, nil }

function asserts.AssertGroupIdentifier(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GroupIdentifier to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GroupIdentifier[k], "GroupIdentifier contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GroupIdentifier
-- <p>Describes a security group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the security group.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- @return GroupIdentifier structure as a key-value pair table
function M.GroupIdentifier(args)
	assert(args, "You must provide an argument table when creating GroupIdentifier")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertGroupIdentifier(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteInternetGatewayRequest = { ["DryRun"] = true, ["InternetGatewayId"] = true, nil }

function asserts.AssertDeleteInternetGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteInternetGatewayRequest to be of type 'table'")
	assert(struct["InternetGatewayId"], "Expected key InternetGatewayId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InternetGatewayId"] then asserts.AssertString(struct["InternetGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteInternetGatewayRequest[k], "DeleteInternetGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteInternetGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InternetGatewayId [String] <p>The ID of the internet gateway.</p>
-- Required key: InternetGatewayId
-- @return DeleteInternetGatewayRequest structure as a key-value pair table
function M.DeleteInternetGatewayRequest(args)
	assert(args, "You must provide an argument table when creating DeleteInternetGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["InternetGatewayId"] = args["InternetGatewayId"],
	}
	asserts.AssertDeleteInternetGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnmonitorInstancesResult = { ["InstanceMonitorings"] = true, nil }

function asserts.AssertUnmonitorInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnmonitorInstancesResult to be of type 'table'")
	if struct["InstanceMonitorings"] then asserts.AssertInstanceMonitoringList(struct["InstanceMonitorings"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnmonitorInstancesResult[k], "UnmonitorInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnmonitorInstancesResult
-- <p>Contains the output of UnmonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceMonitorings [InstanceMonitoringList] <p>The monitoring information.</p>
-- @return UnmonitorInstancesResult structure as a key-value pair table
function M.UnmonitorInstancesResult(args)
	assert(args, "You must provide an argument table when creating UnmonitorInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceMonitorings"] = args["InstanceMonitorings"],
	}
	asserts.AssertUnmonitorInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateInstanceNetworkInterfaceSpecificationRequest = { ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateInstanceNetworkInterfaceSpecificationRequest to be of type 'table'")
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressListRequest(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateInstanceNetworkInterfaceSpecificationRequest[k], "LaunchTemplateInstanceNetworkInterfaceSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateInstanceNetworkInterfaceSpecificationRequest
-- <p>The parameters for a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceIndex [Integer] <p>The device index for the network interface attachment.</p>
-- * Description [String] <p>A description for the network interface.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>
-- * PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses.</p>
-- * SubnetId [String] <p>The ID of the subnet for the network interface.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * PrivateIpAddress [String] <p>The primary private IPv4 address of the network interface.</p>
-- * Groups [SecurityGroupIdStringList] <p>The IDs of one or more security groups.</p>
-- * Ipv6Addresses [InstanceIpv6AddressListRequest] <p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociatePublicIpAddress [Boolean] <p>Associates a public IPv4 address with eth0 for a new network interface.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses to assign to a network interface.</p>
-- @return LaunchTemplateInstanceNetworkInterfaceSpecificationRequest structure as a key-value pair table
function M.LaunchTemplateInstanceNetworkInterfaceSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateInstanceNetworkInterfaceSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceIndex"] = args["DeviceIndex"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["SubnetId"] = args["SubnetId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociatePublicIpAddress"] = args["AssociatePublicIpAddress"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
	}
	asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StaleIpPermission = { ["PrefixListIds"] = true, ["FromPort"] = true, ["IpRanges"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["UserIdGroupPairs"] = true, nil }

function asserts.AssertStaleIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StaleIpPermission to be of type 'table'")
	if struct["PrefixListIds"] then asserts.AssertPrefixListIdSet(struct["PrefixListIds"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then asserts.AssertIpRanges(struct["IpRanges"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then asserts.AssertUserIdGroupPairSet(struct["UserIdGroupPairs"]) end
	for k,_ in pairs(struct) do
		assert(keys.StaleIpPermission[k], "StaleIpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StaleIpPermission
-- <p>Describes a stale rule in a security group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrefixListIds [PrefixListIdSet] <p>One or more prefix list IDs for an AWS service. Not applicable for stale security group rules.</p>
-- * FromPort [Integer] <p>The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- * IpRanges [IpRanges] <p>One or more IP ranges. Not applicable for stale security group rules.</p>
-- * ToPort [Integer] <p>The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>
-- * IpProtocol [String] <p>The IP protocol name (for <code>tcp</code>, <code>udp</code>, and <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers)</a>.</p>
-- * UserIdGroupPairs [UserIdGroupPairSet] <p>One or more security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.</p>
-- @return StaleIpPermission structure as a key-value pair table
function M.StaleIpPermission(args)
	assert(args, "You must provide an argument table when creating StaleIpPermission")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrefixListIds"] = args["PrefixListIds"],
		["FromPort"] = args["FromPort"],
		["IpRanges"] = args["IpRanges"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["UserIdGroupPairs"] = args["UserIdGroupPairs"],
	}
	asserts.AssertStaleIpPermission(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnsuccessfulInstanceCreditSpecificationItem = { ["InstanceId"] = true, ["Error"] = true, nil }

function asserts.AssertUnsuccessfulInstanceCreditSpecificationItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnsuccessfulInstanceCreditSpecificationItem to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Error"] then asserts.AssertUnsuccessfulInstanceCreditSpecificationItemError(struct["Error"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnsuccessfulInstanceCreditSpecificationItem[k], "UnsuccessfulInstanceCreditSpecificationItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnsuccessfulInstanceCreditSpecificationItem
-- <p>Describes the T2 or T3 instance whose credit option for CPU usage was not modified.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Error [UnsuccessfulInstanceCreditSpecificationItemError] <p>The applicable error for the T2 or T3 instance whose credit option for CPU usage was not modified.</p>
-- @return UnsuccessfulInstanceCreditSpecificationItem structure as a key-value pair table
function M.UnsuccessfulInstanceCreditSpecificationItem(args)
	assert(args, "You must provide an argument table when creating UnsuccessfulInstanceCreditSpecificationItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Error"] = args["Error"],
	}
	asserts.AssertUnsuccessfulInstanceCreditSpecificationItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FleetLaunchTemplateSpecificationRequest = { ["LaunchTemplateName"] = true, ["Version"] = true, ["LaunchTemplateId"] = true, nil }

function asserts.AssertFleetLaunchTemplateSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FleetLaunchTemplateSpecificationRequest to be of type 'table'")
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["Version"] then asserts.AssertString(struct["Version"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.FleetLaunchTemplateSpecificationRequest[k], "FleetLaunchTemplateSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FleetLaunchTemplateSpecificationRequest
-- <p>The launch template to use. You must specify either the launch template ID or launch template name in the request. </p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template.</p>
-- * Version [String] <p>The version number of the launch template. </p>
-- * LaunchTemplateId [String] <p>The ID of the launch template.</p>
-- @return FleetLaunchTemplateSpecificationRequest structure as a key-value pair table
function M.FleetLaunchTemplateSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating FleetLaunchTemplateSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["Version"] = args["Version"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
	}
	asserts.AssertFleetLaunchTemplateSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AdvertiseByoipCidrResult = { ["ByoipCidr"] = true, nil }

function asserts.AssertAdvertiseByoipCidrResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AdvertiseByoipCidrResult to be of type 'table'")
	if struct["ByoipCidr"] then asserts.AssertByoipCidr(struct["ByoipCidr"]) end
	for k,_ in pairs(struct) do
		assert(keys.AdvertiseByoipCidrResult[k], "AdvertiseByoipCidrResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AdvertiseByoipCidrResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ByoipCidr [ByoipCidr] <p>Information about the address range.</p>
-- @return AdvertiseByoipCidrResult structure as a key-value pair table
function M.AdvertiseByoipCidrResult(args)
	assert(args, "You must provide an argument table when creating AdvertiseByoipCidrResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ByoipCidr"] = args["ByoipCidr"],
	}
	asserts.AssertAdvertiseByoipCidrResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelSpotFleetRequestsResponse = { ["SuccessfulFleetRequests"] = true, ["UnsuccessfulFleetRequests"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsResponse(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsResponse to be of type 'table'")
	if struct["SuccessfulFleetRequests"] then asserts.AssertCancelSpotFleetRequestsSuccessSet(struct["SuccessfulFleetRequests"]) end
	if struct["UnsuccessfulFleetRequests"] then asserts.AssertCancelSpotFleetRequestsErrorSet(struct["UnsuccessfulFleetRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsResponse[k], "CancelSpotFleetRequestsResponse contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsResponse
-- <p>Contains the output of CancelSpotFleetRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SuccessfulFleetRequests [CancelSpotFleetRequestsSuccessSet] <p>Information about the Spot Fleet requests that are successfully canceled.</p>
-- * UnsuccessfulFleetRequests [CancelSpotFleetRequestsErrorSet] <p>Information about the Spot Fleet requests that are not successfully canceled.</p>
-- @return CancelSpotFleetRequestsResponse structure as a key-value pair table
function M.CancelSpotFleetRequestsResponse(args)
	assert(args, "You must provide an argument table when creating CancelSpotFleetRequestsResponse")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SuccessfulFleetRequests"] = args["SuccessfulFleetRequests"],
		["UnsuccessfulFleetRequests"] = args["UnsuccessfulFleetRequests"],
	}
	asserts.AssertCancelSpotFleetRequestsResponse(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PlacementGroup = { ["GroupName"] = true, ["State"] = true, ["Strategy"] = true, nil }

function asserts.AssertPlacementGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PlacementGroup to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["State"] then asserts.AssertPlacementGroupState(struct["State"]) end
	if struct["Strategy"] then asserts.AssertPlacementStrategy(struct["Strategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.PlacementGroup[k], "PlacementGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PlacementGroup
-- <p>Describes a placement group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>The name of the placement group.</p>
-- * State [PlacementGroupState] <p>The state of the placement group.</p>
-- * Strategy [PlacementStrategy] <p>The placement strategy.</p>
-- @return PlacementGroup structure as a key-value pair table
function M.PlacementGroup(args)
	assert(args, "You must provide an argument table when creating PlacementGroup")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["State"] = args["State"],
		["Strategy"] = args["Strategy"],
	}
	asserts.AssertPlacementGroup(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Purchase = { ["HourlyPrice"] = true, ["InstanceFamily"] = true, ["CurrencyCode"] = true, ["PaymentOption"] = true, ["HostIdSet"] = true, ["HostReservationId"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertPurchase(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Purchase to be of type 'table'")
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["HostIdSet"] then asserts.AssertResponseHostIdSet(struct["HostIdSet"]) end
	if struct["HostReservationId"] then asserts.AssertString(struct["HostReservationId"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.Purchase[k], "Purchase contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Purchase
-- <p>Describes the result of the purchase.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HourlyPrice [String] <p>The hourly price of the reservation per hour.</p>
-- * InstanceFamily [String] <p>The instance family on the Dedicated Host that the reservation can be associated with.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>UpfrontPrice</code> and <code>HourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * PaymentOption [PaymentOption] <p>The payment option for the reservation.</p>
-- * HostIdSet [ResponseHostIdSet] <p>The IDs of the Dedicated Hosts associated with the reservation.</p>
-- * HostReservationId [String] <p>The ID of the reservation.</p>
-- * UpfrontPrice [String] <p>The upfront price of the reservation.</p>
-- * Duration [Integer] <p>The duration of the reservation's term in seconds.</p>
-- @return Purchase structure as a key-value pair table
function M.Purchase(args)
	assert(args, "You must provide an argument table when creating Purchase")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HourlyPrice"] = args["HourlyPrice"],
		["InstanceFamily"] = args["InstanceFamily"],
		["CurrencyCode"] = args["CurrencyCode"],
		["PaymentOption"] = args["PaymentOption"],
		["HostIdSet"] = args["HostIdSet"],
		["HostReservationId"] = args["HostReservationId"],
		["UpfrontPrice"] = args["UpfrontPrice"],
		["Duration"] = args["Duration"],
	}
	asserts.AssertPurchase(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateIamInstanceProfileRequest = { ["InstanceId"] = true, ["IamInstanceProfile"] = true, nil }

function asserts.AssertAssociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["IamInstanceProfile"], "Expected key IamInstanceProfile to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateIamInstanceProfileRequest[k], "AssociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- Required key: IamInstanceProfile
-- Required key: InstanceId
-- @return AssociateIamInstanceProfileRequest structure as a key-value pair table
function M.AssociateIamInstanceProfileRequest(args)
	assert(args, "You must provide an argument table when creating AssociateIamInstanceProfileRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
	}
	asserts.AssertAssociateIamInstanceProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNatGatewayRequest = { ["SubnetId"] = true, ["AllocationId"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateNatGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNatGatewayRequest to be of type 'table'")
	assert(struct["AllocationId"], "Expected key AllocationId to exist in table")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNatGatewayRequest[k], "CreateNatGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNatGatewayRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The subnet in which to create the NAT gateway.</p>
-- * AllocationId [String] <p>The allocation ID of an Elastic IP address to associate with the NAT gateway. If the Elastic IP address is associated with another resource, you must first disassociate it.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p> <p>Constraint: Maximum 64 ASCII characters.</p>
-- Required key: AllocationId
-- Required key: SubnetId
-- @return CreateNatGatewayRequest structure as a key-value pair table
function M.CreateNatGatewayRequest(args)
	assert(args, "You must provide an argument table when creating CreateNatGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["AllocationId"] = args["AllocationId"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateNatGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateSecurityGroupRuleDescriptionsEgressResult = { ["Return"] = true, nil }

function asserts.AssertUpdateSecurityGroupRuleDescriptionsEgressResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateSecurityGroupRuleDescriptionsEgressResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateSecurityGroupRuleDescriptionsEgressResult[k], "UpdateSecurityGroupRuleDescriptionsEgressResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateSecurityGroupRuleDescriptionsEgressResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, returns an error.</p>
-- @return UpdateSecurityGroupRuleDescriptionsEgressResult structure as a key-value pair table
function M.UpdateSecurityGroupRuleDescriptionsEgressResult(args)
	assert(args, "You must provide an argument table when creating UpdateSecurityGroupRuleDescriptionsEgressResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertUpdateSecurityGroupRuleDescriptionsEgressResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PricingDetail = { ["Count"] = true, ["Price"] = true, nil }

function asserts.AssertPricingDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PricingDetail to be of type 'table'")
	if struct["Count"] then asserts.AssertInteger(struct["Count"]) end
	if struct["Price"] then asserts.AssertDouble(struct["Price"]) end
	for k,_ in pairs(struct) do
		assert(keys.PricingDetail[k], "PricingDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PricingDetail
-- <p>Describes a Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Count [Integer] <p>The number of reservations available for the price.</p>
-- * Price [Double] <p>The price per instance.</p>
-- @return PricingDetail structure as a key-value pair table
function M.PricingDetail(args)
	assert(args, "You must provide an argument table when creating PricingDetail")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Count"] = args["Count"],
		["Price"] = args["Price"],
	}
	asserts.AssertPricingDetail(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeByoipCidrsResult = { ["ByoipCidrs"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeByoipCidrsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeByoipCidrsResult to be of type 'table'")
	if struct["ByoipCidrs"] then asserts.AssertByoipCidrSet(struct["ByoipCidrs"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeByoipCidrsResult[k], "DescribeByoipCidrsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeByoipCidrsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ByoipCidrs [ByoipCidrSet] <p>Information about your address ranges.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeByoipCidrsResult structure as a key-value pair table
function M.DescribeByoipCidrsResult(args)
	assert(args, "You must provide an argument table when creating DescribeByoipCidrsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ByoipCidrs"] = args["ByoipCidrs"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeByoipCidrsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EnableVpcClassicLinkResult = { ["Return"] = true, nil }

function asserts.AssertEnableVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkResult[k], "EnableVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return EnableVpcClassicLinkResult structure as a key-value pair table
function M.EnableVpcClassicLinkResult(args)
	assert(args, "You must provide an argument table when creating EnableVpcClassicLinkResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertEnableVpcClassicLinkResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesPrivateIpAddressConfig = { ["Primary"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertScheduledInstancesPrivateIpAddressConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesPrivateIpAddressConfig to be of type 'table'")
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesPrivateIpAddressConfig[k], "ScheduledInstancesPrivateIpAddressConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesPrivateIpAddressConfig
-- <p>Describes a private IPv4 address for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Primary [Boolean] <p>Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.</p>
-- * PrivateIpAddress [String] <p>The IPv4 address.</p>
-- @return ScheduledInstancesPrivateIpAddressConfig structure as a key-value pair table
function M.ScheduledInstancesPrivateIpAddressConfig(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesPrivateIpAddressConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Primary"] = args["Primary"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertScheduledInstancesPrivateIpAddressConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotPlacement = { ["Tenancy"] = true, ["GroupName"] = true, ["AvailabilityZone"] = true, nil }

function asserts.AssertSpotPlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPlacement to be of type 'table'")
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotPlacement[k], "SpotPlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPlacement
-- <p>Describes Spot Instance placement.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for Spot Instances.</p>
-- * GroupName [String] <p>The name of the placement group.</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p> <p>[Spot Fleet only] To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".</p>
-- @return SpotPlacement structure as a key-value pair table
function M.SpotPlacement(args)
	assert(args, "You must provide an argument table when creating SpotPlacement")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Tenancy"] = args["Tenancy"],
		["GroupName"] = args["GroupName"],
		["AvailabilityZone"] = args["AvailabilityZone"],
	}
	asserts.AssertSpotPlacement(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TargetGroupsConfig = { ["TargetGroups"] = true, nil }

function asserts.AssertTargetGroupsConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetGroupsConfig to be of type 'table'")
	assert(struct["TargetGroups"], "Expected key TargetGroups to exist in table")
	if struct["TargetGroups"] then asserts.AssertTargetGroups(struct["TargetGroups"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetGroupsConfig[k], "TargetGroupsConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetGroupsConfig
-- <p>Describes the target groups to attach to a Spot Fleet. Spot Fleet registers the running Spot Instances with these target groups.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetGroups [TargetGroups] <p>One or more target groups.</p>
-- Required key: TargetGroups
-- @return TargetGroupsConfig structure as a key-value pair table
function M.TargetGroupsConfig(args)
	assert(args, "You must provide an argument table when creating TargetGroupsConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TargetGroups"] = args["TargetGroups"],
	}
	asserts.AssertTargetGroupsConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelCapacityReservationResult = { ["Return"] = true, nil }

function asserts.AssertCancelCapacityReservationResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelCapacityReservationResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelCapacityReservationResult[k], "CancelCapacityReservationResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelCapacityReservationResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return CancelCapacityReservationResult structure as a key-value pair table
function M.CancelCapacityReservationResult(args)
	assert(args, "You must provide an argument table when creating CancelCapacityReservationResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertCancelCapacityReservationResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcEndpointsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteVpcEndpointsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointsResult[k], "DeleteVpcEndpointsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsResult
-- <p>Contains the output of DeleteVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the VPC endpoints that were not successfully deleted.</p>
-- @return DeleteVpcEndpointsResult structure as a key-value pair table
function M.DeleteVpcEndpointsResult(args)
	assert(args, "You must provide an argument table when creating DeleteVpcEndpointsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertDeleteVpcEndpointsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EbsInstanceBlockDevice = { ["Status"] = true, ["DeleteOnTermination"] = true, ["VolumeId"] = true, ["AttachTime"] = true, nil }

function asserts.AssertEbsInstanceBlockDevice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EbsInstanceBlockDevice to be of type 'table'")
	if struct["Status"] then asserts.AssertAttachmentStatus(struct["Status"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.EbsInstanceBlockDevice[k], "EbsInstanceBlockDevice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EbsInstanceBlockDevice
-- <p>Describes a parameter used to set up an EBS volume in a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [AttachmentStatus] <p>The attachment state.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the volume is deleted on instance termination.</p>
-- * VolumeId [String] <p>The ID of the EBS volume.</p>
-- * AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- @return EbsInstanceBlockDevice structure as a key-value pair table
function M.EbsInstanceBlockDevice(args)
	assert(args, "You must provide an argument table when creating EbsInstanceBlockDevice")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["VolumeId"] = args["VolumeId"],
		["AttachTime"] = args["AttachTime"],
	}
	asserts.AssertEbsInstanceBlockDevice(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.S3Storage = { ["UploadPolicySignature"] = true, ["Prefix"] = true, ["AWSAccessKeyId"] = true, ["Bucket"] = true, ["UploadPolicy"] = true, nil }

function asserts.AssertS3Storage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected S3Storage to be of type 'table'")
	if struct["UploadPolicySignature"] then asserts.AssertString(struct["UploadPolicySignature"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["AWSAccessKeyId"] then asserts.AssertString(struct["AWSAccessKeyId"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	if struct["UploadPolicy"] then asserts.AssertBlob(struct["UploadPolicy"]) end
	for k,_ in pairs(struct) do
		assert(keys.S3Storage[k], "S3Storage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type S3Storage
-- <p>Describes the storage parameters for S3 and S3 buckets for an instance store-backed AMI.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UploadPolicySignature [String] <p>The signature of the JSON document.</p>
-- * Prefix [String] <p>The beginning of the file name of the AMI.</p>
-- * AWSAccessKeyId [String] <p>The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in <a href="http://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html">Best Practices for Managing AWS Access Keys</a>.</p>
-- * Bucket [String] <p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>
-- * UploadPolicy [Blob] <p>An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.</p>
-- @return S3Storage structure as a key-value pair table
function M.S3Storage(args)
	assert(args, "You must provide an argument table when creating S3Storage")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UploadPolicySignature"] = args["UploadPolicySignature"],
		["Prefix"] = args["Prefix"],
		["AWSAccessKeyId"] = args["AWSAccessKeyId"],
		["Bucket"] = args["Bucket"],
		["UploadPolicy"] = args["UploadPolicy"],
	}
	asserts.AssertS3Storage(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeStatusDetails = { ["Status"] = true, ["Name"] = true, nil }

function asserts.AssertVolumeStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusDetails to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["Name"] then asserts.AssertVolumeStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusDetails[k], "VolumeStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusDetails
-- <p>Describes a volume status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>The intended status of the volume status.</p>
-- * Name [VolumeStatusName] <p>The name of the volume status.</p>
-- @return VolumeStatusDetails structure as a key-value pair table
function M.VolumeStatusDetails(args)
	assert(args, "You must provide an argument table when creating VolumeStatusDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["Name"] = args["Name"],
	}
	asserts.AssertVolumeStatusDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeHostReservationOfferingsRequest = { ["OfferingId"] = true, ["MaxResults"] = true, ["Filter"] = true, ["MinDuration"] = true, ["NextToken"] = true, ["MaxDuration"] = true, nil }

function asserts.AssertDescribeHostReservationOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsRequest to be of type 'table'")
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filter"] then asserts.AssertFilterList(struct["Filter"]) end
	if struct["MinDuration"] then asserts.AssertInteger(struct["MinDuration"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then asserts.AssertInteger(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationOfferingsRequest[k], "DescribeHostReservationOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OfferingId [String] <p>The ID of the reservation offering.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>nextToken</code> value. This value can be between 5 and 500. If <code>maxResults</code> is given a larger value than 500, you receive an error.</p>
-- * Filter [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-family</code> - The instance family of the offering (for example, <code>m4</code>).</p> </li> <li> <p> <code>payment-option</code> - The payment option (<code>NoUpfront</code> | <code>PartialUpfront</code> | <code>AllUpfront</code>).</p> </li> </ul>
-- * MinDuration [Integer] <p>This is the minimum duration of the reservation you'd like to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 31536000 for one year.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- * MaxDuration [Integer] <p>This is the maximum duration of the reservation to purchase, specified in seconds. Reservations are available in one-year and three-year terms. The number of seconds specified must be the number of seconds in a year (365x24x60x60) times one of the supported durations (1 or 3). For example, specify 94608000 for three years.</p>
-- @return DescribeHostReservationOfferingsRequest structure as a key-value pair table
function M.DescribeHostReservationOfferingsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeHostReservationOfferingsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OfferingId"] = args["OfferingId"],
		["MaxResults"] = args["MaxResults"],
		["Filter"] = args["Filter"],
		["MinDuration"] = args["MinDuration"],
		["NextToken"] = args["NextToken"],
		["MaxDuration"] = args["MaxDuration"],
	}
	asserts.AssertDescribeHostReservationOfferingsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreditSpecificationRequest = { ["CpuCredits"] = true, nil }

function asserts.AssertCreditSpecificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreditSpecificationRequest to be of type 'table'")
	assert(struct["CpuCredits"], "Expected key CpuCredits to exist in table")
	if struct["CpuCredits"] then asserts.AssertString(struct["CpuCredits"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreditSpecificationRequest[k], "CreditSpecificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreditSpecificationRequest
-- <p>The credit option for CPU usage of a T2 or T3 instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CpuCredits [String] <p>The credit option for CPU usage of a T2 or T3 instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>
-- Required key: CpuCredits
-- @return CreditSpecificationRequest structure as a key-value pair table
function M.CreditSpecificationRequest(args)
	assert(args, "You must provide an argument table when creating CreditSpecificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CpuCredits"] = args["CpuCredits"],
	}
	asserts.AssertCreditSpecificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.StartInstancesResult = { ["StartingInstances"] = true, nil }

function asserts.AssertStartInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected StartInstancesResult to be of type 'table'")
	if struct["StartingInstances"] then asserts.AssertInstanceStateChangeList(struct["StartingInstances"]) end
	for k,_ in pairs(struct) do
		assert(keys.StartInstancesResult[k], "StartInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type StartInstancesResult
-- <p>Contains the output of StartInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * StartingInstances [InstanceStateChangeList] <p>Information about one or more started instances.</p>
-- @return StartInstancesResult structure as a key-value pair table
function M.StartInstancesResult(args)
	assert(args, "You must provide an argument table when creating StartInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["StartingInstances"] = args["StartingInstances"],
	}
	asserts.AssertStartInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Address = { ["Domain"] = true, ["PublicIpv4Pool"] = true, ["Tags"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["AssociationId"] = true, ["NetworkInterfaceOwnerId"] = true, ["PublicIp"] = true, ["AllocationId"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertAddress(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Address to be of type 'table'")
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["PublicIpv4Pool"] then asserts.AssertString(struct["PublicIpv4Pool"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["NetworkInterfaceOwnerId"] then asserts.AssertString(struct["NetworkInterfaceOwnerId"]) end
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.Address[k], "Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Address
-- <p>Describes an Elastic IP address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Domain [DomainType] <p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>
-- * PublicIpv4Pool [String] <p>The ID of an address pool.</p>
-- * Tags [TagList] <p>Any tags assigned to the Elastic IP address.</p>
-- * InstanceId [String] <p>The ID of the instance that the address is associated with (if any).</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociationId [String] <p>The ID representing the association of the address with an instance in a VPC.</p>
-- * NetworkInterfaceOwnerId [String] <p>The ID of the AWS account that owns the network interface.</p>
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * AllocationId [String] <p>The ID representing the allocation of the address for use with EC2-VPC.</p>
-- * PrivateIpAddress [String] <p>The private IP address associated with the Elastic IP address.</p>
-- @return Address structure as a key-value pair table
function M.Address(args)
	assert(args, "You must provide an argument table when creating Address")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Domain"] = args["Domain"],
		["PublicIpv4Pool"] = args["PublicIpv4Pool"],
		["Tags"] = args["Tags"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociationId"] = args["AssociationId"],
		["NetworkInterfaceOwnerId"] = args["NetworkInterfaceOwnerId"],
		["PublicIp"] = args["PublicIp"],
		["AllocationId"] = args["AllocationId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertAddress(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcClassicLinkRequest = { ["DryRun"] = true, ["Filters"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VpcIds"] then asserts.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkRequest[k], "DescribeVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>is-classic-link-enabled</code> - Whether the VPC is enabled for ClassicLink (<code>true</code> | <code>false</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> </ul>
-- * VpcIds [VpcClassicLinkIdList] <p>One or more VPCs for which you want to describe the ClassicLink status.</p>
-- @return DescribeVpcClassicLinkRequest structure as a key-value pair table
function M.DescribeVpcClassicLinkRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcClassicLinkRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["VpcIds"] = args["VpcIds"],
	}
	asserts.AssertDescribeVpcClassicLinkRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReleaseHostsRequest = { ["HostIds"] = true, nil }

function asserts.AssertReleaseHostsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsRequest to be of type 'table'")
	assert(struct["HostIds"], "Expected key HostIds to exist in table")
	if struct["HostIds"] then asserts.AssertRequestHostIdList(struct["HostIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseHostsRequest[k], "ReleaseHostsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIds [RequestHostIdList] <p>The IDs of the Dedicated Hosts to release.</p>
-- Required key: HostIds
-- @return ReleaseHostsRequest structure as a key-value pair table
function M.ReleaseHostsRequest(args)
	assert(args, "You must provide an argument table when creating ReleaseHostsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostIds"] = args["HostIds"],
	}
	asserts.AssertReleaseHostsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateFleetResult = { ["FleetId"] = true, nil }

function asserts.AssertCreateFleetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateFleetResult to be of type 'table'")
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateFleetResult[k], "CreateFleetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateFleetResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- @return CreateFleetResult structure as a key-value pair table
function M.CreateFleetResult(args)
	assert(args, "You must provide an argument table when creating CreateFleetResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FleetId"] = args["FleetId"],
	}
	asserts.AssertCreateFleetResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceCreditSpecificationsRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["InstanceIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeInstanceCreditSpecificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceCreditSpecificationsRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceCreditSpecificationsRequest[k], "DescribeInstanceCreditSpecificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceCreditSpecificationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000. You cannot specify this parameter and the instance IDs parameter in the same call.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Default: Describes all your instances.</p> <p>Constraints: Maximum 1000 explicitly specified instance IDs.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> </ul>
-- @return DescribeInstanceCreditSpecificationsRequest structure as a key-value pair table
function M.DescribeInstanceCreditSpecificationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceCreditSpecificationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeInstanceCreditSpecificationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeScheduledInstancesResult = { ["NextToken"] = true, ["ScheduledInstanceSet"] = true, nil }

function asserts.AssertDescribeScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeScheduledInstancesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ScheduledInstanceSet"] then asserts.AssertScheduledInstanceSet(struct["ScheduledInstanceSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeScheduledInstancesResult[k], "DescribeScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeScheduledInstancesResult
-- <p>Contains the output of DescribeScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ScheduledInstanceSet [ScheduledInstanceSet] <p>Information about the Scheduled Instances.</p>
-- @return DescribeScheduledInstancesResult structure as a key-value pair table
function M.DescribeScheduledInstancesResult(args)
	assert(args, "You must provide an argument table when creating DescribeScheduledInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ScheduledInstanceSet"] = args["ScheduledInstanceSet"],
	}
	asserts.AssertDescribeScheduledInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CopyFpgaImageResult = { ["FpgaImageId"] = true, nil }

function asserts.AssertCopyFpgaImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CopyFpgaImageResult to be of type 'table'")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CopyFpgaImageResult[k], "CopyFpgaImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CopyFpgaImageResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageId [String] <p>The ID of the new AFI.</p>
-- @return CopyFpgaImageResult structure as a key-value pair table
function M.CopyFpgaImageResult(args)
	assert(args, "You must provide an argument table when creating CopyFpgaImageResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageId"] = args["FpgaImageId"],
	}
	asserts.AssertCopyFpgaImageResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateVpcCidrBlockResult = { ["Ipv6CidrBlockAssociation"] = true, ["CidrBlockAssociation"] = true, ["VpcId"] = true, nil }

function asserts.AssertAssociateVpcCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateVpcCidrBlockResult to be of type 'table'")
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertVpcIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	if struct["CidrBlockAssociation"] then asserts.AssertVpcCidrBlockAssociation(struct["CidrBlockAssociation"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateVpcCidrBlockResult[k], "AssociateVpcCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateVpcCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlockAssociation [VpcIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- * CidrBlockAssociation [VpcCidrBlockAssociation] <p>Information about the IPv4 CIDR block association.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return AssociateVpcCidrBlockResult structure as a key-value pair table
function M.AssociateVpcCidrBlockResult(args)
	assert(args, "You must provide an argument table when creating AssociateVpcCidrBlockResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
		["CidrBlockAssociation"] = args["CidrBlockAssociation"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertAssociateVpcCidrBlockResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PciId = { ["SubsystemVendorId"] = true, ["VendorId"] = true, ["DeviceId"] = true, ["SubsystemId"] = true, nil }

function asserts.AssertPciId(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PciId to be of type 'table'")
	if struct["SubsystemVendorId"] then asserts.AssertString(struct["SubsystemVendorId"]) end
	if struct["VendorId"] then asserts.AssertString(struct["VendorId"]) end
	if struct["DeviceId"] then asserts.AssertString(struct["DeviceId"]) end
	if struct["SubsystemId"] then asserts.AssertString(struct["SubsystemId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PciId[k], "PciId contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PciId
-- <p>Describes the data that identifies an Amazon FPGA image (AFI) on the PCI bus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubsystemVendorId [String] <p>The ID of the vendor for the subsystem.</p>
-- * VendorId [String] <p>The ID of the vendor.</p>
-- * DeviceId [String] <p>The ID of the device.</p>
-- * SubsystemId [String] <p>The ID of the subsystem.</p>
-- @return PciId structure as a key-value pair table
function M.PciId(args)
	assert(args, "You must provide an argument table when creating PciId")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubsystemVendorId"] = args["SubsystemVendorId"],
		["VendorId"] = args["VendorId"],
		["DeviceId"] = args["DeviceId"],
		["SubsystemId"] = args["SubsystemId"],
	}
	asserts.AssertPciId(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RequestSpotLaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Monitoring"] = true, ["KeyName"] = true, ["SecurityGroupIds"] = true, ["ImageId"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["RamdiskId"] = true, ["KernelId"] = true, ["Placement"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertRequestSpotLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotLaunchSpecification to be of type 'table'")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroupIds"] then asserts.AssertValueStringList(struct["SecurityGroupIds"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertValueStringList(struct["SecurityGroups"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotLaunchSpecification[k], "RequestSpotLaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotLaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserData [String] <p>The Base64-encoded user data for the instance.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- * Monitoring [RunInstancesMonitoringEnabled] <p>Indicates whether basic or detailed monitoring is enabled for the instance.</p> <p>Default: Disabled</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * SecurityGroupIds [ValueStringList] <p>One or more security group IDs.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroups [ValueStringList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * AddressingType [String] <p>Deprecated.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
-- @return RequestSpotLaunchSpecification structure as a key-value pair table
function M.RequestSpotLaunchSpecification(args)
	assert(args, "You must provide an argument table when creating RequestSpotLaunchSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Monitoring"] = args["Monitoring"],
		["KeyName"] = args["KeyName"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["ImageId"] = args["ImageId"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroups"] = args["SecurityGroups"],
		["RamdiskId"] = args["RamdiskId"],
		["KernelId"] = args["KernelId"],
		["Placement"] = args["Placement"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["AddressingType"] = args["AddressingType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertRequestSpotLaunchSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CustomerGateway = { ["Tags"] = true, ["IpAddress"] = true, ["State"] = true, ["CustomerGatewayId"] = true, ["BgpAsn"] = true, ["Type"] = true, nil }

function asserts.AssertCustomerGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CustomerGateway to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["IpAddress"] then asserts.AssertString(struct["IpAddress"]) end
	if struct["State"] then asserts.AssertString(struct["State"]) end
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["BgpAsn"] then asserts.AssertString(struct["BgpAsn"]) end
	if struct["Type"] then asserts.AssertString(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CustomerGateway[k], "CustomerGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CustomerGateway
-- <p>Describes a customer gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tags [TagList] <p>Any tags assigned to the customer gateway.</p>
-- * IpAddress [String] <p>The Internet-routable IP address of the customer gateway's outside interface.</p>
-- * State [String] <p>The current state of the customer gateway (<code>pending | available | deleting | deleted</code>).</p>
-- * CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- * BgpAsn [String] <p>The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>
-- * Type [String] <p>The type of VPN connection the customer gateway supports (<code>ipsec.1</code>).</p>
-- @return CustomerGateway structure as a key-value pair table
function M.CustomerGateway(args)
	assert(args, "You must provide an argument table when creating CustomerGateway")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Tags"] = args["Tags"],
		["IpAddress"] = args["IpAddress"],
		["State"] = args["State"],
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["BgpAsn"] = args["BgpAsn"],
		["Type"] = args["Type"],
	}
	asserts.AssertCustomerGateway(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnassignIpv6AddressesRequest = { ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, nil }

function asserts.AssertUnassignIpv6AddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignIpv6AddressesRequest to be of type 'table'")
	assert(struct["Ipv6Addresses"], "Expected key Ipv6Addresses to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Ipv6Addresses"] then asserts.AssertIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignIpv6AddressesRequest[k], "UnassignIpv6AddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignIpv6AddressesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Addresses [Ipv6AddressList] <p>The IPv6 addresses to unassign from the network interface.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- Required key: Ipv6Addresses
-- Required key: NetworkInterfaceId
-- @return UnassignIpv6AddressesRequest structure as a key-value pair table
function M.UnassignIpv6AddressesRequest(args)
	assert(args, "You must provide an argument table when creating UnassignIpv6AddressesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
	}
	asserts.AssertUnassignIpv6AddressesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSpotDatafeedSubscriptionRequest = { ["DryRun"] = true, ["Prefix"] = true, ["Bucket"] = true, nil }

function asserts.AssertCreateSpotDatafeedSubscriptionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionRequest to be of type 'table'")
	assert(struct["Bucket"], "Expected key Bucket to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Prefix"] then asserts.AssertString(struct["Prefix"]) end
	if struct["Bucket"] then asserts.AssertString(struct["Bucket"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSpotDatafeedSubscriptionRequest[k], "CreateSpotDatafeedSubscriptionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionRequest
-- <p>Contains the parameters for CreateSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Prefix [String] <p>A prefix for the data feed file names.</p>
-- * Bucket [String] <p>The Amazon S3 bucket in which to store the Spot Instance data feed.</p>
-- Required key: Bucket
-- @return CreateSpotDatafeedSubscriptionRequest structure as a key-value pair table
function M.CreateSpotDatafeedSubscriptionRequest(args)
	assert(args, "You must provide an argument table when creating CreateSpotDatafeedSubscriptionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Prefix"] = args["Prefix"],
		["Bucket"] = args["Bucket"],
	}
	asserts.AssertCreateSpotDatafeedSubscriptionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFlowLogsRequest = { ["DryRun"] = true, ["FlowLogIds"] = true, nil }

function asserts.AssertDeleteFlowLogsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFlowLogsRequest to be of type 'table'")
	assert(struct["FlowLogIds"], "Expected key FlowLogIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["FlowLogIds"] then asserts.AssertValueStringList(struct["FlowLogIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFlowLogsRequest[k], "DeleteFlowLogsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFlowLogsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * FlowLogIds [ValueStringList] <p>One or more flow log IDs.</p>
-- Required key: FlowLogIds
-- @return DeleteFlowLogsRequest structure as a key-value pair table
function M.DeleteFlowLogsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteFlowLogsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["FlowLogIds"] = args["FlowLogIds"],
	}
	asserts.AssertDeleteFlowLogsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotFleetInstancesRequest = { ["SpotFleetRequestId"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeSpotFleetInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetInstancesRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetInstancesRequest[k], "DescribeSpotFleetInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetInstancesRequest
-- <p>Contains the parameters for DescribeSpotFleetInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- Required key: SpotFleetRequestId
-- @return DescribeSpotFleetInstancesRequest structure as a key-value pair table
function M.DescribeSpotFleetInstancesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSpotFleetInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeSpotFleetInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AvailableCapacity = { ["AvailableInstanceCapacity"] = true, ["AvailableVCpus"] = true, nil }

function asserts.AssertAvailableCapacity(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailableCapacity to be of type 'table'")
	if struct["AvailableInstanceCapacity"] then asserts.AssertAvailableInstanceCapacityList(struct["AvailableInstanceCapacity"]) end
	if struct["AvailableVCpus"] then asserts.AssertInteger(struct["AvailableVCpus"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailableCapacity[k], "AvailableCapacity contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailableCapacity
-- <p>The capacity information for instances launched onto the Dedicated Host.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailableInstanceCapacity [AvailableInstanceCapacityList] <p>The total number of instances supported by the Dedicated Host.</p>
-- * AvailableVCpus [Integer] <p>The number of vCPUs available on the Dedicated Host.</p>
-- @return AvailableCapacity structure as a key-value pair table
function M.AvailableCapacity(args)
	assert(args, "You must provide an argument table when creating AvailableCapacity")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailableInstanceCapacity"] = args["AvailableInstanceCapacity"],
		["AvailableVCpus"] = args["AvailableVCpus"],
	}
	asserts.AssertAvailableCapacity(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetReservedInstancesExchangeQuoteRequest = { ["ReservedInstanceIds"] = true, ["DryRun"] = true, ["TargetConfigurations"] = true, nil }

function asserts.AssertGetReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then asserts.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then asserts.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetReservedInstancesExchangeQuoteRequest[k], "GetReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for GetReservedInstanceExchangeQuote.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TargetConfigurations [TargetConfigurationRequestSet] <p>The configuration of the target Convertible Reserved Instance to exchange for your current Convertible Reserved Instances.</p>
-- Required key: ReservedInstanceIds
-- @return GetReservedInstancesExchangeQuoteRequest structure as a key-value pair table
function M.GetReservedInstancesExchangeQuoteRequest(args)
	assert(args, "You must provide an argument table when creating GetReservedInstancesExchangeQuoteRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstanceIds"] = args["ReservedInstanceIds"],
		["DryRun"] = args["DryRun"],
		["TargetConfigurations"] = args["TargetConfigurations"],
	}
	asserts.AssertGetReservedInstancesExchangeQuoteRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpnStaticRoute = { ["DestinationCidrBlock"] = true, ["State"] = true, ["Source"] = true, nil }

function asserts.AssertVpnStaticRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnStaticRoute to be of type 'table'")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["State"] then asserts.AssertVpnState(struct["State"]) end
	if struct["Source"] then asserts.AssertVpnStaticRouteSource(struct["Source"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnStaticRoute[k], "VpnStaticRoute contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnStaticRoute
-- <p>Describes a static route for a VPN connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer data center.</p>
-- * State [VpnState] <p>The current state of the static route.</p>
-- * Source [VpnStaticRouteSource] <p>Indicates how the routes were provided.</p>
-- @return VpnStaticRoute structure as a key-value pair table
function M.VpnStaticRoute(args)
	assert(args, "You must provide an argument table when creating VpnStaticRoute")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["State"] = args["State"],
		["Source"] = args["Source"],
	}
	asserts.AssertVpnStaticRoute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertDeleteVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcPeeringConnectionRequest to be of type 'table'")
	assert(struct["VpcPeeringConnectionId"], "Expected key VpcPeeringConnectionId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcPeeringConnectionRequest[k], "DeleteVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcPeeringConnectionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- Required key: VpcPeeringConnectionId
-- @return DeleteVpcPeeringConnectionRequest structure as a key-value pair table
function M.DeleteVpcPeeringConnectionRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpcPeeringConnectionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertDeleteVpcPeeringConnectionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesModificationsResult = { ["NextToken"] = true, ["ReservedInstancesModifications"] = true, nil }

function asserts.AssertDescribeReservedInstancesModificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesModificationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ReservedInstancesModifications"] then asserts.AssertReservedInstancesModificationList(struct["ReservedInstancesModifications"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesModificationsResult[k], "DescribeReservedInstancesModificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesModificationsResult
-- <p>Contains the output of DescribeReservedInstancesModifications.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ReservedInstancesModifications [ReservedInstancesModificationList] <p>The Reserved Instance modification information.</p>
-- @return DescribeReservedInstancesModificationsResult structure as a key-value pair table
function M.DescribeReservedInstancesModificationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesModificationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ReservedInstancesModifications"] = args["ReservedInstancesModifications"],
	}
	asserts.AssertDescribeReservedInstancesModificationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeByoipCidrsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeByoipCidrsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeByoipCidrsRequest to be of type 'table'")
	assert(struct["MaxResults"], "Expected key MaxResults to exist in table")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeByoipCidrsRequest[k], "DescribeByoipCidrsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeByoipCidrsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [MaxResults] <p>The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned <code>nextToken</code> value.</p>
-- Required key: MaxResults
-- @return DescribeByoipCidrsRequest structure as a key-value pair table
function M.DescribeByoipCidrsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeByoipCidrsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeByoipCidrsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SubnetCidrBlockState = { ["State"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertSubnetCidrBlockState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SubnetCidrBlockState to be of type 'table'")
	if struct["State"] then asserts.AssertSubnetCidrBlockStateCode(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.SubnetCidrBlockState[k], "SubnetCidrBlockState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SubnetCidrBlockState
-- <p>Describes the state of a CIDR block.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [SubnetCidrBlockStateCode] <p>The state of a CIDR block.</p>
-- * StatusMessage [String] <p>A message about the status of the CIDR block, if applicable.</p>
-- @return SubnetCidrBlockState structure as a key-value pair table
function M.SubnetCidrBlockState(args)
	assert(args, "You must provide an argument table when creating SubnetCidrBlockState")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertSubnetCidrBlockState(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CpuOptions = { ["CoreCount"] = true, ["ThreadsPerCore"] = true, nil }

function asserts.AssertCpuOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CpuOptions to be of type 'table'")
	if struct["CoreCount"] then asserts.AssertInteger(struct["CoreCount"]) end
	if struct["ThreadsPerCore"] then asserts.AssertInteger(struct["ThreadsPerCore"]) end
	for k,_ in pairs(struct) do
		assert(keys.CpuOptions[k], "CpuOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CpuOptions
-- <p>The CPU options for the instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CoreCount [Integer] <p>The number of CPU cores for the instance.</p>
-- * ThreadsPerCore [Integer] <p>The number of threads per CPU core.</p>
-- @return CpuOptions structure as a key-value pair table
function M.CpuOptions(args)
	assert(args, "You must provide an argument table when creating CpuOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CoreCount"] = args["CoreCount"],
		["ThreadsPerCore"] = args["ThreadsPerCore"],
	}
	asserts.AssertCpuOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IdFormat = { ["Resource"] = true, ["Deadline"] = true, ["UseLongIds"] = true, nil }

function asserts.AssertIdFormat(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IdFormat to be of type 'table'")
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	if struct["Deadline"] then asserts.AssertDateTime(struct["Deadline"]) end
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.IdFormat[k], "IdFormat contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IdFormat
-- <p>Describes the ID format for a resource.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Resource [String] <p>The type of resource.</p>
-- * Deadline [DateTime] <p>The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.</p>
-- * UseLongIds [Boolean] <p>Indicates whether longer IDs (17-character IDs) are enabled for the resource.</p>
-- @return IdFormat structure as a key-value pair table
function M.IdFormat(args)
	assert(args, "You must provide an argument table when creating IdFormat")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Resource"] = args["Resource"],
		["Deadline"] = args["Deadline"],
		["UseLongIds"] = args["UseLongIds"],
	}
	asserts.AssertIdFormat(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSnapshotAttributeResult = { ["ProductCodes"] = true, ["CreateVolumePermissions"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertDescribeSnapshotAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeResult to be of type 'table'")
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["CreateVolumePermissions"] then asserts.AssertCreateVolumePermissionList(struct["CreateVolumePermissions"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotAttributeResult[k], "DescribeSnapshotAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeResult
-- <p>Contains the output of DescribeSnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodes [ProductCodeList] <p>A list of product codes.</p>
-- * CreateVolumePermissions [CreateVolumePermissionList] <p>A list of permissions for creating volumes from the snapshot.</p>
-- * SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- @return DescribeSnapshotAttributeResult structure as a key-value pair table
function M.DescribeSnapshotAttributeResult(args)
	assert(args, "You must provide an argument table when creating DescribeSnapshotAttributeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ProductCodes"] = args["ProductCodes"],
		["CreateVolumePermissions"] = args["CreateVolumePermissions"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertDescribeSnapshotAttributeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateOverrides = { ["AvailabilityZone"] = true, ["WeightedCapacity"] = true, ["Priority"] = true, ["SubnetId"] = true, ["InstanceType"] = true, ["SpotPrice"] = true, nil }

function asserts.AssertLaunchTemplateOverrides(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateOverrides to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["WeightedCapacity"] then asserts.AssertDouble(struct["WeightedCapacity"]) end
	if struct["Priority"] then asserts.AssertDouble(struct["Priority"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateOverrides[k], "LaunchTemplateOverrides contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateOverrides
-- <p>Describes overrides for a launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone in which to launch the instances.</p>
-- * WeightedCapacity [Double] <p>The number of units provided by the specified instance type.</p>
-- * Priority [Double] <p>The priority for the launch template override. If <b>OnDemandAllocationStrategy</b> is set to <code>prioritized</code>, Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. Valid values are whole numbers starting at <code>0</code>. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instances.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * SpotPrice [String] <p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>
-- @return LaunchTemplateOverrides structure as a key-value pair table
function M.LaunchTemplateOverrides(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateOverrides")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["WeightedCapacity"] = args["WeightedCapacity"],
		["Priority"] = args["Priority"],
		["SubnetId"] = args["SubnetId"],
		["InstanceType"] = args["InstanceType"],
		["SpotPrice"] = args["SpotPrice"],
	}
	asserts.AssertLaunchTemplateOverrides(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ProvisionByoipCidrRequest = { ["Cidr"] = true, ["DryRun"] = true, ["Description"] = true, ["CidrAuthorizationContext"] = true, nil }

function asserts.AssertProvisionByoipCidrRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProvisionByoipCidrRequest to be of type 'table'")
	assert(struct["Cidr"], "Expected key Cidr to exist in table")
	if struct["Cidr"] then asserts.AssertString(struct["Cidr"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["CidrAuthorizationContext"] then asserts.AssertCidrAuthorizationContext(struct["CidrAuthorizationContext"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProvisionByoipCidrRequest[k], "ProvisionByoipCidrRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProvisionByoipCidrRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Cidr [String] <p>The public IPv4 address range, in CIDR notation. The most specific prefix that you can specify is /24. The address range cannot overlap with another address range that you've brought to this or another region.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [String] <p>A description for the address range and the address pool.</p>
-- * CidrAuthorizationContext [CidrAuthorizationContext] <p>A signed document that proves that you are authorized to bring the specified IP address range to Amazon using BYOIP.</p>
-- Required key: Cidr
-- @return ProvisionByoipCidrRequest structure as a key-value pair table
function M.ProvisionByoipCidrRequest(args)
	assert(args, "You must provide an argument table when creating ProvisionByoipCidrRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Cidr"] = args["Cidr"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["CidrAuthorizationContext"] = args["CidrAuthorizationContext"],
	}
	asserts.AssertProvisionByoipCidrRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceState = { ["Code"] = true, ["Name"] = true, nil }

function asserts.AssertInstanceState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceState to be of type 'table'")
	if struct["Code"] then asserts.AssertInteger(struct["Code"]) end
	if struct["Name"] then asserts.AssertInstanceStateName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceState[k], "InstanceState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceState
-- <p>Describes the current state of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Code [Integer] <p>The low byte represents the state. The high byte is used for internal purposes and should be ignored.</p> <ul> <li> <p> <code>0</code> : <code>pending</code> </p> </li> <li> <p> <code>16</code> : <code>running</code> </p> </li> <li> <p> <code>32</code> : <code>shutting-down</code> </p> </li> <li> <p> <code>48</code> : <code>terminated</code> </p> </li> <li> <p> <code>64</code> : <code>stopping</code> </p> </li> <li> <p> <code>80</code> : <code>stopped</code> </p> </li> </ul>
-- * Name [InstanceStateName] <p>The current state of the instance.</p>
-- @return InstanceState structure as a key-value pair table
function M.InstanceState(args)
	assert(args, "You must provide an argument table when creating InstanceState")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Code"] = args["Code"],
		["Name"] = args["Name"],
	}
	asserts.AssertInstanceState(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EnableVpcClassicLinkDnsSupportRequest = { ["VpcId"] = true, nil }

function asserts.AssertEnableVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkDnsSupportRequest[k], "EnableVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return EnableVpcClassicLinkDnsSupportRequest structure as a key-value pair table
function M.EnableVpcClassicLinkDnsSupportRequest(args)
	assert(args, "You must provide an argument table when creating EnableVpcClassicLinkDnsSupportRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertEnableVpcClassicLinkDnsSupportRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachClassicLinkVpcResult = { ["Return"] = true, nil }

function asserts.AssertAttachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachClassicLinkVpcResult[k], "AttachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachClassicLinkVpcResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return AttachClassicLinkVpcResult structure as a key-value pair table
function M.AttachClassicLinkVpcResult(args)
	assert(args, "You must provide an argument table when creating AttachClassicLinkVpcResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertAttachClassicLinkVpcResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachClassicLinkVpcResult = { ["Return"] = true, nil }

function asserts.AssertDetachClassicLinkVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachClassicLinkVpcResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachClassicLinkVpcResult[k], "DetachClassicLinkVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachClassicLinkVpcResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return DetachClassicLinkVpcResult structure as a key-value pair table
function M.DetachClassicLinkVpcResult(args)
	assert(args, "You must provide an argument table when creating DetachClassicLinkVpcResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDetachClassicLinkVpcResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ScheduledInstancesMonitoring = { ["Enabled"] = true, nil }

function asserts.AssertScheduledInstancesMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ScheduledInstancesMonitoring to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.ScheduledInstancesMonitoring[k], "ScheduledInstancesMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ScheduledInstancesMonitoring
-- <p>Describes whether monitoring is enabled for a Scheduled Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Indicates whether monitoring is enabled.</p>
-- @return ScheduledInstancesMonitoring structure as a key-value pair table
function M.ScheduledInstancesMonitoring(args)
	assert(args, "You must provide an argument table when creating ScheduledInstancesMonitoring")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertScheduledInstancesMonitoring(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNetworkInterfacePermissionResult = { ["InterfacePermission"] = true, nil }

function asserts.AssertCreateNetworkInterfacePermissionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkInterfacePermissionResult to be of type 'table'")
	if struct["InterfacePermission"] then asserts.AssertNetworkInterfacePermission(struct["InterfacePermission"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkInterfacePermissionResult[k], "CreateNetworkInterfacePermissionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkInterfacePermissionResult
-- <p>Contains the output of CreateNetworkInterfacePermission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InterfacePermission [NetworkInterfacePermission] <p>Information about the permission for the network interface.</p>
-- @return CreateNetworkInterfacePermissionResult structure as a key-value pair table
function M.CreateNetworkInterfacePermissionResult(args)
	assert(args, "You must provide an argument table when creating CreateNetworkInterfacePermissionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InterfacePermission"] = args["InterfacePermission"],
	}
	asserts.AssertCreateNetworkInterfacePermissionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateSubnetCidrBlockResult = { ["SubnetId"] = true, ["Ipv6CidrBlockAssociation"] = true, nil }

function asserts.AssertDisassociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateSubnetCidrBlockResult[k], "DisassociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateSubnetCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @return DisassociateSubnetCidrBlockResult structure as a key-value pair table
function M.DisassociateSubnetCidrBlockResult(args)
	assert(args, "You must provide an argument table when creating DisassociateSubnetCidrBlockResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
	}
	asserts.AssertDisassociateSubnetCidrBlockResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyInstanceAttributeRequest = { ["Ramdisk"] = true, ["Kernel"] = true, ["SourceDestCheck"] = true, ["DryRun"] = true, ["UserData"] = true, ["InstanceId"] = true, ["Attribute"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["InstanceInitiatedShutdownBehavior"] = true, ["BlockDeviceMappings"] = true, ["Value"] = true, ["Groups"] = true, ["EbsOptimized"] = true, ["DisableApiTermination"] = true, ["InstanceType"] = true, nil }

function asserts.AssertModifyInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstanceAttributeRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["Ramdisk"] then asserts.AssertAttributeValue(struct["Ramdisk"]) end
	if struct["Kernel"] then asserts.AssertAttributeValue(struct["Kernel"]) end
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["UserData"] then asserts.AssertBlobAttributeValue(struct["UserData"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["EnaSupport"] then asserts.AssertAttributeBooleanValue(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertAttributeValue(struct["SriovNetSupport"]) end
	if struct["InstanceInitiatedShutdownBehavior"] then asserts.AssertAttributeValue(struct["InstanceInitiatedShutdownBehavior"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingSpecificationList(struct["BlockDeviceMappings"]) end
	if struct["Value"] then asserts.AssertString(struct["Value"]) end
	if struct["Groups"] then asserts.AssertGroupIdStringList(struct["Groups"]) end
	if struct["EbsOptimized"] then asserts.AssertAttributeBooleanValue(struct["EbsOptimized"]) end
	if struct["DisableApiTermination"] then asserts.AssertAttributeBooleanValue(struct["DisableApiTermination"]) end
	if struct["InstanceType"] then asserts.AssertAttributeValue(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstanceAttributeRequest[k], "ModifyInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstanceAttributeRequest
-- <p>Contains the parameters for ModifyInstanceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ramdisk [AttributeValue] <p>Changes the instance's RAM disk to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- * Kernel [AttributeValue] <p>Changes the instance's kernel to the specified value. We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedKernels.html">PV-GRUB</a>.</p>
-- * SourceDestCheck [AttributeBooleanValue] <p>Specifies whether source/destination checking is enabled. A value of <code>true</code> means that checking is enabled, and <code>false</code> means that checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * UserData [BlobAttributeValue] <p>Changes the instance's user data to the specified value. If you are using an AWS SDK or command line tool, base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide base64-encoded text.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Attribute [InstanceAttributeName] <p>The name of the attribute.</p>
-- * EnaSupport [AttributeBooleanValue] <p>Set to <code>true</code> to enable enhanced networking with ENA for the instance.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- * SriovNetSupport [AttributeValue] <p>Set to <code>simple</code> to enable enhanced networking with the Intel 82599 Virtual Function interface for the instance.</p> <p>There is no way to disable enhanced networking with the Intel 82599 Virtual Function interface at this time.</p> <p>This option is supported only for HVM instances. Specifying this option with a PV instance can make it unreachable.</p>
-- * InstanceInitiatedShutdownBehavior [AttributeValue] <p>Specifies whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>
-- * BlockDeviceMappings [InstanceBlockDeviceMappingSpecificationList] <p>Modifies the <code>DeleteOnTermination</code> attribute for volumes that are currently attached. The volume must be owned by the caller. If no value is specified for <code>DeleteOnTermination</code>, the default is <code>true</code> and the volume is deleted when the instance is terminated.</p> <p>To add instance store volumes to an Amazon EBS-backed instance, you must add them when you launch the instance. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html#Using_OverridingAMIBDM">Updating the Block Device Mapping when Launching an Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * Value [String] <p>A new value for the attribute. Use only with the <code>kernel</code>, <code>ramdisk</code>, <code>userData</code>, <code>disableApiTermination</code>, or <code>instanceInitiatedShutdownBehavior</code> attribute.</p>
-- * Groups [GroupIdStringList] <p>[EC2-VPC] Changes the security groups of the instance. You must specify at least one security group, even if it's just the default security group for the VPC. You must specify the security group ID, not the security group name.</p>
-- * EbsOptimized [AttributeBooleanValue] <p>Specifies whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- * DisableApiTermination [AttributeBooleanValue] <p>If the value is <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. You cannot use this parameter for Spot Instances.</p>
-- * InstanceType [AttributeValue] <p>Changes the instance type to the specified value. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a>. If the instance type is not valid, the error returned is <code>InvalidInstanceAttributeValue</code>.</p>
-- Required key: InstanceId
-- @return ModifyInstanceAttributeRequest structure as a key-value pair table
function M.ModifyInstanceAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifyInstanceAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ramdisk"] = args["Ramdisk"],
		["Kernel"] = args["Kernel"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["DryRun"] = args["DryRun"],
		["UserData"] = args["UserData"],
		["InstanceId"] = args["InstanceId"],
		["Attribute"] = args["Attribute"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["InstanceInitiatedShutdownBehavior"] = args["InstanceInitiatedShutdownBehavior"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Value"] = args["Value"],
		["Groups"] = args["Groups"],
		["EbsOptimized"] = args["EbsOptimized"],
		["DisableApiTermination"] = args["DisableApiTermination"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertModifyInstanceAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetHostReservationPurchasePreviewRequest = { ["HostIdSet"] = true, ["OfferingId"] = true, nil }

function asserts.AssertGetHostReservationPurchasePreviewRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetHostReservationPurchasePreviewRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["HostIdSet"] then asserts.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetHostReservationPurchasePreviewRequest[k], "GetHostReservationPurchasePreviewRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetHostReservationPurchasePreviewRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostIdSet [RequestHostIdSet] <p>The IDs of the Dedicated Hosts with which the reservation is associated.</p>
-- * OfferingId [String] <p>The offering ID of the reservation.</p>
-- Required key: HostIdSet
-- Required key: OfferingId
-- @return GetHostReservationPurchasePreviewRequest structure as a key-value pair table
function M.GetHostReservationPurchasePreviewRequest(args)
	assert(args, "You must provide an argument table when creating GetHostReservationPurchasePreviewRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostIdSet"] = args["HostIdSet"],
		["OfferingId"] = args["OfferingId"],
	}
	asserts.AssertGetHostReservationPurchasePreviewRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EnableVpcClassicLinkDnsSupportResult = { ["Return"] = true, nil }

function asserts.AssertEnableVpcClassicLinkDnsSupportResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkDnsSupportResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkDnsSupportResult[k], "EnableVpcClassicLinkDnsSupportResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkDnsSupportResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>
-- @return EnableVpcClassicLinkDnsSupportResult structure as a key-value pair table
function M.EnableVpcClassicLinkDnsSupportResult(args)
	assert(args, "You must provide an argument table when creating EnableVpcClassicLinkDnsSupportResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertEnableVpcClassicLinkDnsSupportResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetPasswordDataResult = { ["InstanceId"] = true, ["Timestamp"] = true, ["PasswordData"] = true, nil }

function asserts.AssertGetPasswordDataResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetPasswordDataResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["PasswordData"] then asserts.AssertString(struct["PasswordData"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetPasswordDataResult[k], "GetPasswordDataResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetPasswordDataResult
-- <p>Contains the output of GetPasswordData.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the Windows instance.</p>
-- * Timestamp [DateTime] <p>The time the data was last updated.</p>
-- * PasswordData [String] <p>The password of the instance. Returns an empty string if the password is not available.</p>
-- @return GetPasswordDataResult structure as a key-value pair table
function M.GetPasswordDataResult(args)
	assert(args, "You must provide an argument table when creating GetPasswordDataResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Timestamp"] = args["Timestamp"],
		["PasswordData"] = args["PasswordData"],
	}
	asserts.AssertGetPasswordDataResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.KeyPairInfo = { ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertKeyPairInfo(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected KeyPairInfo to be of type 'table'")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.KeyPairInfo[k], "KeyPairInfo contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type KeyPairInfo
-- <p>Describes a key pair.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>The name of the key pair.</p>
-- * KeyFingerprint [String] <p>If you used <a>CreateKeyPair</a> to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used <a>ImportKeyPair</a> to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.</p>
-- @return KeyPairInfo structure as a key-value pair table
function M.KeyPairInfo(args)
	assert(args, "You must provide an argument table when creating KeyPairInfo")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyName"] = args["KeyName"],
		["KeyFingerprint"] = args["KeyFingerprint"],
	}
	asserts.AssertKeyPairInfo(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReplaceNetworkAclEntryRequest = { ["IcmpTypeCode"] = true, ["NetworkAclId"] = true, ["RuleNumber"] = true, ["DryRun"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["Protocol"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertReplaceNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReplaceNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReplaceNetworkAclEntryRequest[k], "ReplaceNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReplaceNetworkAclEntryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying protocol 1 (ICMP) or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- * NetworkAclId [String] <p>The ID of the ACL.</p>
-- * RuleNumber [Integer] <p>The rule number of the entry to replace.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:bd8:1234:1a00::/64</code>).</p>
-- * Egress [Boolean] <p>Indicates whether to replace the egress rule.</p> <p>Default: If no value is specified, we replace the ingress rule.</p>
-- * RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- * PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to. Required if specifying protocol 6 (TCP) or 17 (UDP).</p>
-- * Protocol [String] <p>The protocol number. A value of "-1" means all protocols. If you specify "-1" or a protocol number other than "6" (TCP), "17" (UDP), or "1" (ICMP), traffic on all ports is allowed, regardless of any ports or ICMP types or codes that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- * CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required key: Egress
-- Required key: NetworkAclId
-- Required key: Protocol
-- Required key: RuleAction
-- Required key: RuleNumber
-- @return ReplaceNetworkAclEntryRequest structure as a key-value pair table
function M.ReplaceNetworkAclEntryRequest(args)
	assert(args, "You must provide an argument table when creating ReplaceNetworkAclEntryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IcmpTypeCode"] = args["IcmpTypeCode"],
		["NetworkAclId"] = args["NetworkAclId"],
		["RuleNumber"] = args["RuleNumber"],
		["DryRun"] = args["DryRun"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["Egress"] = args["Egress"],
		["RuleAction"] = args["RuleAction"],
		["PortRange"] = args["PortRange"],
		["Protocol"] = args["Protocol"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertReplaceNetworkAclEntryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointConnectionNotificationsResult = { ["NextToken"] = true, ["ConnectionNotificationSet"] = true, nil }

function asserts.AssertDescribeVpcEndpointConnectionNotificationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointConnectionNotificationsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["ConnectionNotificationSet"] then asserts.AssertConnectionNotificationSet(struct["ConnectionNotificationSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointConnectionNotificationsResult[k], "DescribeVpcEndpointConnectionNotificationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointConnectionNotificationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * ConnectionNotificationSet [ConnectionNotificationSet] <p>One or more notifications.</p>
-- @return DescribeVpcEndpointConnectionNotificationsResult structure as a key-value pair table
function M.DescribeVpcEndpointConnectionNotificationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointConnectionNotificationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["ConnectionNotificationSet"] = args["ConnectionNotificationSet"],
	}
	asserts.AssertDescribeVpcEndpointConnectionNotificationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcClassicLinkResult = { ["Vpcs"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkResult to be of type 'table'")
	if struct["Vpcs"] then asserts.AssertVpcClassicLinkList(struct["Vpcs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkResult[k], "DescribeVpcClassicLinkResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpcs [VpcClassicLinkList] <p>The ClassicLink status of one or more VPCs.</p>
-- @return DescribeVpcClassicLinkResult structure as a key-value pair table
function M.DescribeVpcClassicLinkResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcClassicLinkResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Vpcs"] = args["Vpcs"],
	}
	asserts.AssertDescribeVpcClassicLinkResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeEgressOnlyInternetGatewaysRequest = { ["EgressOnlyInternetGatewayIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeEgressOnlyInternetGatewaysRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeEgressOnlyInternetGatewaysRequest to be of type 'table'")
	if struct["EgressOnlyInternetGatewayIds"] then asserts.AssertEgressOnlyInternetGatewayIdList(struct["EgressOnlyInternetGatewayIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeEgressOnlyInternetGatewaysRequest[k], "DescribeEgressOnlyInternetGatewaysRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeEgressOnlyInternetGatewaysRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGatewayIds [EgressOnlyInternetGatewayIdList] <p>One or more egress-only internet gateway IDs.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000. If <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned.</p>
-- @return DescribeEgressOnlyInternetGatewaysRequest structure as a key-value pair table
function M.DescribeEgressOnlyInternetGatewaysRequest(args)
	assert(args, "You must provide an argument table when creating DescribeEgressOnlyInternetGatewaysRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EgressOnlyInternetGatewayIds"] = args["EgressOnlyInternetGatewayIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeEgressOnlyInternetGatewaysRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachVpnGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertDetachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachVpnGatewayRequest[k], "DetachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVpnGatewayRequest
-- <p>Contains the parameters for DetachVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required key: VpcId
-- Required key: VpnGatewayId
-- @return DetachVpnGatewayRequest structure as a key-value pair table
function M.DetachVpnGatewayRequest(args)
	assert(args, "You must provide an argument table when creating DetachVpnGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["VpnGatewayId"] = args["VpnGatewayId"],
	}
	asserts.AssertDetachVpnGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDefaultVpcRequest = { ["DryRun"] = true, nil }

function asserts.AssertCreateDefaultVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDefaultVpcRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDefaultVpcRequest[k], "CreateDefaultVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDefaultVpcRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- @return CreateDefaultVpcRequest structure as a key-value pair table
function M.CreateDefaultVpcRequest(args)
	assert(args, "You must provide an argument table when creating CreateDefaultVpcRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertCreateDefaultVpcRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PurchaseHostReservationRequest = { ["CurrencyCode"] = true, ["OfferingId"] = true, ["LimitPrice"] = true, ["HostIdSet"] = true, ["ClientToken"] = true, nil }

function asserts.AssertPurchaseHostReservationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PurchaseHostReservationRequest to be of type 'table'")
	assert(struct["HostIdSet"], "Expected key HostIdSet to exist in table")
	assert(struct["OfferingId"], "Expected key OfferingId to exist in table")
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["LimitPrice"] then asserts.AssertString(struct["LimitPrice"]) end
	if struct["HostIdSet"] then asserts.AssertRequestHostIdSet(struct["HostIdSet"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.PurchaseHostReservationRequest[k], "PurchaseHostReservationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PurchaseHostReservationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CurrencyCode [CurrencyCodeValues] <p>The currency in which the <code>totalUpfrontPrice</code>, <code>LimitPrice</code>, and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>
-- * OfferingId [String] <p>The ID of the offering.</p>
-- * LimitPrice [String] <p>The specified limit is checked against the total upfront cost of the reservation (calculated as the offering's upfront cost multiplied by the host count). If the total upfront cost is greater than the specified price limit, the request fails. This is used to ensure that the purchase does not exceed the expected upfront cost of the purchase. At this time, the only supported currency is <code>USD</code>. For example, to indicate a limit price of USD 100, specify 100.00.</p>
-- * HostIdSet [RequestHostIdSet] <p>The IDs of the Dedicated Hosts with which the reservation will be associated.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Run_Instance_Idempotency.html">How to Ensure Idempotency</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- Required key: HostIdSet
-- Required key: OfferingId
-- @return PurchaseHostReservationRequest structure as a key-value pair table
function M.PurchaseHostReservationRequest(args)
	assert(args, "You must provide an argument table when creating PurchaseHostReservationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CurrencyCode"] = args["CurrencyCode"],
		["OfferingId"] = args["OfferingId"],
		["LimitPrice"] = args["LimitPrice"],
		["HostIdSet"] = args["HostIdSet"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertPurchaseHostReservationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReleaseHostsResult = { ["Successful"] = true, ["Unsuccessful"] = true, nil }

function asserts.AssertReleaseHostsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReleaseHostsResult to be of type 'table'")
	if struct["Successful"] then asserts.AssertResponseHostIdList(struct["Successful"]) end
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemList(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReleaseHostsResult[k], "ReleaseHostsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReleaseHostsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Successful [ResponseHostIdList] <p>The IDs of the Dedicated Hosts that were successfully released.</p>
-- * Unsuccessful [UnsuccessfulItemList] <p>The IDs of the Dedicated Hosts that could not be released, including an error message.</p>
-- @return ReleaseHostsResult structure as a key-value pair table
function M.ReleaseHostsResult(args)
	assert(args, "You must provide an argument table when creating ReleaseHostsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Successful"] = args["Successful"],
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertReleaseHostsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcAttachment = { ["State"] = true, ["VpcId"] = true, nil }

function asserts.AssertVpcAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcAttachment to be of type 'table'")
	if struct["State"] then asserts.AssertAttachmentStatus(struct["State"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcAttachment[k], "VpcAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcAttachment
-- <p>Describes an attachment between a virtual private gateway and a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [AttachmentStatus] <p>The current state of the attachment.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- @return VpcAttachment structure as a key-value pair table
function M.VpcAttachment(args)
	assert(args, "You must provide an argument table when creating VpcAttachment")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["VpcId"] = args["VpcId"],
	}
	asserts.AssertVpcAttachment(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchSpecification = { ["UserData"] = true, ["SubnetId"] = true, ["Placement"] = true, ["Monitoring"] = true, ["ImageId"] = true, ["KeyName"] = true, ["BlockDeviceMappings"] = true, ["EbsOptimized"] = true, ["SecurityGroups"] = true, ["KernelId"] = true, ["RamdiskId"] = true, ["IamInstanceProfile"] = true, ["InstanceType"] = true, ["AddressingType"] = true, ["NetworkInterfaces"] = true, nil }

function asserts.AssertLaunchSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchSpecification to be of type 'table'")
	if struct["UserData"] then asserts.AssertString(struct["UserData"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Placement"] then asserts.AssertSpotPlacement(struct["Placement"]) end
	if struct["Monitoring"] then asserts.AssertRunInstancesMonitoringEnabled(struct["Monitoring"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfileSpecification(struct["IamInstanceProfile"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["AddressingType"] then asserts.AssertString(struct["AddressingType"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceSpecificationList(struct["NetworkInterfaces"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchSpecification[k], "LaunchSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchSpecification
-- <p>Describes the launch specification for an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UserData [String] <p>The Base64-encoded user data for the instance.</p>
-- * SubnetId [String] <p>The ID of the subnet in which to launch the instance.</p>
-- * Placement [SpotPlacement] <p>The placement information for the instance.</p>
-- * Monitoring [RunInstancesMonitoringEnabled] 
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * KeyName [String] <p>The name of the key pair.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>One or more block device mapping entries.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>
-- * SecurityGroups [GroupIdentifierList] <p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>
-- * KernelId [String] <p>The ID of the kernel.</p>
-- * RamdiskId [String] <p>The ID of the RAM disk.</p>
-- * IamInstanceProfile [IamInstanceProfileSpecification] <p>The IAM instance profile.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * AddressingType [String] <p>Deprecated.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceSpecificationList] <p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>
-- @return LaunchSpecification structure as a key-value pair table
function M.LaunchSpecification(args)
	assert(args, "You must provide an argument table when creating LaunchSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UserData"] = args["UserData"],
		["SubnetId"] = args["SubnetId"],
		["Placement"] = args["Placement"],
		["Monitoring"] = args["Monitoring"],
		["ImageId"] = args["ImageId"],
		["KeyName"] = args["KeyName"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["EbsOptimized"] = args["EbsOptimized"],
		["SecurityGroups"] = args["SecurityGroups"],
		["KernelId"] = args["KernelId"],
		["RamdiskId"] = args["RamdiskId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["InstanceType"] = args["InstanceType"],
		["AddressingType"] = args["AddressingType"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
	}
	asserts.AssertLaunchSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateRouteRequest = { ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["RouteTableId"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, nil }

function asserts.AssertCreateRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateRouteRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateRouteRequest[k], "CreateRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateRouteRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR address block used for the destination match. Routing decisions are based on the most specific match.</p>
-- * EgressOnlyInternetGatewayId [String] <p>[IPv6 traffic only] The ID of an egress-only internet gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceId [String] <p>The ID of a NAT instance in your VPC. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- * NetworkInterfaceId [String] <p>The ID of a network interface.</p>
-- * RouteTableId [String] <p>The ID of the route table for the route.</p>
-- * NatGatewayId [String] <p>[IPv4 traffic only] The ID of a NAT gateway.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of a VPC peering connection.</p>
-- * GatewayId [String] <p>The ID of an internet gateway or virtual private gateway attached to your VPC.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match. Routing decisions are based on the most specific match.</p>
-- Required key: RouteTableId
-- @return CreateRouteRequest structure as a key-value pair table
function M.CreateRouteRequest(args)
	assert(args, "You must provide an argument table when creating CreateRouteRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DryRun"] = args["DryRun"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["RouteTableId"] = args["RouteTableId"],
		["NatGatewayId"] = args["NatGatewayId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GatewayId"] = args["GatewayId"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
	}
	asserts.AssertCreateRouteRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateIamInstanceProfileResult = { ["IamInstanceProfileAssociation"] = true, nil }

function asserts.AssertAssociateIamInstanceProfileResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateIamInstanceProfileResult to be of type 'table'")
	if struct["IamInstanceProfileAssociation"] then asserts.AssertIamInstanceProfileAssociation(struct["IamInstanceProfileAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateIamInstanceProfileResult[k], "AssociateIamInstanceProfileResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateIamInstanceProfileResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociation [IamInstanceProfileAssociation] <p>Information about the IAM instance profile association.</p>
-- @return AssociateIamInstanceProfileResult structure as a key-value pair table
function M.AssociateIamInstanceProfileResult(args)
	assert(args, "You must provide an argument table when creating AssociateIamInstanceProfileResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IamInstanceProfileAssociation"] = args["IamInstanceProfileAssociation"],
	}
	asserts.AssertAssociateIamInstanceProfileResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MoveAddressToVpcResult = { ["Status"] = true, ["AllocationId"] = true, nil }

function asserts.AssertMoveAddressToVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MoveAddressToVpcResult to be of type 'table'")
	if struct["Status"] then asserts.AssertStatus(struct["Status"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.MoveAddressToVpcResult[k], "MoveAddressToVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MoveAddressToVpcResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [Status] <p>The status of the move of the IP address.</p>
-- * AllocationId [String] <p>The allocation ID for the Elastic IP address.</p>
-- @return MoveAddressToVpcResult structure as a key-value pair table
function M.MoveAddressToVpcResult(args)
	assert(args, "You must provide an argument table when creating MoveAddressToVpcResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["AllocationId"] = args["AllocationId"],
	}
	asserts.AssertMoveAddressToVpcResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyFleetResult = { ["Return"] = true, nil }

function asserts.AssertModifyFleetResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyFleetResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyFleetResult[k], "ModifyFleetResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyFleetResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
-- @return ModifyFleetResult structure as a key-value pair table
function M.ModifyFleetResult(args)
	assert(args, "You must provide an argument table when creating ModifyFleetResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertModifyFleetResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateDhcpOptionsRequest = { ["VpcId"] = true, ["DryRun"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertAssociateDhcpOptionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateDhcpOptionsRequest to be of type 'table'")
	assert(struct["DhcpOptionsId"], "Expected key DhcpOptionsId to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateDhcpOptionsRequest[k], "AssociateDhcpOptionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateDhcpOptionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * DhcpOptionsId [String] <p>The ID of the DHCP options set, or <code>default</code> to associate no DHCP options with the VPC.</p>
-- Required key: DhcpOptionsId
-- Required key: VpcId
-- @return AssociateDhcpOptionsRequest structure as a key-value pair table
function M.AssociateDhcpOptionsRequest(args)
	assert(args, "You must provide an argument table when creating AssociateDhcpOptionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
	}
	asserts.AssertAssociateDhcpOptionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteNetworkInterfacePermissionResult = { ["Return"] = true, nil }

function asserts.AssertDeleteNetworkInterfacePermissionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkInterfacePermissionResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkInterfacePermissionResult[k], "DeleteNetworkInterfacePermissionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkInterfacePermissionResult
-- <p>Contains the output for DeleteNetworkInterfacePermission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Returns <code>true</code> if the request succeeds, otherwise returns an error.</p>
-- @return DeleteNetworkInterfacePermissionResult structure as a key-value pair table
function M.DeleteNetworkInterfacePermissionResult(args)
	assert(args, "You must provide an argument table when creating DeleteNetworkInterfacePermissionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertDeleteNetworkInterfacePermissionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkInterfacePermissionsResult = { ["NetworkInterfacePermissions"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeNetworkInterfacePermissionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacePermissionsResult to be of type 'table'")
	if struct["NetworkInterfacePermissions"] then asserts.AssertNetworkInterfacePermissionList(struct["NetworkInterfacePermissions"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacePermissionsResult[k], "DescribeNetworkInterfacePermissionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacePermissionsResult
-- <p>Contains the output for DescribeNetworkInterfacePermissions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfacePermissions [NetworkInterfacePermissionList] <p>The network interface permissions.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results.</p>
-- @return DescribeNetworkInterfacePermissionsResult structure as a key-value pair table
function M.DescribeNetworkInterfacePermissionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkInterfacePermissionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfacePermissions"] = args["NetworkInterfacePermissions"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeNetworkInterfacePermissionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MovingAddressStatus = { ["PublicIp"] = true, ["MoveStatus"] = true, nil }

function asserts.AssertMovingAddressStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MovingAddressStatus to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["MoveStatus"] then asserts.AssertMoveStatus(struct["MoveStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.MovingAddressStatus[k], "MovingAddressStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MovingAddressStatus
-- <p>Describes the status of a moving Elastic IP address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * MoveStatus [MoveStatus] <p>The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.</p>
-- @return MovingAddressStatus structure as a key-value pair table
function M.MovingAddressStatus(args)
	assert(args, "You must provide an argument table when creating MovingAddressStatus")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["MoveStatus"] = args["MoveStatus"],
	}
	asserts.AssertMovingAddressStatus(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteSubnetRequest = { ["SubnetId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteSubnetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSubnetRequest to be of type 'table'")
	assert(struct["SubnetId"], "Expected key SubnetId to exist in table")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSubnetRequest[k], "DeleteSubnetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSubnetRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SubnetId
-- @return DeleteSubnetRequest structure as a key-value pair table
function M.DeleteSubnetRequest(args)
	assert(args, "You must provide an argument table when creating DeleteSubnetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteSubnetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotInstanceStateFault = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertSpotInstanceStateFault(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotInstanceStateFault to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotInstanceStateFault[k], "SpotInstanceStateFault contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotInstanceStateFault
-- <p>Describes a Spot Instance state change.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The message for the Spot Instance state change.</p>
-- * Code [String] <p>The reason code for the Spot Instance state change.</p>
-- @return SpotInstanceStateFault structure as a key-value pair table
function M.SpotInstanceStateFault(args)
	assert(args, "You must provide an argument table when creating SpotInstanceStateFault")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertSpotInstanceStateFault(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DhcpConfiguration = { ["Values"] = true, ["Key"] = true, nil }

function asserts.AssertDhcpConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpConfiguration to be of type 'table'")
	if struct["Values"] then asserts.AssertDhcpConfigurationValueList(struct["Values"]) end
	if struct["Key"] then asserts.AssertString(struct["Key"]) end
	for k,_ in pairs(struct) do
		assert(keys.DhcpConfiguration[k], "DhcpConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpConfiguration
-- <p>Describes a DHCP configuration option.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [DhcpConfigurationValueList] <p>One or more values for the DHCP option.</p>
-- * Key [String] <p>The name of a DHCP option.</p>
-- @return DhcpConfiguration structure as a key-value pair table
function M.DhcpConfiguration(args)
	assert(args, "You must provide an argument table when creating DhcpConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Key"] = args["Key"],
	}
	asserts.AssertDhcpConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeDetail = { ["Size"] = true, nil }

function asserts.AssertVolumeDetail(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeDetail to be of type 'table'")
	assert(struct["Size"], "Expected key Size to exist in table")
	if struct["Size"] then asserts.AssertLong(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeDetail[k], "VolumeDetail contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeDetail
-- <p>Describes an EBS volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Size [Long] <p>The size of the volume, in GiB.</p>
-- Required key: Size
-- @return VolumeDetail structure as a key-value pair table
function M.VolumeDetail(args)
	assert(args, "You must provide an argument table when creating VolumeDetail")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Size"] = args["Size"],
	}
	asserts.AssertVolumeDetail(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateVpcCidrBlockRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateVpcCidrBlockRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateVpcCidrBlockRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateVpcCidrBlockRequest[k], "DisassociateVpcCidrBlockRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateVpcCidrBlockRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The association ID for the CIDR block.</p>
-- Required key: AssociationId
-- @return DisassociateVpcCidrBlockRequest structure as a key-value pair table
function M.DisassociateVpcCidrBlockRequest(args)
	assert(args, "You must provide an argument table when creating DisassociateVpcCidrBlockRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertDisassociateVpcCidrBlockRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpnTunnelOptionsSpecification = { ["TunnelInsideCidr"] = true, ["PreSharedKey"] = true, nil }

function asserts.AssertVpnTunnelOptionsSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnTunnelOptionsSpecification to be of type 'table'")
	if struct["TunnelInsideCidr"] then asserts.AssertString(struct["TunnelInsideCidr"]) end
	if struct["PreSharedKey"] then asserts.AssertString(struct["PreSharedKey"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnTunnelOptionsSpecification[k], "VpnTunnelOptionsSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnTunnelOptionsSpecification
-- <p>The tunnel options for a VPN connection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TunnelInsideCidr [String] <p>The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p> <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p> <ul> <li> <p> <code>169.254.0.0/30</code> </p> </li> <li> <p> <code>169.254.1.0/30</code> </p> </li> <li> <p> <code>169.254.2.0/30</code> </p> </li> <li> <p> <code>169.254.3.0/30</code> </p> </li> <li> <p> <code>169.254.4.0/30</code> </p> </li> <li> <p> <code>169.254.5.0/30</code> </p> </li> <li> <p> <code>169.254.169.252/30</code> </p> </li> </ul>
-- * PreSharedKey [String] <p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.</p> <p>Constraints: Allowed characters are alphanumeric characters and ._. Must be between 8 and 64 characters in length and cannot start with zero (0).</p>
-- @return VpnTunnelOptionsSpecification structure as a key-value pair table
function M.VpnTunnelOptionsSpecification(args)
	assert(args, "You must provide an argument table when creating VpnTunnelOptionsSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TunnelInsideCidr"] = args["TunnelInsideCidr"],
		["PreSharedKey"] = args["PreSharedKey"],
	}
	asserts.AssertVpnTunnelOptionsSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Instance = { ["Monitoring"] = true, ["StateReason"] = true, ["PublicDnsName"] = true, ["Platform"] = true, ["State"] = true, ["EbsOptimized"] = true, ["LaunchTime"] = true, ["PublicIpAddress"] = true, ["RamdiskId"] = true, ["PrivateIpAddress"] = true, ["CapacityReservationId"] = true, ["ProductCodes"] = true, ["VpcId"] = true, ["CpuOptions"] = true, ["StateTransitionReason"] = true, ["InstanceId"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["PrivateDnsName"] = true, ["KeyName"] = true, ["SecurityGroups"] = true, ["ClientToken"] = true, ["SubnetId"] = true, ["InstanceType"] = true, ["CapacityReservationSpecification"] = true, ["NetworkInterfaces"] = true, ["SourceDestCheck"] = true, ["Placement"] = true, ["Hypervisor"] = true, ["InstanceLifecycle"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["KernelId"] = true, ["IamInstanceProfile"] = true, ["RootDeviceName"] = true, ["VirtualizationType"] = true, ["RootDeviceType"] = true, ["ElasticGpuAssociations"] = true, ["Tags"] = true, ["SpotInstanceRequestId"] = true, ["AmiLaunchIndex"] = true, nil }

function asserts.AssertInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Instance to be of type 'table'")
	if struct["Monitoring"] then asserts.AssertMonitoring(struct["Monitoring"]) end
	if struct["StateReason"] then asserts.AssertStateReason(struct["StateReason"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["State"] then asserts.AssertInstanceState(struct["State"]) end
	if struct["EbsOptimized"] then asserts.AssertBoolean(struct["EbsOptimized"]) end
	if struct["LaunchTime"] then asserts.AssertDateTime(struct["LaunchTime"]) end
	if struct["PublicIpAddress"] then asserts.AssertString(struct["PublicIpAddress"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["CapacityReservationId"] then asserts.AssertString(struct["CapacityReservationId"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["CpuOptions"] then asserts.AssertCpuOptions(struct["CpuOptions"]) end
	if struct["StateTransitionReason"] then asserts.AssertString(struct["StateTransitionReason"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["SecurityGroups"] then asserts.AssertGroupIdentifierList(struct["SecurityGroups"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["CapacityReservationSpecification"] then asserts.AssertCapacityReservationSpecificationResponse(struct["CapacityReservationSpecification"]) end
	if struct["NetworkInterfaces"] then asserts.AssertInstanceNetworkInterfaceList(struct["NetworkInterfaces"]) end
	if struct["SourceDestCheck"] then asserts.AssertBoolean(struct["SourceDestCheck"]) end
	if struct["Placement"] then asserts.AssertPlacement(struct["Placement"]) end
	if struct["Hypervisor"] then asserts.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["InstanceLifecycle"] then asserts.AssertInstanceLifecycleType(struct["InstanceLifecycle"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertInstanceBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["IamInstanceProfile"] then asserts.AssertIamInstanceProfile(struct["IamInstanceProfile"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["VirtualizationType"] then asserts.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["RootDeviceType"] then asserts.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["ElasticGpuAssociations"] then asserts.AssertElasticGpuAssociationList(struct["ElasticGpuAssociations"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	if struct["AmiLaunchIndex"] then asserts.AssertInteger(struct["AmiLaunchIndex"]) end
	for k,_ in pairs(struct) do
		assert(keys.Instance[k], "Instance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Instance
-- <p>Describes an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Monitoring [Monitoring] <p>The monitoring for the instance.</p>
-- * StateReason [StateReason] <p>The reason for the most recent state transition.</p>
-- * PublicDnsName [String] <p>(IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the <code>running</code> state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.</p>
-- * Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows instances; otherwise blank.</p>
-- * State [InstanceState] <p>The current state of the instance.</p>
-- * EbsOptimized [Boolean] <p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>
-- * LaunchTime [DateTime] <p>The time the instance was launched.</p>
-- * PublicIpAddress [String] <p>The public IPv4 address assigned to the instance, if applicable.</p>
-- * RamdiskId [String] <p>The RAM disk associated with this instance, if applicable.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 address assigned to the instance.</p>
-- * CapacityReservationId [String] <p>The ID of the Capacity Reservation.</p>
-- * ProductCodes [ProductCodeList] <p>The product codes attached to this instance, if applicable.</p>
-- * VpcId [String] <p>[EC2-VPC] The ID of the VPC in which the instance is running.</p>
-- * CpuOptions [CpuOptions] <p>The CPU options for the instance.</p>
-- * StateTransitionReason [String] <p>The reason for the most recent state transition. This might be an empty string.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- * SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * ImageId [String] <p>The ID of the AMI used to launch the instance.</p>
-- * PrivateDnsName [String] <p>(IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the <code>running</code> state. </p> <p>[EC2-VPC] The Amazon-provided DNS server resolves Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.</p>
-- * KeyName [String] <p>The name of the key pair, if this instance was launched with an associated key pair.</p>
-- * SecurityGroups [GroupIdentifierList] <p>One or more security groups for the instance.</p>
-- * ClientToken [String] <p>The idempotency token you provided when you launched the instance, if applicable.</p>
-- * SubnetId [String] <p>[EC2-VPC] The ID of the subnet in which the instance is running.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * CapacityReservationSpecification [CapacityReservationSpecificationResponse] <p>Information about the Capacity Reservation targeting option.</p>
-- * NetworkInterfaces [InstanceNetworkInterfaceList] <p>[EC2-VPC] One or more network interfaces for the instance.</p>
-- * SourceDestCheck [Boolean] <p>Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of <code>true</code> means that checking is enabled, and <code>false</code> means that checking is disabled. The value must be <code>false</code> for the instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- * Placement [Placement] <p>The location where the instance launched, if applicable.</p>
-- * Hypervisor [HypervisorType] <p>The hypervisor type of the instance.</p>
-- * InstanceLifecycle [InstanceLifecycleType] <p>Indicates whether this is a Spot Instance or a Scheduled Instance.</p>
-- * BlockDeviceMappings [InstanceBlockDeviceMappingList] <p>Any block device mapping entries for the instance.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- * KernelId [String] <p>The kernel associated with this instance, if applicable.</p>
-- * IamInstanceProfile [IamInstanceProfile] <p>The IAM instance profile associated with the instance, if applicable.</p>
-- * RootDeviceName [String] <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
-- * VirtualizationType [VirtualizationType] <p>The virtualization type of the instance.</p>
-- * RootDeviceType [DeviceType] <p>The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- * ElasticGpuAssociations [ElasticGpuAssociationList] <p>The Elastic GPU associated with the instance.</p>
-- * Tags [TagList] <p>Any tags assigned to the instance.</p>
-- * SpotInstanceRequestId [String] <p>If the request is a Spot Instance request, the ID of the request.</p>
-- * AmiLaunchIndex [Integer] <p>The AMI launch index, which can be used to find this instance in the launch group.</p>
-- @return Instance structure as a key-value pair table
function M.Instance(args)
	assert(args, "You must provide an argument table when creating Instance")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Monitoring"] = args["Monitoring"],
		["StateReason"] = args["StateReason"],
		["PublicDnsName"] = args["PublicDnsName"],
		["Platform"] = args["Platform"],
		["State"] = args["State"],
		["EbsOptimized"] = args["EbsOptimized"],
		["LaunchTime"] = args["LaunchTime"],
		["PublicIpAddress"] = args["PublicIpAddress"],
		["RamdiskId"] = args["RamdiskId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["CapacityReservationId"] = args["CapacityReservationId"],
		["ProductCodes"] = args["ProductCodes"],
		["VpcId"] = args["VpcId"],
		["CpuOptions"] = args["CpuOptions"],
		["StateTransitionReason"] = args["StateTransitionReason"],
		["InstanceId"] = args["InstanceId"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["ImageId"] = args["ImageId"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["KeyName"] = args["KeyName"],
		["SecurityGroups"] = args["SecurityGroups"],
		["ClientToken"] = args["ClientToken"],
		["SubnetId"] = args["SubnetId"],
		["InstanceType"] = args["InstanceType"],
		["CapacityReservationSpecification"] = args["CapacityReservationSpecification"],
		["NetworkInterfaces"] = args["NetworkInterfaces"],
		["SourceDestCheck"] = args["SourceDestCheck"],
		["Placement"] = args["Placement"],
		["Hypervisor"] = args["Hypervisor"],
		["InstanceLifecycle"] = args["InstanceLifecycle"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Architecture"] = args["Architecture"],
		["KernelId"] = args["KernelId"],
		["IamInstanceProfile"] = args["IamInstanceProfile"],
		["RootDeviceName"] = args["RootDeviceName"],
		["VirtualizationType"] = args["VirtualizationType"],
		["RootDeviceType"] = args["RootDeviceType"],
		["ElasticGpuAssociations"] = args["ElasticGpuAssociations"],
		["Tags"] = args["Tags"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
		["AmiLaunchIndex"] = args["AmiLaunchIndex"],
	}
	asserts.AssertInstance(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteNetworkInterfaceRequest = { ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkInterfaceRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkInterfaceRequest[k], "DeleteNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkInterfaceRequest
-- <p>Contains the parameters for DeleteNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: NetworkInterfaceId
-- @return DeleteNetworkInterfaceRequest structure as a key-value pair table
function M.DeleteNetworkInterfaceRequest(args)
	assert(args, "You must provide an argument table when creating DeleteNetworkInterfaceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteNetworkInterfaceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.IpPermission = { ["PrefixListIds"] = true, ["FromPort"] = true, ["IpRanges"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["UserIdGroupPairs"] = true, ["Ipv6Ranges"] = true, nil }

function asserts.AssertIpPermission(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected IpPermission to be of type 'table'")
	if struct["PrefixListIds"] then asserts.AssertPrefixListIdList(struct["PrefixListIds"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["IpRanges"] then asserts.AssertIpRangeList(struct["IpRanges"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["UserIdGroupPairs"] then asserts.AssertUserIdGroupPairList(struct["UserIdGroupPairs"]) end
	if struct["Ipv6Ranges"] then asserts.AssertIpv6RangeList(struct["Ipv6Ranges"]) end
	for k,_ in pairs(struct) do
		assert(keys.IpPermission[k], "IpPermission contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type IpPermission
-- <p>Describes a set of permissions for a security group rule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrefixListIds [PrefixListIdList] <p>[EC2-VPC only] One or more prefix list IDs for an AWS service. With <a>AuthorizeSecurityGroupEgress</a>, this is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
-- * IpRanges [IpRangeList] <p>One or more IPv4 ranges.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes for the specified ICMP type. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>
-- * IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). </p> <p>[EC2-VPC only] Use <code>-1</code> to specify all protocols. When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>58</code> (ICMPv6) allows traffic on all ports, regardless of any port range you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>58</code> (ICMPv6), you can optionally specify a port range; if you don't, traffic for all types and codes is allowed when authorizing rules. </p>
-- * UserIdGroupPairs [UserIdGroupPairList] <p>One or more security group and AWS account ID pairs.</p>
-- * Ipv6Ranges [Ipv6RangeList] <p>[EC2-VPC only] One or more IPv6 ranges.</p>
-- @return IpPermission structure as a key-value pair table
function M.IpPermission(args)
	assert(args, "You must provide an argument table when creating IpPermission")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrefixListIds"] = args["PrefixListIds"],
		["FromPort"] = args["FromPort"],
		["IpRanges"] = args["IpRanges"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["UserIdGroupPairs"] = args["UserIdGroupPairs"],
		["Ipv6Ranges"] = args["Ipv6Ranges"],
	}
	asserts.AssertIpPermission(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpnConnectionOptionsSpecification = { ["TunnelOptions"] = true, ["StaticRoutesOnly"] = true, nil }

function asserts.AssertVpnConnectionOptionsSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpnConnectionOptionsSpecification to be of type 'table'")
	if struct["TunnelOptions"] then asserts.AssertTunnelOptionsList(struct["TunnelOptions"]) end
	if struct["StaticRoutesOnly"] then asserts.AssertBoolean(struct["StaticRoutesOnly"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpnConnectionOptionsSpecification[k], "VpnConnectionOptionsSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpnConnectionOptionsSpecification
-- <p>Describes VPN connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TunnelOptions [TunnelOptionsList] <p>The tunnel options for the VPN connection.</p>
-- * StaticRoutesOnly [Boolean] <p>Indicate whether the VPN connection uses static routes only. If you are creating a VPN connection for a device that does not support BGP, you must specify <code>true</code>. Use <a>CreateVpnConnectionRoute</a> to create a static route.</p> <p>Default: <code>false</code> </p>
-- @return VpnConnectionOptionsSpecification structure as a key-value pair table
function M.VpnConnectionOptionsSpecification(args)
	assert(args, "You must provide an argument table when creating VpnConnectionOptionsSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TunnelOptions"] = args["TunnelOptions"],
		["StaticRoutesOnly"] = args["StaticRoutesOnly"],
	}
	asserts.AssertVpnConnectionOptionsSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkAclsResult = { ["NetworkAcls"] = true, nil }

function asserts.AssertDescribeNetworkAclsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkAclsResult to be of type 'table'")
	if struct["NetworkAcls"] then asserts.AssertNetworkAclList(struct["NetworkAcls"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkAclsResult[k], "DescribeNetworkAclsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkAclsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkAcls [NetworkAclList] <p>Information about one or more network ACLs.</p>
-- @return DescribeNetworkAclsResult structure as a key-value pair table
function M.DescribeNetworkAclsResult(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkAclsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkAcls"] = args["NetworkAcls"],
	}
	asserts.AssertDescribeNetworkAclsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateTagsRequest = { ["DryRun"] = true, ["Resources"] = true, ["Tags"] = true, nil }

function asserts.AssertCreateTagsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateTagsRequest to be of type 'table'")
	assert(struct["Resources"], "Expected key Resources to exist in table")
	assert(struct["Tags"], "Expected key Tags to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Resources"] then asserts.AssertResourceIdList(struct["Resources"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateTagsRequest[k], "CreateTagsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateTagsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Resources [ResourceIdList] <p>The IDs of one or more resources, separated by spaces.</p>
-- * Tags [TagList] <p>One or more tags. The <code>value</code> parameter is required, but if you don't want the tag to have a value, specify the parameter with no value, and we set the value to an empty string. </p>
-- Required key: Resources
-- Required key: Tags
-- @return CreateTagsRequest structure as a key-value pair table
function M.CreateTagsRequest(args)
	assert(args, "You must provide an argument table when creating CreateTagsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Resources"] = args["Resources"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertCreateTagsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.HostOffering = { ["HourlyPrice"] = true, ["OfferingId"] = true, ["CurrencyCode"] = true, ["InstanceFamily"] = true, ["PaymentOption"] = true, ["UpfrontPrice"] = true, ["Duration"] = true, nil }

function asserts.AssertHostOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected HostOffering to be of type 'table'")
	if struct["HourlyPrice"] then asserts.AssertString(struct["HourlyPrice"]) end
	if struct["OfferingId"] then asserts.AssertString(struct["OfferingId"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["InstanceFamily"] then asserts.AssertString(struct["InstanceFamily"]) end
	if struct["PaymentOption"] then asserts.AssertPaymentOption(struct["PaymentOption"]) end
	if struct["UpfrontPrice"] then asserts.AssertString(struct["UpfrontPrice"]) end
	if struct["Duration"] then asserts.AssertInteger(struct["Duration"]) end
	for k,_ in pairs(struct) do
		assert(keys.HostOffering[k], "HostOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type HostOffering
-- <p>Details about the Dedicated Host Reservation offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HourlyPrice [String] <p>The hourly price of the offering.</p>
-- * OfferingId [String] <p>The ID of the offering.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency of the offering.</p>
-- * InstanceFamily [String] <p>The instance family of the offering.</p>
-- * PaymentOption [PaymentOption] <p>The available payment option.</p>
-- * UpfrontPrice [String] <p>The upfront price of the offering. Does not apply to No Upfront offerings.</p>
-- * Duration [Integer] <p>The duration of the offering (in seconds).</p>
-- @return HostOffering structure as a key-value pair table
function M.HostOffering(args)
	assert(args, "You must provide an argument table when creating HostOffering")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HourlyPrice"] = args["HourlyPrice"],
		["OfferingId"] = args["OfferingId"],
		["CurrencyCode"] = args["CurrencyCode"],
		["InstanceFamily"] = args["InstanceFamily"],
		["PaymentOption"] = args["PaymentOption"],
		["UpfrontPrice"] = args["UpfrontPrice"],
		["Duration"] = args["Duration"],
	}
	asserts.AssertHostOffering(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FleetLaunchTemplateSpecification = { ["LaunchTemplateName"] = true, ["Version"] = true, ["LaunchTemplateId"] = true, nil }

function asserts.AssertFleetLaunchTemplateSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FleetLaunchTemplateSpecification to be of type 'table'")
	if struct["LaunchTemplateName"] then asserts.AssertLaunchTemplateName(struct["LaunchTemplateName"]) end
	if struct["Version"] then asserts.AssertString(struct["Version"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.FleetLaunchTemplateSpecification[k], "FleetLaunchTemplateSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FleetLaunchTemplateSpecification
-- <p>Describes a launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateName [LaunchTemplateName] <p>The name of the launch template. You must specify either a template name or a template ID.</p>
-- * Version [String] <p>The version number of the launch template. You must specify a version number.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template. You must specify either a template ID or a template name.</p>
-- @return FleetLaunchTemplateSpecification structure as a key-value pair table
function M.FleetLaunchTemplateSpecification(args)
	assert(args, "You must provide an argument table when creating FleetLaunchTemplateSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["Version"] = args["Version"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
	}
	asserts.AssertFleetLaunchTemplateSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcClassicLinkDnsSupportRequest = { ["NextToken"] = true, ["MaxResults"] = true, ["VpcIds"] = true, nil }

function asserts.AssertDescribeVpcClassicLinkDnsSupportRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcClassicLinkDnsSupportRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertMaxResults(struct["MaxResults"]) end
	if struct["VpcIds"] then asserts.AssertVpcClassicLinkIdList(struct["VpcIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcClassicLinkDnsSupportRequest[k], "DescribeVpcClassicLinkDnsSupportRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcClassicLinkDnsSupportRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [NextToken] <p>The token for the next set of items to return. (You received this token from a prior call.)</p>
-- * MaxResults [MaxResults] <p>The maximum number of items to return for this request. The request returns a token that you can specify in a subsequent call to get the next set of results.</p>
-- * VpcIds [VpcClassicLinkIdList] <p>One or more VPC IDs.</p>
-- @return DescribeVpcClassicLinkDnsSupportRequest structure as a key-value pair table
function M.DescribeVpcClassicLinkDnsSupportRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcClassicLinkDnsSupportRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["VpcIds"] = args["VpcIds"],
	}
	asserts.AssertDescribeVpcClassicLinkDnsSupportRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotFleetMonitoring = { ["Enabled"] = true, nil }

function asserts.AssertSpotFleetMonitoring(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetMonitoring to be of type 'table'")
	if struct["Enabled"] then asserts.AssertBoolean(struct["Enabled"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetMonitoring[k], "SpotFleetMonitoring contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetMonitoring
-- <p>Describes whether monitoring is enabled.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Enabled [Boolean] <p>Enables monitoring for the instance.</p> <p>Default: <code>false</code> </p>
-- @return SpotFleetMonitoring structure as a key-value pair table
function M.SpotFleetMonitoring(args)
	assert(args, "You must provide an argument table when creating SpotFleetMonitoring")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Enabled"] = args["Enabled"],
	}
	asserts.AssertSpotFleetMonitoring(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotInstanceRequestsRequest = { ["SpotInstanceRequestIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeSpotInstanceRequestsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsRequest to be of type 'table'")
	if struct["SpotInstanceRequestIds"] then asserts.AssertSpotInstanceRequestIdList(struct["SpotInstanceRequestIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotInstanceRequestsRequest[k], "DescribeSpotInstanceRequestsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsRequest
-- <p>Contains the parameters for DescribeSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequestIds [SpotInstanceRequestIdList] <p>One or more Spot Instance request IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone-group</code> - The Availability Zone group.</p> </li> <li> <p> <code>create-time</code> - The time stamp when the Spot Instance request was created.</p> </li> <li> <p> <code>fault-code</code> - The fault code related to the request.</p> </li> <li> <p> <code>fault-message</code> - The fault message related to the request.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance that fulfilled the request.</p> </li> <li> <p> <code>launch-group</code> - The Spot Instance launch group.</p> </li> <li> <p> <code>launch.block-device-mapping.delete-on-termination</code> - Indicates whether the EBS volume is deleted on instance termination.</p> </li> <li> <p> <code>launch.block-device-mapping.device-name</code> - The device name for the volume in the block device mapping (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p> </li> <li> <p> <code>launch.block-device-mapping.snapshot-id</code> - The ID of the snapshot for the EBS volume.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-size</code> - The size of the EBS volume, in GiB.</p> </li> <li> <p> <code>launch.block-device-mapping.volume-type</code> - The type of EBS volume: <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code>for Cold HDD, or <code>standard</code> for Magnetic.</p> </li> <li> <p> <code>launch.group-id</code> - The ID of the security group for the instance.</p> </li> <li> <p> <code>launch.group-name</code> - The name of the security group for the instance.</p> </li> <li> <p> <code>launch.image-id</code> - The ID of the AMI.</p> </li> <li> <p> <code>launch.instance-type</code> - The type of instance (for example, <code>m3.medium</code>).</p> </li> <li> <p> <code>launch.kernel-id</code> - The kernel ID.</p> </li> <li> <p> <code>launch.key-name</code> - The name of the key pair the instance launched with.</p> </li> <li> <p> <code>launch.monitoring-enabled</code> - Whether detailed monitoring is enabled for the Spot Instance.</p> </li> <li> <p> <code>launch.ramdisk-id</code> - The RAM disk ID.</p> </li> <li> <p> <code>launched-availability-zone</code> - The Availability Zone in which the request is launched.</p> </li> <li> <p> <code>network-interface.addresses.primary</code> - Indicates whether the IP address is the primary private IP address.</p> </li> <li> <p> <code>network-interface.delete-on-termination</code> - Indicates whether the network interface is deleted when the instance is terminated.</p> </li> <li> <p> <code>network-interface.description</code> - A description of the network interface.</p> </li> <li> <p> <code>network-interface.device-index</code> - The index of the device for the network interface attachment on the instance.</p> </li> <li> <p> <code>network-interface.group-id</code> - The ID of the security group associated with the network interface.</p> </li> <li> <p> <code>network-interface.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface.private-ip-address</code> - The primary private IP address of the network interface.</p> </li> <li> <p> <code>network-interface.subnet-id</code> - The ID of the subnet for the instance.</p> </li> <li> <p> <code>product-description</code> - The product description associated with the instance (<code>Linux/UNIX</code> | <code>Windows</code>).</p> </li> <li> <p> <code>spot-instance-request-id</code> - The Spot Instance request ID.</p> </li> <li> <p> <code>spot-price</code> - The maximum hourly price for any Spot Instance launched to fulfill the request.</p> </li> <li> <p> <code>state</code> - The state of the Spot Instance request (<code>open</code> | <code>active</code> | <code>closed</code> | <code>cancelled</code> | <code>failed</code>). Spot request status information can help you track your Amazon EC2 Spot Instance requests. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html">Spot Request Status</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p> </li> <li> <p> <code>status-code</code> - The short code describing the most recent evaluation of your Spot Instance request.</p> </li> <li> <p> <code>status-message</code> - The message explaining the status of the Spot Instance request.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>type</code> - The type of Spot Instance request (<code>one-time</code> | <code>persistent</code>).</p> </li> <li> <p> <code>valid-from</code> - The start date of the request.</p> </li> <li> <p> <code>valid-until</code> - The end date of the request.</p> </li> </ul>
-- @return DescribeSpotInstanceRequestsRequest structure as a key-value pair table
function M.DescribeSpotInstanceRequestsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSpotInstanceRequestsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotInstanceRequestIds"] = args["SpotInstanceRequestIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeSpotInstanceRequestsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateBlockDeviceMappingRequest = { ["DeviceName"] = true, ["VirtualName"] = true, ["NoDevice"] = true, ["Ebs"] = true, nil }

function asserts.AssertLaunchTemplateBlockDeviceMappingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateBlockDeviceMappingRequest to be of type 'table'")
	if struct["DeviceName"] then asserts.AssertString(struct["DeviceName"]) end
	if struct["VirtualName"] then asserts.AssertString(struct["VirtualName"]) end
	if struct["NoDevice"] then asserts.AssertString(struct["NoDevice"]) end
	if struct["Ebs"] then asserts.AssertLaunchTemplateEbsBlockDeviceRequest(struct["Ebs"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateBlockDeviceMappingRequest[k], "LaunchTemplateBlockDeviceMappingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateBlockDeviceMappingRequest
-- <p>Describes a block device mapping.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceName [String] <p>The device name (for example, /dev/sdh or xvdh).</p>
-- * VirtualName [String] <p>The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p>
-- * NoDevice [String] <p>Suppresses the specified device included in the block device mapping of the AMI.</p>
-- * Ebs [LaunchTemplateEbsBlockDeviceRequest] <p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>
-- @return LaunchTemplateBlockDeviceMappingRequest structure as a key-value pair table
function M.LaunchTemplateBlockDeviceMappingRequest(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateBlockDeviceMappingRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceName"] = args["DeviceName"],
		["VirtualName"] = args["VirtualName"],
		["NoDevice"] = args["NoDevice"],
		["Ebs"] = args["Ebs"],
	}
	asserts.AssertLaunchTemplateBlockDeviceMappingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteRouteTableRequest = { ["RouteTableId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteRouteTableRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteRouteTableRequest to be of type 'table'")
	assert(struct["RouteTableId"], "Expected key RouteTableId to exist in table")
	if struct["RouteTableId"] then asserts.AssertString(struct["RouteTableId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteRouteTableRequest[k], "DeleteRouteTableRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteRouteTableRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTableId [String] <p>The ID of the route table.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: RouteTableId
-- @return DeleteRouteTableRequest structure as a key-value pair table
function M.DeleteRouteTableRequest(args)
	assert(args, "You must provide an argument table when creating DeleteRouteTableRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["RouteTableId"] = args["RouteTableId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteRouteTableRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpnConnectionRouteRequest = { ["VpnConnectionId"] = true, ["DestinationCidrBlock"] = true, nil }

function asserts.AssertCreateVpnConnectionRouteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionRouteRequest to be of type 'table'")
	assert(struct["DestinationCidrBlock"], "Expected key DestinationCidrBlock to exist in table")
	assert(struct["VpnConnectionId"], "Expected key VpnConnectionId to exist in table")
	if struct["VpnConnectionId"] then asserts.AssertString(struct["VpnConnectionId"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionRouteRequest[k], "CreateVpnConnectionRouteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionRouteRequest
-- <p>Contains the parameters for CreateVpnConnectionRoute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnectionId [String] <p>The ID of the VPN connection.</p>
-- * DestinationCidrBlock [String] <p>The CIDR block associated with the local subnet of the customer network.</p>
-- Required key: DestinationCidrBlock
-- Required key: VpnConnectionId
-- @return CreateVpnConnectionRouteRequest structure as a key-value pair table
function M.CreateVpnConnectionRouteRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpnConnectionRouteRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpnConnectionId"] = args["VpnConnectionId"],
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
	}
	asserts.AssertCreateVpnConnectionRouteRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpnGatewayRequest = { ["AmazonSideAsn"] = true, ["DryRun"] = true, ["AvailabilityZone"] = true, ["Type"] = true, nil }

function asserts.AssertCreateVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnGatewayRequest to be of type 'table'")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["AmazonSideAsn"] then asserts.AssertLong(struct["AmazonSideAsn"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnGatewayRequest[k], "CreateVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnGatewayRequest
-- <p>Contains the parameters for CreateVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AmazonSideAsn [Long] <p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. If you're using a 16-bit ASN, it must be in the 64512 to 65534 range. If you're using a 32-bit ASN, it must be in the 4200000000 to 4294967294 range.</p> <p>Default: 64512</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AvailabilityZone [String] <p>The Availability Zone for the virtual private gateway.</p>
-- * Type [GatewayType] <p>The type of VPN connection this virtual private gateway supports.</p>
-- Required key: Type
-- @return CreateVpnGatewayRequest structure as a key-value pair table
function M.CreateVpnGatewayRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpnGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AmazonSideAsn"] = args["AmazonSideAsn"],
		["DryRun"] = args["DryRun"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Type"] = args["Type"],
	}
	asserts.AssertCreateVpnGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcPeeringConnectionsResult = { ["VpcPeeringConnections"] = true, nil }

function asserts.AssertDescribeVpcPeeringConnectionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsResult to be of type 'table'")
	if struct["VpcPeeringConnections"] then asserts.AssertVpcPeeringConnectionList(struct["VpcPeeringConnections"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcPeeringConnectionsResult[k], "DescribeVpcPeeringConnectionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnections [VpcPeeringConnectionList] <p>Information about the VPC peering connections.</p>
-- @return DescribeVpcPeeringConnectionsResult structure as a key-value pair table
function M.DescribeVpcPeeringConnectionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcPeeringConnectionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcPeeringConnections"] = args["VpcPeeringConnections"],
	}
	asserts.AssertDescribeVpcPeeringConnectionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateDhcpOptionsResult = { ["DhcpOptions"] = true, nil }

function asserts.AssertCreateDhcpOptionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateDhcpOptionsResult to be of type 'table'")
	if struct["DhcpOptions"] then asserts.AssertDhcpOptions(struct["DhcpOptions"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateDhcpOptionsResult[k], "CreateDhcpOptionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateDhcpOptionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DhcpOptions [DhcpOptions] <p>A set of DHCP options.</p>
-- @return CreateDhcpOptionsResult structure as a key-value pair table
function M.CreateDhcpOptionsResult(args)
	assert(args, "You must provide an argument table when creating CreateDhcpOptionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DhcpOptions"] = args["DhcpOptions"],
	}
	asserts.AssertCreateDhcpOptionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteKeyPairRequest = { ["KeyName"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteKeyPairRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteKeyPairRequest to be of type 'table'")
	assert(struct["KeyName"], "Expected key KeyName to exist in table")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteKeyPairRequest[k], "DeleteKeyPairRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteKeyPairRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>The name of the key pair.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: KeyName
-- @return DeleteKeyPairRequest structure as a key-value pair table
function M.DeleteKeyPairRequest(args)
	assert(args, "You must provide an argument table when creating DeleteKeyPairRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyName"] = args["KeyName"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteKeyPairRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EventInformation = { ["InstanceId"] = true, ["EventSubType"] = true, ["EventDescription"] = true, nil }

function asserts.AssertEventInformation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EventInformation to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["EventSubType"] then asserts.AssertString(struct["EventSubType"]) end
	if struct["EventDescription"] then asserts.AssertString(struct["EventDescription"]) end
	for k,_ in pairs(struct) do
		assert(keys.EventInformation[k], "EventInformation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EventInformation
-- <p>Describes a Spot Fleet event.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance. This information is available only for <code>instanceChange</code> events.</p>
-- * EventSubType [String] <p>The event.</p> <p>The following are the <code>error</code> events:</p> <ul> <li> <p> <code>iamFleetRoleInvalid</code> - The Spot Fleet did not have the required permissions either to launch or terminate an instance.</p> </li> <li> <p> <code>launchSpecTemporarilyBlacklisted</code> - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.</p> </li> <li> <p> <code>spotFleetRequestConfigurationInvalid</code> - The configuration is not valid. For more information, see the description of the event.</p> </li> <li> <p> <code>spotInstanceCountLimitExceeded</code> - You've reached the limit on the number of Spot Instances that you can launch.</p> </li> </ul> <p>The following are the <code>fleetRequestChange</code> events:</p> <ul> <li> <p> <code>active</code> - The Spot Fleet has been validated and Amazon EC2 is attempting to maintain the target number of running Spot Instances.</p> </li> <li> <p> <code>cancelled</code> - The Spot Fleet is canceled and has no running Spot Instances. The Spot Fleet will be deleted two days after its instances were terminated.</p> </li> <li> <p> <code>cancelled_running</code> - The Spot Fleet is canceled and does not launch additional Spot Instances. Existing Spot Instances continue to run until they are interrupted or terminated.</p> </li> <li> <p> <code>cancelled_terminating</code> - The Spot Fleet is canceled and its Spot Instances are terminating.</p> </li> <li> <p> <code>expired</code> - The Spot Fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with <code>TerminateInstancesWithExpiration</code> set.</p> </li> <li> <p> <code>modify_in_progress</code> - A request to modify the Spot Fleet request was accepted and is in progress.</p> </li> <li> <p> <code>modify_successful</code> - The Spot Fleet request was modified.</p> </li> <li> <p> <code>price_update</code> - The price for a launch configuration was adjusted because it was too high. This change is permanent.</p> </li> <li> <p> <code>submitted</code> - The Spot Fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot Instances.</p> </li> </ul> <p>The following are the <code>instanceChange</code> events:</p> <ul> <li> <p> <code>launched</code> - A request was fulfilled and a new instance was launched.</p> </li> <li> <p> <code>terminated</code> - An instance was terminated by the user.</p> </li> </ul> <p>The following are the <code>Information</code> events:</p> <ul> <li> <p> <code>launchSpecUnusable</code> - The price in a launch specification is not valid because it is below the Spot price or the Spot price is above the On-Demand price.</p> </li> <li> <p> <code>fleetProgressHalted</code> - The price in every launch specification is not valid. A launch specification might become valid if the Spot price changes.</p> </li> </ul>
-- * EventDescription [String] <p>The description of the event.</p>
-- @return EventInformation structure as a key-value pair table
function M.EventInformation(args)
	assert(args, "You must provide an argument table when creating EventInformation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["EventSubType"] = args["EventSubType"],
		["EventDescription"] = args["EventDescription"],
	}
	asserts.AssertEventInformation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TerminateInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertTerminateInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TerminateInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.TerminateInstancesRequest[k], "TerminateInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TerminateInstancesRequest
-- <p>Contains the parameters for TerminateInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p> <p>Constraints: Up to 1000 instance IDs. We recommend breaking up this request into smaller batches.</p>
-- Required key: InstanceIds
-- @return TerminateInstancesRequest structure as a key-value pair table
function M.TerminateInstancesRequest(args)
	assert(args, "You must provide an argument table when creating TerminateInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertTerminateInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpnConnectionResult = { ["VpnConnection"] = true, nil }

function asserts.AssertCreateVpnConnectionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpnConnectionResult to be of type 'table'")
	if struct["VpnConnection"] then asserts.AssertVpnConnection(struct["VpnConnection"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpnConnectionResult[k], "CreateVpnConnectionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpnConnectionResult
-- <p>Contains the output of CreateVpnConnection.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpnConnection [VpnConnection] <p>Information about the VPN connection.</p>
-- @return CreateVpnConnectionResult structure as a key-value pair table
function M.CreateVpnConnectionResult(args)
	assert(args, "You must provide an argument table when creating CreateVpnConnectionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpnConnection"] = args["VpnConnection"],
	}
	asserts.AssertCreateVpnConnectionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceStatusDetails = { ["Status"] = true, ["ImpairedSince"] = true, ["Name"] = true, nil }

function asserts.AssertInstanceStatusDetails(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatusDetails to be of type 'table'")
	if struct["Status"] then asserts.AssertStatusType(struct["Status"]) end
	if struct["ImpairedSince"] then asserts.AssertDateTime(struct["ImpairedSince"]) end
	if struct["Name"] then asserts.AssertStatusName(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatusDetails[k], "InstanceStatusDetails contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatusDetails
-- <p>Describes the instance status.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [StatusType] <p>The status.</p>
-- * ImpairedSince [DateTime] <p>The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.</p>
-- * Name [StatusName] <p>The type of instance status.</p>
-- @return InstanceStatusDetails structure as a key-value pair table
function M.InstanceStatusDetails(args)
	assert(args, "You must provide an argument table when creating InstanceStatusDetails")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["ImpairedSince"] = args["ImpairedSince"],
		["Name"] = args["Name"],
	}
	asserts.AssertInstanceStatusDetails(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SlotStartTimeRangeRequest = { ["LatestTime"] = true, ["EarliestTime"] = true, nil }

function asserts.AssertSlotStartTimeRangeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SlotStartTimeRangeRequest to be of type 'table'")
	if struct["LatestTime"] then asserts.AssertDateTime(struct["LatestTime"]) end
	if struct["EarliestTime"] then asserts.AssertDateTime(struct["EarliestTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.SlotStartTimeRangeRequest[k], "SlotStartTimeRangeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SlotStartTimeRangeRequest
-- <p>Describes the time period for a Scheduled Instance to start its first schedule.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LatestTime [DateTime] <p>The latest date and time, in UTC, for the Scheduled Instance to start.</p>
-- * EarliestTime [DateTime] <p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>
-- @return SlotStartTimeRangeRequest structure as a key-value pair table
function M.SlotStartTimeRangeRequest(args)
	assert(args, "You must provide an argument table when creating SlotStartTimeRangeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LatestTime"] = args["LatestTime"],
		["EarliestTime"] = args["EarliestTime"],
	}
	asserts.AssertSlotStartTimeRangeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeRouteTablesResult = { ["NextToken"] = true, ["RouteTables"] = true, nil }

function asserts.AssertDescribeRouteTablesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["RouteTables"] then asserts.AssertRouteTableList(struct["RouteTables"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRouteTablesResult[k], "DescribeRouteTablesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesResult
-- <p>Contains the output of DescribeRouteTables.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * RouteTables [RouteTableList] <p>Information about one or more route tables.</p>
-- @return DescribeRouteTablesResult structure as a key-value pair table
function M.DescribeRouteTablesResult(args)
	assert(args, "You must provide an argument table when creating DescribeRouteTablesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["RouteTables"] = args["RouteTables"],
	}
	asserts.AssertDescribeRouteTablesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CancelSpotFleetRequestsError = { ["Message"] = true, ["Code"] = true, nil }

function asserts.AssertCancelSpotFleetRequestsError(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CancelSpotFleetRequestsError to be of type 'table'")
	assert(struct["Code"], "Expected key Code to exist in table")
	assert(struct["Message"], "Expected key Message to exist in table")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	if struct["Code"] then asserts.AssertCancelBatchErrorCode(struct["Code"]) end
	for k,_ in pairs(struct) do
		assert(keys.CancelSpotFleetRequestsError[k], "CancelSpotFleetRequestsError contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CancelSpotFleetRequestsError
-- <p>Describes a Spot Fleet error.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The description for the error code.</p>
-- * Code [CancelBatchErrorCode] <p>The error code.</p>
-- Required key: Code
-- Required key: Message
-- @return CancelSpotFleetRequestsError structure as a key-value pair table
function M.CancelSpotFleetRequestsError(args)
	assert(args, "You must provide an argument table when creating CancelSpotFleetRequestsError")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
		["Code"] = args["Code"],
	}
	asserts.AssertCancelSpotFleetRequestsError(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotFleetRequestConfig = { ["SpotFleetRequestState"] = true, ["SpotFleetRequestId"] = true, ["ActivityStatus"] = true, ["CreateTime"] = true, ["SpotFleetRequestConfig"] = true, nil }

function asserts.AssertSpotFleetRequestConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotFleetRequestConfig to be of type 'table'")
	assert(struct["CreateTime"], "Expected key CreateTime to exist in table")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["SpotFleetRequestState"], "Expected key SpotFleetRequestState to exist in table")
	if struct["SpotFleetRequestState"] then asserts.AssertBatchState(struct["SpotFleetRequestState"]) end
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["ActivityStatus"] then asserts.AssertActivityStatus(struct["ActivityStatus"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["SpotFleetRequestConfig"] then asserts.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotFleetRequestConfig[k], "SpotFleetRequestConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotFleetRequestConfig
-- <p>Describes a Spot Fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestState [BatchState] <p>The state of the Spot Fleet request.</p>
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- * ActivityStatus [ActivityStatus] <p>The progress of the Spot Fleet request. If there is an error, the status is <code>error</code>. After all requests are placed, the status is <code>pending_fulfillment</code>. If the size of the fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>. If the size of the fleet is decreased, the status is <code>pending_termination</code> while Spot Instances are terminating.</p>
-- * CreateTime [DateTime] <p>The creation date and time of the request.</p>
-- * SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>The configuration of the Spot Fleet request.</p>
-- Required key: CreateTime
-- Required key: SpotFleetRequestConfig
-- Required key: SpotFleetRequestId
-- Required key: SpotFleetRequestState
-- @return SpotFleetRequestConfig structure as a key-value pair table
function M.SpotFleetRequestConfig(args)
	assert(args, "You must provide an argument table when creating SpotFleetRequestConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestState"] = args["SpotFleetRequestState"],
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["ActivityStatus"] = args["ActivityStatus"],
		["CreateTime"] = args["CreateTime"],
		["SpotFleetRequestConfig"] = args["SpotFleetRequestConfig"],
	}
	asserts.AssertSpotFleetRequestConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotFleetRequestHistoryRequest = { ["SpotFleetRequestId"] = true, ["DryRun"] = true, ["EventType"] = true, ["MaxResults"] = true, ["StartTime"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeSpotFleetRequestHistoryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotFleetRequestHistoryRequest to be of type 'table'")
	assert(struct["SpotFleetRequestId"], "Expected key SpotFleetRequestId to exist in table")
	assert(struct["StartTime"], "Expected key StartTime to exist in table")
	if struct["SpotFleetRequestId"] then asserts.AssertString(struct["SpotFleetRequestId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["EventType"] then asserts.AssertEventType(struct["EventType"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotFleetRequestHistoryRequest[k], "DescribeSpotFleetRequestHistoryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotFleetRequestHistoryRequest
-- <p>Contains the parameters for DescribeSpotFleetRequestHistory.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestId [String] <p>The ID of the Spot Fleet request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * EventType [EventType] <p>The type of events to describe. By default, all events are described.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- * StartTime [DateTime] <p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- Required key: SpotFleetRequestId
-- Required key: StartTime
-- @return DescribeSpotFleetRequestHistoryRequest structure as a key-value pair table
function M.DescribeSpotFleetRequestHistoryRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSpotFleetRequestHistoryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestId"] = args["SpotFleetRequestId"],
		["DryRun"] = args["DryRun"],
		["EventType"] = args["EventType"],
		["MaxResults"] = args["MaxResults"],
		["StartTime"] = args["StartTime"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeSpotFleetRequestHistoryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ServiceConfiguration = { ["ServiceType"] = true, ["NetworkLoadBalancerArns"] = true, ["ServiceName"] = true, ["ServiceState"] = true, ["PrivateDnsName"] = true, ["ServiceId"] = true, ["AcceptanceRequired"] = true, ["AvailabilityZones"] = true, ["BaseEndpointDnsNames"] = true, nil }

function asserts.AssertServiceConfiguration(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ServiceConfiguration to be of type 'table'")
	if struct["ServiceType"] then asserts.AssertServiceTypeDetailSet(struct["ServiceType"]) end
	if struct["NetworkLoadBalancerArns"] then asserts.AssertValueStringList(struct["NetworkLoadBalancerArns"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["ServiceState"] then asserts.AssertServiceState(struct["ServiceState"]) end
	if struct["PrivateDnsName"] then asserts.AssertString(struct["PrivateDnsName"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["AcceptanceRequired"] then asserts.AssertBoolean(struct["AcceptanceRequired"]) end
	if struct["AvailabilityZones"] then asserts.AssertValueStringList(struct["AvailabilityZones"]) end
	if struct["BaseEndpointDnsNames"] then asserts.AssertValueStringList(struct["BaseEndpointDnsNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.ServiceConfiguration[k], "ServiceConfiguration contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ServiceConfiguration
-- <p>Describes a service configuration for a VPC endpoint service.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ServiceType [ServiceTypeDetailSet] <p>The type of service.</p>
-- * NetworkLoadBalancerArns [ValueStringList] <p>The Amazon Resource Names (ARNs) of the Network Load Balancers for the service.</p>
-- * ServiceName [String] <p>The name of the service.</p>
-- * ServiceState [ServiceState] <p>The service state.</p>
-- * PrivateDnsName [String] <p>The private DNS name for the service.</p>
-- * ServiceId [String] <p>The ID of the service.</p>
-- * AcceptanceRequired [Boolean] <p>Indicates whether requests from other AWS accounts to create an endpoint to the service must first be accepted.</p>
-- * AvailabilityZones [ValueStringList] <p>In the Availability Zones in which the service is available.</p>
-- * BaseEndpointDnsNames [ValueStringList] <p>The DNS names for the service.</p>
-- @return ServiceConfiguration structure as a key-value pair table
function M.ServiceConfiguration(args)
	assert(args, "You must provide an argument table when creating ServiceConfiguration")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ServiceType"] = args["ServiceType"],
		["NetworkLoadBalancerArns"] = args["NetworkLoadBalancerArns"],
		["ServiceName"] = args["ServiceName"],
		["ServiceState"] = args["ServiceState"],
		["PrivateDnsName"] = args["PrivateDnsName"],
		["ServiceId"] = args["ServiceId"],
		["AcceptanceRequired"] = args["AcceptanceRequired"],
		["AvailabilityZones"] = args["AvailabilityZones"],
		["BaseEndpointDnsNames"] = args["BaseEndpointDnsNames"],
	}
	asserts.AssertServiceConfiguration(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceIpv6Address = { ["Ipv6Address"] = true, nil }

function asserts.AssertInstanceIpv6Address(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceIpv6Address to be of type 'table'")
	if struct["Ipv6Address"] then asserts.AssertString(struct["Ipv6Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceIpv6Address[k], "InstanceIpv6Address contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceIpv6Address
-- <p>Describes an IPv6 address.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6Address [String] <p>The IPv6 address.</p>
-- @return InstanceIpv6Address structure as a key-value pair table
function M.InstanceIpv6Address(args)
	assert(args, "You must provide an argument table when creating InstanceIpv6Address")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6Address"] = args["Ipv6Address"],
	}
	asserts.AssertInstanceIpv6Address(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Ipv6CidrBlock = { ["Ipv6CidrBlock"] = true, nil }

function asserts.AssertIpv6CidrBlock(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6CidrBlock to be of type 'table'")
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.Ipv6CidrBlock[k], "Ipv6CidrBlock contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6CidrBlock
-- <p>Describes an IPv6 CIDR block.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Ipv6CidrBlock [String] <p>The IPv6 CIDR block.</p>
-- @return Ipv6CidrBlock structure as a key-value pair table
function M.Ipv6CidrBlock(args)
	assert(args, "You must provide an argument table when creating Ipv6CidrBlock")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
	}
	asserts.AssertIpv6CidrBlock(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointRequest = { ["AddSecurityGroupIds"] = true, ["PrivateDnsEnabled"] = true, ["DryRun"] = true, ["AddSubnetIds"] = true, ["AddRouteTableIds"] = true, ["ResetPolicy"] = true, ["RemoveSecurityGroupIds"] = true, ["RemoveRouteTableIds"] = true, ["PolicyDocument"] = true, ["RemoveSubnetIds"] = true, ["VpcEndpointId"] = true, nil }

function asserts.AssertModifyVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointRequest to be of type 'table'")
	assert(struct["VpcEndpointId"], "Expected key VpcEndpointId to exist in table")
	if struct["AddSecurityGroupIds"] then asserts.AssertValueStringList(struct["AddSecurityGroupIds"]) end
	if struct["PrivateDnsEnabled"] then asserts.AssertBoolean(struct["PrivateDnsEnabled"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AddSubnetIds"] then asserts.AssertValueStringList(struct["AddSubnetIds"]) end
	if struct["AddRouteTableIds"] then asserts.AssertValueStringList(struct["AddRouteTableIds"]) end
	if struct["ResetPolicy"] then asserts.AssertBoolean(struct["ResetPolicy"]) end
	if struct["RemoveSecurityGroupIds"] then asserts.AssertValueStringList(struct["RemoveSecurityGroupIds"]) end
	if struct["RemoveRouteTableIds"] then asserts.AssertValueStringList(struct["RemoveRouteTableIds"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["RemoveSubnetIds"] then asserts.AssertValueStringList(struct["RemoveSubnetIds"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointRequest[k], "ModifyVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointRequest
-- <p>Contains the parameters for ModifyVpcEndpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AddSecurityGroupIds [ValueStringList] <p>(Interface endpoint) One or more security group IDs to associate with the network interface.</p>
-- * PrivateDnsEnabled [Boolean] <p>(Interface endpoint) Indicate whether a private hosted zone is associated with the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AddSubnetIds [ValueStringList] <p>(Interface endpoint) One or more subnet IDs in which to serve the endpoint.</p>
-- * AddRouteTableIds [ValueStringList] <p>(Gateway endpoint) One or more route tables IDs to associate with the endpoint.</p>
-- * ResetPolicy [Boolean] <p>(Gateway endpoint) Specify <code>true</code> to reset the policy document to the default policy. The default policy allows full access to the service.</p>
-- * RemoveSecurityGroupIds [ValueStringList] <p>(Interface endpoint) One or more security group IDs to disassociate from the network interface.</p>
-- * RemoveRouteTableIds [ValueStringList] <p>(Gateway endpoint) One or more route table IDs to disassociate from the endpoint.</p>
-- * PolicyDocument [String] <p>(Gateway endpoint) A policy document to attach to the endpoint. The policy must be in valid JSON format.</p>
-- * RemoveSubnetIds [ValueStringList] <p>(Interface endpoint) One or more subnets IDs in which to remove the endpoint.</p>
-- * VpcEndpointId [String] <p>The ID of the endpoint.</p>
-- Required key: VpcEndpointId
-- @return ModifyVpcEndpointRequest structure as a key-value pair table
function M.ModifyVpcEndpointRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AddSecurityGroupIds"] = args["AddSecurityGroupIds"],
		["PrivateDnsEnabled"] = args["PrivateDnsEnabled"],
		["DryRun"] = args["DryRun"],
		["AddSubnetIds"] = args["AddSubnetIds"],
		["AddRouteTableIds"] = args["AddRouteTableIds"],
		["ResetPolicy"] = args["ResetPolicy"],
		["RemoveSecurityGroupIds"] = args["RemoveSecurityGroupIds"],
		["RemoveRouteTableIds"] = args["RemoveRouteTableIds"],
		["PolicyDocument"] = args["PolicyDocument"],
		["RemoveSubnetIds"] = args["RemoveSubnetIds"],
		["VpcEndpointId"] = args["VpcEndpointId"],
	}
	asserts.AssertModifyVpcEndpointRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstancesListing = { ["ReservedInstancesId"] = true, ["Status"] = true, ["Tags"] = true, ["PriceSchedules"] = true, ["CreateDate"] = true, ["ClientToken"] = true, ["ReservedInstancesListingId"] = true, ["UpdateDate"] = true, ["InstanceCounts"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertReservedInstancesListing(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesListing to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["Status"] then asserts.AssertListingStatus(struct["Status"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["PriceSchedules"] then asserts.AssertPriceScheduleList(struct["PriceSchedules"]) end
	if struct["CreateDate"] then asserts.AssertDateTime(struct["CreateDate"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["ReservedInstancesListingId"] then asserts.AssertString(struct["ReservedInstancesListingId"]) end
	if struct["UpdateDate"] then asserts.AssertDateTime(struct["UpdateDate"]) end
	if struct["InstanceCounts"] then asserts.AssertInstanceCountList(struct["InstanceCounts"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesListing[k], "ReservedInstancesListing contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesListing
-- <p>Describes a Reserved Instance listing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- * Status [ListingStatus] <p>The status of the Reserved Instance listing.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * PriceSchedules [PriceScheduleList] <p>The price of the Reserved Instance listing.</p>
-- * CreateDate [DateTime] <p>The time the listing was created.</p>
-- * ClientToken [String] <p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- * ReservedInstancesListingId [String] <p>The ID of the Reserved Instance listing.</p>
-- * UpdateDate [DateTime] <p>The last modified timestamp of the listing.</p>
-- * InstanceCounts [InstanceCountList] <p>The number of instances in this state.</p>
-- * StatusMessage [String] <p>The reason for the current status of the Reserved Instance listing. The response can be blank.</p>
-- @return ReservedInstancesListing structure as a key-value pair table
function M.ReservedInstancesListing(args)
	assert(args, "You must provide an argument table when creating ReservedInstancesListing")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["Status"] = args["Status"],
		["Tags"] = args["Tags"],
		["PriceSchedules"] = args["PriceSchedules"],
		["CreateDate"] = args["CreateDate"],
		["ClientToken"] = args["ClientToken"],
		["ReservedInstancesListingId"] = args["ReservedInstancesListingId"],
		["UpdateDate"] = args["UpdateDate"],
		["InstanceCounts"] = args["InstanceCounts"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertReservedInstancesListing(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Route = { ["Origin"] = true, ["DestinationCidrBlock"] = true, ["EgressOnlyInternetGatewayId"] = true, ["DestinationPrefixListId"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["State"] = true, ["NatGatewayId"] = true, ["VpcPeeringConnectionId"] = true, ["GatewayId"] = true, ["DestinationIpv6CidrBlock"] = true, ["InstanceOwnerId"] = true, nil }

function asserts.AssertRoute(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Route to be of type 'table'")
	if struct["Origin"] then asserts.AssertRouteOrigin(struct["Origin"]) end
	if struct["DestinationCidrBlock"] then asserts.AssertString(struct["DestinationCidrBlock"]) end
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertString(struct["EgressOnlyInternetGatewayId"]) end
	if struct["DestinationPrefixListId"] then asserts.AssertString(struct["DestinationPrefixListId"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["State"] then asserts.AssertRouteState(struct["State"]) end
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	if struct["GatewayId"] then asserts.AssertString(struct["GatewayId"]) end
	if struct["DestinationIpv6CidrBlock"] then asserts.AssertString(struct["DestinationIpv6CidrBlock"]) end
	if struct["InstanceOwnerId"] then asserts.AssertString(struct["InstanceOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.Route[k], "Route contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Route
-- <p>Describes a route in a route table.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Origin [RouteOrigin] <p>Describes how the route was created.</p> <ul> <li> <p> <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p> </li> <li> <p> <code>CreateRoute</code> - The route was manually added to the route table.</p> </li> <li> <p> <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p> </li> </ul>
-- * DestinationCidrBlock [String] <p>The IPv4 CIDR block used for the destination match.</p>
-- * EgressOnlyInternetGatewayId [String] <p>The ID of the egress-only internet gateway.</p>
-- * DestinationPrefixListId [String] <p>The prefix of the AWS service.</p>
-- * InstanceId [String] <p>The ID of a NAT instance in your VPC.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * State [RouteState] <p>The state of the route. The <code>blackhole</code> state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).</p>
-- * NatGatewayId [String] <p>The ID of a NAT gateway.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection.</p>
-- * GatewayId [String] <p>The ID of a gateway attached to your VPC.</p>
-- * DestinationIpv6CidrBlock [String] <p>The IPv6 CIDR block used for the destination match.</p>
-- * InstanceOwnerId [String] <p>The AWS account ID of the owner of the instance.</p>
-- @return Route structure as a key-value pair table
function M.Route(args)
	assert(args, "You must provide an argument table when creating Route")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Origin"] = args["Origin"],
		["DestinationCidrBlock"] = args["DestinationCidrBlock"],
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["DestinationPrefixListId"] = args["DestinationPrefixListId"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["State"] = args["State"],
		["NatGatewayId"] = args["NatGatewayId"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
		["GatewayId"] = args["GatewayId"],
		["DestinationIpv6CidrBlock"] = args["DestinationIpv6CidrBlock"],
		["InstanceOwnerId"] = args["InstanceOwnerId"],
	}
	asserts.AssertRoute(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ProductCode = { ["ProductCodeId"] = true, ["ProductCodeType"] = true, nil }

function asserts.AssertProductCode(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProductCode to be of type 'table'")
	if struct["ProductCodeId"] then asserts.AssertString(struct["ProductCodeId"]) end
	if struct["ProductCodeType"] then asserts.AssertProductCodeValues(struct["ProductCodeType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProductCode[k], "ProductCode contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProductCode
-- <p>Describes a product code.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ProductCodeId [String] <p>The product code.</p>
-- * ProductCodeType [ProductCodeValues] <p>The type of product code.</p>
-- @return ProductCode structure as a key-value pair table
function M.ProductCode(args)
	assert(args, "You must provide an argument table when creating ProductCode")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ProductCodeId"] = args["ProductCodeId"],
		["ProductCodeType"] = args["ProductCodeType"],
	}
	asserts.AssertProductCode(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Ipv6Range = { ["CidrIpv6"] = true, ["Description"] = true, nil }

function asserts.AssertIpv6Range(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Ipv6Range to be of type 'table'")
	if struct["CidrIpv6"] then asserts.AssertString(struct["CidrIpv6"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.Ipv6Range[k], "Ipv6Range contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Ipv6Range
-- <p>[EC2-VPC only] Describes an IPv6 range.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CidrIpv6 [String] <p>The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.</p>
-- * Description [String] <p>A description for the security group rule that references this IPv6 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>
-- @return Ipv6Range structure as a key-value pair table
function M.Ipv6Range(args)
	assert(args, "You must provide an argument table when creating Ipv6Range")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CidrIpv6"] = args["CidrIpv6"],
		["Description"] = args["Description"],
	}
	asserts.AssertIpv6Range(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AcceptReservedInstancesExchangeQuoteResult = { ["ExchangeId"] = true, nil }

function asserts.AssertAcceptReservedInstancesExchangeQuoteResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteResult to be of type 'table'")
	if struct["ExchangeId"] then asserts.AssertString(struct["ExchangeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptReservedInstancesExchangeQuoteResult[k], "AcceptReservedInstancesExchangeQuoteResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteResult
-- <p>The result of the exchange and whether it was <code>successful</code>.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ExchangeId [String] <p>The ID of the successful exchange.</p>
-- @return AcceptReservedInstancesExchangeQuoteResult structure as a key-value pair table
function M.AcceptReservedInstancesExchangeQuoteResult(args)
	assert(args, "You must provide an argument table when creating AcceptReservedInstancesExchangeQuoteResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ExchangeId"] = args["ExchangeId"],
	}
	asserts.AssertAcceptReservedInstancesExchangeQuoteResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateSpecification = { ["LaunchTemplateName"] = true, ["Version"] = true, ["LaunchTemplateId"] = true, nil }

function asserts.AssertLaunchTemplateSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateSpecification to be of type 'table'")
	if struct["LaunchTemplateName"] then asserts.AssertString(struct["LaunchTemplateName"]) end
	if struct["Version"] then asserts.AssertString(struct["Version"]) end
	if struct["LaunchTemplateId"] then asserts.AssertString(struct["LaunchTemplateId"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateSpecification[k], "LaunchTemplateSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateSpecification
-- <p>The launch template to use. You must specify either the launch template ID or launch template name in the request, but not both.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateName [String] <p>The name of the launch template.</p>
-- * Version [String] <p>The version number of the launch template.</p> <p>Default: The default version for the launch template.</p>
-- * LaunchTemplateId [String] <p>The ID of the launch template.</p>
-- @return LaunchTemplateSpecification structure as a key-value pair table
function M.LaunchTemplateSpecification(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateName"] = args["LaunchTemplateName"],
		["Version"] = args["Version"],
		["LaunchTemplateId"] = args["LaunchTemplateId"],
	}
	asserts.AssertLaunchTemplateSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EgressOnlyInternetGateway = { ["EgressOnlyInternetGatewayId"] = true, ["Attachments"] = true, nil }

function asserts.AssertEgressOnlyInternetGateway(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EgressOnlyInternetGateway to be of type 'table'")
	if struct["EgressOnlyInternetGatewayId"] then asserts.AssertEgressOnlyInternetGatewayId(struct["EgressOnlyInternetGatewayId"]) end
	if struct["Attachments"] then asserts.AssertInternetGatewayAttachmentList(struct["Attachments"]) end
	for k,_ in pairs(struct) do
		assert(keys.EgressOnlyInternetGateway[k], "EgressOnlyInternetGateway contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EgressOnlyInternetGateway
-- <p>Describes an egress-only internet gateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EgressOnlyInternetGatewayId [EgressOnlyInternetGatewayId] <p>The ID of the egress-only internet gateway.</p>
-- * Attachments [InternetGatewayAttachmentList] <p>Information about the attachment of the egress-only internet gateway.</p>
-- @return EgressOnlyInternetGateway structure as a key-value pair table
function M.EgressOnlyInternetGateway(args)
	assert(args, "You must provide an argument table when creating EgressOnlyInternetGateway")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EgressOnlyInternetGatewayId"] = args["EgressOnlyInternetGatewayId"],
		["Attachments"] = args["Attachments"],
	}
	asserts.AssertEgressOnlyInternetGateway(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcEndpointConnection = { ["VpcEndpointId"] = true, ["ServiceId"] = true, ["CreationTimestamp"] = true, ["VpcEndpointState"] = true, ["VpcEndpointOwner"] = true, nil }

function asserts.AssertVpcEndpointConnection(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcEndpointConnection to be of type 'table'")
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["CreationTimestamp"] then asserts.AssertDateTime(struct["CreationTimestamp"]) end
	if struct["VpcEndpointState"] then asserts.AssertState(struct["VpcEndpointState"]) end
	if struct["VpcEndpointOwner"] then asserts.AssertString(struct["VpcEndpointOwner"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcEndpointConnection[k], "VpcEndpointConnection contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcEndpointConnection
-- <p>Describes a VPC endpoint connection to a service.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointId [String] <p>The ID of the VPC endpoint.</p>
-- * ServiceId [String] <p>The ID of the service to which the endpoint is connected.</p>
-- * CreationTimestamp [DateTime] <p>The date and time the VPC endpoint was created.</p>
-- * VpcEndpointState [State] <p>The state of the VPC endpoint.</p>
-- * VpcEndpointOwner [String] <p>The AWS account ID of the owner of the VPC endpoint.</p>
-- @return VpcEndpointConnection structure as a key-value pair table
function M.VpcEndpointConnection(args)
	assert(args, "You must provide an argument table when creating VpcEndpointConnection")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcEndpointId"] = args["VpcEndpointId"],
		["ServiceId"] = args["ServiceId"],
		["CreationTimestamp"] = args["CreationTimestamp"],
		["VpcEndpointState"] = args["VpcEndpointState"],
		["VpcEndpointOwner"] = args["VpcEndpointOwner"],
	}
	asserts.AssertVpcEndpointConnection(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VpcPeeringConnectionOptionsDescription = { ["AllowEgressFromLocalVpcToRemoteClassicLink"] = true, ["AllowDnsResolutionFromRemoteVpc"] = true, ["AllowEgressFromLocalClassicLinkToRemoteVpc"] = true, nil }

function asserts.AssertVpcPeeringConnectionOptionsDescription(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VpcPeeringConnectionOptionsDescription to be of type 'table'")
	if struct["AllowEgressFromLocalVpcToRemoteClassicLink"] then asserts.AssertBoolean(struct["AllowEgressFromLocalVpcToRemoteClassicLink"]) end
	if struct["AllowDnsResolutionFromRemoteVpc"] then asserts.AssertBoolean(struct["AllowDnsResolutionFromRemoteVpc"]) end
	if struct["AllowEgressFromLocalClassicLinkToRemoteVpc"] then asserts.AssertBoolean(struct["AllowEgressFromLocalClassicLinkToRemoteVpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.VpcPeeringConnectionOptionsDescription[k], "VpcPeeringConnectionOptionsDescription contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VpcPeeringConnectionOptionsDescription
-- <p>Describes the VPC peering connection options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllowEgressFromLocalVpcToRemoteClassicLink [Boolean] <p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.</p>
-- * AllowDnsResolutionFromRemoteVpc [Boolean] <p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.</p>
-- * AllowEgressFromLocalClassicLinkToRemoteVpc [Boolean] <p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.</p>
-- @return VpcPeeringConnectionOptionsDescription structure as a key-value pair table
function M.VpcPeeringConnectionOptionsDescription(args)
	assert(args, "You must provide an argument table when creating VpcPeeringConnectionOptionsDescription")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AllowEgressFromLocalVpcToRemoteClassicLink"] = args["AllowEgressFromLocalVpcToRemoteClassicLink"],
		["AllowDnsResolutionFromRemoteVpc"] = args["AllowDnsResolutionFromRemoteVpc"],
		["AllowEgressFromLocalClassicLinkToRemoteVpc"] = args["AllowEgressFromLocalClassicLinkToRemoteVpc"],
	}
	asserts.AssertVpcPeeringConnectionOptionsDescription(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointConnectionNotificationRequest = { ["ConnectionEvents"] = true, ["DryRun"] = true, ["ConnectionNotificationId"] = true, ["ConnectionNotificationArn"] = true, nil }

function asserts.AssertModifyVpcEndpointConnectionNotificationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointConnectionNotificationRequest to be of type 'table'")
	assert(struct["ConnectionNotificationId"], "Expected key ConnectionNotificationId to exist in table")
	if struct["ConnectionEvents"] then asserts.AssertValueStringList(struct["ConnectionEvents"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ConnectionNotificationId"] then asserts.AssertString(struct["ConnectionNotificationId"]) end
	if struct["ConnectionNotificationArn"] then asserts.AssertString(struct["ConnectionNotificationArn"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointConnectionNotificationRequest[k], "ModifyVpcEndpointConnectionNotificationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointConnectionNotificationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConnectionEvents [ValueStringList] <p>One or more events for the endpoint. Valid values are <code>Accept</code>, <code>Connect</code>, <code>Delete</code>, and <code>Reject</code>.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ConnectionNotificationId [String] <p>The ID of the notification.</p>
-- * ConnectionNotificationArn [String] <p>The ARN for the SNS topic for the notification.</p>
-- Required key: ConnectionNotificationId
-- @return ModifyVpcEndpointConnectionNotificationRequest structure as a key-value pair table
function M.ModifyVpcEndpointConnectionNotificationRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointConnectionNotificationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConnectionEvents"] = args["ConnectionEvents"],
		["DryRun"] = args["DryRun"],
		["ConnectionNotificationId"] = args["ConnectionNotificationId"],
		["ConnectionNotificationArn"] = args["ConnectionNotificationArn"],
	}
	asserts.AssertModifyVpcEndpointConnectionNotificationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateSubnetCidrBlockResult = { ["SubnetId"] = true, ["Ipv6CidrBlockAssociation"] = true, nil }

function asserts.AssertAssociateSubnetCidrBlockResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateSubnetCidrBlockResult to be of type 'table'")
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["Ipv6CidrBlockAssociation"] then asserts.AssertSubnetIpv6CidrBlockAssociation(struct["Ipv6CidrBlockAssociation"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateSubnetCidrBlockResult[k], "AssociateSubnetCidrBlockResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateSubnetCidrBlockResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SubnetId [String] <p>The ID of the subnet.</p>
-- * Ipv6CidrBlockAssociation [SubnetIpv6CidrBlockAssociation] <p>Information about the IPv6 CIDR block association.</p>
-- @return AssociateSubnetCidrBlockResult structure as a key-value pair table
function M.AssociateSubnetCidrBlockResult(args)
	assert(args, "You must provide an argument table when creating AssociateSubnetCidrBlockResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SubnetId"] = args["SubnetId"],
		["Ipv6CidrBlockAssociation"] = args["Ipv6CidrBlockAssociation"],
	}
	asserts.AssertAssociateSubnetCidrBlockResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SpotPrice = { ["Timestamp"] = true, ["AvailabilityZone"] = true, ["InstanceType"] = true, ["ProductDescription"] = true, ["SpotPrice"] = true, nil }

function asserts.AssertSpotPrice(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SpotPrice to be of type 'table'")
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["SpotPrice"] then asserts.AssertString(struct["SpotPrice"]) end
	for k,_ in pairs(struct) do
		assert(keys.SpotPrice[k], "SpotPrice contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SpotPrice
-- <p>Describes the maximum price per hour that you are willing to pay for a Spot Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Timestamp [DateTime] <p>The date and time the request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- * AvailabilityZone [String] <p>The Availability Zone.</p>
-- * InstanceType [InstanceType] <p>The instance type.</p>
-- * ProductDescription [RIProductDescription] <p>A general description of the AMI.</p>
-- * SpotPrice [String] <p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>
-- @return SpotPrice structure as a key-value pair table
function M.SpotPrice(args)
	assert(args, "You must provide an argument table when creating SpotPrice")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Timestamp"] = args["Timestamp"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["InstanceType"] = args["InstanceType"],
		["ProductDescription"] = args["ProductDescription"],
		["SpotPrice"] = args["SpotPrice"],
	}
	asserts.AssertSpotPrice(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFpgaImageAttributeRequest = { ["FpgaImageId"] = true, ["DryRun"] = true, ["Attribute"] = true, nil }

function asserts.AssertDescribeFpgaImageAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImageAttributeRequest to be of type 'table'")
	assert(struct["FpgaImageId"], "Expected key FpgaImageId to exist in table")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	if struct["FpgaImageId"] then asserts.AssertString(struct["FpgaImageId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Attribute"] then asserts.AssertFpgaImageAttributeName(struct["Attribute"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImageAttributeRequest[k], "DescribeFpgaImageAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImageAttributeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageId [String] <p>The ID of the AFI.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Attribute [FpgaImageAttributeName] <p>The AFI attribute.</p>
-- Required key: FpgaImageId
-- Required key: Attribute
-- @return DescribeFpgaImageAttributeRequest structure as a key-value pair table
function M.DescribeFpgaImageAttributeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeFpgaImageAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageId"] = args["FpgaImageId"],
		["DryRun"] = args["DryRun"],
		["Attribute"] = args["Attribute"],
	}
	asserts.AssertDescribeFpgaImageAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PrefixList = { ["PrefixListName"] = true, ["Cidrs"] = true, ["PrefixListId"] = true, nil }

function asserts.AssertPrefixList(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrefixList to be of type 'table'")
	if struct["PrefixListName"] then asserts.AssertString(struct["PrefixListName"]) end
	if struct["Cidrs"] then asserts.AssertValueStringList(struct["Cidrs"]) end
	if struct["PrefixListId"] then asserts.AssertString(struct["PrefixListId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrefixList[k], "PrefixList contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrefixList
-- <p>Describes prefixes for AWS services.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrefixListName [String] <p>The name of the prefix.</p>
-- * Cidrs [ValueStringList] <p>The IP address range of the AWS service.</p>
-- * PrefixListId [String] <p>The ID of the prefix.</p>
-- @return PrefixList structure as a key-value pair table
function M.PrefixList(args)
	assert(args, "You must provide an argument table when creating PrefixList")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrefixListName"] = args["PrefixListName"],
		["Cidrs"] = args["Cidrs"],
		["PrefixListId"] = args["PrefixListId"],
	}
	asserts.AssertPrefixList(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcEndpointsRequest = { ["VpcEndpointIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpcEndpointsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointsRequest to be of type 'table'")
	assert(struct["VpcEndpointIds"], "Expected key VpcEndpointIds to exist in table")
	if struct["VpcEndpointIds"] then asserts.AssertValueStringList(struct["VpcEndpointIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointsRequest[k], "DeleteVpcEndpointsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointsRequest
-- <p>Contains the parameters for DeleteVpcEndpoints.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcEndpointIds [ValueStringList] <p>One or more VPC endpoint IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcEndpointIds
-- @return DeleteVpcEndpointsRequest structure as a key-value pair table
function M.DeleteVpcEndpointsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpcEndpointsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcEndpointIds"] = args["VpcEndpointIds"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteVpcEndpointsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ClassicLoadBalancersConfig = { ["ClassicLoadBalancers"] = true, nil }

function asserts.AssertClassicLoadBalancersConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLoadBalancersConfig to be of type 'table'")
	assert(struct["ClassicLoadBalancers"], "Expected key ClassicLoadBalancers to exist in table")
	if struct["ClassicLoadBalancers"] then asserts.AssertClassicLoadBalancers(struct["ClassicLoadBalancers"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLoadBalancersConfig[k], "ClassicLoadBalancersConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLoadBalancersConfig
-- <p>Describes the Classic Load Balancers to attach to a Spot Fleet. Spot Fleet registers the running Spot Instances with these Classic Load Balancers.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ClassicLoadBalancers [ClassicLoadBalancers] <p>One or more Classic Load Balancers.</p>
-- Required key: ClassicLoadBalancers
-- @return ClassicLoadBalancersConfig structure as a key-value pair table
function M.ClassicLoadBalancersConfig(args)
	assert(args, "You must provide an argument table when creating ClassicLoadBalancersConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ClassicLoadBalancers"] = args["ClassicLoadBalancers"],
	}
	asserts.AssertClassicLoadBalancersConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeLaunchTemplateVersionsResult = { ["NextToken"] = true, ["LaunchTemplateVersions"] = true, nil }

function asserts.AssertDescribeLaunchTemplateVersionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeLaunchTemplateVersionsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["LaunchTemplateVersions"] then asserts.AssertLaunchTemplateVersionSet(struct["LaunchTemplateVersions"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeLaunchTemplateVersionsResult[k], "DescribeLaunchTemplateVersionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeLaunchTemplateVersionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * LaunchTemplateVersions [LaunchTemplateVersionSet] <p>Information about the launch template versions.</p>
-- @return DescribeLaunchTemplateVersionsResult structure as a key-value pair table
function M.DescribeLaunchTemplateVersionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeLaunchTemplateVersionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["LaunchTemplateVersions"] = args["LaunchTemplateVersions"],
	}
	asserts.AssertDescribeLaunchTemplateVersionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Image = { ["RootDeviceType"] = true, ["State"] = true, ["ImageLocation"] = true, ["RamdiskId"] = true, ["Public"] = true, ["ProductCodes"] = true, ["Description"] = true, ["Tags"] = true, ["EnaSupport"] = true, ["SriovNetSupport"] = true, ["ImageId"] = true, ["KernelId"] = true, ["Name"] = true, ["Hypervisor"] = true, ["BlockDeviceMappings"] = true, ["Architecture"] = true, ["ImageOwnerAlias"] = true, ["StateReason"] = true, ["RootDeviceName"] = true, ["ImageType"] = true, ["VirtualizationType"] = true, ["Platform"] = true, ["OwnerId"] = true, ["CreationDate"] = true, nil }

function asserts.AssertImage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Image to be of type 'table'")
	if struct["RootDeviceType"] then asserts.AssertDeviceType(struct["RootDeviceType"]) end
	if struct["State"] then asserts.AssertImageState(struct["State"]) end
	if struct["ImageLocation"] then asserts.AssertString(struct["ImageLocation"]) end
	if struct["RamdiskId"] then asserts.AssertString(struct["RamdiskId"]) end
	if struct["Public"] then asserts.AssertBoolean(struct["Public"]) end
	if struct["ProductCodes"] then asserts.AssertProductCodeList(struct["ProductCodes"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["EnaSupport"] then asserts.AssertBoolean(struct["EnaSupport"]) end
	if struct["SriovNetSupport"] then asserts.AssertString(struct["SriovNetSupport"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["KernelId"] then asserts.AssertString(struct["KernelId"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	if struct["Hypervisor"] then asserts.AssertHypervisorType(struct["Hypervisor"]) end
	if struct["BlockDeviceMappings"] then asserts.AssertBlockDeviceMappingList(struct["BlockDeviceMappings"]) end
	if struct["Architecture"] then asserts.AssertArchitectureValues(struct["Architecture"]) end
	if struct["ImageOwnerAlias"] then asserts.AssertString(struct["ImageOwnerAlias"]) end
	if struct["StateReason"] then asserts.AssertStateReason(struct["StateReason"]) end
	if struct["RootDeviceName"] then asserts.AssertString(struct["RootDeviceName"]) end
	if struct["ImageType"] then asserts.AssertImageTypeValues(struct["ImageType"]) end
	if struct["VirtualizationType"] then asserts.AssertVirtualizationType(struct["VirtualizationType"]) end
	if struct["Platform"] then asserts.AssertPlatformValues(struct["Platform"]) end
	if struct["OwnerId"] then asserts.AssertString(struct["OwnerId"]) end
	if struct["CreationDate"] then asserts.AssertString(struct["CreationDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.Image[k], "Image contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Image
-- <p>Describes an image.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RootDeviceType [DeviceType] <p>The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>
-- * State [ImageState] <p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>
-- * ImageLocation [String] <p>The location of the AMI.</p>
-- * RamdiskId [String] <p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>
-- * Public [Boolean] <p>Indicates whether the image has public launch permissions. The value is <code>true</code> if this image has public launch permissions or <code>false</code> if it has only implicit and explicit launch permissions.</p>
-- * ProductCodes [ProductCodeList] <p>Any product codes associated with the AMI.</p>
-- * Description [String] <p>The description of the AMI that was provided during image creation.</p>
-- * Tags [TagList] <p>Any tags assigned to the image.</p>
-- * EnaSupport [Boolean] <p>Specifies whether enhanced networking with ENA is enabled.</p>
-- * SriovNetSupport [String] <p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>
-- * ImageId [String] <p>The ID of the AMI.</p>
-- * KernelId [String] <p>The kernel associated with the image, if any. Only applicable for machine images.</p>
-- * Name [String] <p>The name of the AMI that was provided during image creation.</p>
-- * Hypervisor [HypervisorType] <p>The hypervisor type of the image.</p>
-- * BlockDeviceMappings [BlockDeviceMappingList] <p>Any block device mapping entries.</p>
-- * Architecture [ArchitectureValues] <p>The architecture of the image.</p>
-- * ImageOwnerAlias [String] <p>The AWS account alias (for example, <code>amazon</code>, <code>self</code>) or the AWS account ID of the AMI owner.</p>
-- * StateReason [StateReason] <p>The reason for the state change.</p>
-- * RootDeviceName [String] <p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>
-- * ImageType [ImageTypeValues] <p>The type of image.</p>
-- * VirtualizationType [VirtualizationType] <p>The type of virtualization of the AMI.</p>
-- * Platform [PlatformValues] <p>The value is <code>Windows</code> for Windows AMIs; otherwise blank.</p>
-- * OwnerId [String] <p>The AWS account ID of the image owner.</p>
-- * CreationDate [String] <p>The date and time the image was created.</p>
-- @return Image structure as a key-value pair table
function M.Image(args)
	assert(args, "You must provide an argument table when creating Image")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["RootDeviceType"] = args["RootDeviceType"],
		["State"] = args["State"],
		["ImageLocation"] = args["ImageLocation"],
		["RamdiskId"] = args["RamdiskId"],
		["Public"] = args["Public"],
		["ProductCodes"] = args["ProductCodes"],
		["Description"] = args["Description"],
		["Tags"] = args["Tags"],
		["EnaSupport"] = args["EnaSupport"],
		["SriovNetSupport"] = args["SriovNetSupport"],
		["ImageId"] = args["ImageId"],
		["KernelId"] = args["KernelId"],
		["Name"] = args["Name"],
		["Hypervisor"] = args["Hypervisor"],
		["BlockDeviceMappings"] = args["BlockDeviceMappings"],
		["Architecture"] = args["Architecture"],
		["ImageOwnerAlias"] = args["ImageOwnerAlias"],
		["StateReason"] = args["StateReason"],
		["RootDeviceName"] = args["RootDeviceName"],
		["ImageType"] = args["ImageType"],
		["VirtualizationType"] = args["VirtualizationType"],
		["Platform"] = args["Platform"],
		["OwnerId"] = args["OwnerId"],
		["CreationDate"] = args["CreationDate"],
	}
	asserts.AssertImage(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachNetworkInterfaceRequest = { ["DryRun"] = true, ["AttachmentId"] = true, ["Force"] = true, nil }

function asserts.AssertDetachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["AttachmentId"], "Expected key AttachmentId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachNetworkInterfaceRequest[k], "DetachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachNetworkInterfaceRequest
-- <p>Contains the parameters for DetachNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * AttachmentId [String] <p>The ID of the attachment.</p>
-- * Force [Boolean] <p>Specifies whether to force a detachment.</p>
-- Required key: AttachmentId
-- @return DetachNetworkInterfaceRequest structure as a key-value pair table
function M.DetachNetworkInterfaceRequest(args)
	assert(args, "You must provide an argument table when creating DetachNetworkInterfaceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["AttachmentId"] = args["AttachmentId"],
		["Force"] = args["Force"],
	}
	asserts.AssertDetachNetworkInterfaceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachNetworkInterfaceResult = { ["AttachmentId"] = true, nil }

function asserts.AssertAttachNetworkInterfaceResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceResult to be of type 'table'")
	if struct["AttachmentId"] then asserts.AssertString(struct["AttachmentId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachNetworkInterfaceResult[k], "AttachNetworkInterfaceResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceResult
-- <p>Contains the output of AttachNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttachmentId [String] <p>The ID of the network interface attachment.</p>
-- @return AttachNetworkInterfaceResult structure as a key-value pair table
function M.AttachNetworkInterfaceResult(args)
	assert(args, "You must provide an argument table when creating AttachNetworkInterfaceResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AttachmentId"] = args["AttachmentId"],
	}
	asserts.AssertAttachNetworkInterfaceResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesListingsResult = { ["ReservedInstancesListings"] = true, nil }

function asserts.AssertDescribeReservedInstancesListingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesListingsResult to be of type 'table'")
	if struct["ReservedInstancesListings"] then asserts.AssertReservedInstancesListingList(struct["ReservedInstancesListings"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesListingsResult[k], "DescribeReservedInstancesListingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesListingsResult
-- <p>Contains the output of DescribeReservedInstancesListings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesListings [ReservedInstancesListingList] <p>Information about the Reserved Instance listing.</p>
-- @return DescribeReservedInstancesListingsResult structure as a key-value pair table
function M.DescribeReservedInstancesListingsResult(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesListingsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesListings"] = args["ReservedInstancesListings"],
	}
	asserts.AssertDescribeReservedInstancesListingsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DisassociateIamInstanceProfileRequest = { ["AssociationId"] = true, nil }

function asserts.AssertDisassociateIamInstanceProfileRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DisassociateIamInstanceProfileRequest to be of type 'table'")
	assert(struct["AssociationId"], "Expected key AssociationId to exist in table")
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DisassociateIamInstanceProfileRequest[k], "DisassociateIamInstanceProfileRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DisassociateIamInstanceProfileRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AssociationId [String] <p>The ID of the IAM instance profile association.</p>
-- Required key: AssociationId
-- @return DisassociateIamInstanceProfileRequest structure as a key-value pair table
function M.DisassociateIamInstanceProfileRequest(args)
	assert(args, "You must provide an argument table when creating DisassociateIamInstanceProfileRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AssociationId"] = args["AssociationId"],
	}
	asserts.AssertDisassociateIamInstanceProfileRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteLaunchTemplateResult = { ["LaunchTemplate"] = true, nil }

function asserts.AssertDeleteLaunchTemplateResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteLaunchTemplateResult to be of type 'table'")
	if struct["LaunchTemplate"] then asserts.AssertLaunchTemplate(struct["LaunchTemplate"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteLaunchTemplateResult[k], "DeleteLaunchTemplateResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteLaunchTemplateResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplate [LaunchTemplate] <p>Information about the launch template.</p>
-- @return DeleteLaunchTemplateResult structure as a key-value pair table
function M.DeleteLaunchTemplateResult(args)
	assert(args, "You must provide an argument table when creating DeleteLaunchTemplateResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplate"] = args["LaunchTemplate"],
	}
	asserts.AssertDeleteLaunchTemplateResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplatePlacement = { ["HostId"] = true, ["AvailabilityZone"] = true, ["SpreadDomain"] = true, ["GroupName"] = true, ["Tenancy"] = true, ["Affinity"] = true, nil }

function asserts.AssertLaunchTemplatePlacement(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplatePlacement to be of type 'table'")
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["SpreadDomain"] then asserts.AssertString(struct["SpreadDomain"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["Tenancy"] then asserts.AssertTenancy(struct["Tenancy"]) end
	if struct["Affinity"] then asserts.AssertString(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplatePlacement[k], "LaunchTemplatePlacement contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplatePlacement
-- <p>Describes the placement of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HostId [String] <p>The ID of the Dedicated Host for the instance.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- * SpreadDomain [String] <p>Reserved for future use.</p>
-- * GroupName [String] <p>The name of the placement group for the instance.</p>
-- * Tenancy [Tenancy] <p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. </p>
-- * Affinity [String] <p>The affinity setting for the instance on the Dedicated Host.</p>
-- @return LaunchTemplatePlacement structure as a key-value pair table
function M.LaunchTemplatePlacement(args)
	assert(args, "You must provide an argument table when creating LaunchTemplatePlacement")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HostId"] = args["HostId"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["SpreadDomain"] = args["SpreadDomain"],
		["GroupName"] = args["GroupName"],
		["Tenancy"] = args["Tenancy"],
		["Affinity"] = args["Affinity"],
	}
	asserts.AssertLaunchTemplatePlacement(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AllocateAddressRequest = { ["Domain"] = true, ["DryRun"] = true, ["PublicIpv4Pool"] = true, ["Address"] = true, nil }

function asserts.AssertAllocateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllocateAddressRequest to be of type 'table'")
	if struct["Domain"] then asserts.AssertDomainType(struct["Domain"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["PublicIpv4Pool"] then asserts.AssertString(struct["PublicIpv4Pool"]) end
	if struct["Address"] then asserts.AssertString(struct["Address"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllocateAddressRequest[k], "AllocateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllocateAddressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Domain [DomainType] <p>Set to <code>vpc</code> to allocate the address for use with instances in a VPC.</p> <p>Default: The address is for use with instances in EC2-Classic.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * PublicIpv4Pool [String] <p>The ID of an address pool that you own. Use this parameter to let Amazon EC2 select an address from the address pool. To specify a specific address from the address pool, use the <code>Address</code> parameter instead.</p>
-- * Address [String] <p>[EC2-VPC] The Elastic IP address to recover or an IPv4 address from an address pool.</p>
-- @return AllocateAddressRequest structure as a key-value pair table
function M.AllocateAddressRequest(args)
	assert(args, "You must provide an argument table when creating AllocateAddressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Domain"] = args["Domain"],
		["DryRun"] = args["DryRun"],
		["PublicIpv4Pool"] = args["PublicIpv4Pool"],
		["Address"] = args["Address"],
	}
	asserts.AssertAllocateAddressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIamInstanceProfileAssociationsResult = { ["IamInstanceProfileAssociations"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeIamInstanceProfileAssociationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIamInstanceProfileAssociationsResult to be of type 'table'")
	if struct["IamInstanceProfileAssociations"] then asserts.AssertIamInstanceProfileAssociationSet(struct["IamInstanceProfileAssociations"]) end
	if struct["NextToken"] then asserts.AssertNextToken(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIamInstanceProfileAssociationsResult[k], "DescribeIamInstanceProfileAssociationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIamInstanceProfileAssociationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IamInstanceProfileAssociations [IamInstanceProfileAssociationSet] <p>Information about one or more IAM instance profile associations.</p>
-- * NextToken [NextToken] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeIamInstanceProfileAssociationsResult structure as a key-value pair table
function M.DescribeIamInstanceProfileAssociationsResult(args)
	assert(args, "You must provide an argument table when creating DescribeIamInstanceProfileAssociationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IamInstanceProfileAssociations"] = args["IamInstanceProfileAssociations"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeIamInstanceProfileAssociationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttributeBooleanValue = { ["Value"] = true, nil }

function asserts.AssertAttributeBooleanValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttributeBooleanValue to be of type 'table'")
	if struct["Value"] then asserts.AssertBoolean(struct["Value"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttributeBooleanValue[k], "AttributeBooleanValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttributeBooleanValue
-- <p>Describes a value for a resource attribute that is a Boolean value.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Value [Boolean] <p>The attribute value. The valid values are <code>true</code> or <code>false</code>.</p>
-- @return AttributeBooleanValue structure as a key-value pair table
function M.AttributeBooleanValue(args)
	assert(args, "You must provide an argument table when creating AttributeBooleanValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Value"] = args["Value"],
	}
	asserts.AssertAttributeBooleanValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSnapshotAttributeRequest = { ["Attribute"] = true, ["DryRun"] = true, ["SnapshotId"] = true, nil }

function asserts.AssertDescribeSnapshotAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSnapshotAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["SnapshotId"], "Expected key SnapshotId to exist in table")
	if struct["Attribute"] then asserts.AssertSnapshotAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSnapshotAttributeRequest[k], "DescribeSnapshotAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSnapshotAttributeRequest
-- <p>Contains the parameters for DescribeSnapshotAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [SnapshotAttributeName] <p>The snapshot attribute you would like to view.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * SnapshotId [String] <p>The ID of the EBS snapshot.</p>
-- Required key: Attribute
-- Required key: SnapshotId
-- @return DescribeSnapshotAttributeRequest structure as a key-value pair table
function M.DescribeSnapshotAttributeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeSnapshotAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
		["SnapshotId"] = args["SnapshotId"],
	}
	asserts.AssertDescribeSnapshotAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAvailabilityZonesRequest = { ["DryRun"] = true, ["Filters"] = true, ["ZoneNames"] = true, nil }

function asserts.AssertDescribeAvailabilityZonesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAvailabilityZonesRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ZoneNames"] then asserts.AssertZoneNameStringList(struct["ZoneNames"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAvailabilityZonesRequest[k], "DescribeAvailabilityZonesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAvailabilityZonesRequest
-- <p>Contains the parameters for DescribeAvailabilityZones.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>message</code> - Information about the Availability Zone.</p> </li> <li> <p> <code>region-name</code> - The name of the region for the Availability Zone (for example, <code>us-east-1</code>).</p> </li> <li> <p> <code>state</code> - The state of the Availability Zone (<code>available</code> | <code>information</code> | <code>impaired</code> | <code>unavailable</code>).</p> </li> <li> <p> <code>zone-name</code> - The name of the Availability Zone (for example, <code>us-east-1a</code>).</p> </li> </ul>
-- * ZoneNames [ZoneNameStringList] <p>The names of one or more Availability Zones.</p>
-- @return DescribeAvailabilityZonesRequest structure as a key-value pair table
function M.DescribeAvailabilityZonesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeAvailabilityZonesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["ZoneNames"] = args["ZoneNames"],
	}
	asserts.AssertDescribeAvailabilityZonesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DetachVolumeRequest = { ["Device"] = true, ["InstanceId"] = true, ["DryRun"] = true, ["Force"] = true, ["VolumeId"] = true, nil }

function asserts.AssertDetachVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DetachVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DetachVolumeRequest[k], "DetachVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DetachVolumeRequest
-- <p>Contains the parameters for DetachVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Device [String] <p>The device name.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Force [Boolean] <p>Forces detachment if the previous detachment attempt did not occur cleanly (for example, logging into an instance, unmounting the volume, and detaching normally). This option can lead to data loss or a corrupted file system. Use this option only as a last resort to detach a volume from a failed instance. The instance won't have an opportunity to flush file system caches or file system metadata. If you use this option, you must perform file system check and repair procedures.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- Required key: VolumeId
-- @return DetachVolumeRequest structure as a key-value pair table
function M.DetachVolumeRequest(args)
	assert(args, "You must provide an argument table when creating DetachVolumeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Device"] = args["Device"],
		["InstanceId"] = args["InstanceId"],
		["DryRun"] = args["DryRun"],
		["Force"] = args["Force"],
		["VolumeId"] = args["VolumeId"],
	}
	asserts.AssertDetachVolumeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResetFpgaImageAttributeResult = { ["Return"] = true, nil }

function asserts.AssertResetFpgaImageAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetFpgaImageAttributeResult to be of type 'table'")
	if struct["Return"] then asserts.AssertBoolean(struct["Return"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetFpgaImageAttributeResult[k], "ResetFpgaImageAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetFpgaImageAttributeResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Return [Boolean] <p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>
-- @return ResetFpgaImageAttributeResult structure as a key-value pair table
function M.ResetFpgaImageAttributeResult(args)
	assert(args, "You must provide an argument table when creating ResetFpgaImageAttributeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Return"] = args["Return"],
	}
	asserts.AssertResetFpgaImageAttributeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ResetInstanceAttributeRequest = { ["InstanceId"] = true, ["Attribute"] = true, ["DryRun"] = true, nil }

function asserts.AssertResetInstanceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ResetInstanceAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Attribute"] then asserts.AssertInstanceAttributeName(struct["Attribute"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.ResetInstanceAttributeRequest[k], "ResetInstanceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ResetInstanceAttributeRequest
-- <p>Contains the parameters for ResetInstanceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Attribute [InstanceAttributeName] <p>The attribute to reset.</p> <important> <p>You can only reset the following attributes: <code>kernel</code> | <code>ramdisk</code> | <code>sourceDestCheck</code>. To change an instance attribute, use <a>ModifyInstanceAttribute</a>.</p> </important>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Attribute
-- Required key: InstanceId
-- @return ResetInstanceAttributeRequest structure as a key-value pair table
function M.ResetInstanceAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ResetInstanceAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Attribute"] = args["Attribute"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertResetInstanceAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.SnapshotDiskContainer = { ["Url"] = true, ["UserBucket"] = true, ["Description"] = true, ["Format"] = true, nil }

function asserts.AssertSnapshotDiskContainer(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected SnapshotDiskContainer to be of type 'table'")
	if struct["Url"] then asserts.AssertString(struct["Url"]) end
	if struct["UserBucket"] then asserts.AssertUserBucket(struct["UserBucket"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Format"] then asserts.AssertString(struct["Format"]) end
	for k,_ in pairs(struct) do
		assert(keys.SnapshotDiskContainer[k], "SnapshotDiskContainer contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type SnapshotDiskContainer
-- <p>The disk container object for the import snapshot request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Url [String] <p>The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).</p>
-- * UserBucket [UserBucket] <p>The S3 bucket for the disk image.</p>
-- * Description [String] <p>The description of the disk image being imported.</p>
-- * Format [String] <p>The format of the disk image being imported.</p> <p>Valid values: <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>
-- @return SnapshotDiskContainer structure as a key-value pair table
function M.SnapshotDiskContainer(args)
	assert(args, "You must provide an argument table when creating SnapshotDiskContainer")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Url"] = args["Url"],
		["UserBucket"] = args["UserBucket"],
		["Description"] = args["Description"],
		["Format"] = args["Format"],
	}
	asserts.AssertSnapshotDiskContainer(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RestoreAddressToClassicRequest = { ["PublicIp"] = true, ["DryRun"] = true, nil }

function asserts.AssertRestoreAddressToClassicRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RestoreAddressToClassicRequest to be of type 'table'")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.RestoreAddressToClassicRequest[k], "RestoreAddressToClassicRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RestoreAddressToClassicRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Elastic IP address.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: PublicIp
-- @return RestoreAddressToClassicRequest structure as a key-value pair table
function M.RestoreAddressToClassicRequest(args)
	assert(args, "You must provide an argument table when creating RestoreAddressToClassicRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertRestoreAddressToClassicRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFleetHistoryResult = { ["HistoryRecords"] = true, ["NextToken"] = true, ["FleetId"] = true, ["LastEvaluatedTime"] = true, ["StartTime"] = true, nil }

function asserts.AssertDescribeFleetHistoryResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFleetHistoryResult to be of type 'table'")
	if struct["HistoryRecords"] then asserts.AssertHistoryRecordSet(struct["HistoryRecords"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	if struct["LastEvaluatedTime"] then asserts.AssertDateTime(struct["LastEvaluatedTime"]) end
	if struct["StartTime"] then asserts.AssertDateTime(struct["StartTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFleetHistoryResult[k], "DescribeFleetHistoryResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFleetHistoryResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * HistoryRecords [HistoryRecordSet] <p>Information about the events in the history of the EC2 Fleet.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * FleetId [FleetIdentifier] <p>The ID of the EC Fleet.</p>
-- * LastEvaluatedTime [DateTime] <p>The last date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). All records up to this time were retrieved.</p> <p>If <code>nextToken</code> indicates that there are more results, this value is not present.</p>
-- * StartTime [DateTime] <p>The start date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>
-- @return DescribeFleetHistoryResult structure as a key-value pair table
function M.DescribeFleetHistoryResult(args)
	assert(args, "You must provide an argument table when creating DescribeFleetHistoryResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["HistoryRecords"] = args["HistoryRecords"],
		["NextToken"] = args["NextToken"],
		["FleetId"] = args["FleetId"],
		["LastEvaluatedTime"] = args["LastEvaluatedTime"],
		["StartTime"] = args["StartTime"],
	}
	asserts.AssertDescribeFleetHistoryResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCapacityReservationsRequest = { ["CapacityReservationIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["Filters"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeCapacityReservationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCapacityReservationsRequest to be of type 'table'")
	if struct["CapacityReservationIds"] then asserts.AssertCapacityReservationIdSet(struct["CapacityReservationIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCapacityReservationsRequest[k], "DescribeCapacityReservationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCapacityReservationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationIds [CapacityReservationIdSet] <p>The ID of the Capacity Reservation.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results can be seen by sending another request with the returned nextToken value.</p>
-- @return DescribeCapacityReservationsRequest structure as a key-value pair table
function M.DescribeCapacityReservationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeCapacityReservationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationIds"] = args["CapacityReservationIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeCapacityReservationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.OnDemandOptions = { ["AllocationStrategy"] = true, nil }

function asserts.AssertOnDemandOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected OnDemandOptions to be of type 'table'")
	if struct["AllocationStrategy"] then asserts.AssertFleetOnDemandAllocationStrategy(struct["AllocationStrategy"]) end
	for k,_ in pairs(struct) do
		assert(keys.OnDemandOptions[k], "OnDemandOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type OnDemandOptions
-- <p>The allocation strategy of On-Demand Instances in an EC2 Fleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllocationStrategy [FleetOnDemandAllocationStrategy] <p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first. If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>
-- @return OnDemandOptions structure as a key-value pair table
function M.OnDemandOptions(args)
	assert(args, "You must provide an argument table when creating OnDemandOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AllocationStrategy"] = args["AllocationStrategy"],
	}
	asserts.AssertOnDemandOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PrivateIpAddressSpecification = { ["Primary"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertPrivateIpAddressSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PrivateIpAddressSpecification to be of type 'table'")
	if struct["Primary"] then asserts.AssertBoolean(struct["Primary"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.PrivateIpAddressSpecification[k], "PrivateIpAddressSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PrivateIpAddressSpecification
-- <p>Describes a secondary private IPv4 address for a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Primary [Boolean] <p>Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.</p>
-- * PrivateIpAddress [String] <p>The private IPv4 addresses.</p>
-- @return PrivateIpAddressSpecification structure as a key-value pair table
function M.PrivateIpAddressSpecification(args)
	assert(args, "You must provide an argument table when creating PrivateIpAddressSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Primary"] = args["Primary"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertPrivateIpAddressSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UpdateSecurityGroupRuleDescriptionsEgressRequest = { ["IpPermissions"] = true, ["GroupName"] = true, ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertUpdateSecurityGroupRuleDescriptionsEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UpdateSecurityGroupRuleDescriptionsEgressRequest to be of type 'table'")
	assert(struct["IpPermissions"], "Expected key IpPermissions to exist in table")
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.UpdateSecurityGroupRuleDescriptionsEgressRequest[k], "UpdateSecurityGroupRuleDescriptionsEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UpdateSecurityGroupRuleDescriptionsEgressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IpPermissions [IpPermissionList] <p>The IP permissions for the security group rule.</p>
-- * GroupName [String] <p>[Default VPC] The name of the security group. You must specify either the security group ID or the security group name in the request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupId [String] <p>The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.</p>
-- Required key: IpPermissions
-- @return UpdateSecurityGroupRuleDescriptionsEgressRequest structure as a key-value pair table
function M.UpdateSecurityGroupRuleDescriptionsEgressRequest(args)
	assert(args, "You must provide an argument table when creating UpdateSecurityGroupRuleDescriptionsEgressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IpPermissions"] = args["IpPermissions"],
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertUpdateSecurityGroupRuleDescriptionsEgressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AcceptReservedInstancesExchangeQuoteRequest = { ["ReservedInstanceIds"] = true, ["DryRun"] = true, ["TargetConfigurations"] = true, nil }

function asserts.AssertAcceptReservedInstancesExchangeQuoteRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptReservedInstancesExchangeQuoteRequest to be of type 'table'")
	assert(struct["ReservedInstanceIds"], "Expected key ReservedInstanceIds to exist in table")
	if struct["ReservedInstanceIds"] then asserts.AssertReservedInstanceIdSet(struct["ReservedInstanceIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["TargetConfigurations"] then asserts.AssertTargetConfigurationRequestSet(struct["TargetConfigurations"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptReservedInstancesExchangeQuoteRequest[k], "AcceptReservedInstancesExchangeQuoteRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptReservedInstancesExchangeQuoteRequest
-- <p>Contains the parameters for accepting the quote.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstanceIds [ReservedInstanceIdSet] <p>The IDs of the Convertible Reserved Instances to exchange for another Convertible Reserved Instance of the same or higher value.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * TargetConfigurations [TargetConfigurationRequestSet] <p>The configuration of the target Convertible Reserved Instance to exchange for your current Convertible Reserved Instances.</p>
-- Required key: ReservedInstanceIds
-- @return AcceptReservedInstancesExchangeQuoteRequest structure as a key-value pair table
function M.AcceptReservedInstancesExchangeQuoteRequest(args)
	assert(args, "You must provide an argument table when creating AcceptReservedInstancesExchangeQuoteRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstanceIds"] = args["ReservedInstanceIds"],
		["DryRun"] = args["DryRun"],
		["TargetConfigurations"] = args["TargetConfigurations"],
	}
	asserts.AssertAcceptReservedInstancesExchangeQuoteRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TargetGroup = { ["Arn"] = true, nil }

function asserts.AssertTargetGroup(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetGroup to be of type 'table'")
	assert(struct["Arn"], "Expected key Arn to exist in table")
	if struct["Arn"] then asserts.AssertString(struct["Arn"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetGroup[k], "TargetGroup contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetGroup
-- <p>Describes a load balancer target group.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Arn [String] <p>The Amazon Resource Name (ARN) of the target group.</p>
-- Required key: Arn
-- @return TargetGroup structure as a key-value pair table
function M.TargetGroup(args)
	assert(args, "You must provide an argument table when creating TargetGroup")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Arn"] = args["Arn"],
	}
	asserts.AssertTargetGroup(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachVpnGatewayRequest = { ["VpcId"] = true, ["DryRun"] = true, ["VpnGatewayId"] = true, nil }

function asserts.AssertAttachVpnGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachVpnGatewayRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["VpnGatewayId"], "Expected key VpnGatewayId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpnGatewayId"] then asserts.AssertString(struct["VpnGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachVpnGatewayRequest[k], "AttachVpnGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachVpnGatewayRequest
-- <p>Contains the parameters for AttachVpnGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpnGatewayId [String] <p>The ID of the virtual private gateway.</p>
-- Required key: VpcId
-- Required key: VpnGatewayId
-- @return AttachVpnGatewayRequest structure as a key-value pair table
function M.AttachVpnGatewayRequest(args)
	assert(args, "You must provide an argument table when creating AttachVpnGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["VpnGatewayId"] = args["VpnGatewayId"],
	}
	asserts.AssertAttachVpnGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcEndpointRequest = { ["VpcId"] = true, ["DryRun"] = true, ["ServiceName"] = true, ["SubnetIds"] = true, ["SecurityGroupIds"] = true, ["PolicyDocument"] = true, ["RouteTableIds"] = true, ["ClientToken"] = true, ["PrivateDnsEnabled"] = true, ["VpcEndpointType"] = true, nil }

function asserts.AssertCreateVpcEndpointRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcEndpointRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	assert(struct["ServiceName"], "Expected key ServiceName to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ServiceName"] then asserts.AssertString(struct["ServiceName"]) end
	if struct["SubnetIds"] then asserts.AssertValueStringList(struct["SubnetIds"]) end
	if struct["SecurityGroupIds"] then asserts.AssertValueStringList(struct["SecurityGroupIds"]) end
	if struct["PolicyDocument"] then asserts.AssertString(struct["PolicyDocument"]) end
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["PrivateDnsEnabled"] then asserts.AssertBoolean(struct["PrivateDnsEnabled"]) end
	if struct["VpcEndpointType"] then asserts.AssertVpcEndpointType(struct["VpcEndpointType"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcEndpointRequest[k], "CreateVpcEndpointRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcEndpointRequest
-- <p>Contains the parameters for CreateVpcEndpoint.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC in which the endpoint will be used.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ServiceName [String] <p>The service name. To get a list of available services, use the <a>DescribeVpcEndpointServices</a> request, or get the name from the service provider.</p>
-- * SubnetIds [ValueStringList] <p>(Interface endpoint) The ID of one or more subnets in which to create an endpoint network interface.</p>
-- * SecurityGroupIds [ValueStringList] <p>(Interface endpoint) The ID of one or more security groups to associate with the endpoint network interface.</p>
-- * PolicyDocument [String] <p>(Gateway endpoint) A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.</p>
-- * RouteTableIds [ValueStringList] <p>(Gateway endpoint) One or more route table IDs.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">How to Ensure Idempotency</a>.</p>
-- * PrivateDnsEnabled [Boolean] <p>(Interface endpoint) Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the region (for example, <code>kinesis.us-east-1.amazonaws.com</code>) which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.</p> <p>To use a private hosted zone, you must set the following VPC attributes to <code>true</code>: <code>enableDnsHostnames</code> and <code>enableDnsSupport</code>. Use <a>ModifyVpcAttribute</a> to set the VPC attributes.</p> <p>Default: <code>false</code> </p>
-- * VpcEndpointType [VpcEndpointType] <p>The type of endpoint.</p> <p>Default: Gateway</p>
-- Required key: VpcId
-- Required key: ServiceName
-- @return CreateVpcEndpointRequest structure as a key-value pair table
function M.CreateVpcEndpointRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpcEndpointRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
		["ServiceName"] = args["ServiceName"],
		["SubnetIds"] = args["SubnetIds"],
		["SecurityGroupIds"] = args["SecurityGroupIds"],
		["PolicyDocument"] = args["PolicyDocument"],
		["RouteTableIds"] = args["RouteTableIds"],
		["ClientToken"] = args["ClientToken"],
		["PrivateDnsEnabled"] = args["PrivateDnsEnabled"],
		["VpcEndpointType"] = args["VpcEndpointType"],
	}
	asserts.AssertCreateVpcEndpointRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssociateAddressRequest = { ["DryRun"] = true, ["InstanceId"] = true, ["NetworkInterfaceId"] = true, ["PublicIp"] = true, ["AllowReassociation"] = true, ["AllocationId"] = true, ["PrivateIpAddress"] = true, nil }

function asserts.AssertAssociateAddressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssociateAddressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AllowReassociation"] then asserts.AssertBoolean(struct["AllowReassociation"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssociateAddressRequest[k], "AssociateAddressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssociateAddressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceId [String] <p>The ID of the instance. This is required for EC2-Classic. For EC2-VPC, you can specify either the instance ID or the network interface ID, but not both. The operation fails if you specify an instance ID unless exactly one network interface is attached.</p>
-- * NetworkInterfaceId [String] <p>[EC2-VPC] The ID of the network interface. If the instance has more than one network interface, you must specify a network interface ID.</p>
-- * PublicIp [String] <p>The Elastic IP address. This is required for EC2-Classic.</p>
-- * AllowReassociation [Boolean] <p>[EC2-VPC] For a VPC in an EC2-Classic account, specify true to allow an Elastic IP address that is already associated with an instance or network interface to be reassociated with the specified instance or network interface. Otherwise, the operation fails. In a VPC in an EC2-VPC-only account, reassociation is automatic, therefore you can specify false to ensure the operation fails if the Elastic IP address is already associated with another resource.</p>
-- * AllocationId [String] <p>[EC2-VPC] The allocation ID. This is required for EC2-VPC.</p>
-- * PrivateIpAddress [String] <p>[EC2-VPC] The primary or secondary private IP address to associate with the Elastic IP address. If no private IP address is specified, the Elastic IP address is associated with the primary private IP address.</p>
-- @return AssociateAddressRequest structure as a key-value pair table
function M.AssociateAddressRequest(args)
	assert(args, "You must provide an argument table when creating AssociateAddressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["InstanceId"] = args["InstanceId"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["PublicIp"] = args["PublicIp"],
		["AllowReassociation"] = args["AllowReassociation"],
		["AllocationId"] = args["AllocationId"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
	}
	asserts.AssertAssociateAddressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFleetInstancesRequest = { ["FleetId"] = true, ["NextToken"] = true, ["DryRun"] = true, ["Filters"] = true, ["MaxResults"] = true, nil }

function asserts.AssertDescribeFleetInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFleetInstancesRequest to be of type 'table'")
	assert(struct["FleetId"], "Expected key FleetId to exist in table")
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFleetInstancesRequest[k], "DescribeFleetInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFleetInstancesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- * NextToken [String] <p>The token for the next set of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>instance-type</code> - The instance type.</p> </li> </ul>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. Specify a value between 1 and 1000. The default value is 1000. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value.</p>
-- Required key: FleetId
-- @return DescribeFleetInstancesRequest structure as a key-value pair table
function M.DescribeFleetInstancesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeFleetInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FleetId"] = args["FleetId"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["MaxResults"] = args["MaxResults"],
	}
	asserts.AssertDescribeFleetInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeLaunchTemplatesRequest = { ["DryRun"] = true, ["LaunchTemplateIds"] = true, ["MaxResults"] = true, ["Filters"] = true, ["LaunchTemplateNames"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeLaunchTemplatesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeLaunchTemplatesRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["LaunchTemplateIds"] then asserts.AssertValueStringList(struct["LaunchTemplateIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["LaunchTemplateNames"] then asserts.AssertLaunchTemplateNameStringList(struct["LaunchTemplateNames"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeLaunchTemplatesRequest[k], "DescribeLaunchTemplatesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeLaunchTemplatesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * LaunchTemplateIds [ValueStringList] <p>One or more launch template IDs.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>create-time</code> - The time the launch template was created.</p> </li> <li> <p> <code>launch-template-name</code> - The name of the launch template.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> </ul>
-- * LaunchTemplateNames [LaunchTemplateNameStringList] <p>One or more launch template names.</p>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- @return DescribeLaunchTemplatesRequest structure as a key-value pair table
function M.DescribeLaunchTemplatesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeLaunchTemplatesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["LaunchTemplateIds"] = args["LaunchTemplateIds"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["LaunchTemplateNames"] = args["LaunchTemplateNames"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeLaunchTemplatesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteNatGatewayResult = { ["NatGatewayId"] = true, nil }

function asserts.AssertDeleteNatGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNatGatewayResult to be of type 'table'")
	if struct["NatGatewayId"] then asserts.AssertString(struct["NatGatewayId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNatGatewayResult[k], "DeleteNatGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNatGatewayResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NatGatewayId [String] <p>The ID of the NAT gateway.</p>
-- @return DeleteNatGatewayResult structure as a key-value pair table
function M.DeleteNatGatewayResult(args)
	assert(args, "You must provide an argument table when creating DeleteNatGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NatGatewayId"] = args["NatGatewayId"],
	}
	asserts.AssertDeleteNatGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportImageTask = { ["Status"] = true, ["LicenseType"] = true, ["Description"] = true, ["Hypervisor"] = true, ["ImageId"] = true, ["Platform"] = true, ["Architecture"] = true, ["SnapshotDetails"] = true, ["Progress"] = true, ["StatusMessage"] = true, ["ImportTaskId"] = true, nil }

function asserts.AssertImportImageTask(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportImageTask to be of type 'table'")
	if struct["Status"] then asserts.AssertString(struct["Status"]) end
	if struct["LicenseType"] then asserts.AssertString(struct["LicenseType"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Hypervisor"] then asserts.AssertString(struct["Hypervisor"]) end
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	if struct["Platform"] then asserts.AssertString(struct["Platform"]) end
	if struct["Architecture"] then asserts.AssertString(struct["Architecture"]) end
	if struct["SnapshotDetails"] then asserts.AssertSnapshotDetailList(struct["SnapshotDetails"]) end
	if struct["Progress"] then asserts.AssertString(struct["Progress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	if struct["ImportTaskId"] then asserts.AssertString(struct["ImportTaskId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportImageTask[k], "ImportImageTask contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportImageTask
-- <p>Describes an import image task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [String] <p>A brief status for the import image task.</p>
-- * LicenseType [String] <p>The license type of the virtual machine.</p>
-- * Description [String] <p>A description of the import task.</p>
-- * Hypervisor [String] <p>The target hypervisor for the import task.</p> <p>Valid values: <code>xen</code> </p>
-- * ImageId [String] <p>The ID of the Amazon Machine Image (AMI) of the imported virtual machine.</p>
-- * Platform [String] <p>The description string for the import image task.</p>
-- * Architecture [String] <p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> </p>
-- * SnapshotDetails [SnapshotDetailList] <p>Information about the snapshots.</p>
-- * Progress [String] <p>The percentage of progress of the import image task.</p>
-- * StatusMessage [String] <p>A descriptive status message for the import image task.</p>
-- * ImportTaskId [String] <p>The ID of the import image task.</p>
-- @return ImportImageTask structure as a key-value pair table
function M.ImportImageTask(args)
	assert(args, "You must provide an argument table when creating ImportImageTask")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["LicenseType"] = args["LicenseType"],
		["Description"] = args["Description"],
		["Hypervisor"] = args["Hypervisor"],
		["ImageId"] = args["ImageId"],
		["Platform"] = args["Platform"],
		["Architecture"] = args["Architecture"],
		["SnapshotDetails"] = args["SnapshotDetails"],
		["Progress"] = args["Progress"],
		["StatusMessage"] = args["StatusMessage"],
		["ImportTaskId"] = args["ImportTaskId"],
	}
	asserts.AssertImportImageTask(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeRouteTablesRequest = { ["RouteTableIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeRouteTablesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeRouteTablesRequest to be of type 'table'")
	if struct["RouteTableIds"] then asserts.AssertValueStringList(struct["RouteTableIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeRouteTablesRequest[k], "DescribeRouteTablesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeRouteTablesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * RouteTableIds [ValueStringList] <p>One or more route table IDs.</p> <p>Default: Describes all your route tables.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <b>NextToken</b> value. This value can be between 5 and 100.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>association.route-table-association-id</code> - The ID of an association ID for the route table.</p> </li> <li> <p> <code>association.route-table-id</code> - The ID of the route table involved in the association.</p> </li> <li> <p> <code>association.subnet-id</code> - The ID of the subnet involved in the association.</p> </li> <li> <p> <code>association.main</code> - Indicates whether the route table is the main route table for the VPC (<code>true</code> | <code>false</code>). Route tables that do not have an association ID are not returned in the response.</p> </li> <li> <p> <code>route-table-id</code> - The ID of the route table.</p> </li> <li> <p> <code>route.destination-cidr-block</code> - The IPv4 CIDR range specified in a route in the table.</p> </li> <li> <p> <code>route.destination-ipv6-cidr-block</code> - The IPv6 CIDR range specified in a route in the route table.</p> </li> <li> <p> <code>route.destination-prefix-list-id</code> - The ID (prefix) of the AWS service specified in a route in the table.</p> </li> <li> <p> <code>route.egress-only-internet-gateway-id</code> - The ID of an egress-only Internet gateway specified in a route in the route table.</p> </li> <li> <p> <code>route.gateway-id</code> - The ID of a gateway specified in a route in the table.</p> </li> <li> <p> <code>route.instance-id</code> - The ID of an instance specified in a route in the table.</p> </li> <li> <p> <code>route.nat-gateway-id</code> - The ID of a NAT gateway.</p> </li> <li> <p> <code>route.origin</code> - Describes how the route was created. <code>CreateRouteTable</code> indicates that the route was automatically created when the route table was created; <code>CreateRoute</code> indicates that the route was manually added to the route table; <code>EnableVgwRoutePropagation</code> indicates that the route was propagated by route propagation.</p> </li> <li> <p> <code>route.state</code> - The state of a route in the route table (<code>active</code> | <code>blackhole</code>). The blackhole state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, the specified NAT instance has been terminated, and so on).</p> </li> <li> <p> <code>route.vpc-peering-connection-id</code> - The ID of a VPC peering connection specified in a route in the table.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC for the route table.</p> </li> </ul>
-- @return DescribeRouteTablesRequest structure as a key-value pair table
function M.DescribeRouteTablesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeRouteTablesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["RouteTableIds"] = args["RouteTableIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeRouteTablesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateInternetGatewayResult = { ["InternetGateway"] = true, nil }

function asserts.AssertCreateInternetGatewayResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateInternetGatewayResult to be of type 'table'")
	if struct["InternetGateway"] then asserts.AssertInternetGateway(struct["InternetGateway"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateInternetGatewayResult[k], "CreateInternetGatewayResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateInternetGatewayResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InternetGateway [InternetGateway] <p>Information about the internet gateway.</p>
-- @return CreateInternetGatewayResult structure as a key-value pair table
function M.CreateInternetGatewayResult(args)
	assert(args, "You must provide an argument table when creating CreateInternetGatewayResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InternetGateway"] = args["InternetGateway"],
	}
	asserts.AssertCreateInternetGatewayResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVpcEndpointServiceConfigurationRequest = { ["AcceptanceRequired"] = true, ["AddNetworkLoadBalancerArns"] = true, ["ServiceId"] = true, ["DryRun"] = true, ["RemoveNetworkLoadBalancerArns"] = true, nil }

function asserts.AssertModifyVpcEndpointServiceConfigurationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVpcEndpointServiceConfigurationRequest to be of type 'table'")
	assert(struct["ServiceId"], "Expected key ServiceId to exist in table")
	if struct["AcceptanceRequired"] then asserts.AssertBoolean(struct["AcceptanceRequired"]) end
	if struct["AddNetworkLoadBalancerArns"] then asserts.AssertValueStringList(struct["AddNetworkLoadBalancerArns"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["RemoveNetworkLoadBalancerArns"] then asserts.AssertValueStringList(struct["RemoveNetworkLoadBalancerArns"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVpcEndpointServiceConfigurationRequest[k], "ModifyVpcEndpointServiceConfigurationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVpcEndpointServiceConfigurationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AcceptanceRequired [Boolean] <p>Indicate whether requests to create an endpoint to your service must be accepted.</p>
-- * AddNetworkLoadBalancerArns [ValueStringList] <p>The Amazon Resource Names (ARNs) of Network Load Balancers to add to your service configuration.</p>
-- * ServiceId [String] <p>The ID of the service.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * RemoveNetworkLoadBalancerArns [ValueStringList] <p>The Amazon Resource Names (ARNs) of Network Load Balancers to remove from your service configuration.</p>
-- Required key: ServiceId
-- @return ModifyVpcEndpointServiceConfigurationRequest structure as a key-value pair table
function M.ModifyVpcEndpointServiceConfigurationRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVpcEndpointServiceConfigurationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AcceptanceRequired"] = args["AcceptanceRequired"],
		["AddNetworkLoadBalancerArns"] = args["AddNetworkLoadBalancerArns"],
		["ServiceId"] = args["ServiceId"],
		["DryRun"] = args["DryRun"],
		["RemoveNetworkLoadBalancerArns"] = args["RemoveNetworkLoadBalancerArns"],
	}
	asserts.AssertModifyVpcEndpointServiceConfigurationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateConfig = { ["LaunchTemplateSpecification"] = true, ["Overrides"] = true, nil }

function asserts.AssertLaunchTemplateConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateConfig to be of type 'table'")
	if struct["LaunchTemplateSpecification"] then asserts.AssertFleetLaunchTemplateSpecification(struct["LaunchTemplateSpecification"]) end
	if struct["Overrides"] then asserts.AssertLaunchTemplateOverridesList(struct["Overrides"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateConfig[k], "LaunchTemplateConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateConfig
-- <p>Describes a launch template and overrides.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * LaunchTemplateSpecification [FleetLaunchTemplateSpecification] <p>The launch template.</p>
-- * Overrides [LaunchTemplateOverridesList] <p>Any parameters that you specify override the same parameters in the launch template.</p>
-- @return LaunchTemplateConfig structure as a key-value pair table
function M.LaunchTemplateConfig(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["LaunchTemplateSpecification"] = args["LaunchTemplateSpecification"],
		["Overrides"] = args["Overrides"],
	}
	asserts.AssertLaunchTemplateConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AllowedPrincipal = { ["PrincipalType"] = true, ["Principal"] = true, nil }

function asserts.AssertAllowedPrincipal(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AllowedPrincipal to be of type 'table'")
	if struct["PrincipalType"] then asserts.AssertPrincipalType(struct["PrincipalType"]) end
	if struct["Principal"] then asserts.AssertString(struct["Principal"]) end
	for k,_ in pairs(struct) do
		assert(keys.AllowedPrincipal[k], "AllowedPrincipal contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AllowedPrincipal
-- <p>Describes a principal.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PrincipalType [PrincipalType] <p>The type of principal.</p>
-- * Principal [String] <p>The Amazon Resource Name (ARN) of the principal.</p>
-- @return AllowedPrincipal structure as a key-value pair table
function M.AllowedPrincipal(args)
	assert(args, "You must provide an argument table when creating AllowedPrincipal")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PrincipalType"] = args["PrincipalType"],
		["Principal"] = args["Principal"],
	}
	asserts.AssertAllowedPrincipal(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeInstanceStatusResult = { ["InstanceStatuses"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeInstanceStatusResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeInstanceStatusResult to be of type 'table'")
	if struct["InstanceStatuses"] then asserts.AssertInstanceStatusList(struct["InstanceStatuses"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeInstanceStatusResult[k], "DescribeInstanceStatusResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeInstanceStatusResult
-- <p>Contains the output of DescribeInstanceStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceStatuses [InstanceStatusList] <p>One or more instance status descriptions.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeInstanceStatusResult structure as a key-value pair table
function M.DescribeInstanceStatusResult(args)
	assert(args, "You must provide an argument table when creating DescribeInstanceStatusResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceStatuses"] = args["InstanceStatuses"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeInstanceStatusResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RunScheduledInstancesResult = { ["InstanceIdSet"] = true, nil }

function asserts.AssertRunScheduledInstancesResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RunScheduledInstancesResult to be of type 'table'")
	if struct["InstanceIdSet"] then asserts.AssertInstanceIdSet(struct["InstanceIdSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.RunScheduledInstancesResult[k], "RunScheduledInstancesResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RunScheduledInstancesResult
-- <p>Contains the output of RunScheduledInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceIdSet [InstanceIdSet] <p>The IDs of the newly launched instances.</p>
-- @return RunScheduledInstancesResult structure as a key-value pair table
function M.RunScheduledInstancesResult(args)
	assert(args, "You must provide an argument table when creating RunScheduledInstancesResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceIdSet"] = args["InstanceIdSet"],
	}
	asserts.AssertRunScheduledInstancesResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetConsoleOutputResult = { ["InstanceId"] = true, ["Output"] = true, ["Timestamp"] = true, nil }

function asserts.AssertGetConsoleOutputResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleOutputResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["Output"] then asserts.AssertString(struct["Output"]) end
	if struct["Timestamp"] then asserts.AssertDateTime(struct["Timestamp"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleOutputResult[k], "GetConsoleOutputResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleOutputResult
-- <p>Contains the output of GetConsoleOutput.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * Output [String] <p>The console output, base64-encoded. If you are using a command line tool, the tool decodes the output for you.</p>
-- * Timestamp [DateTime] <p>The time at which the output was last updated.</p>
-- @return GetConsoleOutputResult structure as a key-value pair table
function M.GetConsoleOutputResult(args)
	assert(args, "You must provide an argument table when creating GetConsoleOutputResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["Output"] = args["Output"],
		["Timestamp"] = args["Timestamp"],
	}
	asserts.AssertGetConsoleOutputResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ClassicLinkInstance = { ["InstanceId"] = true, ["VpcId"] = true, ["Groups"] = true, ["Tags"] = true, nil }

function asserts.AssertClassicLinkInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLinkInstance[k], "ClassicLinkInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkInstance
-- <p>Describes a linked EC2-Classic instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * Groups [GroupIdentifierList] <p>A list of security groups.</p>
-- * Tags [TagList] <p>Any tags assigned to the instance.</p>
-- @return ClassicLinkInstance structure as a key-value pair table
function M.ClassicLinkInstance(args)
	assert(args, "You must provide an argument table when creating ClassicLinkInstance")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["VpcId"] = args["VpcId"],
		["Groups"] = args["Groups"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertClassicLinkInstance(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyNetworkInterfaceAttributeRequest = { ["SourceDestCheck"] = true, ["DryRun"] = true, ["Description"] = true, ["NetworkInterfaceId"] = true, ["Attachment"] = true, ["Groups"] = true, nil }

function asserts.AssertModifyNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachmentChanges(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertSecurityGroupIdStringList(struct["Groups"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyNetworkInterfaceAttributeRequest[k], "ModifyNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for ModifyNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means checking is enabled, and <code>false</code> means checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT. For more information, see <a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Description [AttributeValue] <p>A description for the network interface.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * Attachment [NetworkInterfaceAttachmentChanges] <p>Information about the interface attachment. If modifying the 'delete on termination' attribute, you must specify the ID of the interface attachment.</p>
-- * Groups [SecurityGroupIdStringList] <p>Changes the security groups for the network interface. The new set of groups you specify replaces the current set. You must specify at least one group, even if it's just the default security group in the VPC. You must specify the ID of the security group, not the name.</p>
-- Required key: NetworkInterfaceId
-- @return ModifyNetworkInterfaceAttributeRequest structure as a key-value pair table
function M.ModifyNetworkInterfaceAttributeRequest(args)
	assert(args, "You must provide an argument table when creating ModifyNetworkInterfaceAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SourceDestCheck"] = args["SourceDestCheck"],
		["DryRun"] = args["DryRun"],
		["Description"] = args["Description"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
	}
	asserts.AssertModifyNetworkInterfaceAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.InstanceStatus = { ["InstanceStatus"] = true, ["AvailabilityZone"] = true, ["InstanceId"] = true, ["InstanceState"] = true, ["Events"] = true, ["SystemStatus"] = true, nil }

function asserts.AssertInstanceStatus(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected InstanceStatus to be of type 'table'")
	if struct["InstanceStatus"] then asserts.AssertInstanceStatusSummary(struct["InstanceStatus"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceState"] then asserts.AssertInstanceState(struct["InstanceState"]) end
	if struct["Events"] then asserts.AssertInstanceStatusEventList(struct["Events"]) end
	if struct["SystemStatus"] then asserts.AssertInstanceStatusSummary(struct["SystemStatus"]) end
	for k,_ in pairs(struct) do
		assert(keys.InstanceStatus[k], "InstanceStatus contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type InstanceStatus
-- <p>Describes the status of an instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.</p>
-- * AvailabilityZone [String] <p>The Availability Zone of the instance.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * InstanceState [InstanceState] <p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires that an instance be in the <code>running</code> state.</p>
-- * Events [InstanceStatusEventList] <p>Any scheduled events associated with the instance.</p>
-- * SystemStatus [InstanceStatusSummary] <p>Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.</p>
-- @return InstanceStatus structure as a key-value pair table
function M.InstanceStatus(args)
	assert(args, "You must provide an argument table when creating InstanceStatus")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceStatus"] = args["InstanceStatus"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["InstanceId"] = args["InstanceId"],
		["InstanceState"] = args["InstanceState"],
		["Events"] = args["Events"],
		["SystemStatus"] = args["SystemStatus"],
	}
	asserts.AssertInstanceStatus(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AcceptVpcPeeringConnectionRequest = { ["DryRun"] = true, ["VpcPeeringConnectionId"] = true, nil }

function asserts.AssertAcceptVpcPeeringConnectionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AcceptVpcPeeringConnectionRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VpcPeeringConnectionId"] then asserts.AssertString(struct["VpcPeeringConnectionId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AcceptVpcPeeringConnectionRequest[k], "AcceptVpcPeeringConnectionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AcceptVpcPeeringConnectionRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VpcPeeringConnectionId [String] <p>The ID of the VPC peering connection. You must specify this parameter in the request.</p>
-- @return AcceptVpcPeeringConnectionRequest structure as a key-value pair table
function M.AcceptVpcPeeringConnectionRequest(args)
	assert(args, "You must provide an argument table when creating AcceptVpcPeeringConnectionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["VpcPeeringConnectionId"] = args["VpcPeeringConnectionId"],
	}
	asserts.AssertAcceptVpcPeeringConnectionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.PublicIpv4Pool = { ["TotalAvailableAddressCount"] = true, ["PoolAddressRanges"] = true, ["TotalAddressCount"] = true, ["Description"] = true, ["PoolId"] = true, nil }

function asserts.AssertPublicIpv4Pool(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected PublicIpv4Pool to be of type 'table'")
	if struct["TotalAvailableAddressCount"] then asserts.AssertInteger(struct["TotalAvailableAddressCount"]) end
	if struct["PoolAddressRanges"] then asserts.AssertPublicIpv4PoolRangeSet(struct["PoolAddressRanges"]) end
	if struct["TotalAddressCount"] then asserts.AssertInteger(struct["TotalAddressCount"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["PoolId"] then asserts.AssertString(struct["PoolId"]) end
	for k,_ in pairs(struct) do
		assert(keys.PublicIpv4Pool[k], "PublicIpv4Pool contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type PublicIpv4Pool
-- <p>Describes an address pool.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TotalAvailableAddressCount [Integer] <p>The total number of available addresses.</p>
-- * PoolAddressRanges [PublicIpv4PoolRangeSet] <p>The address ranges.</p>
-- * TotalAddressCount [Integer] <p>The total number of addresses.</p>
-- * Description [String] <p>A description of the address pool.</p>
-- * PoolId [String] <p>The ID of the IPv4 address pool.</p>
-- @return PublicIpv4Pool structure as a key-value pair table
function M.PublicIpv4Pool(args)
	assert(args, "You must provide an argument table when creating PublicIpv4Pool")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TotalAvailableAddressCount"] = args["TotalAvailableAddressCount"],
		["PoolAddressRanges"] = args["PoolAddressRanges"],
		["TotalAddressCount"] = args["TotalAddressCount"],
		["Description"] = args["Description"],
		["PoolId"] = args["PoolId"],
	}
	asserts.AssertPublicIpv4Pool(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LoadBalancersConfig = { ["TargetGroupsConfig"] = true, ["ClassicLoadBalancersConfig"] = true, nil }

function asserts.AssertLoadBalancersConfig(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LoadBalancersConfig to be of type 'table'")
	if struct["TargetGroupsConfig"] then asserts.AssertTargetGroupsConfig(struct["TargetGroupsConfig"]) end
	if struct["ClassicLoadBalancersConfig"] then asserts.AssertClassicLoadBalancersConfig(struct["ClassicLoadBalancersConfig"]) end
	for k,_ in pairs(struct) do
		assert(keys.LoadBalancersConfig[k], "LoadBalancersConfig contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LoadBalancersConfig
-- <p>Describes the Classic Load Balancers and target groups to attach to a Spot Fleet request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetGroupsConfig [TargetGroupsConfig] <p>The target groups.</p>
-- * ClassicLoadBalancersConfig [ClassicLoadBalancersConfig] <p>The Classic Load Balancers.</p>
-- @return LoadBalancersConfig structure as a key-value pair table
function M.LoadBalancersConfig(args)
	assert(args, "You must provide an argument table when creating LoadBalancersConfig")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TargetGroupsConfig"] = args["TargetGroupsConfig"],
		["ClassicLoadBalancersConfig"] = args["ClassicLoadBalancersConfig"],
	}
	asserts.AssertLoadBalancersConfig(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteFleetSuccessItem = { ["CurrentFleetState"] = true, ["PreviousFleetState"] = true, ["FleetId"] = true, nil }

function asserts.AssertDeleteFleetSuccessItem(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteFleetSuccessItem to be of type 'table'")
	if struct["CurrentFleetState"] then asserts.AssertFleetStateCode(struct["CurrentFleetState"]) end
	if struct["PreviousFleetState"] then asserts.AssertFleetStateCode(struct["PreviousFleetState"]) end
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteFleetSuccessItem[k], "DeleteFleetSuccessItem contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteFleetSuccessItem
-- <p>Describes an EC2 Fleet that was successfully deleted.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CurrentFleetState [FleetStateCode] <p>The current state of the EC2 Fleet.</p>
-- * PreviousFleetState [FleetStateCode] <p>The previous state of the EC2 Fleet.</p>
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- @return DeleteFleetSuccessItem structure as a key-value pair table
function M.DeleteFleetSuccessItem(args)
	assert(args, "You must provide an argument table when creating DeleteFleetSuccessItem")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CurrentFleetState"] = args["CurrentFleetState"],
		["PreviousFleetState"] = args["PreviousFleetState"],
		["FleetId"] = args["FleetId"],
	}
	asserts.AssertDeleteFleetSuccessItem(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePublicIpv4PoolsResult = { ["NextToken"] = true, ["PublicIpv4Pools"] = true, nil }

function asserts.AssertDescribePublicIpv4PoolsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePublicIpv4PoolsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["PublicIpv4Pools"] then asserts.AssertPublicIpv4PoolSet(struct["PublicIpv4Pools"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePublicIpv4PoolsResult[k], "DescribePublicIpv4PoolsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePublicIpv4PoolsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * PublicIpv4Pools [PublicIpv4PoolSet] <p>Information about the address pools.</p>
-- @return DescribePublicIpv4PoolsResult structure as a key-value pair table
function M.DescribePublicIpv4PoolsResult(args)
	assert(args, "You must provide an argument table when creating DescribePublicIpv4PoolsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["PublicIpv4Pools"] = args["PublicIpv4Pools"],
	}
	asserts.AssertDescribePublicIpv4PoolsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.UnassignPrivateIpAddressesRequest = { ["NetworkInterfaceId"] = true, ["PrivateIpAddresses"] = true, nil }

function asserts.AssertUnassignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected UnassignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	assert(struct["PrivateIpAddresses"], "Expected key PrivateIpAddresses to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	for k,_ in pairs(struct) do
		assert(keys.UnassignPrivateIpAddressesRequest[k], "UnassignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type UnassignPrivateIpAddressesRequest
-- <p>Contains the parameters for UnassignPrivateIpAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * PrivateIpAddresses [PrivateIpAddressStringList] <p>The secondary private IP addresses to unassign from the network interface. You can specify this option multiple times to unassign more than one IP address.</p>
-- Required key: NetworkInterfaceId
-- Required key: PrivateIpAddresses
-- @return UnassignPrivateIpAddressesRequest structure as a key-value pair table
function M.UnassignPrivateIpAddressesRequest(args)
	assert(args, "You must provide an argument table when creating UnassignPrivateIpAddressesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
	}
	asserts.AssertUnassignPrivateIpAddressesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Filter = { ["Values"] = true, ["Name"] = true, nil }

function asserts.AssertFilter(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Filter to be of type 'table'")
	if struct["Values"] then asserts.AssertValueStringList(struct["Values"]) end
	if struct["Name"] then asserts.AssertString(struct["Name"]) end
	for k,_ in pairs(struct) do
		assert(keys.Filter[k], "Filter contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Filter
-- <p>A filter name and value pair that is used to return a more specific list of results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs. The filters supported by a describe operation are documented with the describe operation. For example:</p> <ul> <li> <p> <a>DescribeAvailabilityZones</a> </p> </li> <li> <p> <a>DescribeImages</a> </p> </li> <li> <p> <a>DescribeInstances</a> </p> </li> <li> <p> <a>DescribeKeyPairs</a> </p> </li> <li> <p> <a>DescribeSecurityGroups</a> </p> </li> <li> <p> <a>DescribeSnapshots</a> </p> </li> <li> <p> <a>DescribeSubnets</a> </p> </li> <li> <p> <a>DescribeTags</a> </p> </li> <li> <p> <a>DescribeVolumes</a> </p> </li> <li> <p> <a>DescribeVpcs</a> </p> </li> </ul>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Values [ValueStringList] <p>One or more filter values. Filter values are case-sensitive.</p>
-- * Name [String] <p>The name of the filter. Filter names are case-sensitive.</p>
-- @return Filter structure as a key-value pair table
function M.Filter(args)
	assert(args, "You must provide an argument table when creating Filter")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Values"] = args["Values"],
		["Name"] = args["Name"],
	}
	asserts.AssertFilter(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.TargetReservationValue = { ["TargetConfiguration"] = true, ["ReservationValue"] = true, nil }

function asserts.AssertTargetReservationValue(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected TargetReservationValue to be of type 'table'")
	if struct["TargetConfiguration"] then asserts.AssertTargetConfiguration(struct["TargetConfiguration"]) end
	if struct["ReservationValue"] then asserts.AssertReservationValue(struct["ReservationValue"]) end
	for k,_ in pairs(struct) do
		assert(keys.TargetReservationValue[k], "TargetReservationValue contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type TargetReservationValue
-- <p>The total value of the new Convertible Reserved Instances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * TargetConfiguration [TargetConfiguration] <p>The configuration of the Convertible Reserved Instances that make up the exchange.</p>
-- * ReservationValue [ReservationValue] <p>The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.</p>
-- @return TargetReservationValue structure as a key-value pair table
function M.TargetReservationValue(args)
	assert(args, "You must provide an argument table when creating TargetReservationValue")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["TargetConfiguration"] = args["TargetConfiguration"],
		["ReservationValue"] = args["ReservationValue"],
	}
	asserts.AssertTargetReservationValue(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyIdFormatRequest = { ["UseLongIds"] = true, ["Resource"] = true, nil }

function asserts.AssertModifyIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyIdFormatRequest to be of type 'table'")
	assert(struct["Resource"], "Expected key Resource to exist in table")
	assert(struct["UseLongIds"], "Expected key UseLongIds to exist in table")
	if struct["UseLongIds"] then asserts.AssertBoolean(struct["UseLongIds"]) end
	if struct["Resource"] then asserts.AssertString(struct["Resource"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyIdFormatRequest[k], "ModifyIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyIdFormatRequest
-- <p>Contains the parameters of ModifyIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UseLongIds [Boolean] <p>Indicate whether the resource should use longer IDs (17-character IDs).</p>
-- * Resource [String] <p>The type of resource: <code>bundle</code> | <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> | <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> | <code>export-task</code> | <code>flow-log</code> | <code>image</code> | <code>import-task</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-acl-association</code> | <code>network-interface</code> | <code>network-interface-attachment</code> | <code>prefix-list</code> | <code>route-table</code> | <code>route-table-association</code> | <code>security-group</code> | <code>subnet</code> | <code>subnet-cidr-block-association</code> | <code>vpc</code> | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code>.</p> <p>Alternatively, use the <code>all-current</code> option to include all resource types that are currently within their opt-in period for longer IDs.</p>
-- Required key: Resource
-- Required key: UseLongIds
-- @return ModifyIdFormatRequest structure as a key-value pair table
function M.ModifyIdFormatRequest(args)
	assert(args, "You must provide an argument table when creating ModifyIdFormatRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UseLongIds"] = args["UseLongIds"],
		["Resource"] = args["Resource"],
	}
	asserts.AssertModifyIdFormatRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeStatusAction = { ["EventId"] = true, ["EventType"] = true, ["Code"] = true, ["Description"] = true, nil }

function asserts.AssertVolumeStatusAction(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeStatusAction to be of type 'table'")
	if struct["EventId"] then asserts.AssertString(struct["EventId"]) end
	if struct["EventType"] then asserts.AssertString(struct["EventType"]) end
	if struct["Code"] then asserts.AssertString(struct["Code"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeStatusAction[k], "VolumeStatusAction contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeStatusAction
-- <p>Describes a volume status operation code.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * EventId [String] <p>The ID of the event associated with this operation.</p>
-- * EventType [String] <p>The event type associated with this operation.</p>
-- * Code [String] <p>The code identifying the operation, for example, <code>enable-volume-io</code>.</p>
-- * Description [String] <p>A description of the operation.</p>
-- @return VolumeStatusAction structure as a key-value pair table
function M.VolumeStatusAction(args)
	assert(args, "You must provide an argument table when creating VolumeStatusAction")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["EventId"] = args["EventId"],
		["EventType"] = args["EventType"],
		["Code"] = args["Code"],
		["Description"] = args["Description"],
	}
	asserts.AssertVolumeStatusAction(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeIdentityIdFormatResult = { ["Statuses"] = true, nil }

function asserts.AssertDescribeIdentityIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeIdentityIdFormatResult to be of type 'table'")
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeIdentityIdFormatResult[k], "DescribeIdentityIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeIdentityIdFormatResult
-- <p>Contains the output of DescribeIdentityIdFormat.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Statuses [IdFormatList] <p>Information about the ID format for the resources.</p>
-- @return DescribeIdentityIdFormatResult structure as a key-value pair table
function M.DescribeIdentityIdFormatResult(args)
	assert(args, "You must provide an argument table when creating DescribeIdentityIdFormatResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Statuses"] = args["Statuses"],
	}
	asserts.AssertDescribeIdentityIdFormatResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportVolumeResult = { ["ConversionTask"] = true, nil }

function asserts.AssertImportVolumeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportVolumeResult to be of type 'table'")
	if struct["ConversionTask"] then asserts.AssertConversionTask(struct["ConversionTask"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportVolumeResult[k], "ImportVolumeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportVolumeResult
-- <p>Contains the output for ImportVolume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConversionTask [ConversionTask] <p>Information about the conversion task.</p>
-- @return ImportVolumeResult structure as a key-value pair table
function M.ImportVolumeResult(args)
	assert(args, "You must provide an argument table when creating ImportVolumeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConversionTask"] = args["ConversionTask"],
	}
	asserts.AssertImportVolumeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeKeyPairsResult = { ["KeyPairs"] = true, nil }

function asserts.AssertDescribeKeyPairsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeKeyPairsResult to be of type 'table'")
	if struct["KeyPairs"] then asserts.AssertKeyPairList(struct["KeyPairs"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeKeyPairsResult[k], "DescribeKeyPairsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeKeyPairsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyPairs [KeyPairList] <p>Information about one or more key pairs.</p>
-- @return DescribeKeyPairsResult structure as a key-value pair table
function M.DescribeKeyPairsResult(args)
	assert(args, "You must provide an argument table when creating DescribeKeyPairsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyPairs"] = args["KeyPairs"],
	}
	asserts.AssertDescribeKeyPairsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateTagSpecification = { ["ResourceType"] = true, ["Tags"] = true, nil }

function asserts.AssertLaunchTemplateTagSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateTagSpecification to be of type 'table'")
	if struct["ResourceType"] then asserts.AssertResourceType(struct["ResourceType"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateTagSpecification[k], "LaunchTemplateTagSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateTagSpecification
-- <p>The tag specification for the launch template.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ResourceType [ResourceType] <p>The type of resource.</p>
-- * Tags [TagList] <p>The tags for the resource.</p>
-- @return LaunchTemplateTagSpecification structure as a key-value pair table
function M.LaunchTemplateTagSpecification(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateTagSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ResourceType"] = args["ResourceType"],
		["Tags"] = args["Tags"],
	}
	asserts.AssertLaunchTemplateTagSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VolumeAttachment = { ["AttachTime"] = true, ["InstanceId"] = true, ["VolumeId"] = true, ["State"] = true, ["DeleteOnTermination"] = true, ["Device"] = true, nil }

function asserts.AssertVolumeAttachment(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VolumeAttachment to be of type 'table'")
	if struct["AttachTime"] then asserts.AssertDateTime(struct["AttachTime"]) end
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["State"] then asserts.AssertVolumeAttachmentState(struct["State"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["Device"] then asserts.AssertString(struct["Device"]) end
	for k,_ in pairs(struct) do
		assert(keys.VolumeAttachment[k], "VolumeAttachment contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VolumeAttachment
-- <p>Describes volume attachment details.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AttachTime [DateTime] <p>The time stamp when the attachment initiated.</p>
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- * State [VolumeAttachmentState] <p>The attachment state of the volume.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the EBS volume is deleted on instance termination.</p>
-- * Device [String] <p>The device name.</p>
-- @return VolumeAttachment structure as a key-value pair table
function M.VolumeAttachment(args)
	assert(args, "You must provide an argument table when creating VolumeAttachment")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AttachTime"] = args["AttachTime"],
		["InstanceId"] = args["InstanceId"],
		["VolumeId"] = args["VolumeId"],
		["State"] = args["State"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["Device"] = args["Device"],
	}
	asserts.AssertVolumeAttachment(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesRequest = { ["OfferingType"] = true, ["OfferingClass"] = true, ["DryRun"] = true, ["ReservedInstancesIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeReservedInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesRequest to be of type 'table'")
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ReservedInstancesIds"] then asserts.AssertReservedInstancesIdStringList(struct["ReservedInstancesIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesRequest[k], "DescribeReservedInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesRequest
-- <p>Contains the parameters for DescribeReservedInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type.</p>
-- * OfferingClass [OfferingClassType] <p>Describes whether the Reserved Instance is Standard or Convertible.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ReservedInstancesIds [ReservedInstancesIdStringList] <p>One or more Reserved Instance IDs.</p> <p>Default: Describes all your Reserved Instances, or only those otherwise specified.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>end</code> - The time when the Reserved Instance expires (for example, 2015-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Region</code> or <code>Availability Zone</code>).</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code>Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>).</p> </li> <li> <p> <code>reserved-instances-id</code> - The ID of the Reserved Instance.</p> </li> <li> <p> <code>start</code> - The time at which the Reserved Instance purchase request was placed (for example, 2014-08-07T11:54:42.000Z).</p> </li> <li> <p> <code>state</code> - The state of the Reserved Instance (<code>payment-pending</code> | <code>active</code> | <code>payment-failed</code> | <code>retired</code>).</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
-- @return DescribeReservedInstancesRequest structure as a key-value pair table
function M.DescribeReservedInstancesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OfferingType"] = args["OfferingType"],
		["OfferingClass"] = args["OfferingClass"],
		["DryRun"] = args["DryRun"],
		["ReservedInstancesIds"] = args["ReservedInstancesIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeReservedInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateCustomerGatewayRequest = { ["PublicIp"] = true, ["BgpAsn"] = true, ["DryRun"] = true, ["Type"] = true, nil }

function asserts.AssertCreateCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateCustomerGatewayRequest to be of type 'table'")
	assert(struct["BgpAsn"], "Expected key BgpAsn to exist in table")
	assert(struct["PublicIp"], "Expected key PublicIp to exist in table")
	assert(struct["Type"], "Expected key Type to exist in table")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["BgpAsn"] then asserts.AssertInteger(struct["BgpAsn"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Type"] then asserts.AssertGatewayType(struct["Type"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateCustomerGatewayRequest[k], "CreateCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateCustomerGatewayRequest
-- <p>Contains the parameters for CreateCustomerGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The Internet-routable IP address for the customer gateway's outside interface. The address must be static.</p>
-- * BgpAsn [Integer] <p>For devices that support BGP, the customer gateway's BGP ASN.</p> <p>Default: 65000</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Type [GatewayType] <p>The type of VPN connection that this customer gateway supports (<code>ipsec.1</code>).</p>
-- Required key: BgpAsn
-- Required key: PublicIp
-- Required key: Type
-- @return CreateCustomerGatewayRequest structure as a key-value pair table
function M.CreateCustomerGatewayRequest(args)
	assert(args, "You must provide an argument table when creating CreateCustomerGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["BgpAsn"] = args["BgpAsn"],
		["DryRun"] = args["DryRun"],
		["Type"] = args["Type"],
	}
	asserts.AssertCreateCustomerGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteSecurityGroupRequest = { ["GroupName"] = true, ["DryRun"] = true, ["GroupId"] = true, nil }

function asserts.AssertDeleteSecurityGroupRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteSecurityGroupRequest to be of type 'table'")
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteSecurityGroupRequest[k], "DeleteSecurityGroupRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteSecurityGroupRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group. You can specify either the security group name or the security group ID.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupId [String] <p>The ID of the security group. Required for a nondefault VPC.</p>
-- @return DeleteSecurityGroupRequest structure as a key-value pair table
function M.DeleteSecurityGroupRequest(args)
	assert(args, "You must provide an argument table when creating DeleteSecurityGroupRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["GroupName"] = args["GroupName"],
		["DryRun"] = args["DryRun"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertDeleteSecurityGroupRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyCapacityReservationRequest = { ["CapacityReservationId"] = true, ["EndDateType"] = true, ["DryRun"] = true, ["InstanceCount"] = true, ["EndDate"] = true, nil }

function asserts.AssertModifyCapacityReservationRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyCapacityReservationRequest to be of type 'table'")
	assert(struct["CapacityReservationId"], "Expected key CapacityReservationId to exist in table")
	if struct["CapacityReservationId"] then asserts.AssertString(struct["CapacityReservationId"]) end
	if struct["EndDateType"] then asserts.AssertEndDateType(struct["EndDateType"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["EndDate"] then asserts.AssertDateTime(struct["EndDate"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyCapacityReservationRequest[k], "ModifyCapacityReservationRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyCapacityReservationRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CapacityReservationId [String] <p>The ID of the Capacity Reservation.</p>
-- * EndDateType [EndDateType] <p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types:</p> <ul> <li> <p> <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it. Do not provide an <code>EndDate</code> value if <code>EndDateType</code> is <code>unlimited</code>.</p> </li> <li> <p> <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time. You must provide an <code>EndDate</code> value if <code>EndDateType</code> is <code>limited</code>.</p> </li> </ul>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceCount [Integer] <p>The number of instances for which to reserve capacity.</p>
-- * EndDate [DateTime] <p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to <code>expired</code> when it reaches its end date and time.</p> <p>The Capacity Reservation is cancelled within an hour from the specified time. For example, if you specify 5/31/2019, 13:30:55, the Capacity Reservation is guaranteed to end between 13:30:55 and 14:30:55 on 5/31/2019.</p> <p>You must provide an <code>EndDate</code> value if <code>EndDateType</code> is <code>limited</code>. Omit <code>EndDate</code> if <code>EndDateType</code> is <code>unlimited</code>.</p>
-- Required key: CapacityReservationId
-- @return ModifyCapacityReservationRequest structure as a key-value pair table
function M.ModifyCapacityReservationRequest(args)
	assert(args, "You must provide an argument table when creating ModifyCapacityReservationRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CapacityReservationId"] = args["CapacityReservationId"],
		["EndDateType"] = args["EndDateType"],
		["DryRun"] = args["DryRun"],
		["InstanceCount"] = args["InstanceCount"],
		["EndDate"] = args["EndDate"],
	}
	asserts.AssertModifyCapacityReservationRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteNetworkInterfacePermissionRequest = { ["NetworkInterfacePermissionId"] = true, ["DryRun"] = true, ["Force"] = true, nil }

function asserts.AssertDeleteNetworkInterfacePermissionRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteNetworkInterfacePermissionRequest to be of type 'table'")
	assert(struct["NetworkInterfacePermissionId"], "Expected key NetworkInterfacePermissionId to exist in table")
	if struct["NetworkInterfacePermissionId"] then asserts.AssertString(struct["NetworkInterfacePermissionId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Force"] then asserts.AssertBoolean(struct["Force"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteNetworkInterfacePermissionRequest[k], "DeleteNetworkInterfacePermissionRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteNetworkInterfacePermissionRequest
-- <p>Contains the parameters for DeleteNetworkInterfacePermission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfacePermissionId [String] <p>The ID of the network interface permission.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Force [Boolean] <p>Specify <code>true</code> to remove the permission even if the network interface is attached to an instance.</p>
-- Required key: NetworkInterfacePermissionId
-- @return DeleteNetworkInterfacePermissionRequest structure as a key-value pair table
function M.DeleteNetworkInterfacePermissionRequest(args)
	assert(args, "You must provide an argument table when creating DeleteNetworkInterfacePermissionRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfacePermissionId"] = args["NetworkInterfacePermissionId"],
		["DryRun"] = args["DryRun"],
		["Force"] = args["Force"],
	}
	asserts.AssertDeleteNetworkInterfacePermissionRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ActiveInstance = { ["InstanceId"] = true, ["InstanceHealth"] = true, ["InstanceType"] = true, ["SpotInstanceRequestId"] = true, nil }

function asserts.AssertActiveInstance(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ActiveInstance to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["InstanceHealth"] then asserts.AssertInstanceHealthStatus(struct["InstanceHealth"]) end
	if struct["InstanceType"] then asserts.AssertString(struct["InstanceType"]) end
	if struct["SpotInstanceRequestId"] then asserts.AssertString(struct["SpotInstanceRequestId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ActiveInstance[k], "ActiveInstance contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ActiveInstance
-- <p>Describes a running instance in a Spot Fleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * InstanceHealth [InstanceHealthStatus] <p>The health status of the instance. If the status of either the instance status check or the system status check is <code>impaired</code>, the health status of the instance is <code>unhealthy</code>. Otherwise, the health status is <code>healthy</code>.</p>
-- * InstanceType [String] <p>The instance type.</p>
-- * SpotInstanceRequestId [String] <p>The ID of the Spot Instance request.</p>
-- @return ActiveInstance structure as a key-value pair table
function M.ActiveInstance(args)
	assert(args, "You must provide an argument table when creating ActiveInstance")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["InstanceHealth"] = args["InstanceHealth"],
		["InstanceType"] = args["InstanceType"],
		["SpotInstanceRequestId"] = args["SpotInstanceRequestId"],
	}
	asserts.AssertActiveInstance(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyVolumeRequest = { ["VolumeType"] = true, ["Iops"] = true, ["DryRun"] = true, ["VolumeId"] = true, ["Size"] = true, nil }

function asserts.AssertModifyVolumeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyVolumeRequest to be of type 'table'")
	assert(struct["VolumeId"], "Expected key VolumeId to exist in table")
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyVolumeRequest[k], "ModifyVolumeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyVolumeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VolumeType [VolumeType] <p>The target EBS volume type of the volume.</p> <p>Default: If no type is specified, the existing type is retained.</p>
-- * Iops [Integer] <p>The target IOPS rate of the volume.</p> <p>This is only valid for Provisioned IOPS SSD (<code>io1</code>) volumes. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html#EBSVolumeTypes_piops">Provisioned IOPS SSD (io1) Volumes</a>.</p> <p>Default: If no IOPS value is specified, the existing value is retained.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- * Size [Integer] <p>The target size of the volume, in GiB. The target volume size must be greater than or equal to than the existing size of the volume. For information about available EBS volume sizes, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a>.</p> <p>Default: If no size is specified, the existing size is retained.</p>
-- Required key: VolumeId
-- @return ModifyVolumeRequest structure as a key-value pair table
function M.ModifyVolumeRequest(args)
	assert(args, "You must provide an argument table when creating ModifyVolumeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VolumeType"] = args["VolumeType"],
		["Iops"] = args["Iops"],
		["DryRun"] = args["DryRun"],
		["VolumeId"] = args["VolumeId"],
		["Size"] = args["Size"],
	}
	asserts.AssertModifyVolumeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkInterfaceAttributeRequest = { ["Attribute"] = true, ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeNetworkInterfaceAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["Attribute"] then asserts.AssertNetworkInterfaceAttribute(struct["Attribute"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfaceAttributeRequest[k], "DescribeNetworkInterfaceAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeRequest
-- <p>Contains the parameters for DescribeNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [NetworkInterfaceAttribute] <p>The attribute of the network interface. This parameter is required.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: NetworkInterfaceId
-- @return DescribeNetworkInterfaceAttributeRequest structure as a key-value pair table
function M.DescribeNetworkInterfaceAttributeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkInterfaceAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Attribute"] = args["Attribute"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeNetworkInterfaceAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ModifyInstancePlacementRequest = { ["InstanceId"] = true, ["GroupName"] = true, ["Tenancy"] = true, ["HostId"] = true, ["Affinity"] = true, nil }

function asserts.AssertModifyInstancePlacementRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ModifyInstancePlacementRequest to be of type 'table'")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["Tenancy"] then asserts.AssertHostTenancy(struct["Tenancy"]) end
	if struct["HostId"] then asserts.AssertString(struct["HostId"]) end
	if struct["Affinity"] then asserts.AssertAffinity(struct["Affinity"]) end
	for k,_ in pairs(struct) do
		assert(keys.ModifyInstancePlacementRequest[k], "ModifyInstancePlacementRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ModifyInstancePlacementRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance that you are modifying.</p>
-- * GroupName [String] <p>The name of the placement group in which to place the instance. For spread placement groups, the instance must have a tenancy of <code>default</code>. For cluster placement groups, the instance must have a tenancy of <code>default</code> or <code>dedicated</code>.</p> <p>To remove an instance from a placement group, specify an empty string ("").</p>
-- * Tenancy [HostTenancy] <p>The tenancy for the instance.</p>
-- * HostId [String] <p>The ID of the Dedicated Host with which to associate the instance.</p>
-- * Affinity [Affinity] <p>The affinity setting for the instance.</p>
-- Required key: InstanceId
-- @return ModifyInstancePlacementRequest structure as a key-value pair table
function M.ModifyInstancePlacementRequest(args)
	assert(args, "You must provide an argument table when creating ModifyInstancePlacementRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["GroupName"] = args["GroupName"],
		["Tenancy"] = args["Tenancy"],
		["HostId"] = args["HostId"],
		["Affinity"] = args["Affinity"],
	}
	asserts.AssertModifyInstancePlacementRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RevokeSecurityGroupIngressRequest = { ["DryRun"] = true, ["GroupName"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertRevokeSecurityGroupIngressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RevokeSecurityGroupIngressRequest to be of type 'table'")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["GroupName"] then asserts.AssertString(struct["GroupName"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.RevokeSecurityGroupIngressRequest[k], "RevokeSecurityGroupIngressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RevokeSecurityGroupIngressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * GroupName [String] <p>[EC2-Classic, default VPC] The name of the security group. You must specify either the security group ID or the security group name in the request.</p>
-- * CidrIp [String] <p>The CIDR IP address range. You can't specify this parameter when specifying a source security group.</p>
-- * IpPermissions [IpPermissionList] <p>One or more sets of IP permissions. You can't specify a source security group and a CIDR IP address range in the same set of permissions.</p>
-- * FromPort [Integer] <p>The start of port range for the TCP and UDP protocols, or an ICMP type number. For the ICMP type number, use <code>-1</code> to specify all ICMP types.</p>
-- * SourceSecurityGroupOwnerId [String] <p>[EC2-Classic] The AWS account ID of the source security group, if the source security group is in a different account. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the IP protocol, the start of the port range, and the end of the port range. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- * SourceSecurityGroupName [String] <p>[EC2-Classic, default VPC] The name of the source security group. You can't specify this parameter in combination with the following parameters: the CIDR IP address range, the start of the port range, the IP protocol, and the end of the port range. For EC2-VPC, the source security group must be in the same VPC. To revoke a specific rule for an IP protocol and port range, use a set of IP permissions instead.</p>
-- * ToPort [Integer] <p>The end of port range for the TCP and UDP protocols, or an ICMP code number. For the ICMP code number, use <code>-1</code> to specify all ICMP codes for the ICMP type.</p>
-- * IpProtocol [String] <p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>) or number (see <a href="http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml">Protocol Numbers</a>). Use <code>-1</code> to specify all.</p>
-- * GroupId [String] <p>The ID of the security group. You must specify either the security group ID or the security group name in the request. For security groups in a nondefault VPC, you must specify the security group ID.</p>
-- @return RevokeSecurityGroupIngressRequest structure as a key-value pair table
function M.RevokeSecurityGroupIngressRequest(args)
	assert(args, "You must provide an argument table when creating RevokeSecurityGroupIngressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["GroupName"] = args["GroupName"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertRevokeSecurityGroupIngressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeAggregateIdFormatResult = { ["UseLongIdsAggregated"] = true, ["Statuses"] = true, nil }

function asserts.AssertDescribeAggregateIdFormatResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeAggregateIdFormatResult to be of type 'table'")
	if struct["UseLongIdsAggregated"] then asserts.AssertBoolean(struct["UseLongIdsAggregated"]) end
	if struct["Statuses"] then asserts.AssertIdFormatList(struct["Statuses"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeAggregateIdFormatResult[k], "DescribeAggregateIdFormatResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeAggregateIdFormatResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * UseLongIdsAggregated [Boolean] <p>Indicates whether all resource types in the region are configured to use longer IDs. This value is only <code>true</code> if all users are configured to use longer IDs for all resources types in the region.</p>
-- * Statuses [IdFormatList] <p>Information about each resource's ID format.</p>
-- @return DescribeAggregateIdFormatResult structure as a key-value pair table
function M.DescribeAggregateIdFormatResult(args)
	assert(args, "You must provide an argument table when creating DescribeAggregateIdFormatResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["UseLongIdsAggregated"] = args["UseLongIdsAggregated"],
		["Statuses"] = args["Statuses"],
	}
	asserts.AssertDescribeAggregateIdFormatResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateSpotDatafeedSubscriptionResult = { ["SpotDatafeedSubscription"] = true, nil }

function asserts.AssertCreateSpotDatafeedSubscriptionResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateSpotDatafeedSubscriptionResult to be of type 'table'")
	if struct["SpotDatafeedSubscription"] then asserts.AssertSpotDatafeedSubscription(struct["SpotDatafeedSubscription"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateSpotDatafeedSubscriptionResult[k], "CreateSpotDatafeedSubscriptionResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateSpotDatafeedSubscriptionResult
-- <p>Contains the output of CreateSpotDatafeedSubscription.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotDatafeedSubscription [SpotDatafeedSubscription] <p>The Spot Instance data feed subscription.</p>
-- @return CreateSpotDatafeedSubscriptionResult structure as a key-value pair table
function M.CreateSpotDatafeedSubscriptionResult(args)
	assert(args, "You must provide an argument table when creating CreateSpotDatafeedSubscriptionResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotDatafeedSubscription"] = args["SpotDatafeedSubscription"],
	}
	asserts.AssertCreateSpotDatafeedSubscriptionResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeClassicLinkInstancesRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["InstanceIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeClassicLinkInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeClassicLinkInstancesRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeClassicLinkInstancesRequest[k], "DescribeClassicLinkInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeClassicLinkInstancesRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000. If <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. You cannot specify this parameter and the instance IDs parameter in the same request.</p> <p>Constraint: If the value is greater than 1000, we return only 1000 items.</p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs. Must be instances linked to a VPC through ClassicLink.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>group-id</code> - The ID of a VPC security group that's associated with the instance.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-id</code> - The ID of the VPC to which the instance is linked.</p> <p> <code>vpc-id</code> - The ID of the VPC that the instance is linked to.</p> </li> </ul>
-- @return DescribeClassicLinkInstancesRequest structure as a key-value pair table
function M.DescribeClassicLinkInstancesRequest(args)
	assert(args, "You must provide an argument table when creating DescribeClassicLinkInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeClassicLinkInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeReservedInstancesOfferingsRequest = { ["MaxInstanceCount"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["DryRun"] = true, ["ProductDescription"] = true, ["IncludeMarketplace"] = true, ["ReservedInstancesOfferingIds"] = true, ["MaxResults"] = true, ["InstanceType"] = true, ["OfferingClass"] = true, ["Filters"] = true, ["MinDuration"] = true, ["InstanceTenancy"] = true, ["NextToken"] = true, ["MaxDuration"] = true, nil }

function asserts.AssertDescribeReservedInstancesOfferingsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeReservedInstancesOfferingsRequest to be of type 'table'")
	if struct["MaxInstanceCount"] then asserts.AssertInteger(struct["MaxInstanceCount"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["IncludeMarketplace"] then asserts.AssertBoolean(struct["IncludeMarketplace"]) end
	if struct["ReservedInstancesOfferingIds"] then asserts.AssertReservedInstancesOfferingIdStringList(struct["ReservedInstancesOfferingIds"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["MinDuration"] then asserts.AssertLong(struct["MinDuration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxDuration"] then asserts.AssertLong(struct["MaxDuration"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeReservedInstancesOfferingsRequest[k], "DescribeReservedInstancesOfferingsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeReservedInstancesOfferingsRequest
-- <p>Contains the parameters for DescribeReservedInstancesOfferings.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxInstanceCount [Integer] <p>The maximum number of instances to filter when searching for offerings.</p> <p>Default: 20</p>
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type. If you are using tools that predate the 2011-11-01 API version, you only have access to the <code>Medium Utilization</code> Reserved Instance offering type. </p>
-- * AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the description are for use with Amazon VPC.</p>
-- * IncludeMarketplace [Boolean] <p>Include Reserved Instance Marketplace offerings in the response.</p>
-- * ReservedInstancesOfferingIds [ReservedInstancesOfferingIdStringList] <p>One or more Reserved Instances offering IDs.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. The maximum is 100.</p> <p>Default: 100</p>
-- * InstanceType [InstanceType] <p>The instance type that the reservation will cover (for example, <code>m1.small</code>). For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>
-- * OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance. Can be <code>standard</code> or <code>convertible</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone where the Reserved Instance can be used.</p> </li> <li> <p> <code>duration</code> - The duration of the Reserved Instance (for example, one year or three years), in seconds (<code>31536000</code> | <code>94608000</code>).</p> </li> <li> <p> <code>fixed-price</code> - The purchase price of the Reserved Instance (for example, 9800.0).</p> </li> <li> <p> <code>instance-type</code> - The instance type that is covered by the reservation.</p> </li> <li> <p> <code>marketplace</code> - Set to <code>true</code> to show only Reserved Instance Marketplace offerings. When this filter is not used, which is the default behavior, all offerings from both AWS and the Reserved Instance Marketplace are listed.</p> </li> <li> <p> <code>product-description</code> - The Reserved Instance product platform description. Instances that include <code>(Amazon VPC)</code> in the product platform description will only be displayed to EC2-Classic account holders and are for use with Amazon VPC. (<code>Linux/UNIX</code> | <code>Linux/UNIX (Amazon VPC)</code> | <code>SUSE Linux</code> | <code>SUSE Linux (Amazon VPC)</code> | <code>Red Hat Enterprise Linux</code> | <code>Red Hat Enterprise Linux (Amazon VPC)</code> | <code>Windows</code> | <code>Windows (Amazon VPC)</code> | <code>Windows with SQL Server Standard</code> | <code>Windows with SQL Server Standard (Amazon VPC)</code> | <code>Windows with SQL Server Web</code> | <code> Windows with SQL Server Web (Amazon VPC)</code> | <code>Windows with SQL Server Enterprise</code> | <code>Windows with SQL Server Enterprise (Amazon VPC)</code>) </p> </li> <li> <p> <code>reserved-instances-offering-id</code> - The Reserved Instances offering ID.</p> </li> <li> <p> <code>scope</code> - The scope of the Reserved Instance (<code>Availability Zone</code> or <code>Region</code>).</p> </li> <li> <p> <code>usage-price</code> - The usage price of the Reserved Instance, per hour (for example, 0.84).</p> </li> </ul>
-- * MinDuration [Long] <p>The minimum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 2592000 (1 month)</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy of the instances covered by the reservation. A Reserved Instance with a tenancy of <code>dedicated</code> is applied to instances that run in a VPC on single-tenant hardware (i.e., Dedicated Instances).</p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * MaxDuration [Long] <p>The maximum duration (in seconds) to filter when searching for offerings.</p> <p>Default: 94608000 (3 years)</p>
-- @return DescribeReservedInstancesOfferingsRequest structure as a key-value pair table
function M.DescribeReservedInstancesOfferingsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeReservedInstancesOfferingsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxInstanceCount"] = args["MaxInstanceCount"],
		["OfferingType"] = args["OfferingType"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["DryRun"] = args["DryRun"],
		["ProductDescription"] = args["ProductDescription"],
		["IncludeMarketplace"] = args["IncludeMarketplace"],
		["ReservedInstancesOfferingIds"] = args["ReservedInstancesOfferingIds"],
		["MaxResults"] = args["MaxResults"],
		["InstanceType"] = args["InstanceType"],
		["OfferingClass"] = args["OfferingClass"],
		["Filters"] = args["Filters"],
		["MinDuration"] = args["MinDuration"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["NextToken"] = args["NextToken"],
		["MaxDuration"] = args["MaxDuration"],
	}
	asserts.AssertDescribeReservedInstancesOfferingsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.FleetData = { ["Type"] = true, ["FulfilledCapacity"] = true, ["LaunchTemplateConfigs"] = true, ["Tags"] = true, ["TerminateInstancesWithExpiration"] = true, ["SpotOptions"] = true, ["TargetCapacitySpecification"] = true, ["FulfilledOnDemandCapacity"] = true, ["ActivityStatus"] = true, ["FleetId"] = true, ["ReplaceUnhealthyInstances"] = true, ["ValidUntil"] = true, ["ClientToken"] = true, ["OnDemandOptions"] = true, ["FleetState"] = true, ["ValidFrom"] = true, ["ExcessCapacityTerminationPolicy"] = true, ["CreateTime"] = true, nil }

function asserts.AssertFleetData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected FleetData to be of type 'table'")
	if struct["Type"] then asserts.AssertFleetType(struct["Type"]) end
	if struct["FulfilledCapacity"] then asserts.AssertDouble(struct["FulfilledCapacity"]) end
	if struct["LaunchTemplateConfigs"] then asserts.AssertFleetLaunchTemplateConfigList(struct["LaunchTemplateConfigs"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["TerminateInstancesWithExpiration"] then asserts.AssertBoolean(struct["TerminateInstancesWithExpiration"]) end
	if struct["SpotOptions"] then asserts.AssertSpotOptions(struct["SpotOptions"]) end
	if struct["TargetCapacitySpecification"] then asserts.AssertTargetCapacitySpecification(struct["TargetCapacitySpecification"]) end
	if struct["FulfilledOnDemandCapacity"] then asserts.AssertDouble(struct["FulfilledOnDemandCapacity"]) end
	if struct["ActivityStatus"] then asserts.AssertFleetActivityStatus(struct["ActivityStatus"]) end
	if struct["FleetId"] then asserts.AssertFleetIdentifier(struct["FleetId"]) end
	if struct["ReplaceUnhealthyInstances"] then asserts.AssertBoolean(struct["ReplaceUnhealthyInstances"]) end
	if struct["ValidUntil"] then asserts.AssertDateTime(struct["ValidUntil"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	if struct["OnDemandOptions"] then asserts.AssertOnDemandOptions(struct["OnDemandOptions"]) end
	if struct["FleetState"] then asserts.AssertFleetStateCode(struct["FleetState"]) end
	if struct["ValidFrom"] then asserts.AssertDateTime(struct["ValidFrom"]) end
	if struct["ExcessCapacityTerminationPolicy"] then asserts.AssertFleetExcessCapacityTerminationPolicy(struct["ExcessCapacityTerminationPolicy"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	for k,_ in pairs(struct) do
		assert(keys.FleetData[k], "FleetData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type FleetData
-- <p>Describes an EC2 Fleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Type [FleetType] <p>The type of request. Indicates whether the EC2 Fleet only <code>requests</code> the target capacity, or also attempts to <code>maintain</code> it. If you request a certain target capacity, EC2 Fleet only places the required requests; it does not attempt to replenish instances if capacity is diminished, and does not submit requests in alternative capacity pools if capacity is unavailable. To maintain a certain target capacity, EC2 Fleet places the required requests to meet this target capacity. It also automatically replenishes any interrupted Spot Instances. Default: <code>maintain</code>.</p>
-- * FulfilledCapacity [Double] <p>The number of units fulfilled by this request compared to the set target capacity.</p>
-- * LaunchTemplateConfigs [FleetLaunchTemplateConfigList] <p>The launch template and overrides.</p>
-- * Tags [TagList] <p>The tags for an EC2 Fleet resource.</p>
-- * TerminateInstancesWithExpiration [Boolean] <p>Indicates whether running instances should be terminated when the EC2 Fleet expires. </p>
-- * SpotOptions [SpotOptions] <p>The configuration of Spot Instances in an EC2 Fleet.</p>
-- * TargetCapacitySpecification [TargetCapacitySpecification] <p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>
-- * FulfilledOnDemandCapacity [Double] <p>The number of units fulfilled by this request compared to the set target On-Demand capacity.</p>
-- * ActivityStatus [FleetActivityStatus] <p>The progress of the EC2 Fleet. If there is an error, the status is <code>error</code>. After all requests are placed, the status is <code>pending_fulfillment</code>. If the size of the EC2 Fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>. If the size of the EC2 Fleet is decreased, the status is <code>pending_termination</code> while instances are terminating.</p>
-- * FleetId [FleetIdentifier] <p>The ID of the EC2 Fleet.</p>
-- * ReplaceUnhealthyInstances [Boolean] <p>Indicates whether EC2 Fleet should replace unhealthy instances.</p>
-- * ValidUntil [DateTime] <p>The end date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). At this point, no new instance requests are placed or able to fulfill the request. The default end date is 7 days from the current date. </p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p> <p>Constraints: Maximum 64 ASCII characters</p>
-- * OnDemandOptions [OnDemandOptions] <p>The allocation strategy of On-Demand Instances in an EC2 Fleet.</p>
-- * FleetState [FleetStateCode] <p>The state of the EC2 Fleet.</p>
-- * ValidFrom [DateTime] <p>The start date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The default is to start fulfilling the request immediately. </p>
-- * ExcessCapacityTerminationPolicy [FleetExcessCapacityTerminationPolicy] <p>Indicates whether running instances should be terminated if the target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>
-- * CreateTime [DateTime] <p>The creation date and time of the EC2 Fleet.</p>
-- @return FleetData structure as a key-value pair table
function M.FleetData(args)
	assert(args, "You must provide an argument table when creating FleetData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Type"] = args["Type"],
		["FulfilledCapacity"] = args["FulfilledCapacity"],
		["LaunchTemplateConfigs"] = args["LaunchTemplateConfigs"],
		["Tags"] = args["Tags"],
		["TerminateInstancesWithExpiration"] = args["TerminateInstancesWithExpiration"],
		["SpotOptions"] = args["SpotOptions"],
		["TargetCapacitySpecification"] = args["TargetCapacitySpecification"],
		["FulfilledOnDemandCapacity"] = args["FulfilledOnDemandCapacity"],
		["ActivityStatus"] = args["ActivityStatus"],
		["FleetId"] = args["FleetId"],
		["ReplaceUnhealthyInstances"] = args["ReplaceUnhealthyInstances"],
		["ValidUntil"] = args["ValidUntil"],
		["ClientToken"] = args["ClientToken"],
		["OnDemandOptions"] = args["OnDemandOptions"],
		["FleetState"] = args["FleetState"],
		["ValidFrom"] = args["ValidFrom"],
		["ExcessCapacityTerminationPolicy"] = args["ExcessCapacityTerminationPolicy"],
		["CreateTime"] = args["CreateTime"],
	}
	asserts.AssertFleetData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateImageResult = { ["ImageId"] = true, nil }

function asserts.AssertCreateImageResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateImageResult to be of type 'table'")
	if struct["ImageId"] then asserts.AssertString(struct["ImageId"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateImageResult[k], "CreateImageResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateImageResult
-- <p>Contains the output of CreateImage.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ImageId [String] <p>The ID of the new AMI.</p>
-- @return CreateImageResult structure as a key-value pair table
function M.CreateImageResult(args)
	assert(args, "You must provide an argument table when creating CreateImageResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ImageId"] = args["ImageId"],
	}
	asserts.AssertCreateImageResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DhcpOptions = { ["Tags"] = true, ["DhcpConfigurations"] = true, ["DhcpOptionsId"] = true, nil }

function asserts.AssertDhcpOptions(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DhcpOptions to be of type 'table'")
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["DhcpConfigurations"] then asserts.AssertDhcpConfigurationList(struct["DhcpConfigurations"]) end
	if struct["DhcpOptionsId"] then asserts.AssertString(struct["DhcpOptionsId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DhcpOptions[k], "DhcpOptions contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DhcpOptions
-- <p>Describes a set of DHCP options.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Tags [TagList] <p>Any tags assigned to the DHCP options set.</p>
-- * DhcpConfigurations [DhcpConfigurationList] <p>One or more DHCP options in the set.</p>
-- * DhcpOptionsId [String] <p>The ID of the set of DHCP options.</p>
-- @return DhcpOptions structure as a key-value pair table
function M.DhcpOptions(args)
	assert(args, "You must provide an argument table when creating DhcpOptions")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Tags"] = args["Tags"],
		["DhcpConfigurations"] = args["DhcpConfigurations"],
		["DhcpOptionsId"] = args["DhcpOptionsId"],
	}
	asserts.AssertDhcpOptions(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.LaunchTemplateInstanceNetworkInterfaceSpecification = { ["DeviceIndex"] = true, ["Description"] = true, ["Ipv6AddressCount"] = true, ["PrivateIpAddresses"] = true, ["SubnetId"] = true, ["DeleteOnTermination"] = true, ["PrivateIpAddress"] = true, ["Groups"] = true, ["Ipv6Addresses"] = true, ["NetworkInterfaceId"] = true, ["AssociatePublicIpAddress"] = true, ["SecondaryPrivateIpAddressCount"] = true, nil }

function asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected LaunchTemplateInstanceNetworkInterfaceSpecification to be of type 'table'")
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["Description"] then asserts.AssertString(struct["Description"]) end
	if struct["Ipv6AddressCount"] then asserts.AssertInteger(struct["Ipv6AddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressSpecificationList(struct["PrivateIpAddresses"]) end
	if struct["SubnetId"] then asserts.AssertString(struct["SubnetId"]) end
	if struct["DeleteOnTermination"] then asserts.AssertBoolean(struct["DeleteOnTermination"]) end
	if struct["PrivateIpAddress"] then asserts.AssertString(struct["PrivateIpAddress"]) end
	if struct["Groups"] then asserts.AssertGroupIdStringList(struct["Groups"]) end
	if struct["Ipv6Addresses"] then asserts.AssertInstanceIpv6AddressList(struct["Ipv6Addresses"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["AssociatePublicIpAddress"] then asserts.AssertBoolean(struct["AssociatePublicIpAddress"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.LaunchTemplateInstanceNetworkInterfaceSpecification[k], "LaunchTemplateInstanceNetworkInterfaceSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type LaunchTemplateInstanceNetworkInterfaceSpecification
-- <p>Describes a network interface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DeviceIndex [Integer] <p>The device index for the network interface attachment.</p>
-- * Description [String] <p>A description for the network interface.</p>
-- * Ipv6AddressCount [Integer] <p>The number of IPv6 addresses for the network interface.</p>
-- * PrivateIpAddresses [PrivateIpAddressSpecificationList] <p>One or more private IPv4 addresses.</p>
-- * SubnetId [String] <p>The ID of the subnet for the network interface.</p>
-- * DeleteOnTermination [Boolean] <p>Indicates whether the network interface is deleted when the instance is terminated.</p>
-- * PrivateIpAddress [String] <p>The primary private IPv4 address of the network interface.</p>
-- * Groups [GroupIdStringList] <p>The IDs of one or more security groups.</p>
-- * Ipv6Addresses [InstanceIpv6AddressList] <p>The IPv6 addresses for the network interface.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * AssociatePublicIpAddress [Boolean] <p>Indicates whether to associate a public IPv4 address with eth0 for a new network interface.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary private IPv4 addresses for the network interface.</p>
-- @return LaunchTemplateInstanceNetworkInterfaceSpecification structure as a key-value pair table
function M.LaunchTemplateInstanceNetworkInterfaceSpecification(args)
	assert(args, "You must provide an argument table when creating LaunchTemplateInstanceNetworkInterfaceSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DeviceIndex"] = args["DeviceIndex"],
		["Description"] = args["Description"],
		["Ipv6AddressCount"] = args["Ipv6AddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["SubnetId"] = args["SubnetId"],
		["DeleteOnTermination"] = args["DeleteOnTermination"],
		["PrivateIpAddress"] = args["PrivateIpAddress"],
		["Groups"] = args["Groups"],
		["Ipv6Addresses"] = args["Ipv6Addresses"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["AssociatePublicIpAddress"] = args["AssociatePublicIpAddress"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
	}
	asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstances = { ["ReservedInstancesId"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["End"] = true, ["ProductDescription"] = true, ["Tags"] = true, ["Scope"] = true, ["UsagePrice"] = true, ["RecurringCharges"] = true, ["OfferingClass"] = true, ["Start"] = true, ["State"] = true, ["FixedPrice"] = true, ["CurrencyCode"] = true, ["Duration"] = true, ["InstanceTenancy"] = true, ["InstanceType"] = true, ["InstanceCount"] = true, nil }

function asserts.AssertReservedInstances(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstances to be of type 'table'")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["End"] then asserts.AssertDateTime(struct["End"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["UsagePrice"] then asserts.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then asserts.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Start"] then asserts.AssertDateTime(struct["Start"]) end
	if struct["State"] then asserts.AssertReservedInstanceState(struct["State"]) end
	if struct["FixedPrice"] then asserts.AssertFloat(struct["FixedPrice"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["Duration"] then asserts.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstances[k], "ReservedInstances contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstances
-- <p>Describes a Reserved Instance.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the Reserved Instance.</p>
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- * AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- * End [DateTime] <p>The time when the Reserved Instance expires.</p>
-- * ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- * Tags [TagList] <p>Any tags assigned to the resource.</p>
-- * Scope [scope] <p>The scope of the Reserved Instance.</p>
-- * UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- * RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- * OfferingClass [OfferingClassType] <p>The offering class of the Reserved Instance.</p>
-- * Start [DateTime] <p>The date and time the Reserved Instance started.</p>
-- * State [ReservedInstanceState] <p>The state of the Reserved Instance purchase.</p>
-- * FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- * Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- * InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
-- * InstanceCount [Integer] <p>The number of reservations purchased.</p>
-- @return ReservedInstances structure as a key-value pair table
function M.ReservedInstances(args)
	assert(args, "You must provide an argument table when creating ReservedInstances")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["OfferingType"] = args["OfferingType"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["End"] = args["End"],
		["ProductDescription"] = args["ProductDescription"],
		["Tags"] = args["Tags"],
		["Scope"] = args["Scope"],
		["UsagePrice"] = args["UsagePrice"],
		["RecurringCharges"] = args["RecurringCharges"],
		["OfferingClass"] = args["OfferingClass"],
		["Start"] = args["Start"],
		["State"] = args["State"],
		["FixedPrice"] = args["FixedPrice"],
		["CurrencyCode"] = args["CurrencyCode"],
		["Duration"] = args["Duration"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["InstanceType"] = args["InstanceType"],
		["InstanceCount"] = args["InstanceCount"],
	}
	asserts.AssertReservedInstances(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeElasticGpusRequest = { ["ElasticGpuIds"] = true, ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeElasticGpusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeElasticGpusRequest to be of type 'table'")
	if struct["ElasticGpuIds"] then asserts.AssertElasticGpuIdSet(struct["ElasticGpuIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeElasticGpusRequest[k], "DescribeElasticGpusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeElasticGpusRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ElasticGpuIds [ElasticGpuIdSet] <p>One or more Elastic GPU IDs.</p>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. This value can be between 5 and 1000.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>availability-zone</code> - The Availability Zone in which the Elastic GPU resides.</p> </li> <li> <p> <code>elastic-gpu-health</code> - The status of the Elastic GPU (<code>OK</code> | <code>IMPAIRED</code>).</p> </li> <li> <p> <code>elastic-gpu-state</code> - The state of the Elastic GPU (<code>ATTACHED</code>).</p> </li> <li> <p> <code>elastic-gpu-type</code> - The type of Elastic GPU; for example, <code>eg1.medium</code>.</p> </li> <li> <p> <code>instance-id</code> - The ID of the instance to which the Elastic GPU is associated.</p> </li> </ul>
-- @return DescribeElasticGpusRequest structure as a key-value pair table
function M.DescribeElasticGpusRequest(args)
	assert(args, "You must provide an argument table when creating DescribeElasticGpusRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ElasticGpuIds"] = args["ElasticGpuIds"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeElasticGpusRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumesModificationsRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["VolumeIds"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVolumesModificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumesModificationsRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumesModificationsRequest[k], "DescribeVolumesModificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumesModificationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results (up to a limit of 500) to be returned in a paginated request.</p>
-- * NextToken [String] <p>The <code>nextToken</code> value returned by a previous paginated request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * VolumeIds [VolumeIdStringList] <p>One or more volume IDs for which in-progress modifications will be described.</p>
-- * Filters [FilterList] <p>One or more filters. Supported filters: <code>volume-id</code>, <code>modification-state</code>, <code>target-size</code>, <code>target-iops</code>, <code>target-volume-type</code>, <code>original-size</code>, <code>original-iops</code>, <code>original-volume-type</code>, <code>start-time</code>. </p>
-- @return DescribeVolumesModificationsRequest structure as a key-value pair table
function M.DescribeVolumesModificationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVolumesModificationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["VolumeIds"] = args["VolumeIds"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVolumesModificationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeCustomerGatewaysResult = { ["CustomerGateways"] = true, nil }

function asserts.AssertDescribeCustomerGatewaysResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeCustomerGatewaysResult to be of type 'table'")
	if struct["CustomerGateways"] then asserts.AssertCustomerGatewayList(struct["CustomerGateways"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeCustomerGatewaysResult[k], "DescribeCustomerGatewaysResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeCustomerGatewaysResult
-- <p>Contains the output of DescribeCustomerGateways.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGateways [CustomerGatewayList] <p>Information about one or more customer gateways.</p>
-- @return DescribeCustomerGatewaysResult structure as a key-value pair table
function M.DescribeCustomerGatewaysResult(args)
	assert(args, "You must provide an argument table when creating DescribeCustomerGatewaysResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CustomerGateways"] = args["CustomerGateways"],
	}
	asserts.AssertDescribeCustomerGatewaysResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AvailabilityZoneMessage = { ["Message"] = true, nil }

function asserts.AssertAvailabilityZoneMessage(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AvailabilityZoneMessage to be of type 'table'")
	if struct["Message"] then asserts.AssertString(struct["Message"]) end
	for k,_ in pairs(struct) do
		assert(keys.AvailabilityZoneMessage[k], "AvailabilityZoneMessage contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AvailabilityZoneMessage
-- <p>Describes a message about an Availability Zone.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Message [String] <p>The message about the Availability Zone.</p>
-- @return AvailabilityZoneMessage structure as a key-value pair table
function M.AvailabilityZoneMessage(args)
	assert(args, "You must provide an argument table when creating AvailabilityZoneMessage")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Message"] = args["Message"],
	}
	asserts.AssertAvailabilityZoneMessage(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkInterfacePermissionsRequest = { ["NetworkInterfacePermissionIds"] = true, ["NextToken"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeNetworkInterfacePermissionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfacePermissionsRequest to be of type 'table'")
	if struct["NetworkInterfacePermissionIds"] then asserts.AssertNetworkInterfacePermissionIdList(struct["NetworkInterfacePermissionIds"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfacePermissionsRequest[k], "DescribeNetworkInterfacePermissionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfacePermissionsRequest
-- <p>Contains the parameters for DescribeNetworkInterfacePermissions.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfacePermissionIds [NetworkInterfacePermissionIdList] <p>One or more network interface permission IDs.</p>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned <code>NextToken</code> value. If this parameter is not specified, up to 50 results are returned by default.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>network-interface-permission.network-interface-permission-id</code> - The ID of the permission.</p> </li> <li> <p> <code>network-interface-permission.network-interface-id</code> - The ID of the network interface.</p> </li> <li> <p> <code>network-interface-permission.aws-account-id</code> - The AWS account ID.</p> </li> <li> <p> <code>network-interface-permission.aws-service</code> - The AWS service.</p> </li> <li> <p> <code>network-interface-permission.permission</code> - The type of permission (<code>INSTANCE-ATTACH</code> | <code>EIP-ASSOCIATE</code>).</p> </li> </ul>
-- @return DescribeNetworkInterfacePermissionsRequest structure as a key-value pair table
function M.DescribeNetworkInterfacePermissionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkInterfacePermissionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfacePermissionIds"] = args["NetworkInterfacePermissionIds"],
		["NextToken"] = args["NextToken"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeNetworkInterfacePermissionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.GetConsoleScreenshotResult = { ["InstanceId"] = true, ["ImageData"] = true, nil }

function asserts.AssertGetConsoleScreenshotResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected GetConsoleScreenshotResult to be of type 'table'")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["ImageData"] then asserts.AssertString(struct["ImageData"]) end
	for k,_ in pairs(struct) do
		assert(keys.GetConsoleScreenshotResult[k], "GetConsoleScreenshotResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type GetConsoleScreenshotResult
-- <p>Contains the output of the request.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * ImageData [String] <p>The data that comprises the image.</p>
-- @return GetConsoleScreenshotResult structure as a key-value pair table
function M.GetConsoleScreenshotResult(args)
	assert(args, "You must provide an argument table when creating GetConsoleScreenshotResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["ImageData"] = args["ImageData"],
	}
	asserts.AssertGetConsoleScreenshotResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeFpgaImageAttributeResult = { ["FpgaImageAttribute"] = true, nil }

function asserts.AssertDescribeFpgaImageAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeFpgaImageAttributeResult to be of type 'table'")
	if struct["FpgaImageAttribute"] then asserts.AssertFpgaImageAttribute(struct["FpgaImageAttribute"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeFpgaImageAttributeResult[k], "DescribeFpgaImageAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeFpgaImageAttributeResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * FpgaImageAttribute [FpgaImageAttribute] <p>Information about the attribute.</p>
-- @return DescribeFpgaImageAttributeResult structure as a key-value pair table
function M.DescribeFpgaImageAttributeResult(args)
	assert(args, "You must provide an argument table when creating DescribeFpgaImageAttributeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["FpgaImageAttribute"] = args["FpgaImageAttribute"],
	}
	asserts.AssertDescribeFpgaImageAttributeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcPeeringConnectionsRequest = { ["VpcPeeringConnectionIds"] = true, ["DryRun"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcPeeringConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcPeeringConnectionsRequest to be of type 'table'")
	if struct["VpcPeeringConnectionIds"] then asserts.AssertValueStringList(struct["VpcPeeringConnectionIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcPeeringConnectionsRequest[k], "DescribeVpcPeeringConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcPeeringConnectionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcPeeringConnectionIds [ValueStringList] <p>One or more VPC peering connection IDs.</p> <p>Default: Describes all your VPC peering connections.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>accepter-vpc-info.cidr-block</code> - The IPv4 CIDR block of the accepter VPC.</p> </li> <li> <p> <code>accepter-vpc-info.owner-id</code> - The AWS account ID of the owner of the accepter VPC.</p> </li> <li> <p> <code>accepter-vpc-info.vpc-id</code> - The ID of the accepter VPC.</p> </li> <li> <p> <code>expiration-time</code> - The expiration date and time for the VPC peering connection.</p> </li> <li> <p> <code>requester-vpc-info.cidr-block</code> - The IPv4 CIDR block of the requester's VPC.</p> </li> <li> <p> <code>requester-vpc-info.owner-id</code> - The AWS account ID of the owner of the requester VPC.</p> </li> <li> <p> <code>requester-vpc-info.vpc-id</code> - The ID of the requester VPC.</p> </li> <li> <p> <code>status-code</code> - The status of the VPC peering connection (<code>pending-acceptance</code> | <code>failed</code> | <code>expired</code> | <code>provisioning</code> | <code>active</code> | <code>deleting</code> | <code>deleted</code> | <code>rejected</code>).</p> </li> <li> <p> <code>status-message</code> - A message that provides more information about the status of the VPC peering connection, if applicable.</p> </li> <li> <p> <code>tag</code>:&lt;key&gt; - The key/value combination of a tag assigned to the resource. Use the tag key in the filter name and the tag value as the filter value. For example, to find all resources that have a tag with the key <code>Owner</code> and the value <code>TeamA</code>, specify <code>tag:Owner</code> for the filter name and <code>TeamA</code> for the filter value.</p> </li> <li> <p> <code>tag-key</code> - The key of a tag assigned to the resource. Use this filter to find all resources assigned a tag with a specific key, regardless of the tag value.</p> </li> <li> <p> <code>vpc-peering-connection-id</code> - The ID of the VPC peering connection.</p> </li> </ul>
-- @return DescribeVpcPeeringConnectionsRequest structure as a key-value pair table
function M.DescribeVpcPeeringConnectionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcPeeringConnectionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcPeeringConnectionIds"] = args["VpcPeeringConnectionIds"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpcPeeringConnectionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AuthorizeSecurityGroupEgressRequest = { ["DryRun"] = true, ["CidrIp"] = true, ["IpPermissions"] = true, ["FromPort"] = true, ["SourceSecurityGroupOwnerId"] = true, ["SourceSecurityGroupName"] = true, ["ToPort"] = true, ["IpProtocol"] = true, ["GroupId"] = true, nil }

function asserts.AssertAuthorizeSecurityGroupEgressRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AuthorizeSecurityGroupEgressRequest to be of type 'table'")
	assert(struct["GroupId"], "Expected key GroupId to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["CidrIp"] then asserts.AssertString(struct["CidrIp"]) end
	if struct["IpPermissions"] then asserts.AssertIpPermissionList(struct["IpPermissions"]) end
	if struct["FromPort"] then asserts.AssertInteger(struct["FromPort"]) end
	if struct["SourceSecurityGroupOwnerId"] then asserts.AssertString(struct["SourceSecurityGroupOwnerId"]) end
	if struct["SourceSecurityGroupName"] then asserts.AssertString(struct["SourceSecurityGroupName"]) end
	if struct["ToPort"] then asserts.AssertInteger(struct["ToPort"]) end
	if struct["IpProtocol"] then asserts.AssertString(struct["IpProtocol"]) end
	if struct["GroupId"] then asserts.AssertString(struct["GroupId"]) end
	for k,_ in pairs(struct) do
		assert(keys.AuthorizeSecurityGroupEgressRequest[k], "AuthorizeSecurityGroupEgressRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AuthorizeSecurityGroupEgressRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * CidrIp [String] <p>Not supported. Use a set of IP permissions to specify the CIDR.</p>
-- * IpPermissions [IpPermissionList] <p>One or more sets of IP permissions. You can't specify a destination security group and a CIDR IP address range in the same set of permissions.</p>
-- * FromPort [Integer] <p>Not supported. Use a set of IP permissions to specify the port.</p>
-- * SourceSecurityGroupOwnerId [String] <p>Not supported. Use a set of IP permissions to specify a destination security group.</p>
-- * SourceSecurityGroupName [String] <p>Not supported. Use a set of IP permissions to specify a destination security group.</p>
-- * ToPort [Integer] <p>Not supported. Use a set of IP permissions to specify the port.</p>
-- * IpProtocol [String] <p>Not supported. Use a set of IP permissions to specify the protocol name or number.</p>
-- * GroupId [String] <p>The ID of the security group.</p>
-- Required key: GroupId
-- @return AuthorizeSecurityGroupEgressRequest structure as a key-value pair table
function M.AuthorizeSecurityGroupEgressRequest(args)
	assert(args, "You must provide an argument table when creating AuthorizeSecurityGroupEgressRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["CidrIp"] = args["CidrIp"],
		["IpPermissions"] = args["IpPermissions"],
		["FromPort"] = args["FromPort"],
		["SourceSecurityGroupOwnerId"] = args["SourceSecurityGroupOwnerId"],
		["SourceSecurityGroupName"] = args["SourceSecurityGroupName"],
		["ToPort"] = args["ToPort"],
		["IpProtocol"] = args["IpProtocol"],
		["GroupId"] = args["GroupId"],
	}
	asserts.AssertAuthorizeSecurityGroupEgressRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteCustomerGatewayRequest = { ["CustomerGatewayId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteCustomerGatewayRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteCustomerGatewayRequest to be of type 'table'")
	assert(struct["CustomerGatewayId"], "Expected key CustomerGatewayId to exist in table")
	if struct["CustomerGatewayId"] then asserts.AssertString(struct["CustomerGatewayId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteCustomerGatewayRequest[k], "DeleteCustomerGatewayRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteCustomerGatewayRequest
-- <p>Contains the parameters for DeleteCustomerGateway.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * CustomerGatewayId [String] <p>The ID of the customer gateway.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: CustomerGatewayId
-- @return DeleteCustomerGatewayRequest structure as a key-value pair table
function M.DeleteCustomerGatewayRequest(args)
	assert(args, "You must provide an argument table when creating DeleteCustomerGatewayRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["CustomerGatewayId"] = args["CustomerGatewayId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteCustomerGatewayRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcEndpointConnectionNotificationsRequest = { ["ConnectionNotificationIds"] = true, ["DryRun"] = true, nil }

function asserts.AssertDeleteVpcEndpointConnectionNotificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointConnectionNotificationsRequest to be of type 'table'")
	assert(struct["ConnectionNotificationIds"], "Expected key ConnectionNotificationIds to exist in table")
	if struct["ConnectionNotificationIds"] then asserts.AssertValueStringList(struct["ConnectionNotificationIds"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointConnectionNotificationsRequest[k], "DeleteVpcEndpointConnectionNotificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointConnectionNotificationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConnectionNotificationIds [ValueStringList] <p>One or more notification IDs.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: ConnectionNotificationIds
-- @return DeleteVpcEndpointConnectionNotificationsRequest structure as a key-value pair table
function M.DeleteVpcEndpointConnectionNotificationsRequest(args)
	assert(args, "You must provide an argument table when creating DeleteVpcEndpointConnectionNotificationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConnectionNotificationIds"] = args["ConnectionNotificationIds"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDeleteVpcEndpointConnectionNotificationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateReservedInstancesListingRequest = { ["ReservedInstancesId"] = true, ["PriceSchedules"] = true, ["InstanceCount"] = true, ["ClientToken"] = true, nil }

function asserts.AssertCreateReservedInstancesListingRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateReservedInstancesListingRequest to be of type 'table'")
	assert(struct["ClientToken"], "Expected key ClientToken to exist in table")
	assert(struct["InstanceCount"], "Expected key InstanceCount to exist in table")
	assert(struct["PriceSchedules"], "Expected key PriceSchedules to exist in table")
	assert(struct["ReservedInstancesId"], "Expected key ReservedInstancesId to exist in table")
	if struct["ReservedInstancesId"] then asserts.AssertString(struct["ReservedInstancesId"]) end
	if struct["PriceSchedules"] then asserts.AssertPriceScheduleSpecificationList(struct["PriceSchedules"]) end
	if struct["InstanceCount"] then asserts.AssertInteger(struct["InstanceCount"]) end
	if struct["ClientToken"] then asserts.AssertString(struct["ClientToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateReservedInstancesListingRequest[k], "CreateReservedInstancesListingRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateReservedInstancesListingRequest
-- <p>Contains the parameters for CreateReservedInstancesListing.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ReservedInstancesId [String] <p>The ID of the active Standard Reserved Instance.</p>
-- * PriceSchedules [PriceScheduleSpecificationList] <p>A list specifying the price of the Standard Reserved Instance for each month remaining in the Reserved Instance term.</p>
-- * InstanceCount [Integer] <p>The number of instances that are a part of a Reserved Instance account to be listed in the Reserved Instance Marketplace. This number should be less than or equal to the instance count associated with the Reserved Instance ID specified in this call.</p>
-- * ClientToken [String] <p>Unique, case-sensitive identifier you provide to ensure idempotency of your listings. This helps avoid duplicate listings. For more information, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html">Ensuring Idempotency</a>.</p>
-- Required key: ClientToken
-- Required key: InstanceCount
-- Required key: PriceSchedules
-- Required key: ReservedInstancesId
-- @return CreateReservedInstancesListingRequest structure as a key-value pair table
function M.CreateReservedInstancesListingRequest(args)
	assert(args, "You must provide an argument table when creating CreateReservedInstancesListingRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ReservedInstancesId"] = args["ReservedInstancesId"],
		["PriceSchedules"] = args["PriceSchedules"],
		["InstanceCount"] = args["InstanceCount"],
		["ClientToken"] = args["ClientToken"],
	}
	asserts.AssertCreateReservedInstancesListingRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterfaceAssociation = { ["PublicIp"] = true, ["AssociationId"] = true, ["PublicDnsName"] = true, ["AllocationId"] = true, ["IpOwnerId"] = true, nil }

function asserts.AssertNetworkInterfaceAssociation(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfaceAssociation to be of type 'table'")
	if struct["PublicIp"] then asserts.AssertString(struct["PublicIp"]) end
	if struct["AssociationId"] then asserts.AssertString(struct["AssociationId"]) end
	if struct["PublicDnsName"] then asserts.AssertString(struct["PublicDnsName"]) end
	if struct["AllocationId"] then asserts.AssertString(struct["AllocationId"]) end
	if struct["IpOwnerId"] then asserts.AssertString(struct["IpOwnerId"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfaceAssociation[k], "NetworkInterfaceAssociation contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfaceAssociation
-- <p>Describes association information for an Elastic IP address (IPv4 only).</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * PublicIp [String] <p>The address of the Elastic IP address bound to the network interface.</p>
-- * AssociationId [String] <p>The association ID.</p>
-- * PublicDnsName [String] <p>The public DNS name.</p>
-- * AllocationId [String] <p>The allocation ID.</p>
-- * IpOwnerId [String] <p>The ID of the Elastic IP address owner.</p>
-- @return NetworkInterfaceAssociation structure as a key-value pair table
function M.NetworkInterfaceAssociation(args)
	assert(args, "You must provide an argument table when creating NetworkInterfaceAssociation")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["PublicIp"] = args["PublicIp"],
		["AssociationId"] = args["AssociationId"],
		["PublicDnsName"] = args["PublicDnsName"],
		["AllocationId"] = args["AllocationId"],
		["IpOwnerId"] = args["IpOwnerId"],
	}
	asserts.AssertNetworkInterfaceAssociation(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ReservedInstancesOffering = { ["OfferingClass"] = true, ["Marketplace"] = true, ["ProductDescription"] = true, ["CurrencyCode"] = true, ["PricingDetails"] = true, ["UsagePrice"] = true, ["RecurringCharges"] = true, ["OfferingType"] = true, ["AvailabilityZone"] = true, ["FixedPrice"] = true, ["Scope"] = true, ["Duration"] = true, ["InstanceTenancy"] = true, ["ReservedInstancesOfferingId"] = true, ["InstanceType"] = true, nil }

function asserts.AssertReservedInstancesOffering(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ReservedInstancesOffering to be of type 'table'")
	if struct["OfferingClass"] then asserts.AssertOfferingClassType(struct["OfferingClass"]) end
	if struct["Marketplace"] then asserts.AssertBoolean(struct["Marketplace"]) end
	if struct["ProductDescription"] then asserts.AssertRIProductDescription(struct["ProductDescription"]) end
	if struct["CurrencyCode"] then asserts.AssertCurrencyCodeValues(struct["CurrencyCode"]) end
	if struct["PricingDetails"] then asserts.AssertPricingDetailsList(struct["PricingDetails"]) end
	if struct["UsagePrice"] then asserts.AssertFloat(struct["UsagePrice"]) end
	if struct["RecurringCharges"] then asserts.AssertRecurringChargesList(struct["RecurringCharges"]) end
	if struct["OfferingType"] then asserts.AssertOfferingTypeValues(struct["OfferingType"]) end
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["FixedPrice"] then asserts.AssertFloat(struct["FixedPrice"]) end
	if struct["Scope"] then asserts.Assertscope(struct["Scope"]) end
	if struct["Duration"] then asserts.AssertLong(struct["Duration"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["ReservedInstancesOfferingId"] then asserts.AssertString(struct["ReservedInstancesOfferingId"]) end
	if struct["InstanceType"] then asserts.AssertInstanceType(struct["InstanceType"]) end
	for k,_ in pairs(struct) do
		assert(keys.ReservedInstancesOffering[k], "ReservedInstancesOffering contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ReservedInstancesOffering
-- <p>Describes a Reserved Instance offering.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * OfferingClass [OfferingClassType] <p>If <code>convertible</code> it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If <code>standard</code>, it is not possible to perform an exchange.</p>
-- * Marketplace [Boolean] <p>Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is <code>true</code>.</p>
-- * ProductDescription [RIProductDescription] <p>The Reserved Instance product platform description.</p>
-- * CurrencyCode [CurrencyCodeValues] <p>The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>
-- * PricingDetails [PricingDetailsList] <p>The pricing details of the Reserved Instance offering.</p>
-- * UsagePrice [Float] <p>The usage price of the Reserved Instance, per hour.</p>
-- * RecurringCharges [RecurringChargesList] <p>The recurring charge tag assigned to the resource.</p>
-- * OfferingType [OfferingTypeValues] <p>The Reserved Instance offering type.</p>
-- * AvailabilityZone [String] <p>The Availability Zone in which the Reserved Instance can be used.</p>
-- * FixedPrice [Float] <p>The purchase price of the Reserved Instance.</p>
-- * Scope [scope] <p>Whether the Reserved Instance is applied to instances in a region or an Availability Zone.</p>
-- * Duration [Long] <p>The duration of the Reserved Instance, in seconds.</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy of the instance.</p>
-- * ReservedInstancesOfferingId [String] <p>The ID of the Reserved Instance offering. This is the offering ID used in <a>GetReservedInstancesExchangeQuote</a> to confirm that an exchange can be made.</p>
-- * InstanceType [InstanceType] <p>The instance type on which the Reserved Instance can be used.</p>
-- @return ReservedInstancesOffering structure as a key-value pair table
function M.ReservedInstancesOffering(args)
	assert(args, "You must provide an argument table when creating ReservedInstancesOffering")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["OfferingClass"] = args["OfferingClass"],
		["Marketplace"] = args["Marketplace"],
		["ProductDescription"] = args["ProductDescription"],
		["CurrencyCode"] = args["CurrencyCode"],
		["PricingDetails"] = args["PricingDetails"],
		["UsagePrice"] = args["UsagePrice"],
		["RecurringCharges"] = args["RecurringCharges"],
		["OfferingType"] = args["OfferingType"],
		["AvailabilityZone"] = args["AvailabilityZone"],
		["FixedPrice"] = args["FixedPrice"],
		["Scope"] = args["Scope"],
		["Duration"] = args["Duration"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["ReservedInstancesOfferingId"] = args["ReservedInstancesOfferingId"],
		["InstanceType"] = args["InstanceType"],
	}
	asserts.AssertReservedInstancesOffering(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.MonitorInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertMonitorInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected MonitorInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.MonitorInstancesRequest[k], "MonitorInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type MonitorInstancesRequest
-- <p>Contains the parameters for MonitorInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return MonitorInstancesRequest structure as a key-value pair table
function M.MonitorInstancesRequest(args)
	assert(args, "You must provide an argument table when creating MonitorInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertMonitorInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.Volume = { ["AvailabilityZone"] = true, ["Attachments"] = true, ["Tags"] = true, ["Encrypted"] = true, ["VolumeType"] = true, ["VolumeId"] = true, ["State"] = true, ["KmsKeyId"] = true, ["SnapshotId"] = true, ["Iops"] = true, ["CreateTime"] = true, ["Size"] = true, nil }

function asserts.AssertVolume(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected Volume to be of type 'table'")
	if struct["AvailabilityZone"] then asserts.AssertString(struct["AvailabilityZone"]) end
	if struct["Attachments"] then asserts.AssertVolumeAttachmentList(struct["Attachments"]) end
	if struct["Tags"] then asserts.AssertTagList(struct["Tags"]) end
	if struct["Encrypted"] then asserts.AssertBoolean(struct["Encrypted"]) end
	if struct["VolumeType"] then asserts.AssertVolumeType(struct["VolumeType"]) end
	if struct["VolumeId"] then asserts.AssertString(struct["VolumeId"]) end
	if struct["State"] then asserts.AssertVolumeState(struct["State"]) end
	if struct["KmsKeyId"] then asserts.AssertString(struct["KmsKeyId"]) end
	if struct["SnapshotId"] then asserts.AssertString(struct["SnapshotId"]) end
	if struct["Iops"] then asserts.AssertInteger(struct["Iops"]) end
	if struct["CreateTime"] then asserts.AssertDateTime(struct["CreateTime"]) end
	if struct["Size"] then asserts.AssertInteger(struct["Size"]) end
	for k,_ in pairs(struct) do
		assert(keys.Volume[k], "Volume contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type Volume
-- <p>Describes a volume.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AvailabilityZone [String] <p>The Availability Zone for the volume.</p>
-- * Attachments [VolumeAttachmentList] <p>Information about the volume attachments.</p>
-- * Tags [TagList] <p>Any tags assigned to the volume.</p>
-- * Encrypted [Boolean] <p>Indicates whether the volume will be encrypted.</p>
-- * VolumeType [VolumeType] <p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>
-- * VolumeId [String] <p>The ID of the volume.</p>
-- * State [VolumeState] <p>The volume state.</p>
-- * KmsKeyId [String] <p>The full ARN of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.</p>
-- * SnapshotId [String] <p>The snapshot from which the volume was created, if applicable.</p>
-- * Iops [Integer] <p>The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-32000 IOPS for io1 volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>
-- * CreateTime [DateTime] <p>The time stamp when volume creation was initiated.</p>
-- * Size [Integer] <p>The size of the volume, in GiBs.</p>
-- @return Volume structure as a key-value pair table
function M.Volume(args)
	assert(args, "You must provide an argument table when creating Volume")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AvailabilityZone"] = args["AvailabilityZone"],
		["Attachments"] = args["Attachments"],
		["Tags"] = args["Tags"],
		["Encrypted"] = args["Encrypted"],
		["VolumeType"] = args["VolumeType"],
		["VolumeId"] = args["VolumeId"],
		["State"] = args["State"],
		["KmsKeyId"] = args["KmsKeyId"],
		["SnapshotId"] = args["SnapshotId"],
		["Iops"] = args["Iops"],
		["CreateTime"] = args["CreateTime"],
		["Size"] = args["Size"],
	}
	asserts.AssertVolume(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcResult = { ["Vpc"] = true, nil }

function asserts.AssertCreateVpcResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcResult to be of type 'table'")
	if struct["Vpc"] then asserts.AssertVpc(struct["Vpc"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcResult[k], "CreateVpcResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Vpc [Vpc] <p>Information about the VPC.</p>
-- @return CreateVpcResult structure as a key-value pair table
function M.CreateVpcResult(args)
	assert(args, "You must provide an argument table when creating CreateVpcResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Vpc"] = args["Vpc"],
	}
	asserts.AssertCreateVpcResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.EnableVpcClassicLinkRequest = { ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertEnableVpcClassicLinkRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected EnableVpcClassicLinkRequest to be of type 'table'")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.EnableVpcClassicLinkRequest[k], "EnableVpcClassicLinkRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type EnableVpcClassicLinkRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: VpcId
-- @return EnableVpcClassicLinkRequest structure as a key-value pair table
function M.EnableVpcClassicLinkRequest(args)
	assert(args, "You must provide an argument table when creating EnableVpcClassicLinkRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertEnableVpcClassicLinkRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ConnectionNotification = { ["ConnectionEvents"] = true, ["ConnectionNotificationState"] = true, ["ConnectionNotificationType"] = true, ["ServiceId"] = true, ["ConnectionNotificationId"] = true, ["ConnectionNotificationArn"] = true, ["VpcEndpointId"] = true, nil }

function asserts.AssertConnectionNotification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ConnectionNotification to be of type 'table'")
	if struct["ConnectionEvents"] then asserts.AssertValueStringList(struct["ConnectionEvents"]) end
	if struct["ConnectionNotificationState"] then asserts.AssertConnectionNotificationState(struct["ConnectionNotificationState"]) end
	if struct["ConnectionNotificationType"] then asserts.AssertConnectionNotificationType(struct["ConnectionNotificationType"]) end
	if struct["ServiceId"] then asserts.AssertString(struct["ServiceId"]) end
	if struct["ConnectionNotificationId"] then asserts.AssertString(struct["ConnectionNotificationId"]) end
	if struct["ConnectionNotificationArn"] then asserts.AssertString(struct["ConnectionNotificationArn"]) end
	if struct["VpcEndpointId"] then asserts.AssertString(struct["VpcEndpointId"]) end
	for k,_ in pairs(struct) do
		assert(keys.ConnectionNotification[k], "ConnectionNotification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ConnectionNotification
-- <p>Describes a connection notification for a VPC endpoint or VPC endpoint service.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ConnectionEvents [ValueStringList] <p>The events for the notification. Valid values are <code>Accept</code>, <code>Connect</code>, <code>Delete</code>, and <code>Reject</code>.</p>
-- * ConnectionNotificationState [ConnectionNotificationState] <p>The state of the notification.</p>
-- * ConnectionNotificationType [ConnectionNotificationType] <p>The type of notification.</p>
-- * ServiceId [String] <p>The ID of the endpoint service.</p>
-- * ConnectionNotificationId [String] <p>The ID of the notification.</p>
-- * ConnectionNotificationArn [String] <p>The ARN of the SNS topic for the notification.</p>
-- * VpcEndpointId [String] <p>The ID of the VPC endpoint.</p>
-- @return ConnectionNotification structure as a key-value pair table
function M.ConnectionNotification(args)
	assert(args, "You must provide an argument table when creating ConnectionNotification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ConnectionEvents"] = args["ConnectionEvents"],
		["ConnectionNotificationState"] = args["ConnectionNotificationState"],
		["ConnectionNotificationType"] = args["ConnectionNotificationType"],
		["ServiceId"] = args["ServiceId"],
		["ConnectionNotificationId"] = args["ConnectionNotificationId"],
		["ConnectionNotificationArn"] = args["ConnectionNotificationArn"],
		["VpcEndpointId"] = args["VpcEndpointId"],
	}
	asserts.AssertConnectionNotification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DeleteVpcEndpointServiceConfigurationsResult = { ["Unsuccessful"] = true, nil }

function asserts.AssertDeleteVpcEndpointServiceConfigurationsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DeleteVpcEndpointServiceConfigurationsResult to be of type 'table'")
	if struct["Unsuccessful"] then asserts.AssertUnsuccessfulItemSet(struct["Unsuccessful"]) end
	for k,_ in pairs(struct) do
		assert(keys.DeleteVpcEndpointServiceConfigurationsResult[k], "DeleteVpcEndpointServiceConfigurationsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DeleteVpcEndpointServiceConfigurationsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Unsuccessful [UnsuccessfulItemSet] <p>Information about the service configurations that were not deleted, if applicable.</p>
-- @return DeleteVpcEndpointServiceConfigurationsResult structure as a key-value pair table
function M.DeleteVpcEndpointServiceConfigurationsResult(args)
	assert(args, "You must provide an argument table when creating DeleteVpcEndpointServiceConfigurationsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Unsuccessful"] = args["Unsuccessful"],
	}
	asserts.AssertDeleteVpcEndpointServiceConfigurationsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVolumeStatusRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, ["VolumeIds"] = true, nil }

function asserts.AssertDescribeVolumeStatusRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVolumeStatusRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["VolumeIds"] then asserts.AssertVolumeIdStringList(struct["VolumeIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVolumeStatusRequest[k], "DescribeVolumeStatusRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVolumeStatusRequest
-- <p>Contains the parameters for DescribeVolumeStatus.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The <code>NextToken</code> value to include in a future <code>DescribeVolumeStatus</code> request. When the results of the request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of volume results returned by <code>DescribeVolumeStatus</code> in paginated output. When this parameter is used, the request only returns <code>MaxResults</code> results in a single page along with a <code>NextToken</code> response element. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned. If this parameter is not used, then <code>DescribeVolumeStatus</code> returns all results. You cannot specify this parameter and the volume IDs parameter in the same request.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>action.code</code> - The action code for the event (for example, <code>enable-volume-io</code>).</p> </li> <li> <p> <code>action.description</code> - A description of the action.</p> </li> <li> <p> <code>action.event-id</code> - The event ID associated with the action.</p> </li> <li> <p> <code>availability-zone</code> - The Availability Zone of the instance.</p> </li> <li> <p> <code>event.description</code> - A description of the event.</p> </li> <li> <p> <code>event.event-id</code> - The event ID.</p> </li> <li> <p> <code>event.event-type</code> - The event type (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>io-performance:degraded</code> | <code>io-performance:severely-degraded</code> | <code>io-performance:stalled</code>).</p> </li> <li> <p> <code>event.not-after</code> - The latest end time for the event.</p> </li> <li> <p> <code>event.not-before</code> - The earliest start time for the event.</p> </li> <li> <p> <code>volume-status.details-name</code> - The cause for <code>volume-status.status</code> (<code>io-enabled</code> | <code>io-performance</code>).</p> </li> <li> <p> <code>volume-status.details-status</code> - The status of <code>volume-status.details-name</code> (for <code>io-enabled</code>: <code>passed</code> | <code>failed</code>; for <code>io-performance</code>: <code>normal</code> | <code>degraded</code> | <code>severely-degraded</code> | <code>stalled</code>).</p> </li> <li> <p> <code>volume-status.status</code> - The status of the volume (<code>ok</code> | <code>impaired</code> | <code>warning</code> | <code>insufficient-data</code>).</p> </li> </ul>
-- * VolumeIds [VolumeIdStringList] <p>One or more volume IDs.</p> <p>Default: Describes all your volumes.</p>
-- @return DescribeVolumeStatusRequest structure as a key-value pair table
function M.DescribeVolumeStatusRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVolumeStatusRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
		["VolumeIds"] = args["VolumeIds"],
	}
	asserts.AssertDescribeVolumeStatusRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AssignPrivateIpAddressesRequest = { ["NetworkInterfaceId"] = true, ["SecondaryPrivateIpAddressCount"] = true, ["PrivateIpAddresses"] = true, ["AllowReassignment"] = true, nil }

function asserts.AssertAssignPrivateIpAddressesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AssignPrivateIpAddressesRequest to be of type 'table'")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["SecondaryPrivateIpAddressCount"] then asserts.AssertInteger(struct["SecondaryPrivateIpAddressCount"]) end
	if struct["PrivateIpAddresses"] then asserts.AssertPrivateIpAddressStringList(struct["PrivateIpAddresses"]) end
	if struct["AllowReassignment"] then asserts.AssertBoolean(struct["AllowReassignment"]) end
	for k,_ in pairs(struct) do
		assert(keys.AssignPrivateIpAddressesRequest[k], "AssignPrivateIpAddressesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AssignPrivateIpAddressesRequest
-- <p>Contains the parameters for AssignPrivateIpAddresses.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * SecondaryPrivateIpAddressCount [Integer] <p>The number of secondary IP addresses to assign to the network interface. You can't specify this parameter when also specifying private IP addresses.</p>
-- * PrivateIpAddresses [PrivateIpAddressStringList] <p>One or more IP addresses to be assigned as a secondary private IP address to the network interface. You can't specify this parameter when also specifying a number of secondary IP addresses.</p> <p>If you don't specify an IP address, Amazon EC2 automatically selects an IP address within the subnet range.</p>
-- * AllowReassignment [Boolean] <p>Indicates whether to allow an IP address that is already assigned to another network interface or instance to be reassigned to the specified network interface.</p>
-- Required key: NetworkInterfaceId
-- @return AssignPrivateIpAddressesRequest structure as a key-value pair table
function M.AssignPrivateIpAddressesRequest(args)
	assert(args, "You must provide an argument table when creating AssignPrivateIpAddressesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["SecondaryPrivateIpAddressCount"] = args["SecondaryPrivateIpAddressCount"],
		["PrivateIpAddresses"] = args["PrivateIpAddresses"],
		["AllowReassignment"] = args["AllowReassignment"],
	}
	asserts.AssertAssignPrivateIpAddressesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RequestSpotFleetRequest = { ["SpotFleetRequestConfig"] = true, ["DryRun"] = true, nil }

function asserts.AssertRequestSpotFleetRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RequestSpotFleetRequest to be of type 'table'")
	assert(struct["SpotFleetRequestConfig"], "Expected key SpotFleetRequestConfig to exist in table")
	if struct["SpotFleetRequestConfig"] then asserts.AssertSpotFleetRequestConfigData(struct["SpotFleetRequestConfig"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.RequestSpotFleetRequest[k], "RequestSpotFleetRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RequestSpotFleetRequest
-- <p>Contains the parameters for RequestSpotFleet.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotFleetRequestConfig [SpotFleetRequestConfigData] <p>The configuration for the Spot Fleet request.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: SpotFleetRequestConfig
-- @return RequestSpotFleetRequest structure as a key-value pair table
function M.RequestSpotFleetRequest(args)
	assert(args, "You must provide an argument table when creating RequestSpotFleetRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotFleetRequestConfig"] = args["SpotFleetRequestConfig"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertRequestSpotFleetRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateVpcRequest = { ["AmazonProvidedIpv6CidrBlock"] = true, ["DryRun"] = true, ["InstanceTenancy"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateVpcRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateVpcRequest to be of type 'table'")
	assert(struct["CidrBlock"], "Expected key CidrBlock to exist in table")
	if struct["AmazonProvidedIpv6CidrBlock"] then asserts.AssertBoolean(struct["AmazonProvidedIpv6CidrBlock"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceTenancy"] then asserts.AssertTenancy(struct["InstanceTenancy"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateVpcRequest[k], "CreateVpcRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateVpcRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AmazonProvidedIpv6CidrBlock [Boolean] <p>Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceTenancy [Tenancy] <p>The tenancy options for instances launched into the VPC. For <code>default</code>, instances are launched with shared tenancy by default. You can launch instances with any tenancy into a shared tenancy VPC. For <code>dedicated</code>, instances are launched as dedicated tenancy instances by default. You can only launch instances with a tenancy of <code>dedicated</code> or <code>host</code> into a dedicated tenancy VPC. </p> <p> <b>Important:</b> The <code>host</code> value cannot be used with this parameter. Use the <code>default</code> or <code>dedicated</code> values only.</p> <p>Default: <code>default</code> </p>
-- * CidrBlock [String] <p>The IPv4 network range for the VPC, in CIDR notation. For example, <code>10.0.0.0/16</code>.</p>
-- Required key: CidrBlock
-- @return CreateVpcRequest structure as a key-value pair table
function M.CreateVpcRequest(args)
	assert(args, "You must provide an argument table when creating CreateVpcRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AmazonProvidedIpv6CidrBlock"] = args["AmazonProvidedIpv6CidrBlock"],
		["DryRun"] = args["DryRun"],
		["InstanceTenancy"] = args["InstanceTenancy"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertCreateVpcRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ClassicLinkDnsSupport = { ["VpcId"] = true, ["ClassicLinkDnsSupported"] = true, nil }

function asserts.AssertClassicLinkDnsSupport(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClassicLinkDnsSupport to be of type 'table'")
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["ClassicLinkDnsSupported"] then asserts.AssertBoolean(struct["ClassicLinkDnsSupported"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClassicLinkDnsSupport[k], "ClassicLinkDnsSupport contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClassicLinkDnsSupport
-- <p>Describes the ClassicLink DNS support status of a VPC.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * ClassicLinkDnsSupported [Boolean] <p>Indicates whether ClassicLink DNS support is enabled for the VPC.</p>
-- @return ClassicLinkDnsSupport structure as a key-value pair table
function M.ClassicLinkDnsSupport(args)
	assert(args, "You must provide an argument table when creating ClassicLinkDnsSupport")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["VpcId"] = args["VpcId"],
		["ClassicLinkDnsSupported"] = args["ClassicLinkDnsSupported"],
	}
	asserts.AssertClassicLinkDnsSupport(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.RebootInstancesRequest = { ["DryRun"] = true, ["InstanceIds"] = true, nil }

function asserts.AssertRebootInstancesRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected RebootInstancesRequest to be of type 'table'")
	assert(struct["InstanceIds"], "Expected key InstanceIds to exist in table")
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["InstanceIds"] then asserts.AssertInstanceIdStringList(struct["InstanceIds"]) end
	for k,_ in pairs(struct) do
		assert(keys.RebootInstancesRequest[k], "RebootInstancesRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type RebootInstancesRequest
-- <p>Contains the parameters for RebootInstances.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * InstanceIds [InstanceIdStringList] <p>One or more instance IDs.</p>
-- Required key: InstanceIds
-- @return RebootInstancesRequest structure as a key-value pair table
function M.RebootInstancesRequest(args)
	assert(args, "You must provide an argument table when creating RebootInstancesRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["DryRun"] = args["DryRun"],
		["InstanceIds"] = args["InstanceIds"],
	}
	asserts.AssertRebootInstancesRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.CreateNetworkAclEntryRequest = { ["IcmpTypeCode"] = true, ["NetworkAclId"] = true, ["RuleNumber"] = true, ["DryRun"] = true, ["Ipv6CidrBlock"] = true, ["Egress"] = true, ["RuleAction"] = true, ["PortRange"] = true, ["Protocol"] = true, ["CidrBlock"] = true, nil }

function asserts.AssertCreateNetworkAclEntryRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected CreateNetworkAclEntryRequest to be of type 'table'")
	assert(struct["Egress"], "Expected key Egress to exist in table")
	assert(struct["NetworkAclId"], "Expected key NetworkAclId to exist in table")
	assert(struct["Protocol"], "Expected key Protocol to exist in table")
	assert(struct["RuleAction"], "Expected key RuleAction to exist in table")
	assert(struct["RuleNumber"], "Expected key RuleNumber to exist in table")
	if struct["IcmpTypeCode"] then asserts.AssertIcmpTypeCode(struct["IcmpTypeCode"]) end
	if struct["NetworkAclId"] then asserts.AssertString(struct["NetworkAclId"]) end
	if struct["RuleNumber"] then asserts.AssertInteger(struct["RuleNumber"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Ipv6CidrBlock"] then asserts.AssertString(struct["Ipv6CidrBlock"]) end
	if struct["Egress"] then asserts.AssertBoolean(struct["Egress"]) end
	if struct["RuleAction"] then asserts.AssertRuleAction(struct["RuleAction"]) end
	if struct["PortRange"] then asserts.AssertPortRange(struct["PortRange"]) end
	if struct["Protocol"] then asserts.AssertString(struct["Protocol"]) end
	if struct["CidrBlock"] then asserts.AssertString(struct["CidrBlock"]) end
	for k,_ in pairs(struct) do
		assert(keys.CreateNetworkAclEntryRequest[k], "CreateNetworkAclEntryRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type CreateNetworkAclEntryRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * IcmpTypeCode [IcmpTypeCode] <p>ICMP protocol: The ICMP or ICMPv6 type and code. Required if specifying protocol 1 (ICMP) or protocol 58 (ICMPv6) with an IPv6 CIDR block.</p>
-- * NetworkAclId [String] <p>The ID of the network ACL.</p>
-- * RuleNumber [Integer] <p>The rule number for the entry (for example, 100). ACL entries are processed in ascending order by rule number.</p> <p>Constraints: Positive integer from 1 to 32766. The range 32767 to 65535 is reserved for internal use.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Ipv6CidrBlock [String] <p>The IPv6 network range to allow or deny, in CIDR notation (for example <code>2001:db8:1234:1a00::/64</code>).</p>
-- * Egress [Boolean] <p>Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet).</p>
-- * RuleAction [RuleAction] <p>Indicates whether to allow or deny the traffic that matches the rule.</p>
-- * PortRange [PortRange] <p>TCP or UDP protocols: The range of ports the rule applies to. Required if specifying protocol 6 (TCP) or 17 (UDP).</p>
-- * Protocol [String] <p>The protocol number. A value of "-1" means all protocols. If you specify "-1" or a protocol number other than "6" (TCP), "17" (UDP), or "1" (ICMP), traffic on all ports is allowed, regardless of any ports or ICMP types or codes that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol "58" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code.</p>
-- * CidrBlock [String] <p>The IPv4 network range to allow or deny, in CIDR notation (for example <code>172.16.0.0/24</code>).</p>
-- Required key: Egress
-- Required key: NetworkAclId
-- Required key: Protocol
-- Required key: RuleAction
-- Required key: RuleNumber
-- @return CreateNetworkAclEntryRequest structure as a key-value pair table
function M.CreateNetworkAclEntryRequest(args)
	assert(args, "You must provide an argument table when creating CreateNetworkAclEntryRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["IcmpTypeCode"] = args["IcmpTypeCode"],
		["NetworkAclId"] = args["NetworkAclId"],
		["RuleNumber"] = args["RuleNumber"],
		["DryRun"] = args["DryRun"],
		["Ipv6CidrBlock"] = args["Ipv6CidrBlock"],
		["Egress"] = args["Egress"],
		["RuleAction"] = args["RuleAction"],
		["PortRange"] = args["PortRange"],
		["Protocol"] = args["Protocol"],
		["CidrBlock"] = args["CidrBlock"],
	}
	asserts.AssertCreateNetworkAclEntryRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.AttachNetworkInterfaceRequest = { ["InstanceId"] = true, ["DeviceIndex"] = true, ["NetworkInterfaceId"] = true, ["DryRun"] = true, nil }

function asserts.AssertAttachNetworkInterfaceRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected AttachNetworkInterfaceRequest to be of type 'table'")
	assert(struct["DeviceIndex"], "Expected key DeviceIndex to exist in table")
	assert(struct["InstanceId"], "Expected key InstanceId to exist in table")
	assert(struct["NetworkInterfaceId"], "Expected key NetworkInterfaceId to exist in table")
	if struct["InstanceId"] then asserts.AssertString(struct["InstanceId"]) end
	if struct["DeviceIndex"] then asserts.AssertInteger(struct["DeviceIndex"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.AttachNetworkInterfaceRequest[k], "AttachNetworkInterfaceRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type AttachNetworkInterfaceRequest
-- <p>Contains the parameters for AttachNetworkInterface.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * InstanceId [String] <p>The ID of the instance.</p>
-- * DeviceIndex [Integer] <p>The index of the device for the network interface attachment.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: DeviceIndex
-- Required key: InstanceId
-- Required key: NetworkInterfaceId
-- @return AttachNetworkInterfaceRequest structure as a key-value pair table
function M.AttachNetworkInterfaceRequest(args)
	assert(args, "You must provide an argument table when creating AttachNetworkInterfaceRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["InstanceId"] = args["InstanceId"],
		["DeviceIndex"] = args["DeviceIndex"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertAttachNetworkInterfaceRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ImportKeyPairResult = { ["KeyName"] = true, ["KeyFingerprint"] = true, nil }

function asserts.AssertImportKeyPairResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ImportKeyPairResult to be of type 'table'")
	if struct["KeyName"] then asserts.AssertString(struct["KeyName"]) end
	if struct["KeyFingerprint"] then asserts.AssertString(struct["KeyFingerprint"]) end
	for k,_ in pairs(struct) do
		assert(keys.ImportKeyPairResult[k], "ImportKeyPairResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ImportKeyPairResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * KeyName [String] <p>The key pair name you provided.</p>
-- * KeyFingerprint [String] <p>The MD5 public key fingerprint as specified in section 4 of RFC 4716.</p>
-- @return ImportKeyPairResult structure as a key-value pair table
function M.ImportKeyPairResult(args)
	assert(args, "You must provide an argument table when creating ImportKeyPairResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["KeyName"] = args["KeyName"],
		["KeyFingerprint"] = args["KeyFingerprint"],
	}
	asserts.AssertImportKeyPairResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.NetworkInterfacePermissionState = { ["State"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertNetworkInterfacePermissionState(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected NetworkInterfacePermissionState to be of type 'table'")
	if struct["State"] then asserts.AssertNetworkInterfacePermissionStateCode(struct["State"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.NetworkInterfacePermissionState[k], "NetworkInterfacePermissionState contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type NetworkInterfacePermissionState
-- <p>Describes the state of a network interface permission.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * State [NetworkInterfacePermissionStateCode] <p>The state of the permission.</p>
-- * StatusMessage [String] <p>A status message, if applicable.</p>
-- @return NetworkInterfacePermissionState structure as a key-value pair table
function M.NetworkInterfacePermissionState(args)
	assert(args, "You must provide an argument table when creating NetworkInterfacePermissionState")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["State"] = args["State"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertNetworkInterfacePermissionState(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeSpotInstanceRequestsResult = { ["SpotInstanceRequests"] = true, nil }

function asserts.AssertDescribeSpotInstanceRequestsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeSpotInstanceRequestsResult to be of type 'table'")
	if struct["SpotInstanceRequests"] then asserts.AssertSpotInstanceRequestList(struct["SpotInstanceRequests"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeSpotInstanceRequestsResult[k], "DescribeSpotInstanceRequestsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeSpotInstanceRequestsResult
-- <p>Contains the output of DescribeSpotInstanceRequests.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SpotInstanceRequests [SpotInstanceRequestList] <p>One or more Spot Instance requests.</p>
-- @return DescribeSpotInstanceRequestsResult structure as a key-value pair table
function M.DescribeSpotInstanceRequestsResult(args)
	assert(args, "You must provide an argument table when creating DescribeSpotInstanceRequestsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SpotInstanceRequests"] = args["SpotInstanceRequests"],
	}
	asserts.AssertDescribeSpotInstanceRequestsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribePrincipalIdFormatRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Resources"] = true, nil }

function asserts.AssertDescribePrincipalIdFormatRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribePrincipalIdFormatRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Resources"] then asserts.AssertResourceList(struct["Resources"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribePrincipalIdFormatRequest[k], "DescribePrincipalIdFormatRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribePrincipalIdFormatRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another call with the returned NextToken value. </p>
-- * Resources [ResourceList] <p>The type of resource: <code>bundle</code> | <code>conversion-task</code> | <code>customer-gateway</code> | <code>dhcp-options</code> | <code>elastic-ip-allocation</code> | <code>elastic-ip-association</code> | <code>export-task</code> | <code>flow-log</code> | <code>image</code> | <code>import-task</code> | <code>instance</code> | <code>internet-gateway</code> | <code>network-acl</code> | <code>network-acl-association</code> | <code>network-interface</code> | <code>network-interface-attachment</code> | <code>prefix-list</code> | <code>reservation</code> | <code>route-table</code> | <code>route-table-association</code> | <code>security-group</code> | <code>snapshot</code> | <code>subnet</code> | <code>subnet-cidr-block-association</code> | <code>volume</code> | <code>vpc</code> | <code>vpc-cidr-block-association</code> | <code>vpc-endpoint</code> | <code>vpc-peering-connection</code> | <code>vpn-connection</code> | <code>vpn-gateway</code> </p>
-- @return DescribePrincipalIdFormatRequest structure as a key-value pair table
function M.DescribePrincipalIdFormatRequest(args)
	assert(args, "You must provide an argument table when creating DescribePrincipalIdFormatRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Resources"] = args["Resources"],
	}
	asserts.AssertDescribePrincipalIdFormatRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ClientData = { ["Comment"] = true, ["UploadSize"] = true, ["UploadEnd"] = true, ["UploadStart"] = true, nil }

function asserts.AssertClientData(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ClientData to be of type 'table'")
	if struct["Comment"] then asserts.AssertString(struct["Comment"]) end
	if struct["UploadSize"] then asserts.AssertDouble(struct["UploadSize"]) end
	if struct["UploadEnd"] then asserts.AssertDateTime(struct["UploadEnd"]) end
	if struct["UploadStart"] then asserts.AssertDateTime(struct["UploadStart"]) end
	for k,_ in pairs(struct) do
		assert(keys.ClientData[k], "ClientData contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ClientData
-- <p>Describes the client-specific data.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Comment [String] <p>A user-defined comment about the disk upload.</p>
-- * UploadSize [Double] <p>The size of the uploaded disk image, in GiB.</p>
-- * UploadEnd [DateTime] <p>The time that the disk upload ends.</p>
-- * UploadStart [DateTime] <p>The time that the disk upload starts.</p>
-- @return ClientData structure as a key-value pair table
function M.ClientData(args)
	assert(args, "You must provide an argument table when creating ClientData")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Comment"] = args["Comment"],
		["UploadSize"] = args["UploadSize"],
		["UploadEnd"] = args["UploadEnd"],
		["UploadStart"] = args["UploadStart"],
	}
	asserts.AssertClientData(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeNetworkInterfaceAttributeResult = { ["SourceDestCheck"] = true, ["NetworkInterfaceId"] = true, ["Attachment"] = true, ["Groups"] = true, ["Description"] = true, nil }

function asserts.AssertDescribeNetworkInterfaceAttributeResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeNetworkInterfaceAttributeResult to be of type 'table'")
	if struct["SourceDestCheck"] then asserts.AssertAttributeBooleanValue(struct["SourceDestCheck"]) end
	if struct["NetworkInterfaceId"] then asserts.AssertString(struct["NetworkInterfaceId"]) end
	if struct["Attachment"] then asserts.AssertNetworkInterfaceAttachment(struct["Attachment"]) end
	if struct["Groups"] then asserts.AssertGroupIdentifierList(struct["Groups"]) end
	if struct["Description"] then asserts.AssertAttributeValue(struct["Description"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeNetworkInterfaceAttributeResult[k], "DescribeNetworkInterfaceAttributeResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeNetworkInterfaceAttributeResult
-- <p>Contains the output of DescribeNetworkInterfaceAttribute.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * SourceDestCheck [AttributeBooleanValue] <p>Indicates whether source/destination checking is enabled.</p>
-- * NetworkInterfaceId [String] <p>The ID of the network interface.</p>
-- * Attachment [NetworkInterfaceAttachment] <p>The attachment (if any) of the network interface.</p>
-- * Groups [GroupIdentifierList] <p>The security groups associated with the network interface.</p>
-- * Description [AttributeValue] <p>The description of the network interface.</p>
-- @return DescribeNetworkInterfaceAttributeResult structure as a key-value pair table
function M.DescribeNetworkInterfaceAttributeResult(args)
	assert(args, "You must provide an argument table when creating DescribeNetworkInterfaceAttributeResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["SourceDestCheck"] = args["SourceDestCheck"],
		["NetworkInterfaceId"] = args["NetworkInterfaceId"],
		["Attachment"] = args["Attachment"],
		["Groups"] = args["Groups"],
		["Description"] = args["Description"],
	}
	asserts.AssertDescribeNetworkInterfaceAttributeResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointConnectionsRequest = { ["NextToken"] = true, ["DryRun"] = true, ["MaxResults"] = true, ["Filters"] = true, nil }

function asserts.AssertDescribeVpcEndpointConnectionsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointConnectionsRequest to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointConnectionsRequest[k], "DescribeVpcEndpointConnectionsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointConnectionsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to retrieve the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * MaxResults [Integer] <p>The maximum number of results to return for the request in a single page. The remaining results of the initial request can be seen by sending another request with the returned <code>NextToken</code> value. This value can be between 5 and 1000; if <code>MaxResults</code> is given a value larger than 1000, only 1000 results are returned.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>service-id</code> - The ID of the service.</p> </li> <li> <p> <code>vpc-endpoint-owner</code> - The AWS account number of the owner of the endpoint.</p> </li> <li> <p> <code>vpc-endpoint-state</code> - The state of the endpoint (<code>pendingAcceptance</code> | <code>pending</code> | <code>available</code> | <code>deleting</code> | <code>deleted</code> | <code>rejected</code> | <code>failed</code>).</p> </li> <li> <p> <code>vpc-endpoint-id</code> - The ID of the endpoint.</p> </li> </ul>
-- @return DescribeVpcEndpointConnectionsRequest structure as a key-value pair table
function M.DescribeVpcEndpointConnectionsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointConnectionsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["MaxResults"] = args["MaxResults"],
		["Filters"] = args["Filters"],
	}
	asserts.AssertDescribeVpcEndpointConnectionsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ProvisionByoipCidrResult = { ["ByoipCidr"] = true, nil }

function asserts.AssertProvisionByoipCidrResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ProvisionByoipCidrResult to be of type 'table'")
	if struct["ByoipCidr"] then asserts.AssertByoipCidr(struct["ByoipCidr"]) end
	for k,_ in pairs(struct) do
		assert(keys.ProvisionByoipCidrResult[k], "ProvisionByoipCidrResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ProvisionByoipCidrResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * ByoipCidr [ByoipCidr] <p>Information about the address pool.</p>
-- @return ProvisionByoipCidrResult structure as a key-value pair table
function M.ProvisionByoipCidrResult(args)
	assert(args, "You must provide an argument table when creating ProvisionByoipCidrResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["ByoipCidr"] = args["ByoipCidr"],
	}
	asserts.AssertProvisionByoipCidrResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.ExportToS3TaskSpecification = { ["S3Bucket"] = true, ["DiskImageFormat"] = true, ["S3Prefix"] = true, ["ContainerFormat"] = true, nil }

function asserts.AssertExportToS3TaskSpecification(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected ExportToS3TaskSpecification to be of type 'table'")
	if struct["S3Bucket"] then asserts.AssertString(struct["S3Bucket"]) end
	if struct["DiskImageFormat"] then asserts.AssertDiskImageFormat(struct["DiskImageFormat"]) end
	if struct["S3Prefix"] then asserts.AssertString(struct["S3Prefix"]) end
	if struct["ContainerFormat"] then asserts.AssertContainerFormat(struct["ContainerFormat"]) end
	for k,_ in pairs(struct) do
		assert(keys.ExportToS3TaskSpecification[k], "ExportToS3TaskSpecification contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type ExportToS3TaskSpecification
-- <p>Describes an instance export task.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * S3Bucket [String] <p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>
-- * DiskImageFormat [DiskImageFormat] <p>The format for the exported image.</p>
-- * S3Prefix [String] <p>The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.</p>
-- * ContainerFormat [ContainerFormat] <p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>
-- @return ExportToS3TaskSpecification structure as a key-value pair table
function M.ExportToS3TaskSpecification(args)
	assert(args, "You must provide an argument table when creating ExportToS3TaskSpecification")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["S3Bucket"] = args["S3Bucket"],
		["DiskImageFormat"] = args["DiskImageFormat"],
		["S3Prefix"] = args["S3Prefix"],
		["ContainerFormat"] = args["ContainerFormat"],
	}
	asserts.AssertExportToS3TaskSpecification(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.VgwTelemetry = { ["Status"] = true, ["AcceptedRouteCount"] = true, ["LastStatusChange"] = true, ["OutsideIpAddress"] = true, ["StatusMessage"] = true, nil }

function asserts.AssertVgwTelemetry(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected VgwTelemetry to be of type 'table'")
	if struct["Status"] then asserts.AssertTelemetryStatus(struct["Status"]) end
	if struct["AcceptedRouteCount"] then asserts.AssertInteger(struct["AcceptedRouteCount"]) end
	if struct["LastStatusChange"] then asserts.AssertDateTime(struct["LastStatusChange"]) end
	if struct["OutsideIpAddress"] then asserts.AssertString(struct["OutsideIpAddress"]) end
	if struct["StatusMessage"] then asserts.AssertString(struct["StatusMessage"]) end
	for k,_ in pairs(struct) do
		assert(keys.VgwTelemetry[k], "VgwTelemetry contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type VgwTelemetry
-- <p>Describes telemetry for a VPN tunnel.</p>
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Status [TelemetryStatus] <p>The status of the VPN tunnel.</p>
-- * AcceptedRouteCount [Integer] <p>The number of accepted routes.</p>
-- * LastStatusChange [DateTime] <p>The date and time of the last change in status.</p>
-- * OutsideIpAddress [String] <p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>
-- * StatusMessage [String] <p>If an error occurs, a description of the error.</p>
-- @return VgwTelemetry structure as a key-value pair table
function M.VgwTelemetry(args)
	assert(args, "You must provide an argument table when creating VgwTelemetry")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Status"] = args["Status"],
		["AcceptedRouteCount"] = args["AcceptedRouteCount"],
		["LastStatusChange"] = args["LastStatusChange"],
		["OutsideIpAddress"] = args["OutsideIpAddress"],
		["StatusMessage"] = args["StatusMessage"],
	}
	asserts.AssertVgwTelemetry(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeHostReservationOfferingsResult = { ["NextToken"] = true, ["OfferingSet"] = true, nil }

function asserts.AssertDescribeHostReservationOfferingsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeHostReservationOfferingsResult to be of type 'table'")
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["OfferingSet"] then asserts.AssertHostOfferingSet(struct["OfferingSet"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeHostReservationOfferingsResult[k], "DescribeHostReservationOfferingsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeHostReservationOfferingsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- * OfferingSet [HostOfferingSet] <p>Information about the offerings.</p>
-- @return DescribeHostReservationOfferingsResult structure as a key-value pair table
function M.DescribeHostReservationOfferingsResult(args)
	assert(args, "You must provide an argument table when creating DescribeHostReservationOfferingsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["NextToken"] = args["NextToken"],
		["OfferingSet"] = args["OfferingSet"],
	}
	asserts.AssertDescribeHostReservationOfferingsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointServicePermissionsResult = { ["AllowedPrincipals"] = true, ["NextToken"] = true, nil }

function asserts.AssertDescribeVpcEndpointServicePermissionsResult(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointServicePermissionsResult to be of type 'table'")
	if struct["AllowedPrincipals"] then asserts.AssertAllowedPrincipalSet(struct["AllowedPrincipals"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointServicePermissionsResult[k], "DescribeVpcEndpointServicePermissionsResult contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointServicePermissionsResult
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * AllowedPrincipals [AllowedPrincipalSet] <p>Information about one or more allowed principals.</p>
-- * NextToken [String] <p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>
-- @return DescribeVpcEndpointServicePermissionsResult structure as a key-value pair table
function M.DescribeVpcEndpointServicePermissionsResult(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointServicePermissionsResult")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["AllowedPrincipals"] = args["AllowedPrincipals"],
		["NextToken"] = args["NextToken"],
	}
	asserts.AssertDescribeVpcEndpointServicePermissionsResult(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcAttributeRequest = { ["Attribute"] = true, ["VpcId"] = true, ["DryRun"] = true, nil }

function asserts.AssertDescribeVpcAttributeRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcAttributeRequest to be of type 'table'")
	assert(struct["Attribute"], "Expected key Attribute to exist in table")
	assert(struct["VpcId"], "Expected key VpcId to exist in table")
	if struct["Attribute"] then asserts.AssertVpcAttributeName(struct["Attribute"]) end
	if struct["VpcId"] then asserts.AssertString(struct["VpcId"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcAttributeRequest[k], "DescribeVpcAttributeRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcAttributeRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * Attribute [VpcAttributeName] <p>The VPC attribute.</p>
-- * VpcId [String] <p>The ID of the VPC.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- Required key: Attribute
-- Required key: VpcId
-- @return DescribeVpcAttributeRequest structure as a key-value pair table
function M.DescribeVpcAttributeRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcAttributeRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["Attribute"] = args["Attribute"],
		["VpcId"] = args["VpcId"],
		["DryRun"] = args["DryRun"],
	}
	asserts.AssertDescribeVpcAttributeRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

keys.DescribeVpcEndpointConnectionNotificationsRequest = { ["MaxResults"] = true, ["NextToken"] = true, ["DryRun"] = true, ["Filters"] = true, ["ConnectionNotificationId"] = true, nil }

function asserts.AssertDescribeVpcEndpointConnectionNotificationsRequest(struct)
	assert(struct)
	assert(type(struct) == "table", "Expected DescribeVpcEndpointConnectionNotificationsRequest to be of type 'table'")
	if struct["MaxResults"] then asserts.AssertInteger(struct["MaxResults"]) end
	if struct["NextToken"] then asserts.AssertString(struct["NextToken"]) end
	if struct["DryRun"] then asserts.AssertBoolean(struct["DryRun"]) end
	if struct["Filters"] then asserts.AssertFilterList(struct["Filters"]) end
	if struct["ConnectionNotificationId"] then asserts.AssertString(struct["ConnectionNotificationId"]) end
	for k,_ in pairs(struct) do
		assert(keys.DescribeVpcEndpointConnectionNotificationsRequest[k], "DescribeVpcEndpointConnectionNotificationsRequest contains unknown key " .. tostring(k))
	end
end

--- Create a structure of type DescribeVpcEndpointConnectionNotificationsRequest
--  
-- @param args Table with arguments in key-value form.
-- Valid keys:
-- * MaxResults [Integer] <p>The maximum number of results to return in a single call. To retrieve the remaining results, make another request with the returned <code>NextToken</code> value.</p>
-- * NextToken [String] <p>The token to request the next page of results.</p>
-- * DryRun [Boolean] <p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>
-- * Filters [FilterList] <p>One or more filters.</p> <ul> <li> <p> <code>connection-notification-arn</code> - The ARN of SNS topic for the notification.</p> </li> <li> <p> <code>connection-notification-id</code> - The ID of the notification.</p> </li> <li> <p> <code>connection-notification-state</code> - The state of the notification (<code>Enabled</code> | <code>Disabled</code>).</p> </li> <li> <p> <code>connection-notification-type</code> - The type of notification (<code>Topic</code>).</p> </li> <li> <p> <code>service-id</code> - The ID of the endpoint service.</p> </li> <li> <p> <code>vpc-endpoint-id</code> - The ID of the VPC endpoint.</p> </li> </ul>
-- * ConnectionNotificationId [String] <p>The ID of the notification.</p>
-- @return DescribeVpcEndpointConnectionNotificationsRequest structure as a key-value pair table
function M.DescribeVpcEndpointConnectionNotificationsRequest(args)
	assert(args, "You must provide an argument table when creating DescribeVpcEndpointConnectionNotificationsRequest")
    local query_args = { 
    }
    local uri_args = { 
    }
    local header_args = { 
    }
	local all_args = { 
		["MaxResults"] = args["MaxResults"],
		["NextToken"] = args["NextToken"],
		["DryRun"] = args["DryRun"],
		["Filters"] = args["Filters"],
		["ConnectionNotificationId"] = args["ConnectionNotificationId"],
	}
	asserts.AssertDescribeVpcEndpointConnectionNotificationsRequest(all_args)
	return {
        all = all_args,
        query = query_args,
        uri = uri_args,
        headers = header_args,
    }
end

function asserts.AssertEgressOnlyInternetGatewayId(str)
	assert(str)
	assert(type(str) == "string", "Expected EgressOnlyInternetGatewayId to be of type 'string'")
end

--  
function M.EgressOnlyInternetGatewayId(str)
	asserts.AssertEgressOnlyInternetGatewayId(str)
	return str
end

function asserts.AssertPlacementGroupState(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementGroupState to be of type 'string'")
end

--  
function M.PlacementGroupState(str)
	asserts.AssertPlacementGroupState(str)
	return str
end

function asserts.AssertVpcTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcTenancy to be of type 'string'")
end

--  
function M.VpcTenancy(str)
	asserts.AssertVpcTenancy(str)
	return str
end

function asserts.AssertIpv6Address(str)
	assert(str)
	assert(type(str) == "string", "Expected Ipv6Address to be of type 'string'")
end

--  
function M.Ipv6Address(str)
	asserts.AssertIpv6Address(str)
	return str
end

function asserts.AssertVolumeModificationState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeModificationState to be of type 'string'")
end

--  
function M.VolumeModificationState(str)
	asserts.AssertVolumeModificationState(str)
	return str
end

function asserts.AssertVpnState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnState to be of type 'string'")
end

--  
function M.VpnState(str)
	asserts.AssertVpnState(str)
	return str
end

function asserts.AssertSubnetState(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetState to be of type 'string'")
end

--  
function M.SubnetState(str)
	asserts.AssertSubnetState(str)
	return str
end

function asserts.AssertOfferingTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingTypeValues to be of type 'string'")
end

--  
function M.OfferingTypeValues(str)
	asserts.AssertOfferingTypeValues(str)
	return str
end

function asserts.AssertState(str)
	assert(str)
	assert(type(str) == "string", "Expected State to be of type 'string'")
end

--  
function M.State(str)
	asserts.AssertState(str)
	return str
end

function asserts.AssertEventCode(str)
	assert(str)
	assert(type(str) == "string", "Expected EventCode to be of type 'string'")
end

--  
function M.EventCode(str)
	asserts.AssertEventCode(str)
	return str
end

function asserts.AssertMonitoringState(str)
	assert(str)
	assert(type(str) == "string", "Expected MonitoringState to be of type 'string'")
end

--  
function M.MonitoringState(str)
	asserts.AssertMonitoringState(str)
	return str
end

function asserts.AssertMoveStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected MoveStatus to be of type 'string'")
end

--  
function M.MoveStatus(str)
	asserts.AssertMoveStatus(str)
	return str
end

function asserts.AssertSubnetCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected SubnetCidrBlockStateCode to be of type 'string'")
end

--  
function M.SubnetCidrBlockStateCode(str)
	asserts.AssertSubnetCidrBlockStateCode(str)
	return str
end

function asserts.AssertRouteState(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteState to be of type 'string'")
end

--  
function M.RouteState(str)
	asserts.AssertRouteState(str)
	return str
end

function asserts.AssertVpcCidrBlockStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcCidrBlockStateCode to be of type 'string'")
end

--  
function M.VpcCidrBlockStateCode(str)
	asserts.AssertVpcCidrBlockStateCode(str)
	return str
end

function asserts.AssertStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected Status to be of type 'string'")
end

--  
function M.Status(str)
	asserts.AssertStatus(str)
	return str
end

function asserts.AssertEventType(str)
	assert(str)
	assert(type(str) == "string", "Expected EventType to be of type 'string'")
end

--  
function M.EventType(str)
	asserts.AssertEventType(str)
	return str
end

function asserts.AssertServiceState(str)
	assert(str)
	assert(type(str) == "string", "Expected ServiceState to be of type 'string'")
end

--  
function M.ServiceState(str)
	asserts.AssertServiceState(str)
	return str
end

function asserts.AssertVolumeState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeState to be of type 'string'")
end

--  
function M.VolumeState(str)
	asserts.AssertVolumeState(str)
	return str
end

function asserts.Assertscope(str)
	assert(str)
	assert(type(str) == "string", "Expected scope to be of type 'string'")
end

--  
function M.scope(str)
	asserts.Assertscope(str)
	return str
end

function asserts.AssertFleetEventType(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetEventType to be of type 'string'")
end

--  
function M.FleetEventType(str)
	asserts.AssertFleetEventType(str)
	return str
end

function asserts.AssertVpcEndpointType(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcEndpointType to be of type 'string'")
end

--  
function M.VpcEndpointType(str)
	asserts.AssertVpcEndpointType(str)
	return str
end

function asserts.AssertFleetIdentifier(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetIdentifier to be of type 'string'")
end

--  
function M.FleetIdentifier(str)
	asserts.AssertFleetIdentifier(str)
	return str
end

function asserts.AssertConnectionNotificationState(str)
	assert(str)
	assert(type(str) == "string", "Expected ConnectionNotificationState to be of type 'string'")
end

--  
function M.ConnectionNotificationState(str)
	asserts.AssertConnectionNotificationState(str)
	return str
end

function asserts.AssertImageTypeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageTypeValues to be of type 'string'")
end

--  
function M.ImageTypeValues(str)
	asserts.AssertImageTypeValues(str)
	return str
end

function asserts.AssertLaunchTemplateName(str)
	assert(str)
	assert(type(str) == "string", "Expected LaunchTemplateName to be of type 'string'")
	assert(#str <= 128, "Expected string to be max 128 characters")
	assert(#str >= 3, "Expected string to be min 3 characters")
end

--  
function M.LaunchTemplateName(str)
	asserts.AssertLaunchTemplateName(str)
	return str
end

function asserts.AssertSpotAllocationStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotAllocationStrategy to be of type 'string'")
end

--  
function M.SpotAllocationStrategy(str)
	asserts.AssertSpotAllocationStrategy(str)
	return str
end

function asserts.AssertResetFpgaImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ResetFpgaImageAttributeName to be of type 'string'")
end

--  
function M.ResetFpgaImageAttributeName(str)
	asserts.AssertResetFpgaImageAttributeName(str)
	return str
end

function asserts.AssertReportStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportStatusType to be of type 'string'")
end

--  
function M.ReportStatusType(str)
	asserts.AssertReportStatusType(str)
	return str
end

function asserts.AssertInstanceLifecycleType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceLifecycleType to be of type 'string'")
end

--  
function M.InstanceLifecycleType(str)
	asserts.AssertInstanceLifecycleType(str)
	return str
end

function asserts.AssertSpotInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceType to be of type 'string'")
end

--  
function M.SpotInstanceType(str)
	asserts.AssertSpotInstanceType(str)
	return str
end

function asserts.AssertReservedInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservedInstanceState to be of type 'string'")
end

--  
function M.ReservedInstanceState(str)
	asserts.AssertReservedInstanceState(str)
	return str
end

function asserts.AssertFleetStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetStateCode to be of type 'string'")
end

--  
function M.FleetStateCode(str)
	asserts.AssertFleetStateCode(str)
	return str
end

function asserts.AssertNextToken(str)
	assert(str)
	assert(type(str) == "string", "Expected NextToken to be of type 'string'")
	assert(#str <= 1024, "Expected string to be max 1024 characters")
	assert(#str >= 1, "Expected string to be min 1 characters")
end

--  
function M.NextToken(str)
	asserts.AssertNextToken(str)
	return str
end

function asserts.AssertUnsuccessfulInstanceCreditSpecificationErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected UnsuccessfulInstanceCreditSpecificationErrorCode to be of type 'string'")
end

--  
function M.UnsuccessfulInstanceCreditSpecificationErrorCode(str)
	asserts.AssertUnsuccessfulInstanceCreditSpecificationErrorCode(str)
	return str
end

function asserts.AssertVpcPeeringConnectionStateReasonCode(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcPeeringConnectionStateReasonCode to be of type 'string'")
end

--  
function M.VpcPeeringConnectionStateReasonCode(str)
	asserts.AssertVpcPeeringConnectionStateReasonCode(str)
	return str
end

function asserts.AssertSnapshotState(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotState to be of type 'string'")
end

--  
function M.SnapshotState(str)
	asserts.AssertSnapshotState(str)
	return str
end

function asserts.AssertDeleteFleetErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected DeleteFleetErrorCode to be of type 'string'")
end

--  
function M.DeleteFleetErrorCode(str)
	asserts.AssertDeleteFleetErrorCode(str)
	return str
end

function asserts.AssertFleetType(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetType to be of type 'string'")
end

--  
function M.FleetType(str)
	asserts.AssertFleetType(str)
	return str
end

function asserts.AssertVirtualizationType(str)
	assert(str)
	assert(type(str) == "string", "Expected VirtualizationType to be of type 'string'")
end

--  
function M.VirtualizationType(str)
	asserts.AssertVirtualizationType(str)
	return str
end

function asserts.AssertString(str)
	assert(str)
	assert(type(str) == "string", "Expected String to be of type 'string'")
end

--  
function M.String(str)
	asserts.AssertString(str)
	return str
end

function asserts.AssertFpgaImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected FpgaImageAttributeName to be of type 'string'")
end

--  
function M.FpgaImageAttributeName(str)
	asserts.AssertFpgaImageAttributeName(str)
	return str
end

function asserts.AssertListingStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingStatus to be of type 'string'")
end

--  
function M.ListingStatus(str)
	asserts.AssertListingStatus(str)
	return str
end

function asserts.AssertInstanceMatchCriteria(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceMatchCriteria to be of type 'string'")
end

--  
function M.InstanceMatchCriteria(str)
	asserts.AssertInstanceMatchCriteria(str)
	return str
end

function asserts.AssertNetworkInterfaceAttribute(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceAttribute to be of type 'string'")
end

--  
function M.NetworkInterfaceAttribute(str)
	asserts.AssertNetworkInterfaceAttribute(str)
	return str
end

function asserts.AssertVersionDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected VersionDescription to be of type 'string'")
	assert(#str <= 255, "Expected string to be max 255 characters")
end

--  
function M.VersionDescription(str)
	asserts.AssertVersionDescription(str)
	return str
end

function asserts.AssertBatchState(str)
	assert(str)
	assert(type(str) == "string", "Expected BatchState to be of type 'string'")
end

--  
function M.BatchState(str)
	asserts.AssertBatchState(str)
	return str
end

function asserts.AssertNetworkInterfaceType(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceType to be of type 'string'")
end

--  
function M.NetworkInterfaceType(str)
	asserts.AssertNetworkInterfaceType(str)
	return str
end

function asserts.AssertVolumeAttachmentState(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttachmentState to be of type 'string'")
end

--  
function M.VolumeAttachmentState(str)
	asserts.AssertVolumeAttachmentState(str)
	return str
end

function asserts.AssertShutdownBehavior(str)
	assert(str)
	assert(type(str) == "string", "Expected ShutdownBehavior to be of type 'string'")
end

--  
function M.ShutdownBehavior(str)
	asserts.AssertShutdownBehavior(str)
	return str
end

function asserts.AssertInstanceAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceAttributeName to be of type 'string'")
end

--  
function M.InstanceAttributeName(str)
	asserts.AssertInstanceAttributeName(str)
	return str
end

function asserts.AssertDefaultTargetCapacityType(str)
	assert(str)
	assert(type(str) == "string", "Expected DefaultTargetCapacityType to be of type 'string'")
end

--  
function M.DefaultTargetCapacityType(str)
	asserts.AssertDefaultTargetCapacityType(str)
	return str
end

function asserts.AssertActivityStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ActivityStatus to be of type 'string'")
end

--  
function M.ActivityStatus(str)
	asserts.AssertActivityStatus(str)
	return str
end

function asserts.AssertPaymentOption(str)
	assert(str)
	assert(type(str) == "string", "Expected PaymentOption to be of type 'string'")
end

--  
function M.PaymentOption(str)
	asserts.AssertPaymentOption(str)
	return str
end

function asserts.AssertVolumeType(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeType to be of type 'string'")
end

--  
function M.VolumeType(str)
	asserts.AssertVolumeType(str)
	return str
end

function asserts.AssertSpotInstanceState(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceState to be of type 'string'")
end

--  
function M.SpotInstanceState(str)
	asserts.AssertSpotInstanceState(str)
	return str
end

function asserts.AssertInstanceType(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceType to be of type 'string'")
end

--  
function M.InstanceType(str)
	asserts.AssertInstanceType(str)
	return str
end

function asserts.AssertCancelBatchErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelBatchErrorCode to be of type 'string'")
end

--  
function M.CancelBatchErrorCode(str)
	asserts.AssertCancelBatchErrorCode(str)
	return str
end

function asserts.AssertImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageAttributeName to be of type 'string'")
end

--  
function M.ImageAttributeName(str)
	asserts.AssertImageAttributeName(str)
	return str
end

function asserts.AssertBundleTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected BundleTaskState to be of type 'string'")
end

--  
function M.BundleTaskState(str)
	asserts.AssertBundleTaskState(str)
	return str
end

function asserts.AssertAvailabilityZoneState(str)
	assert(str)
	assert(type(str) == "string", "Expected AvailabilityZoneState to be of type 'string'")
end

--  
function M.AvailabilityZoneState(str)
	asserts.AssertAvailabilityZoneState(str)
	return str
end

function asserts.AssertHostTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected HostTenancy to be of type 'string'")
end

--  
function M.HostTenancy(str)
	asserts.AssertHostTenancy(str)
	return str
end

function asserts.AssertPermissionGroup(str)
	assert(str)
	assert(type(str) == "string", "Expected PermissionGroup to be of type 'string'")
end

--  
function M.PermissionGroup(str)
	asserts.AssertPermissionGroup(str)
	return str
end

function asserts.AssertDomainType(str)
	assert(str)
	assert(type(str) == "string", "Expected DomainType to be of type 'string'")
end

--  
function M.DomainType(str)
	asserts.AssertDomainType(str)
	return str
end

function asserts.AssertInterfacePermissionType(str)
	assert(str)
	assert(type(str) == "string", "Expected InterfacePermissionType to be of type 'string'")
end

--  
function M.InterfacePermissionType(str)
	asserts.AssertInterfacePermissionType(str)
	return str
end

function asserts.AssertRecurringChargeFrequency(str)
	assert(str)
	assert(type(str) == "string", "Expected RecurringChargeFrequency to be of type 'string'")
end

--  
function M.RecurringChargeFrequency(str)
	asserts.AssertRecurringChargeFrequency(str)
	return str
end

function asserts.AssertCancelSpotInstanceRequestState(str)
	assert(str)
	assert(type(str) == "string", "Expected CancelSpotInstanceRequestState to be of type 'string'")
end

--  
function M.CancelSpotInstanceRequestState(str)
	asserts.AssertCancelSpotInstanceRequestState(str)
	return str
end

function asserts.AssertArchitectureValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ArchitectureValues to be of type 'string'")
end

--  
function M.ArchitectureValues(str)
	asserts.AssertArchitectureValues(str)
	return str
end

function asserts.AssertPrincipalType(str)
	assert(str)
	assert(type(str) == "string", "Expected PrincipalType to be of type 'string'")
end

--  
function M.PrincipalType(str)
	asserts.AssertPrincipalType(str)
	return str
end

function asserts.AssertServiceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ServiceType to be of type 'string'")
end

--  
function M.ServiceType(str)
	asserts.AssertServiceType(str)
	return str
end

function asserts.AssertInstanceHealthStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceHealthStatus to be of type 'string'")
end

--  
function M.InstanceHealthStatus(str)
	asserts.AssertInstanceHealthStatus(str)
	return str
end

function asserts.AssertAllocationState(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationState to be of type 'string'")
end

--  
function M.AllocationState(str)
	asserts.AssertAllocationState(str)
	return str
end

function asserts.AssertIamInstanceProfileAssociationState(str)
	assert(str)
	assert(type(str) == "string", "Expected IamInstanceProfileAssociationState to be of type 'string'")
end

--  
function M.IamInstanceProfileAssociationState(str)
	asserts.AssertIamInstanceProfileAssociationState(str)
	return str
end

function asserts.AssertResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected ResourceType to be of type 'string'")
end

--  
function M.ResourceType(str)
	asserts.AssertResourceType(str)
	return str
end

function asserts.AssertOfferingClassType(str)
	assert(str)
	assert(type(str) == "string", "Expected OfferingClassType to be of type 'string'")
end

--  
function M.OfferingClassType(str)
	asserts.AssertOfferingClassType(str)
	return str
end

function asserts.AssertSummaryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected SummaryStatus to be of type 'string'")
end

--  
function M.SummaryStatus(str)
	asserts.AssertSummaryStatus(str)
	return str
end

function asserts.AssertHypervisorType(str)
	assert(str)
	assert(type(str) == "string", "Expected HypervisorType to be of type 'string'")
end

--  
function M.HypervisorType(str)
	asserts.AssertHypervisorType(str)
	return str
end

function asserts.AssertSnapshotAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected SnapshotAttributeName to be of type 'string'")
end

--  
function M.SnapshotAttributeName(str)
	asserts.AssertSnapshotAttributeName(str)
	return str
end

function asserts.AssertCapacityReservationInstancePlatform(str)
	assert(str)
	assert(type(str) == "string", "Expected CapacityReservationInstancePlatform to be of type 'string'")
end

--  
function M.CapacityReservationInstancePlatform(str)
	asserts.AssertCapacityReservationInstancePlatform(str)
	return str
end

function asserts.AssertLogDestinationType(str)
	assert(str)
	assert(type(str) == "string", "Expected LogDestinationType to be of type 'string'")
end

--  
function M.LogDestinationType(str)
	asserts.AssertLogDestinationType(str)
	return str
end

function asserts.AssertByoipCidrState(str)
	assert(str)
	assert(type(str) == "string", "Expected ByoipCidrState to be of type 'string'")
end

--  
function M.ByoipCidrState(str)
	asserts.AssertByoipCidrState(str)
	return str
end

function asserts.AssertFleetOnDemandAllocationStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetOnDemandAllocationStrategy to be of type 'string'")
end

--  
function M.FleetOnDemandAllocationStrategy(str)
	asserts.AssertFleetOnDemandAllocationStrategy(str)
	return str
end

function asserts.AssertExcessCapacityTerminationPolicy(str)
	assert(str)
	assert(type(str) == "string", "Expected ExcessCapacityTerminationPolicy to be of type 'string'")
end

--  
function M.ExcessCapacityTerminationPolicy(str)
	asserts.AssertExcessCapacityTerminationPolicy(str)
	return str
end

function asserts.AssertAccountAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected AccountAttributeName to be of type 'string'")
end

--  
function M.AccountAttributeName(str)
	asserts.AssertAccountAttributeName(str)
	return str
end

function asserts.AssertOnDemandAllocationStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected OnDemandAllocationStrategy to be of type 'string'")
end

--  
function M.OnDemandAllocationStrategy(str)
	asserts.AssertOnDemandAllocationStrategy(str)
	return str
end

function asserts.AssertTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected Tenancy to be of type 'string'")
end

--  
function M.Tenancy(str)
	asserts.AssertTenancy(str)
	return str
end

function asserts.AssertNetworkInterfaceStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfaceStatus to be of type 'string'")
end

--  
function M.NetworkInterfaceStatus(str)
	asserts.AssertNetworkInterfaceStatus(str)
	return str
end

function asserts.AssertVolumeStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusName to be of type 'string'")
end

--  
function M.VolumeStatusName(str)
	asserts.AssertVolumeStatusName(str)
	return str
end

function asserts.AssertVolumeStatusInfoStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeStatusInfoStatus to be of type 'string'")
end

--  
function M.VolumeStatusInfoStatus(str)
	asserts.AssertVolumeStatusInfoStatus(str)
	return str
end

function asserts.AssertDeviceType(str)
	assert(str)
	assert(type(str) == "string", "Expected DeviceType to be of type 'string'")
end

--  
function M.DeviceType(str)
	asserts.AssertDeviceType(str)
	return str
end

function asserts.AssertOperationType(str)
	assert(str)
	assert(type(str) == "string", "Expected OperationType to be of type 'string'")
end

--  
function M.OperationType(str)
	asserts.AssertOperationType(str)
	return str
end

function asserts.AssertResetImageAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected ResetImageAttributeName to be of type 'string'")
end

--  
function M.ResetImageAttributeName(str)
	asserts.AssertResetImageAttributeName(str)
	return str
end

function asserts.AssertFpgaImageStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected FpgaImageStateCode to be of type 'string'")
end

--  
function M.FpgaImageStateCode(str)
	asserts.AssertFpgaImageStateCode(str)
	return str
end

function asserts.AssertInstanceStateName(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceStateName to be of type 'string'")
end

--  
function M.InstanceStateName(str)
	asserts.AssertInstanceStateName(str)
	return str
end

function asserts.AssertStatusName(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusName to be of type 'string'")
end

--  
function M.StatusName(str)
	asserts.AssertStatusName(str)
	return str
end

function asserts.AssertDiskImageFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected DiskImageFormat to be of type 'string'")
end

--  
function M.DiskImageFormat(str)
	asserts.AssertDiskImageFormat(str)
	return str
end

function asserts.AssertPlacementStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected PlacementStrategy to be of type 'string'")
end

--  
function M.PlacementStrategy(str)
	asserts.AssertPlacementStrategy(str)
	return str
end

function asserts.AssertProductCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected ProductCodeValues to be of type 'string'")
end

--  
function M.ProductCodeValues(str)
	asserts.AssertProductCodeValues(str)
	return str
end

function asserts.AssertRuleAction(str)
	assert(str)
	assert(type(str) == "string", "Expected RuleAction to be of type 'string'")
end

--  
function M.RuleAction(str)
	asserts.AssertRuleAction(str)
	return str
end

function asserts.AssertGatewayType(str)
	assert(str)
	assert(type(str) == "string", "Expected GatewayType to be of type 'string'")
end

--  
function M.GatewayType(str)
	asserts.AssertGatewayType(str)
	return str
end

function asserts.AssertCurrencyCodeValues(str)
	assert(str)
	assert(type(str) == "string", "Expected CurrencyCodeValues to be of type 'string'")
end

--  
function M.CurrencyCodeValues(str)
	asserts.AssertCurrencyCodeValues(str)
	return str
end

function asserts.AssertCapacityReservationState(str)
	assert(str)
	assert(type(str) == "string", "Expected CapacityReservationState to be of type 'string'")
end

--  
function M.CapacityReservationState(str)
	asserts.AssertCapacityReservationState(str)
	return str
end

function asserts.AssertVpcAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcAttributeName to be of type 'string'")
end

--  
function M.VpcAttributeName(str)
	asserts.AssertVpcAttributeName(str)
	return str
end

function asserts.AssertReservationState(str)
	assert(str)
	assert(type(str) == "string", "Expected ReservationState to be of type 'string'")
end

--  
function M.ReservationState(str)
	asserts.AssertReservationState(str)
	return str
end

function asserts.AssertPlatformValues(str)
	assert(str)
	assert(type(str) == "string", "Expected PlatformValues to be of type 'string'")
end

--  
function M.PlatformValues(str)
	asserts.AssertPlatformValues(str)
	return str
end

function asserts.AssertFleetActivityStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetActivityStatus to be of type 'string'")
end

--  
function M.FleetActivityStatus(str)
	asserts.AssertFleetActivityStatus(str)
	return str
end

function asserts.AssertAllocationStrategy(str)
	assert(str)
	assert(type(str) == "string", "Expected AllocationStrategy to be of type 'string'")
end

--  
function M.AllocationStrategy(str)
	asserts.AssertAllocationStrategy(str)
	return str
end

function asserts.AssertExportEnvironment(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportEnvironment to be of type 'string'")
end

--  
function M.ExportEnvironment(str)
	asserts.AssertExportEnvironment(str)
	return str
end

function asserts.AssertTelemetryStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected TelemetryStatus to be of type 'string'")
end

--  
function M.TelemetryStatus(str)
	asserts.AssertTelemetryStatus(str)
	return str
end

function asserts.AssertAttachmentStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected AttachmentStatus to be of type 'string'")
end

--  
function M.AttachmentStatus(str)
	asserts.AssertAttachmentStatus(str)
	return str
end

function asserts.AssertCapacityReservationTenancy(str)
	assert(str)
	assert(type(str) == "string", "Expected CapacityReservationTenancy to be of type 'string'")
end

--  
function M.CapacityReservationTenancy(str)
	asserts.AssertCapacityReservationTenancy(str)
	return str
end

function asserts.AssertDatafeedSubscriptionState(str)
	assert(str)
	assert(type(str) == "string", "Expected DatafeedSubscriptionState to be of type 'string'")
end

--  
function M.DatafeedSubscriptionState(str)
	asserts.AssertDatafeedSubscriptionState(str)
	return str
end

function asserts.AssertElasticGpuStatus(str)
	assert(str)
	assert(type(str) == "string", "Expected ElasticGpuStatus to be of type 'string'")
end

--  
function M.ElasticGpuStatus(str)
	asserts.AssertElasticGpuStatus(str)
	return str
end

function asserts.AssertNetworkInterfacePermissionStateCode(str)
	assert(str)
	assert(type(str) == "string", "Expected NetworkInterfacePermissionStateCode to be of type 'string'")
end

--  
function M.NetworkInterfacePermissionStateCode(str)
	asserts.AssertNetworkInterfacePermissionStateCode(str)
	return str
end

function asserts.AssertVolumeAttributeName(str)
	assert(str)
	assert(type(str) == "string", "Expected VolumeAttributeName to be of type 'string'")
end

--  
function M.VolumeAttributeName(str)
	asserts.AssertVolumeAttributeName(str)
	return str
end

function asserts.AssertTrafficType(str)
	assert(str)
	assert(type(str) == "string", "Expected TrafficType to be of type 'string'")
end

--  
function M.TrafficType(str)
	asserts.AssertTrafficType(str)
	return str
end

function asserts.AssertContainerFormat(str)
	assert(str)
	assert(type(str) == "string", "Expected ContainerFormat to be of type 'string'")
end

--  
function M.ContainerFormat(str)
	asserts.AssertContainerFormat(str)
	return str
end

function asserts.AssertListingState(str)
	assert(str)
	assert(type(str) == "string", "Expected ListingState to be of type 'string'")
end

--  
function M.ListingState(str)
	asserts.AssertListingState(str)
	return str
end

function asserts.AssertVpnStaticRouteSource(str)
	assert(str)
	assert(type(str) == "string", "Expected VpnStaticRouteSource to be of type 'string'")
end

--  
function M.VpnStaticRouteSource(str)
	asserts.AssertVpnStaticRouteSource(str)
	return str
end

function asserts.AssertImageState(str)
	assert(str)
	assert(type(str) == "string", "Expected ImageState to be of type 'string'")
end

--  
function M.ImageState(str)
	asserts.AssertImageState(str)
	return str
end

function asserts.AssertElasticGpuState(str)
	assert(str)
	assert(type(str) == "string", "Expected ElasticGpuState to be of type 'string'")
end

--  
function M.ElasticGpuState(str)
	asserts.AssertElasticGpuState(str)
	return str
end

function asserts.AssertCapacityReservationPreference(str)
	assert(str)
	assert(type(str) == "string", "Expected CapacityReservationPreference to be of type 'string'")
end

--  
function M.CapacityReservationPreference(str)
	asserts.AssertCapacityReservationPreference(str)
	return str
end

function asserts.AssertInstanceInterruptionBehavior(str)
	assert(str)
	assert(type(str) == "string", "Expected InstanceInterruptionBehavior to be of type 'string'")
end

--  
function M.InstanceInterruptionBehavior(str)
	asserts.AssertInstanceInterruptionBehavior(str)
	return str
end

function asserts.AssertMarketType(str)
	assert(str)
	assert(type(str) == "string", "Expected MarketType to be of type 'string'")
end

--  
function M.MarketType(str)
	asserts.AssertMarketType(str)
	return str
end

function asserts.AssertSpotInstanceInterruptionBehavior(str)
	assert(str)
	assert(type(str) == "string", "Expected SpotInstanceInterruptionBehavior to be of type 'string'")
end

--  
function M.SpotInstanceInterruptionBehavior(str)
	asserts.AssertSpotInstanceInterruptionBehavior(str)
	return str
end

function asserts.AssertNatGatewayState(str)
	assert(str)
	assert(type(str) == "string", "Expected NatGatewayState to be of type 'string'")
end

--  
function M.NatGatewayState(str)
	asserts.AssertNatGatewayState(str)
	return str
end

function asserts.AssertRIProductDescription(str)
	assert(str)
	assert(type(str) == "string", "Expected RIProductDescription to be of type 'string'")
end

--  
function M.RIProductDescription(str)
	asserts.AssertRIProductDescription(str)
	return str
end

function asserts.AssertLaunchTemplateErrorCode(str)
	assert(str)
	assert(type(str) == "string", "Expected LaunchTemplateErrorCode to be of type 'string'")
end

--  
function M.LaunchTemplateErrorCode(str)
	asserts.AssertLaunchTemplateErrorCode(str)
	return str
end

function asserts.AssertAffinity(str)
	assert(str)
	assert(type(str) == "string", "Expected Affinity to be of type 'string'")
end

--  
function M.Affinity(str)
	asserts.AssertAffinity(str)
	return str
end

function asserts.AssertEndDateType(str)
	assert(str)
	assert(type(str) == "string", "Expected EndDateType to be of type 'string'")
end

--  
function M.EndDateType(str)
	asserts.AssertEndDateType(str)
	return str
end

function asserts.AssertFlowLogsResourceType(str)
	assert(str)
	assert(type(str) == "string", "Expected FlowLogsResourceType to be of type 'string'")
end

--  
function M.FlowLogsResourceType(str)
	asserts.AssertFlowLogsResourceType(str)
	return str
end

function asserts.AssertFleetExcessCapacityTerminationPolicy(str)
	assert(str)
	assert(type(str) == "string", "Expected FleetExcessCapacityTerminationPolicy to be of type 'string'")
end

--  
function M.FleetExcessCapacityTerminationPolicy(str)
	asserts.AssertFleetExcessCapacityTerminationPolicy(str)
	return str
end

function asserts.AssertStatusType(str)
	assert(str)
	assert(type(str) == "string", "Expected StatusType to be of type 'string'")
end

--  
function M.StatusType(str)
	asserts.AssertStatusType(str)
	return str
end

function asserts.AssertExportTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ExportTaskState to be of type 'string'")
end

--  
function M.ExportTaskState(str)
	asserts.AssertExportTaskState(str)
	return str
end

function asserts.AssertConnectionNotificationType(str)
	assert(str)
	assert(type(str) == "string", "Expected ConnectionNotificationType to be of type 'string'")
end

--  
function M.ConnectionNotificationType(str)
	asserts.AssertConnectionNotificationType(str)
	return str
end

function asserts.AssertVpcState(str)
	assert(str)
	assert(type(str) == "string", "Expected VpcState to be of type 'string'")
end

--  
function M.VpcState(str)
	asserts.AssertVpcState(str)
	return str
end

function asserts.AssertReportInstanceReasonCodes(str)
	assert(str)
	assert(type(str) == "string", "Expected ReportInstanceReasonCodes to be of type 'string'")
end

--  
function M.ReportInstanceReasonCodes(str)
	asserts.AssertReportInstanceReasonCodes(str)
	return str
end

function asserts.AssertConversionTaskState(str)
	assert(str)
	assert(type(str) == "string", "Expected ConversionTaskState to be of type 'string'")
end

--  
function M.ConversionTaskState(str)
	asserts.AssertConversionTaskState(str)
	return str
end

function asserts.AssertAutoPlacement(str)
	assert(str)
	assert(type(str) == "string", "Expected AutoPlacement to be of type 'string'")
end

--  
function M.AutoPlacement(str)
	asserts.AssertAutoPlacement(str)
	return str
end

function asserts.AssertRouteOrigin(str)
	assert(str)
	assert(type(str) == "string", "Expected RouteOrigin to be of type 'string'")
end

--  
function M.RouteOrigin(str)
	asserts.AssertRouteOrigin(str)
	return str
end

function asserts.AssertFloat(float)
	assert(float)
	assert(type(float) == "number", "Expected Float to be of type 'number'")
end

function M.Float(float)
	asserts.AssertFloat(float)
	return float
end

function asserts.AssertDouble(double)
	assert(double)
	assert(type(double) == "number", "Expected Double to be of type 'number'")
end

function M.Double(double)
	asserts.AssertDouble(double)
	return double
end

function asserts.AssertLong(long)
	assert(long)
	assert(type(long) == "number", "Expected Long to be of type 'number'")
	assert(long % 1 == 0, "Expected a whole integer number")
end

function M.Long(long)
	asserts.AssertLong(long)
	return long
end

function asserts.AssertPoolMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected PoolMaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 10, "Expected integer to be max 10")
	assert(integer >= 1, "Expected integer to be min 1")
end

function M.PoolMaxResults(integer)
	asserts.AssertPoolMaxResults(integer)
	return integer
end

function asserts.AssertInteger(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected Integer to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
end

function M.Integer(integer)
	asserts.AssertInteger(integer)
	return integer
end

function asserts.AssertMaxResults(integer)
	assert(integer)
	assert(type(integer) == "number", "Expected MaxResults to be of type 'number'")
	assert(integer % 1 == 0, "Expected a while integer number")
	assert(integer <= 255, "Expected integer to be max 255")
	assert(integer >= 5, "Expected integer to be min 5")
end

function M.MaxResults(integer)
	asserts.AssertMaxResults(integer)
	return integer
end

function asserts.AssertBoolean(boolean)
	assert(boolean)
	assert(type(boolean) == "boolean", "Expected Boolean to be of type 'boolean'")
end

function M.Boolean(boolean)
	asserts.AssertBoolean(boolean)
	return boolean
end

function asserts.AssertDateTime(timestamp)
	assert(timestamp)
	assert(type(timestamp) == "string", "Expected DateTime to be of type 'string'")
end

function M.DateTime(timestamp)
	asserts.AssertDateTime(timestamp)
	return timestamp
end

function asserts.AssertBlob(blob)
	assert(blob)
	assert(type(blob) == "string", "Expected Blob to be of type 'string'")
end

function M.Blob(blob)
	asserts.AssertBlob(blob)
	return blob
end

function asserts.AssertOccurrenceDaySet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDaySet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDaySet(list)
	asserts.AssertOccurrenceDaySet(list)
	return list
end

function asserts.AssertInstanceStatusEventList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusEventList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatusEvent(v)
	end
end

--  
-- List of InstanceStatusEvent objects
function M.InstanceStatusEventList(list)
	asserts.AssertInstanceStatusEventList(list)
	return list
end

function asserts.AssertInstanceStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatusDetails(v)
	end
end

--  
-- List of InstanceStatusDetails objects
function M.InstanceStatusDetailsList(list)
	asserts.AssertInstanceStatusDetailsList(list)
	return list
end

function asserts.AssertVpcCidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcCidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcCidrBlockAssociation(v)
	end
end

--  
-- List of VpcCidrBlockAssociation objects
function M.VpcCidrBlockAssociationSet(list)
	asserts.AssertVpcCidrBlockAssociationSet(list)
	return list
end

function asserts.AssertResponseHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdSet(list)
	asserts.AssertResponseHostIdSet(list)
	return list
end

function asserts.AssertReservedInstancesModificationResultList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationResultList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesModificationResult(v)
	end
end

--  
-- List of ReservedInstancesModificationResult objects
function M.ReservedInstancesModificationResultList(list)
	asserts.AssertReservedInstancesModificationResultList(list)
	return list
end

function asserts.AssertDnsEntrySet(list)
	assert(list)
	assert(type(list) == "table", "Expected DnsEntrySet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDnsEntry(v)
	end
end

--  
-- List of DnsEntry objects
function M.DnsEntrySet(list)
	asserts.AssertDnsEntrySet(list)
	return list
end

function asserts.AssertPriceScheduleList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPriceSchedule(v)
	end
end

--  
-- List of PriceSchedule objects
function M.PriceScheduleList(list)
	asserts.AssertPriceScheduleList(list)
	return list
end

function asserts.AssertTargetReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTargetReservationValue(v)
	end
end

--  
-- List of TargetReservationValue objects
function M.TargetReservationValueSet(list)
	asserts.AssertTargetReservationValueSet(list)
	return list
end

function asserts.AssertUnsuccessfulItemSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemSet(list)
	asserts.AssertUnsuccessfulItemSet(list)
	return list
end

function asserts.AssertRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRoute(v)
	end
end

--  
-- List of Route objects
function M.RouteList(list)
	asserts.AssertRouteList(list)
	return list
end

function asserts.AssertGroupIds(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIds to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIds(list)
	asserts.AssertGroupIds(list)
	return list
end

function asserts.AssertTagSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTagSpecification(v)
	end
end

--  
-- List of TagSpecification objects
function M.TagSpecificationList(list)
	asserts.AssertTagSpecificationList(list)
	return list
end

function asserts.AssertSubnetList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSubnet(v)
	end
end

--  
-- List of Subnet objects
function M.SubnetList(list)
	asserts.AssertSubnetList(list)
	return list
end

function asserts.AssertNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterface(v)
	end
end

--  
-- List of NetworkInterface objects
function M.NetworkInterfaceList(list)
	asserts.AssertNetworkInterfaceList(list)
	return list
end

function asserts.AssertLaunchTemplateOverridesList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateOverridesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateOverrides(v)
	end
end

--  
-- List of LaunchTemplateOverrides objects
function M.LaunchTemplateOverridesList(list)
	asserts.AssertLaunchTemplateOverridesList(list)
	return list
end

function asserts.AssertIpv6RangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6RangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpv6Range(v)
	end
end

--  
-- List of Ipv6Range objects
function M.Ipv6RangeList(list)
	asserts.AssertIpv6RangeList(list)
	return list
end

function asserts.AssertScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.ScheduledInstanceSet(list)
	asserts.AssertScheduledInstanceSet(list)
	return list
end

function asserts.AssertPurchaseSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPurchase(v)
	end
end

--  
-- List of Purchase objects
function M.PurchaseSet(list)
	asserts.AssertPurchaseSet(list)
	return list
end

function asserts.AssertImportInstanceVolumeDetailSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportInstanceVolumeDetailSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportInstanceVolumeDetailItem(v)
	end
end

--  
-- List of ImportInstanceVolumeDetailItem objects
function M.ImportInstanceVolumeDetailSet(list)
	asserts.AssertImportInstanceVolumeDetailSet(list)
	return list
end

function asserts.AssertPricingDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected PricingDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPricingDetail(v)
	end
end

--  
-- List of PricingDetail objects
function M.PricingDetailsList(list)
	asserts.AssertPricingDetailsList(list)
	return list
end

function asserts.AssertPlacementGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPlacementGroup(v)
	end
end

--  
-- List of PlacementGroup objects
function M.PlacementGroupList(list)
	asserts.AssertPlacementGroupList(list)
	return list
end

function asserts.AssertVpcAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcAttachment(v)
	end
end

--  
-- List of VpcAttachment objects
function M.VpcAttachmentList(list)
	asserts.AssertVpcAttachmentList(list)
	return list
end

function asserts.AssertNetworkInterfacePermissionIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfacePermissionIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.NetworkInterfacePermissionIdList(list)
	asserts.AssertNetworkInterfacePermissionIdList(list)
	return list
end

function asserts.AssertDiskImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected DiskImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDiskImage(v)
	end
end

--  
-- List of DiskImage objects
function M.DiskImageList(list)
	asserts.AssertDiskImageList(list)
	return list
end

function asserts.AssertSecurityGroupList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityGroup(v)
	end
end

--  
-- List of SecurityGroup objects
function M.SecurityGroupList(list)
	asserts.AssertSecurityGroupList(list)
	return list
end

function asserts.AssertReservedInstancesModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesModification(v)
	end
end

--  
-- List of ReservedInstancesModification objects
function M.ReservedInstancesModificationList(list)
	asserts.AssertReservedInstancesModificationList(list)
	return list
end

function asserts.AssertGroupIdentifierSet(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdentifierSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityGroupIdentifier(v)
	end
end

--  
-- List of SecurityGroupIdentifier objects
function M.GroupIdentifierSet(list)
	asserts.AssertGroupIdentifierSet(list)
	return list
end

function asserts.AssertIpRangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpRange(v)
	end
end

--  
-- List of IpRange objects
function M.IpRangeList(list)
	asserts.AssertIpRangeList(list)
	return list
end

function asserts.AssertRestorableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RestorableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RestorableByStringList(list)
	asserts.AssertRestorableByStringList(list)
	return list
end

function asserts.AssertPublicIpv4PoolRangeSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PublicIpv4PoolRangeSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPublicIpv4PoolRange(v)
	end
end

--  
-- List of PublicIpv4PoolRange objects
function M.PublicIpv4PoolRangeSet(list)
	asserts.AssertPublicIpv4PoolRangeSet(list)
	return list
end

function asserts.AssertCustomerGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCustomerGateway(v)
	end
end

--  
-- List of CustomerGateway objects
function M.CustomerGatewayList(list)
	asserts.AssertCustomerGatewayList(list)
	return list
end

function asserts.AssertNatGatewayAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNatGatewayAddress(v)
	end
end

--  
-- List of NatGatewayAddress objects
function M.NatGatewayAddressList(list)
	asserts.AssertNatGatewayAddressList(list)
	return list
end

function asserts.AssertNetworkAclList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAcl(v)
	end
end

--  
-- List of NetworkAcl objects
function M.NetworkAclList(list)
	asserts.AssertNetworkAclList(list)
	return list
end

function asserts.AssertImportImageTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportImageTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportImageTask(v)
	end
end

--  
-- List of ImportImageTask objects
function M.ImportImageTaskList(list)
	asserts.AssertImportImageTaskList(list)
	return list
end

function asserts.AssertLaunchTemplateTagSpecificationRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateTagSpecificationRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateTagSpecificationRequest(v)
	end
end

--  
-- List of LaunchTemplateTagSpecificationRequest objects
function M.LaunchTemplateTagSpecificationRequestList(list)
	asserts.AssertLaunchTemplateTagSpecificationRequestList(list)
	return list
end

function asserts.AssertInstanceIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceIpv6Address(v)
	end
end

--  
-- List of InstanceIpv6Address objects
function M.InstanceIpv6AddressList(list)
	asserts.AssertInstanceIpv6AddressList(list)
	return list
end

function asserts.AssertPropagatingVgwList(list)
	assert(list)
	assert(type(list) == "table", "Expected PropagatingVgwList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPropagatingVgw(v)
	end
end

--  
-- List of PropagatingVgw objects
function M.PropagatingVgwList(list)
	asserts.AssertPropagatingVgwList(list)
	return list
end

function asserts.AssertBlockDeviceMappingRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingRequestList(list)
	asserts.AssertBlockDeviceMappingRequestList(list)
	return list
end

function asserts.AssertElasticGpuSpecificationResponseList(list)
	assert(list)
	assert(type(list) == "table", "Expected ElasticGpuSpecificationResponseList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertElasticGpuSpecificationResponse(v)
	end
end

--  
-- List of ElasticGpuSpecificationResponse objects
function M.ElasticGpuSpecificationResponseList(list)
	asserts.AssertElasticGpuSpecificationResponseList(list)
	return list
end

function asserts.AssertNewDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NewDhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNewDhcpConfiguration(v)
	end
end

--  
-- List of NewDhcpConfiguration objects
function M.NewDhcpConfigurationList(list)
	asserts.AssertNewDhcpConfigurationList(list)
	return list
end

function asserts.AssertVolumeStatusActionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusActionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusAction(v)
	end
end

--  
-- List of VolumeStatusAction objects
function M.VolumeStatusActionsList(list)
	asserts.AssertVolumeStatusActionsList(list)
	return list
end

function asserts.AssertAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAddress(v)
	end
end

--  
-- List of Address objects
function M.AddressList(list)
	asserts.AssertAddressList(list)
	return list
end

function asserts.AssertInternetGatewayAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInternetGatewayAttachment(v)
	end
end

--  
-- List of InternetGatewayAttachment objects
function M.InternetGatewayAttachmentList(list)
	asserts.AssertInternetGatewayAttachmentList(list)
	return list
end

function asserts.AssertFilterList(list)
	assert(list)
	assert(type(list) == "table", "Expected FilterList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFilter(v)
	end
end

--  
-- List of Filter objects
function M.FilterList(list)
	asserts.AssertFilterList(list)
	return list
end

function asserts.AssertInstanceMonitoringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceMonitoringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceMonitoring(v)
	end
end

--  
-- List of InstanceMonitoring objects
function M.InstanceMonitoringList(list)
	asserts.AssertInstanceMonitoringList(list)
	return list
end

function asserts.AssertUnsuccessfulItemList(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulItemList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUnsuccessfulItem(v)
	end
end

--  
-- List of UnsuccessfulItem objects
function M.UnsuccessfulItemList(list)
	asserts.AssertUnsuccessfulItemList(list)
	return list
end

function asserts.AssertImportSnapshotTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportSnapshotTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImportSnapshotTask(v)
	end
end

--  
-- List of ImportSnapshotTask objects
function M.ImportSnapshotTaskList(list)
	asserts.AssertImportSnapshotTaskList(list)
	return list
end

function asserts.AssertCapacityReservationIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CapacityReservationIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.CapacityReservationIdSet(list)
	asserts.AssertCapacityReservationIdSet(list)
	return list
end

function asserts.AssertCancelSpotFleetRequestsErrorSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsErrorSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelSpotFleetRequestsErrorItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsErrorItem objects
function M.CancelSpotFleetRequestsErrorSet(list)
	asserts.AssertCancelSpotFleetRequestsErrorSet(list)
	return list
end

function asserts.AssertSubnetIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSubnetIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of SubnetIpv6CidrBlockAssociation objects
function M.SubnetIpv6CidrBlockAssociationSet(list)
	asserts.AssertSubnetIpv6CidrBlockAssociationSet(list)
	return list
end

function asserts.AssertOwnerStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected OwnerStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.OwnerStringList(list)
	asserts.AssertOwnerStringList(list)
	return list
end

function asserts.AssertVpcEndpointConnectionSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcEndpointConnectionSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcEndpointConnection(v)
	end
end

--  
-- List of VpcEndpointConnection objects
function M.VpcEndpointConnectionSet(list)
	asserts.AssertVpcEndpointConnectionSet(list)
	return list
end

function asserts.AssertFleetSet(list)
	assert(list)
	assert(type(list) == "table", "Expected FleetSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFleetData(v)
	end
end

--  
-- List of FleetData objects
function M.FleetSet(list)
	asserts.AssertFleetSet(list)
	return list
end

function asserts.AssertFleetLaunchTemplateConfigList(list)
	assert(list)
	assert(type(list) == "table", "Expected FleetLaunchTemplateConfigList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFleetLaunchTemplateConfig(v)
	end
end

--  
-- List of FleetLaunchTemplateConfig objects
function M.FleetLaunchTemplateConfigList(list)
	asserts.AssertFleetLaunchTemplateConfigList(list)
	return list
end

function asserts.AssertEgressOnlyInternetGatewayIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEgressOnlyInternetGatewayId(v)
	end
end

--  
-- List of EgressOnlyInternetGatewayId objects
function M.EgressOnlyInternetGatewayIdList(list)
	asserts.AssertEgressOnlyInternetGatewayIdList(list)
	return list
end

function asserts.AssertElasticGpuIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ElasticGpuIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ElasticGpuIdSet(list)
	asserts.AssertElasticGpuIdSet(list)
	return list
end

function asserts.AssertInstanceCountList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceCountList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCount(v)
	end
end

--  
-- List of InstanceCount objects
function M.InstanceCountList(list)
	asserts.AssertInstanceCountList(list)
	return list
end

function asserts.AssertImportTaskIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImportTaskIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImportTaskIdList(list)
	asserts.AssertImportTaskIdList(list)
	return list
end

function asserts.AssertZoneNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ZoneNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ZoneNameStringList(list)
	asserts.AssertZoneNameStringList(list)
	return list
end

function asserts.AssertGroupIdentifierList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdentifierList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertGroupIdentifier(v)
	end
end

--  
-- List of GroupIdentifier objects
function M.GroupIdentifierList(list)
	asserts.AssertGroupIdentifierList(list)
	return list
end

function asserts.AssertBillingProductList(list)
	assert(list)
	assert(type(list) == "table", "Expected BillingProductList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.BillingProductList(list)
	asserts.AssertBillingProductList(list)
	return list
end

function asserts.AssertSecurityGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupStringList(list)
	asserts.AssertSecurityGroupStringList(list)
	return list
end

function asserts.AssertLaunchSpecsList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchSpecsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotFleetLaunchSpecification(v)
	end
end

--  
-- List of SpotFleetLaunchSpecification objects
function M.LaunchSpecsList(list)
	asserts.AssertLaunchSpecsList(list)
	return list
end

function asserts.AssertSpotInstanceRequestIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SpotInstanceRequestIdList(list)
	asserts.AssertSpotInstanceRequestIdList(list)
	return list
end

function asserts.AssertLaunchTemplateConfigList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateConfigList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateConfig(v)
	end
end

--  
-- List of LaunchTemplateConfig objects
function M.LaunchTemplateConfigList(list)
	asserts.AssertLaunchTemplateConfigList(list)
	return list
end

function asserts.AssertTunnelOptionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected TunnelOptionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnTunnelOptionsSpecification(v)
	end
end

--  
-- List of VpnTunnelOptionsSpecification objects
function M.TunnelOptionsList(list)
	asserts.AssertTunnelOptionsList(list)
	return list
end

function asserts.AssertDeleteFleetSuccessSet(list)
	assert(list)
	assert(type(list) == "table", "Expected DeleteFleetSuccessSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDeleteFleetSuccessItem(v)
	end
end

--  
-- List of DeleteFleetSuccessItem objects
function M.DeleteFleetSuccessSet(list)
	asserts.AssertDeleteFleetSuccessSet(list)
	return list
end

function asserts.AssertPurchaseRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchaseRequestSet to be of type ''table")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertPurchaseRequest(v)
	end
end

--  
-- List of PurchaseRequest objects
function M.PurchaseRequestSet(list)
	asserts.AssertPurchaseRequestSet(list)
	return list
end

function asserts.AssertImageIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ImageIdStringList(list)
	asserts.AssertImageIdStringList(list)
	return list
end

function asserts.AssertCancelledSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelledSpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelledSpotInstanceRequest(v)
	end
end

--  
-- List of CancelledSpotInstanceRequest objects
function M.CancelledSpotInstanceRequestList(list)
	asserts.AssertCancelledSpotInstanceRequestList(list)
	return list
end

function asserts.AssertDhcpOptionsIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.DhcpOptionsIdStringList(list)
	asserts.AssertDhcpOptionsIdStringList(list)
	return list
end

function asserts.AssertVolumeStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusItem(v)
	end
end

--  
-- List of VolumeStatusItem objects
function M.VolumeStatusList(list)
	asserts.AssertVolumeStatusList(list)
	return list
end

function asserts.AssertTagDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTagDescription(v)
	end
end

--  
-- List of TagDescription objects
function M.TagDescriptionList(list)
	asserts.AssertTagDescriptionList(list)
	return list
end

function asserts.AssertImageDiskContainerList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageDiskContainerList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImageDiskContainer(v)
	end
end

--  
-- List of ImageDiskContainer objects
function M.ImageDiskContainerList(list)
	asserts.AssertImageDiskContainerList(list)
	return list
end

function asserts.AssertNetworkInterfacePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfacePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterfacePrivateIpAddress(v)
	end
end

--  
-- List of NetworkInterfacePrivateIpAddress objects
function M.NetworkInterfacePrivateIpAddressList(list)
	asserts.AssertNetworkInterfacePrivateIpAddressList(list)
	return list
end

function asserts.AssertHostReservationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostReservation(v)
	end
end

--  
-- List of HostReservation objects
function M.HostReservationSet(list)
	asserts.AssertHostReservationSet(list)
	return list
end

function asserts.AssertNetworkAclEntryList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclEntryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAclEntry(v)
	end
end

--  
-- List of NetworkAclEntry objects
function M.NetworkAclEntryList(list)
	asserts.AssertNetworkAclEntryList(list)
	return list
end

function asserts.AssertRequestHostIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdSet(list)
	asserts.AssertRequestHostIdSet(list)
	return list
end

function asserts.AssertProductCodeStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductCodeStringList(list)
	asserts.AssertProductCodeStringList(list)
	return list
end

function asserts.AssertReservedInstancesOfferingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesOffering(v)
	end
end

--  
-- List of ReservedInstancesOffering objects
function M.ReservedInstancesOfferingList(list)
	asserts.AssertReservedInstancesOfferingList(list)
	return list
end

function asserts.AssertInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstance(v)
	end
end

--  
-- List of Instance objects
function M.InstanceList(list)
	asserts.AssertInstanceList(list)
	return list
end

function asserts.AssertVpcClassicLinkIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcClassicLinkIdList(list)
	asserts.AssertVpcClassicLinkIdList(list)
	return list
end

function asserts.AssertVolumeIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VolumeIdStringList(list)
	asserts.AssertVolumeIdStringList(list)
	return list
end

function asserts.AssertInstanceBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceBlockDeviceMapping(v)
	end
end

--  
-- List of InstanceBlockDeviceMapping objects
function M.InstanceBlockDeviceMappingList(list)
	asserts.AssertInstanceBlockDeviceMappingList(list)
	return list
end

function asserts.AssertResourceList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResourceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResourceList(list)
	asserts.AssertResourceList(list)
	return list
end

function asserts.AssertUserGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserGroupStringList(list)
	asserts.AssertUserGroupStringList(list)
	return list
end

function asserts.AssertExportTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertExportTask(v)
	end
end

--  
-- List of ExportTask objects
function M.ExportTaskList(list)
	asserts.AssertExportTaskList(list)
	return list
end

function asserts.AssertVolumeList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolume(v)
	end
end

--  
-- List of Volume objects
function M.VolumeList(list)
	asserts.AssertVolumeList(list)
	return list
end

function asserts.AssertRegionList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRegion(v)
	end
end

--  
-- List of Region objects
function M.RegionList(list)
	asserts.AssertRegionList(list)
	return list
end

function asserts.AssertVolumeModificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeModificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeModification(v)
	end
end

--  
-- List of VolumeModification objects
function M.VolumeModificationList(list)
	asserts.AssertVolumeModificationList(list)
	return list
end

function asserts.AssertResponseHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResponseHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResponseHostIdList(list)
	asserts.AssertResponseHostIdList(list)
	return list
end

function asserts.AssertVpcPeeringConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcPeeringConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcPeeringConnection(v)
	end
end

--  
-- List of VpcPeeringConnection objects
function M.VpcPeeringConnectionList(list)
	asserts.AssertVpcPeeringConnectionList(list)
	return list
end

function asserts.AssertScheduledInstancesBlockDeviceMappingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesBlockDeviceMappingSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesBlockDeviceMapping(v)
	end
end

--  
-- List of ScheduledInstancesBlockDeviceMapping objects
function M.ScheduledInstancesBlockDeviceMappingSet(list)
	asserts.AssertScheduledInstancesBlockDeviceMappingSet(list)
	return list
end

function asserts.AssertFpgaImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFpgaImage(v)
	end
end

--  
-- List of FpgaImage objects
function M.FpgaImageList(list)
	asserts.AssertFpgaImageList(list)
	return list
end

function asserts.AssertBundleTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBundleTask(v)
	end
end

--  
-- List of BundleTask objects
function M.BundleTaskList(list)
	asserts.AssertBundleTaskList(list)
	return list
end

function asserts.AssertUnsuccessfulInstanceCreditSpecificationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UnsuccessfulInstanceCreditSpecificationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUnsuccessfulInstanceCreditSpecificationItem(v)
	end
end

--  
-- List of UnsuccessfulInstanceCreditSpecificationItem objects
function M.UnsuccessfulInstanceCreditSpecificationSet(list)
	asserts.AssertUnsuccessfulInstanceCreditSpecificationSet(list)
	return list
end

function asserts.AssertHistoryRecordSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HistoryRecordSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHistoryRecordEntry(v)
	end
end

--  
-- List of HistoryRecordEntry objects
function M.HistoryRecordSet(list)
	asserts.AssertHistoryRecordSet(list)
	return list
end

function asserts.AssertVpcEndpointSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcEndpointSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcEndpoint(v)
	end
end

--  
-- List of VpcEndpoint objects
function M.VpcEndpointSet(list)
	asserts.AssertVpcEndpointSet(list)
	return list
end

function asserts.AssertAvailabilityZoneMessageList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneMessageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAvailabilityZoneMessage(v)
	end
end

--  
-- List of AvailabilityZoneMessage objects
function M.AvailabilityZoneMessageList(list)
	asserts.AssertAvailabilityZoneMessageList(list)
	return list
end

function asserts.AssertVpnConnectionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnConnectionIdStringList(list)
	asserts.AssertVpnConnectionIdStringList(list)
	return list
end

function asserts.AssertHistoryRecords(list)
	assert(list)
	assert(type(list) == "table", "Expected HistoryRecords to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHistoryRecord(v)
	end
end

--  
-- List of HistoryRecord objects
function M.HistoryRecords(list)
	asserts.AssertHistoryRecords(list)
	return list
end

function asserts.AssertInstanceStateChangeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStateChangeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStateChange(v)
	end
end

--  
-- List of InstanceStateChange objects
function M.InstanceStateChangeList(list)
	asserts.AssertInstanceStateChangeList(list)
	return list
end

function asserts.AssertFleetLaunchTemplateOverridesList(list)
	assert(list)
	assert(type(list) == "table", "Expected FleetLaunchTemplateOverridesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFleetLaunchTemplateOverrides(v)
	end
end

--  
-- List of FleetLaunchTemplateOverrides objects
function M.FleetLaunchTemplateOverridesList(list)
	asserts.AssertFleetLaunchTemplateOverridesList(list)
	return list
end

function asserts.AssertHostList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHost(v)
	end
end

--  
-- List of Host objects
function M.HostList(list)
	asserts.AssertHostList(list)
	return list
end

function asserts.AssertPrivateIpAddressStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrivateIpAddressStringList(list)
	asserts.AssertPrivateIpAddressStringList(list)
	return list
end

function asserts.AssertNetworkInterfaceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.NetworkInterfaceIdList(list)
	asserts.AssertNetworkInterfaceIdList(list)
	return list
end

function asserts.AssertPurchasedScheduledInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PurchasedScheduledInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstance(v)
	end
end

--  
-- List of ScheduledInstance objects
function M.PurchasedScheduledInstanceSet(list)
	asserts.AssertPurchasedScheduledInstanceSet(list)
	return list
end

function asserts.AssertKeyNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.KeyNameStringList(list)
	asserts.AssertKeyNameStringList(list)
	return list
end

function asserts.AssertBundleIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected BundleIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.BundleIdStringList(list)
	asserts.AssertBundleIdStringList(list)
	return list
end

function asserts.AssertInstanceIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdStringList(list)
	asserts.AssertInstanceIdStringList(list)
	return list
end

function asserts.AssertStaleSecurityGroupSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleSecurityGroupSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStaleSecurityGroup(v)
	end
end

--  
-- List of StaleSecurityGroup objects
function M.StaleSecurityGroupSet(list)
	asserts.AssertStaleSecurityGroupSet(list)
	return list
end

function asserts.AssertSubnetIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SubnetIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SubnetIdStringList(list)
	asserts.AssertSubnetIdStringList(list)
	return list
end

function asserts.AssertSpotPriceHistoryList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotPriceHistoryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotPrice(v)
	end
end

--  
-- List of SpotPrice objects
function M.SpotPriceHistoryList(list)
	asserts.AssertSpotPriceHistoryList(list)
	return list
end

function asserts.AssertRouteTableList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRouteTable(v)
	end
end

--  
-- List of RouteTable objects
function M.RouteTableList(list)
	asserts.AssertRouteTableList(list)
	return list
end

function asserts.AssertIdFormatList(list)
	assert(list)
	assert(type(list) == "table", "Expected IdFormatList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIdFormat(v)
	end
end

--  
-- List of IdFormat objects
function M.IdFormatList(list)
	asserts.AssertIdFormatList(list)
	return list
end

function asserts.AssertRequestHostIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected RequestHostIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RequestHostIdList(list)
	asserts.AssertRequestHostIdList(list)
	return list
end

function asserts.AssertLaunchTemplateBlockDeviceMappingRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateBlockDeviceMappingRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateBlockDeviceMappingRequest(v)
	end
end

--  
-- List of LaunchTemplateBlockDeviceMappingRequest objects
function M.LaunchTemplateBlockDeviceMappingRequestList(list)
	asserts.AssertLaunchTemplateBlockDeviceMappingRequestList(list)
	return list
end

function asserts.AssertServiceConfigurationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ServiceConfigurationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertServiceConfiguration(v)
	end
end

--  
-- List of ServiceConfiguration objects
function M.ServiceConfigurationSet(list)
	asserts.AssertServiceConfigurationSet(list)
	return list
end

function asserts.AssertKeyPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected KeyPairList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertKeyPairInfo(v)
	end
end

--  
-- List of KeyPairInfo objects
function M.KeyPairList(list)
	asserts.AssertKeyPairList(list)
	return list
end

function asserts.AssertPrincipalIdFormatList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrincipalIdFormatList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrincipalIdFormat(v)
	end
end

--  
-- List of PrincipalIdFormat objects
function M.PrincipalIdFormatList(list)
	asserts.AssertPrincipalIdFormatList(list)
	return list
end

function asserts.AssertScheduledInstancesSecurityGroupIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesSecurityGroupIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstancesSecurityGroupIdSet(list)
	asserts.AssertScheduledInstancesSecurityGroupIdSet(list)
	return list
end

function asserts.AssertPriceScheduleSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PriceScheduleSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPriceScheduleSpecification(v)
	end
end

--  
-- List of PriceScheduleSpecification objects
function M.PriceScheduleSpecificationList(list)
	asserts.AssertPriceScheduleSpecificationList(list)
	return list
end

function asserts.AssertSnapshotIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SnapshotIdStringList(list)
	asserts.AssertSnapshotIdStringList(list)
	return list
end

function asserts.AssertCancelSpotFleetRequestsSuccessSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CancelSpotFleetRequestsSuccessSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCancelSpotFleetRequestsSuccessItem(v)
	end
end

--  
-- List of CancelSpotFleetRequestsSuccessItem objects
function M.CancelSpotFleetRequestsSuccessSet(list)
	asserts.AssertCancelSpotFleetRequestsSuccessSet(list)
	return list
end

function asserts.AssertAvailabilityZoneList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailabilityZoneList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAvailabilityZone(v)
	end
end

--  
-- List of AvailabilityZone objects
function M.AvailabilityZoneList(list)
	asserts.AssertAvailabilityZoneList(list)
	return list
end

function asserts.AssertPublicIpv4PoolSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PublicIpv4PoolSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPublicIpv4Pool(v)
	end
end

--  
-- List of PublicIpv4Pool objects
function M.PublicIpv4PoolSet(list)
	asserts.AssertPublicIpv4PoolSet(list)
	return list
end

function asserts.AssertServiceTypeDetailSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ServiceTypeDetailSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertServiceTypeDetail(v)
	end
end

--  
-- List of ServiceTypeDetail objects
function M.ServiceTypeDetailSet(list)
	asserts.AssertServiceTypeDetailSet(list)
	return list
end

function asserts.AssertFlowLogSet(list)
	assert(list)
	assert(type(list) == "table", "Expected FlowLogSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFlowLog(v)
	end
end

--  
-- List of FlowLog objects
function M.FlowLogSet(list)
	asserts.AssertFlowLogSet(list)
	return list
end

function asserts.AssertDhcpConfigurationValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAttributeValue(v)
	end
end

--  
-- List of AttributeValue objects
function M.DhcpConfigurationValueList(list)
	asserts.AssertDhcpConfigurationValueList(list)
	return list
end

function asserts.AssertImageList(list)
	assert(list)
	assert(type(list) == "table", "Expected ImageList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertImage(v)
	end
end

--  
-- List of Image objects
function M.ImageList(list)
	asserts.AssertImageList(list)
	return list
end

function asserts.AssertConnectionNotificationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ConnectionNotificationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertConnectionNotification(v)
	end
end

--  
-- List of ConnectionNotification objects
function M.ConnectionNotificationSet(list)
	asserts.AssertConnectionNotificationSet(list)
	return list
end

function asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateInstanceNetworkInterfaceSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecification(v)
	end
end

--  
-- List of LaunchTemplateInstanceNetworkInterfaceSpecification objects
function M.LaunchTemplateInstanceNetworkInterfaceSpecificationList(list)
	asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationList(list)
	return list
end

function asserts.AssertRecurringChargesList(list)
	assert(list)
	assert(type(list) == "table", "Expected RecurringChargesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRecurringCharge(v)
	end
end

--  
-- List of RecurringCharge objects
function M.RecurringChargesList(list)
	asserts.AssertRecurringChargesList(list)
	return list
end

function asserts.AssertAllowedPrincipalSet(list)
	assert(list)
	assert(type(list) == "table", "Expected AllowedPrincipalSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAllowedPrincipal(v)
	end
end

--  
-- List of AllowedPrincipal objects
function M.AllowedPrincipalSet(list)
	asserts.AssertAllowedPrincipalSet(list)
	return list
end

function asserts.AssertFleetIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected FleetIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertFleetIdentifier(v)
	end
end

--  
-- List of FleetIdentifier objects
function M.FleetIdSet(list)
	asserts.AssertFleetIdSet(list)
	return list
end

function asserts.AssertLoadPermissionListRequest(list)
	assert(list)
	assert(type(list) == "table", "Expected LoadPermissionListRequest to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLoadPermissionRequest(v)
	end
end

--  
-- List of LoadPermissionRequest objects
function M.LoadPermissionListRequest(list)
	asserts.AssertLoadPermissionListRequest(list)
	return list
end

function asserts.AssertHostReservationIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostReservationIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.HostReservationIdSet(list)
	asserts.AssertHostReservationIdSet(list)
	return list
end

function asserts.AssertServiceDetailSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ServiceDetailSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertServiceDetail(v)
	end
end

--  
-- List of ServiceDetail objects
function M.ServiceDetailSet(list)
	asserts.AssertServiceDetailSet(list)
	return list
end

function asserts.AssertClassicLinkInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertClassicLinkInstance(v)
	end
end

--  
-- List of ClassicLinkInstance objects
function M.ClassicLinkInstanceList(list)
	asserts.AssertClassicLinkInstanceList(list)
	return list
end

function asserts.AssertVpcClassicLinkList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcClassicLinkList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcClassicLink(v)
	end
end

--  
-- List of VpcClassicLink objects
function M.VpcClassicLinkList(list)
	asserts.AssertVpcClassicLinkList(list)
	return list
end

function asserts.AssertVersionStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VersionStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VersionStringList(list)
	asserts.AssertVersionStringList(list)
	return list
end

function asserts.AssertSpotFleetRequestConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotFleetRequestConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotFleetRequestConfig(v)
	end
end

--  
-- List of SpotFleetRequestConfig objects
function M.SpotFleetRequestConfigSet(list)
	asserts.AssertSpotFleetRequestConfigSet(list)
	return list
end

function asserts.AssertTagList(list)
	assert(list)
	assert(type(list) == "table", "Expected TagList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTag(v)
	end
end

--  
-- List of Tag objects
function M.TagList(list)
	asserts.AssertTagList(list)
	return list
end

function asserts.AssertPrivateIpAddressConfigSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressConfigSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesPrivateIpAddressConfig(v)
	end
end

--  
-- List of ScheduledInstancesPrivateIpAddressConfig objects
function M.PrivateIpAddressConfigSet(list)
	asserts.AssertPrivateIpAddressConfigSet(list)
	return list
end

function asserts.AssertTargetGroups(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetGroups to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertTargetGroup(v)
	end
end

--  
-- List of TargetGroup objects
function M.TargetGroups(list)
	asserts.AssertTargetGroups(list)
	return list
end

function asserts.AssertInstanceTypeList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceTypeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceType(v)
	end
end

--  
-- List of InstanceType objects
function M.InstanceTypeList(list)
	asserts.AssertInstanceTypeList(list)
	return list
end

function asserts.AssertDhcpConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDhcpConfiguration(v)
	end
end

--  
-- List of DhcpConfiguration objects
function M.DhcpConfigurationList(list)
	asserts.AssertDhcpConfigurationList(list)
	return list
end

function asserts.AssertSuccessfulInstanceCreditSpecificationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected SuccessfulInstanceCreditSpecificationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSuccessfulInstanceCreditSpecificationItem(v)
	end
end

--  
-- List of SuccessfulInstanceCreditSpecificationItem objects
function M.SuccessfulInstanceCreditSpecificationSet(list)
	asserts.AssertSuccessfulInstanceCreditSpecificationSet(list)
	return list
end

function asserts.AssertNetworkAclAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkAclAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkAclAssociation(v)
	end
end

--  
-- List of NetworkAclAssociation objects
function M.NetworkAclAssociationList(list)
	asserts.AssertNetworkAclAssociationList(list)
	return list
end

function asserts.AssertCapacityReservationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CapacityReservationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCapacityReservation(v)
	end
end

--  
-- List of CapacityReservation objects
function M.CapacityReservationSet(list)
	asserts.AssertCapacityReservationSet(list)
	return list
end

function asserts.AssertExportTaskIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExportTaskIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExportTaskIdStringList(list)
	asserts.AssertExportTaskIdStringList(list)
	return list
end

function asserts.AssertUserIdGroupPairSet(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairSet(list)
	asserts.AssertUserIdGroupPairSet(list)
	return list
end

function asserts.AssertInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.InstanceIdSet(list)
	asserts.AssertInstanceIdSet(list)
	return list
end

function asserts.AssertAccountAttributeList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttribute(v)
	end
end

--  
-- List of AccountAttribute objects
function M.AccountAttributeList(list)
	asserts.AssertAccountAttributeList(list)
	return list
end

function asserts.AssertInstanceIpv6AddressListRequest(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceIpv6AddressListRequest to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceIpv6AddressRequest(v)
	end
end

--  
-- List of InstanceIpv6AddressRequest objects
function M.InstanceIpv6AddressListRequest(list)
	asserts.AssertInstanceIpv6AddressListRequest(list)
	return list
end

function asserts.AssertDescribeConversionTaskList(list)
	assert(list)
	assert(type(list) == "table", "Expected DescribeConversionTaskList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertConversionTask(v)
	end
end

--  
-- List of ConversionTask objects
function M.DescribeConversionTaskList(list)
	asserts.AssertDescribeConversionTaskList(list)
	return list
end

function asserts.AssertReasonCodesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReasonCodesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReportInstanceReasonCodes(v)
	end
end

--  
-- List of ReportInstanceReasonCodes objects
function M.ReasonCodesList(list)
	asserts.AssertReasonCodesList(list)
	return list
end

function asserts.AssertAccountAttributeValueList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeValueList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttributeValue(v)
	end
end

--  
-- List of AccountAttributeValue objects
function M.AccountAttributeValueList(list)
	asserts.AssertAccountAttributeValueList(list)
	return list
end

function asserts.AssertInstanceCreditSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceCreditSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCreditSpecification(v)
	end
end

--  
-- List of InstanceCreditSpecification objects
function M.InstanceCreditSpecificationList(list)
	asserts.AssertInstanceCreditSpecificationList(list)
	return list
end

function asserts.AssertReservedInstanceIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstanceIdSet(list)
	asserts.AssertReservedInstanceIdSet(list)
	return list
end

function asserts.AssertSpotFleetTagSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotFleetTagSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotFleetTagSpecification(v)
	end
end

--  
-- List of SpotFleetTagSpecification objects
function M.SpotFleetTagSpecificationList(list)
	asserts.AssertSpotFleetTagSpecificationList(list)
	return list
end

function asserts.AssertLoadPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected LoadPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLoadPermission(v)
	end
end

--  
-- List of LoadPermission objects
function M.LoadPermissionList(list)
	asserts.AssertLoadPermissionList(list)
	return list
end

function asserts.AssertInstanceNetworkInterfaceList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceNetworkInterface(v)
	end
end

--  
-- List of InstanceNetworkInterface objects
function M.InstanceNetworkInterfaceList(list)
	asserts.AssertInstanceNetworkInterfaceList(list)
	return list
end

function asserts.AssertAssociationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AssociationIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.AssociationIdList(list)
	asserts.AssertAssociationIdList(list)
	return list
end

function asserts.AssertLaunchTemplateSet(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplate(v)
	end
end

--  
-- List of LaunchTemplate objects
function M.LaunchTemplateSet(list)
	asserts.AssertLaunchTemplateSet(list)
	return list
end

function asserts.AssertDhcpOptionsList(list)
	assert(list)
	assert(type(list) == "table", "Expected DhcpOptionsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDhcpOptions(v)
	end
end

--  
-- List of DhcpOptions objects
function M.DhcpOptionsList(list)
	asserts.AssertDhcpOptionsList(list)
	return list
end

function asserts.AssertElasticGpuSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ElasticGpuSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertElasticGpus(v)
	end
end

--  
-- List of ElasticGpus objects
function M.ElasticGpuSet(list)
	asserts.AssertElasticGpuSet(list)
	return list
end

function asserts.AssertEgressOnlyInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected EgressOnlyInternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertEgressOnlyInternetGateway(v)
	end
end

--  
-- List of EgressOnlyInternetGateway objects
function M.EgressOnlyInternetGatewayList(list)
	asserts.AssertEgressOnlyInternetGatewayList(list)
	return list
end

function asserts.AssertExecutableByStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ExecutableByStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ExecutableByStringList(list)
	asserts.AssertExecutableByStringList(list)
	return list
end

function asserts.AssertByoipCidrSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ByoipCidrSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertByoipCidr(v)
	end
end

--  
-- List of ByoipCidr objects
function M.ByoipCidrSet(list)
	asserts.AssertByoipCidrSet(list)
	return list
end

function asserts.AssertRouteTableAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected RouteTableAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertRouteTableAssociation(v)
	end
end

--  
-- List of RouteTableAssociation objects
function M.RouteTableAssociationList(list)
	asserts.AssertRouteTableAssociationList(list)
	return list
end

function asserts.AssertLaunchTemplateNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateName(v)
	end
end

--  
-- List of LaunchTemplateName objects
function M.LaunchTemplateNameStringList(list)
	asserts.AssertLaunchTemplateNameStringList(list)
	return list
end

function asserts.AssertInternetGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected InternetGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInternetGateway(v)
	end
end

--  
-- List of InternetGateway objects
function M.InternetGatewayList(list)
	asserts.AssertInternetGatewayList(list)
	return list
end

function asserts.AssertPublicIpStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PublicIpStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PublicIpStringList(list)
	asserts.AssertPublicIpStringList(list)
	return list
end

function asserts.AssertProductCodeList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductCodeList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertProductCode(v)
	end
end

--  
-- List of ProductCode objects
function M.ProductCodeList(list)
	asserts.AssertProductCodeList(list)
	return list
end

function asserts.AssertScheduledInstancesNetworkInterfaceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesNetworkInterfaceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesNetworkInterface(v)
	end
end

--  
-- List of ScheduledInstancesNetworkInterface objects
function M.ScheduledInstancesNetworkInterfaceSet(list)
	asserts.AssertScheduledInstancesNetworkInterfaceSet(list)
	return list
end

function asserts.AssertLaunchTemplateVersionSet(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateVersionSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateVersion(v)
	end
end

--  
-- List of LaunchTemplateVersion objects
function M.LaunchTemplateVersionSet(list)
	asserts.AssertLaunchTemplateVersionSet(list)
	return list
end

function asserts.AssertReservedInstancesConfigurationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesConfigurationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesConfiguration(v)
	end
end

--  
-- List of ReservedInstancesConfiguration objects
function M.ReservedInstancesConfigurationList(list)
	asserts.AssertReservedInstancesConfigurationList(list)
	return list
end

function asserts.AssertPrefixListIdSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PrefixListIdSet(list)
	asserts.AssertPrefixListIdSet(list)
	return list
end

function asserts.AssertSnapshotDetailList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotDetailList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSnapshotDetail(v)
	end
end

--  
-- List of SnapshotDetail objects
function M.SnapshotDetailList(list)
	asserts.AssertSnapshotDetailList(list)
	return list
end

function asserts.AssertNatGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected NatGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNatGateway(v)
	end
end

--  
-- List of NatGateway objects
function M.NatGatewayList(list)
	asserts.AssertNatGatewayList(list)
	return list
end

function asserts.AssertConversionIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ConversionIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ConversionIdStringList(list)
	asserts.AssertConversionIdStringList(list)
	return list
end

function asserts.AssertVpnStaticRouteList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnStaticRouteList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnStaticRoute(v)
	end
end

--  
-- List of VpnStaticRoute objects
function M.VpnStaticRouteList(list)
	asserts.AssertVpnStaticRouteList(list)
	return list
end

function asserts.AssertFpgaImageIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected FpgaImageIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.FpgaImageIdList(list)
	asserts.AssertFpgaImageIdList(list)
	return list
end

function asserts.AssertInstanceNetworkInterfaceSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceNetworkInterfaceSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceNetworkInterfaceSpecification(v)
	end
end

--  
-- List of InstanceNetworkInterfaceSpecification objects
function M.InstanceNetworkInterfaceSpecificationList(list)
	asserts.AssertInstanceNetworkInterfaceSpecificationList(list)
	return list
end

function asserts.AssertDeleteFleetErrorSet(list)
	assert(list)
	assert(type(list) == "table", "Expected DeleteFleetErrorSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDeleteFleetErrorItem(v)
	end
end

--  
-- List of DeleteFleetErrorItem objects
function M.DeleteFleetErrorSet(list)
	asserts.AssertDeleteFleetErrorSet(list)
	return list
end

function asserts.AssertElasticGpuSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ElasticGpuSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertElasticGpuSpecification(v)
	end
end

--  
-- List of ElasticGpuSpecification objects
function M.ElasticGpuSpecificationList(list)
	asserts.AssertElasticGpuSpecificationList(list)
	return list
end

function asserts.AssertReservedInstancesIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesIdStringList(list)
	asserts.AssertReservedInstancesIdStringList(list)
	return list
end

function asserts.AssertInstanceBlockDeviceMappingSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceBlockDeviceMappingSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceBlockDeviceMappingSpecification(v)
	end
end

--  
-- List of InstanceBlockDeviceMappingSpecification objects
function M.InstanceBlockDeviceMappingSpecificationList(list)
	asserts.AssertInstanceBlockDeviceMappingSpecificationList(list)
	return list
end

function asserts.AssertReservedInstancesOfferingIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesOfferingIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesOfferingIdStringList(list)
	asserts.AssertReservedInstancesOfferingIdStringList(list)
	return list
end

function asserts.AssertTargetConfigurationRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected TargetConfigurationRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertTargetConfigurationRequest(v)
	end
end

--  
-- List of TargetConfigurationRequest objects
function M.TargetConfigurationRequestSet(list)
	asserts.AssertTargetConfigurationRequestSet(list)
	return list
end

function asserts.AssertUserIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.UserIdStringList(list)
	asserts.AssertUserIdStringList(list)
	return list
end

function asserts.AssertLaunchPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchPermission(v)
	end
end

--  
-- List of LaunchPermission objects
function M.LaunchPermissionList(list)
	asserts.AssertLaunchPermissionList(list)
	return list
end

function asserts.AssertRegionNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected RegionNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.RegionNameStringList(list)
	asserts.AssertRegionNameStringList(list)
	return list
end

function asserts.AssertUserIdGroupPairList(list)
	assert(list)
	assert(type(list) == "table", "Expected UserIdGroupPairList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertUserIdGroupPair(v)
	end
end

--  
-- List of UserIdGroupPair objects
function M.UserIdGroupPairList(list)
	asserts.AssertUserIdGroupPairList(list)
	return list
end

function asserts.AssertNetworkInterfacePermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfacePermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterfacePermission(v)
	end
end

--  
-- List of NetworkInterfacePermission objects
function M.NetworkInterfacePermissionList(list)
	asserts.AssertNetworkInterfacePermissionList(list)
	return list
end

function asserts.AssertVpcIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpcIdStringList(list)
	asserts.AssertVpcIdStringList(list)
	return list
end

function asserts.AssertStaleIpPermissionSet(list)
	assert(list)
	assert(type(list) == "table", "Expected StaleIpPermissionSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertStaleIpPermission(v)
	end
end

--  
-- List of StaleIpPermission objects
function M.StaleIpPermissionSet(list)
	asserts.AssertStaleIpPermissionSet(list)
	return list
end

function asserts.AssertResourceIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected ResourceIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ResourceIdList(list)
	asserts.AssertResourceIdList(list)
	return list
end

function asserts.AssertSnapshotList(list)
	assert(list)
	assert(type(list) == "table", "Expected SnapshotList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSnapshot(v)
	end
end

--  
-- List of Snapshot objects
function M.SnapshotList(list)
	asserts.AssertSnapshotList(list)
	return list
end

function asserts.AssertPrefixListSet(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrefixList(v)
	end
end

--  
-- List of PrefixList objects
function M.PrefixListSet(list)
	asserts.AssertPrefixListSet(list)
	return list
end

function asserts.AssertMovingAddressStatusSet(list)
	assert(list)
	assert(type(list) == "table", "Expected MovingAddressStatusSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertMovingAddressStatus(v)
	end
end

--  
-- List of MovingAddressStatus objects
function M.MovingAddressStatusSet(list)
	asserts.AssertMovingAddressStatusSet(list)
	return list
end

function asserts.AssertReservationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservation(v)
	end
end

--  
-- List of Reservation objects
function M.ReservationList(list)
	asserts.AssertReservationList(list)
	return list
end

function asserts.AssertIpv6CidrBlockSet(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6CidrBlockSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpv6CidrBlock(v)
	end
end

--  
-- List of Ipv6CidrBlock objects
function M.Ipv6CidrBlockSet(list)
	asserts.AssertIpv6CidrBlockSet(list)
	return list
end

function asserts.AssertPrefixListIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrefixListIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrefixListId(v)
	end
end

--  
-- List of PrefixListId objects
function M.PrefixListIdList(list)
	asserts.AssertPrefixListIdList(list)
	return list
end

function asserts.AssertCustomerGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected CustomerGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.CustomerGatewayIdStringList(list)
	asserts.AssertCustomerGatewayIdStringList(list)
	return list
end

function asserts.AssertActiveInstanceSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ActiveInstanceSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertActiveInstance(v)
	end
end

--  
-- List of ActiveInstance objects
function M.ActiveInstanceSet(list)
	asserts.AssertActiveInstanceSet(list)
	return list
end

function asserts.AssertCidrBlockSet(list)
	assert(list)
	assert(type(list) == "table", "Expected CidrBlockSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCidrBlock(v)
	end
end

--  
-- List of CidrBlock objects
function M.CidrBlockSet(list)
	asserts.AssertCidrBlockSet(list)
	return list
end

function asserts.AssertLaunchTemplateTagSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateTagSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateTagSpecification(v)
	end
end

--  
-- List of LaunchTemplateTagSpecification objects
function M.LaunchTemplateTagSpecificationList(list)
	asserts.AssertLaunchTemplateTagSpecificationList(list)
	return list
end

function asserts.AssertIamInstanceProfileAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected IamInstanceProfileAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIamInstanceProfileAssociation(v)
	end
end

--  
-- List of IamInstanceProfileAssociation objects
function M.IamInstanceProfileAssociationSet(list)
	asserts.AssertIamInstanceProfileAssociationSet(list)
	return list
end

function asserts.AssertGroupNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupNameStringList(list)
	asserts.AssertGroupNameStringList(list)
	return list
end

function asserts.AssertScheduledInstanceIdRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceIdRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ScheduledInstanceIdRequestSet(list)
	asserts.AssertScheduledInstanceIdRequestSet(list)
	return list
end

function asserts.AssertGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected GroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.GroupIdStringList(list)
	asserts.AssertGroupIdStringList(list)
	return list
end

function asserts.AssertProductDescriptionList(list)
	assert(list)
	assert(type(list) == "table", "Expected ProductDescriptionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ProductDescriptionList(list)
	asserts.AssertProductDescriptionList(list)
	return list
end

function asserts.AssertElasticGpuAssociationList(list)
	assert(list)
	assert(type(list) == "table", "Expected ElasticGpuAssociationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertElasticGpuAssociation(v)
	end
end

--  
-- List of ElasticGpuAssociation objects
function M.ElasticGpuAssociationList(list)
	asserts.AssertElasticGpuAssociationList(list)
	return list
end

function asserts.AssertFleetLaunchTemplateConfigListRequest(list)
	assert(list)
	assert(type(list) == "table", "Expected FleetLaunchTemplateConfigListRequest to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	for _,v in ipairs(list) do
		asserts.AssertFleetLaunchTemplateConfigRequest(v)
	end
end

--  
-- List of FleetLaunchTemplateConfigRequest objects
function M.FleetLaunchTemplateConfigListRequest(list)
	asserts.AssertFleetLaunchTemplateConfigListRequest(list)
	return list
end

function asserts.AssertAvailableInstanceCapacityList(list)
	assert(list)
	assert(type(list) == "table", "Expected AvailableInstanceCapacityList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCapacity(v)
	end
end

--  
-- List of InstanceCapacity objects
function M.AvailableInstanceCapacityList(list)
	asserts.AssertAvailableInstanceCapacityList(list)
	return list
end

function asserts.AssertReservedIntancesIds(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedIntancesIds to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesId(v)
	end
end

--  
-- List of ReservedInstancesId objects
function M.ReservedIntancesIds(list)
	asserts.AssertReservedIntancesIds(list)
	return list
end

function asserts.AssertIpRanges(list)
	assert(list)
	assert(type(list) == "table", "Expected IpRanges to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.IpRanges(list)
	asserts.AssertIpRanges(list)
	return list
end

function asserts.AssertScheduledInstanceAvailabilitySet(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstanceAvailabilitySet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstanceAvailability(v)
	end
end

--  
-- List of ScheduledInstanceAvailability objects
function M.ScheduledInstanceAvailabilitySet(list)
	asserts.AssertScheduledInstanceAvailabilitySet(list)
	return list
end

function asserts.AssertScheduledInstancesIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected ScheduledInstancesIpv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertScheduledInstancesIpv6Address(v)
	end
end

--  
-- List of ScheduledInstancesIpv6Address objects
function M.ScheduledInstancesIpv6AddressList(list)
	asserts.AssertScheduledInstancesIpv6AddressList(list)
	return list
end

function asserts.AssertVpnGatewayIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.VpnGatewayIdStringList(list)
	asserts.AssertVpnGatewayIdStringList(list)
	return list
end

function asserts.AssertSecurityGroupIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.SecurityGroupIdStringList(list)
	asserts.AssertSecurityGroupIdStringList(list)
	return list
end

function asserts.AssertPlacementGroupStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected PlacementGroupStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.PlacementGroupStringList(list)
	asserts.AssertPlacementGroupStringList(list)
	return list
end

function asserts.AssertInstanceCreditSpecificationListRequest(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceCreditSpecificationListRequest to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceCreditSpecificationRequest(v)
	end
end

--  
-- List of InstanceCreditSpecificationRequest objects
function M.InstanceCreditSpecificationListRequest(list)
	asserts.AssertInstanceCreditSpecificationListRequest(list)
	return list
end

function asserts.AssertValueStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ValueStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ValueStringList(list)
	asserts.AssertValueStringList(list)
	return list
end

function asserts.AssertAccountAttributeNameStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected AccountAttributeNameStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertAccountAttributeName(v)
	end
end

--  
-- List of AccountAttributeName objects
function M.AccountAttributeNameStringList(list)
	asserts.AssertAccountAttributeNameStringList(list)
	return list
end

function asserts.AssertNetworkInterfaceIpv6AddressesList(list)
	assert(list)
	assert(type(list) == "table", "Expected NetworkInterfaceIpv6AddressesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertNetworkInterfaceIpv6Address(v)
	end
end

--  
-- List of NetworkInterfaceIpv6Address objects
function M.NetworkInterfaceIpv6AddressesList(list)
	asserts.AssertNetworkInterfaceIpv6AddressesList(list)
	return list
end

function asserts.AssertPrivateIpAddressSpecificationList(list)
	assert(list)
	assert(type(list) == "table", "Expected PrivateIpAddressSpecificationList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertPrivateIpAddressSpecification(v)
	end
end

--  
-- List of PrivateIpAddressSpecification objects
function M.PrivateIpAddressSpecificationList(list)
	asserts.AssertPrivateIpAddressSpecificationList(list)
	return list
end

function asserts.AssertVpnConnectionList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnConnectionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnConnection(v)
	end
end

--  
-- List of VpnConnection objects
function M.VpnConnectionList(list)
	asserts.AssertVpnConnectionList(list)
	return list
end

function asserts.AssertVpcList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpc(v)
	end
end

--  
-- List of Vpc objects
function M.VpcList(list)
	asserts.AssertVpcList(list)
	return list
end

function asserts.AssertBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected BlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertBlockDeviceMapping(v)
	end
end

--  
-- List of BlockDeviceMapping objects
function M.BlockDeviceMappingList(list)
	asserts.AssertBlockDeviceMappingList(list)
	return list
end

function asserts.AssertReservedInstancesList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstances(v)
	end
end

--  
-- List of ReservedInstances objects
function M.ReservedInstancesList(list)
	asserts.AssertReservedInstancesList(list)
	return list
end

function asserts.AssertClassicLoadBalancers(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLoadBalancers to be of type ''table")
	assert(#list <= 5, "Expected list to be contain 5 elements")
	assert(#list >= 1, "Expected list to be contain 1 elements")
	for _,v in ipairs(list) do
		asserts.AssertClassicLoadBalancer(v)
	end
end

--  
-- List of ClassicLoadBalancer objects
function M.ClassicLoadBalancers(list)
	asserts.AssertClassicLoadBalancers(list)
	return list
end

function asserts.AssertVolumeStatusDetailsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusDetailsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusDetails(v)
	end
end

--  
-- List of VolumeStatusDetails objects
function M.VolumeStatusDetailsList(list)
	asserts.AssertVolumeStatusDetailsList(list)
	return list
end

function asserts.AssertSpotInstanceRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected SpotInstanceRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSpotInstanceRequest(v)
	end
end

--  
-- List of SpotInstanceRequest objects
function M.SpotInstanceRequestList(list)
	asserts.AssertSpotInstanceRequestList(list)
	return list
end

function asserts.AssertReservedInstancesModificationIdStringList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesModificationIdStringList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.ReservedInstancesModificationIdStringList(list)
	asserts.AssertReservedInstancesModificationIdStringList(list)
	return list
end

function asserts.AssertClassicLinkDnsSupportList(list)
	assert(list)
	assert(type(list) == "table", "Expected ClassicLinkDnsSupportList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertClassicLinkDnsSupport(v)
	end
end

--  
-- List of ClassicLinkDnsSupport objects
function M.ClassicLinkDnsSupportList(list)
	asserts.AssertClassicLinkDnsSupportList(list)
	return list
end

function asserts.AssertHostOfferingSet(list)
	assert(list)
	assert(type(list) == "table", "Expected HostOfferingSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostOffering(v)
	end
end

--  
-- List of HostOffering objects
function M.HostOfferingSet(list)
	asserts.AssertHostOfferingSet(list)
	return list
end

function asserts.AssertInstanceStatusList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstanceStatusList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstanceStatus(v)
	end
end

--  
-- List of InstanceStatus objects
function M.InstanceStatusList(list)
	asserts.AssertInstanceStatusList(list)
	return list
end

function asserts.AssertCreateVolumePermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected CreateVolumePermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertCreateVolumePermission(v)
	end
end

--  
-- List of CreateVolumePermission objects
function M.CreateVolumePermissionList(list)
	asserts.AssertCreateVolumePermissionList(list)
	return list
end

function asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationRequest(v)
	end
end

--  
-- List of LaunchTemplateInstanceNetworkInterfaceSpecificationRequest objects
function M.LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(list)
	asserts.AssertLaunchTemplateInstanceNetworkInterfaceSpecificationRequestList(list)
	return list
end

function asserts.AssertInstancePrivateIpAddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected InstancePrivateIpAddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInstancePrivateIpAddress(v)
	end
end

--  
-- List of InstancePrivateIpAddress objects
function M.InstancePrivateIpAddressList(list)
	asserts.AssertInstancePrivateIpAddressList(list)
	return list
end

function asserts.AssertVpnGatewayList(list)
	assert(list)
	assert(type(list) == "table", "Expected VpnGatewayList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpnGateway(v)
	end
end

--  
-- List of VpnGateway objects
function M.VpnGatewayList(list)
	asserts.AssertVpnGatewayList(list)
	return list
end

function asserts.AssertReservedInstanceReservationValueSet(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstanceReservationValueSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstanceReservationValue(v)
	end
end

--  
-- List of ReservedInstanceReservationValue objects
function M.ReservedInstanceReservationValueSet(list)
	asserts.AssertReservedInstanceReservationValueSet(list)
	return list
end

function asserts.AssertVolumeAttachmentList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeAttachmentList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeAttachment(v)
	end
end

--  
-- List of VolumeAttachment objects
function M.VolumeAttachmentList(list)
	asserts.AssertVolumeAttachmentList(list)
	return list
end

function asserts.AssertReservedInstancesListingList(list)
	assert(list)
	assert(type(list) == "table", "Expected ReservedInstancesListingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertReservedInstancesListing(v)
	end
end

--  
-- List of ReservedInstancesListing objects
function M.ReservedInstancesListingList(list)
	asserts.AssertReservedInstancesListingList(list)
	return list
end

function asserts.AssertIpv6AddressList(list)
	assert(list)
	assert(type(list) == "table", "Expected Ipv6AddressList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.Ipv6AddressList(list)
	asserts.AssertIpv6AddressList(list)
	return list
end

function asserts.AssertFleetLaunchTemplateOverridesListRequest(list)
	assert(list)
	assert(type(list) == "table", "Expected FleetLaunchTemplateOverridesListRequest to be of type ''table")
	assert(#list <= 50, "Expected list to be contain 50 elements")
	for _,v in ipairs(list) do
		asserts.AssertFleetLaunchTemplateOverridesRequest(v)
	end
end

--  
-- List of FleetLaunchTemplateOverridesRequest objects
function M.FleetLaunchTemplateOverridesListRequest(list)
	asserts.AssertFleetLaunchTemplateOverridesListRequest(list)
	return list
end

function asserts.AssertAllocationIdList(list)
	assert(list)
	assert(type(list) == "table", "Expected AllocationIdList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertString(v)
	end
end

--  
-- List of String objects
function M.AllocationIdList(list)
	asserts.AssertAllocationIdList(list)
	return list
end

function asserts.AssertOccurrenceDayRequestSet(list)
	assert(list)
	assert(type(list) == "table", "Expected OccurrenceDayRequestSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertInteger(v)
	end
end

--  
-- List of Integer objects
function M.OccurrenceDayRequestSet(list)
	asserts.AssertOccurrenceDayRequestSet(list)
	return list
end

function asserts.AssertDeleteLaunchTemplateVersionsResponseErrorSet(list)
	assert(list)
	assert(type(list) == "table", "Expected DeleteLaunchTemplateVersionsResponseErrorSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDeleteLaunchTemplateVersionsResponseErrorItem(v)
	end
end

--  
-- List of DeleteLaunchTemplateVersionsResponseErrorItem objects
function M.DeleteLaunchTemplateVersionsResponseErrorSet(list)
	asserts.AssertDeleteLaunchTemplateVersionsResponseErrorSet(list)
	return list
end

function asserts.AssertElasticGpuSpecifications(list)
	assert(list)
	assert(type(list) == "table", "Expected ElasticGpuSpecifications to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertElasticGpuSpecification(v)
	end
end

--  
-- List of ElasticGpuSpecification objects
function M.ElasticGpuSpecifications(list)
	asserts.AssertElasticGpuSpecifications(list)
	return list
end

function asserts.AssertHostInstanceList(list)
	assert(list)
	assert(type(list) == "table", "Expected HostInstanceList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertHostInstance(v)
	end
end

--  
-- List of HostInstance objects
function M.HostInstanceList(list)
	asserts.AssertHostInstanceList(list)
	return list
end

function asserts.AssertVolumeStatusEventsList(list)
	assert(list)
	assert(type(list) == "table", "Expected VolumeStatusEventsList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVolumeStatusEvent(v)
	end
end

--  
-- List of VolumeStatusEvent objects
function M.VolumeStatusEventsList(list)
	asserts.AssertVolumeStatusEventsList(list)
	return list
end

function asserts.AssertIpPermissionList(list)
	assert(list)
	assert(type(list) == "table", "Expected IpPermissionList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertIpPermission(v)
	end
end

--  
-- List of IpPermission objects
function M.IpPermissionList(list)
	asserts.AssertIpPermissionList(list)
	return list
end

function asserts.AssertSecurityGroupReferences(list)
	assert(list)
	assert(type(list) == "table", "Expected SecurityGroupReferences to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertSecurityGroupReference(v)
	end
end

--  
-- List of SecurityGroupReference objects
function M.SecurityGroupReferences(list)
	asserts.AssertSecurityGroupReferences(list)
	return list
end

function asserts.AssertDeleteLaunchTemplateVersionsResponseSuccessSet(list)
	assert(list)
	assert(type(list) == "table", "Expected DeleteLaunchTemplateVersionsResponseSuccessSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertDeleteLaunchTemplateVersionsResponseSuccessItem(v)
	end
end

--  
-- List of DeleteLaunchTemplateVersionsResponseSuccessItem objects
function M.DeleteLaunchTemplateVersionsResponseSuccessSet(list)
	asserts.AssertDeleteLaunchTemplateVersionsResponseSuccessSet(list)
	return list
end

function asserts.AssertVpcIpv6CidrBlockAssociationSet(list)
	assert(list)
	assert(type(list) == "table", "Expected VpcIpv6CidrBlockAssociationSet to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVpcIpv6CidrBlockAssociation(v)
	end
end

--  
-- List of VpcIpv6CidrBlockAssociation objects
function M.VpcIpv6CidrBlockAssociationSet(list)
	asserts.AssertVpcIpv6CidrBlockAssociationSet(list)
	return list
end

function asserts.AssertLaunchTemplateBlockDeviceMappingList(list)
	assert(list)
	assert(type(list) == "table", "Expected LaunchTemplateBlockDeviceMappingList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertLaunchTemplateBlockDeviceMapping(v)
	end
end

--  
-- List of LaunchTemplateBlockDeviceMapping objects
function M.LaunchTemplateBlockDeviceMappingList(list)
	asserts.AssertLaunchTemplateBlockDeviceMappingList(list)
	return list
end

function asserts.AssertVgwTelemetryList(list)
	assert(list)
	assert(type(list) == "table", "Expected VgwTelemetryList to be of type ''table")
	for _,v in ipairs(list) do
		asserts.AssertVgwTelemetry(v)
	end
end

--  
-- List of VgwTelemetry objects
function M.VgwTelemetryList(list)
	asserts.AssertVgwTelemetryList(list)
	return list
end


local content_type = require "aws-sdk.core.content_type"
local request_headers = require "aws-sdk.core.request_headers"
local request_handlers = require "aws-sdk.core.request_handlers"

local settings = {}


local function endpoint_for_region(region, use_dualstack)
	if not use_dualstack then
		if region == "us-east-1" then
			return "ec2.amazonaws.com"
		end
	end
	local ss = { "ec2" }
	if use_dualstack then
		ss[#ss + 1] = "dualstack"
	end
	ss[#ss + 1] = region
	ss[#ss + 1] = "amazonaws.com"
	if region == "cn-north-1" then
		ss[#ss + 1] = "cn"
	end
	return table.concat(ss, ".")
end


function M.init(config)
	assert(config, "You must provide a config table")
	assert(config.region, "You must provide a region in the config table")

	settings.service = M.metadata.endpoint_prefix
	settings.protocol = M.metadata.protocol
	settings.region = config.region
	settings.endpoint = config.endpoint_override or endpoint_for_region(config.region, config.use_dualstack)
	settings.signature_version = M.metadata.signature_version
	settings.uri = (config.scheme or "https") .. "://" .. settings.endpoint
end


--
-- OPERATIONS
--
--- Call DeleteTags asynchronously, invoking a callback when done
-- @param DeleteTagsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteTagsAsync(DeleteTagsRequest, cb)
	assert(DeleteTagsRequest, "You must provide a DeleteTagsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteTags",
	}
	for header,value in pairs(DeleteTagsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteTagsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteTagsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteTagsSync(DeleteTagsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteTagsAsync(DeleteTagsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetSnapshotAttribute asynchronously, invoking a callback when done
-- @param ResetSnapshotAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ResetSnapshotAttributeAsync(ResetSnapshotAttributeRequest, cb)
	assert(ResetSnapshotAttributeRequest, "You must provide a ResetSnapshotAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetSnapshotAttribute",
	}
	for header,value in pairs(ResetSnapshotAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetSnapshotAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetSnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetSnapshotAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ResetSnapshotAttributeSync(ResetSnapshotAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetSnapshotAttributeAsync(ResetSnapshotAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeCustomerGateways asynchronously, invoking a callback when done
-- @param DescribeCustomerGatewaysRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeCustomerGatewaysAsync(DescribeCustomerGatewaysRequest, cb)
	assert(DescribeCustomerGatewaysRequest, "You must provide a DescribeCustomerGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeCustomerGateways",
	}
	for header,value in pairs(DescribeCustomerGatewaysRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeCustomerGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeCustomerGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeCustomerGatewaysRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeCustomerGatewaysSync(DescribeCustomerGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeCustomerGatewaysAsync(DescribeCustomerGatewaysRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceIamInstanceProfileAssociation asynchronously, invoking a callback when done
-- @param ReplaceIamInstanceProfileAssociationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReplaceIamInstanceProfileAssociationAsync(ReplaceIamInstanceProfileAssociationRequest, cb)
	assert(ReplaceIamInstanceProfileAssociationRequest, "You must provide a ReplaceIamInstanceProfileAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceIamInstanceProfileAssociation",
	}
	for header,value in pairs(ReplaceIamInstanceProfileAssociationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceIamInstanceProfileAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceIamInstanceProfileAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceIamInstanceProfileAssociationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReplaceIamInstanceProfileAssociationSync(ReplaceIamInstanceProfileAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceIamInstanceProfileAssociationAsync(ReplaceIamInstanceProfileAssociationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param EnableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.EnableVpcClassicLinkDnsSupportAsync(EnableVpcClassicLinkDnsSupportRequest, cb)
	assert(EnableVpcClassicLinkDnsSupportRequest, "You must provide a EnableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLinkDnsSupport",
	}
	for header,value in pairs(EnableVpcClassicLinkDnsSupportRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVpcClassicLinkDnsSupportRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_type
-- @return error_message
function M.EnableVpcClassicLinkDnsSupportSync(EnableVpcClassicLinkDnsSupportRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVpcClassicLinkDnsSupportAsync(EnableVpcClassicLinkDnsSupportRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkAcls asynchronously, invoking a callback when done
-- @param DescribeNetworkAclsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeNetworkAclsAsync(DescribeNetworkAclsRequest, cb)
	assert(DescribeNetworkAclsRequest, "You must provide a DescribeNetworkAclsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNetworkAcls",
	}
	for header,value in pairs(DescribeNetworkAclsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNetworkAclsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkAcls synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkAclsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeNetworkAclsSync(DescribeNetworkAclsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkAclsAsync(DescribeNetworkAclsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AdvertiseByoipCidr asynchronously, invoking a callback when done
-- @param AdvertiseByoipCidrRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AdvertiseByoipCidrAsync(AdvertiseByoipCidrRequest, cb)
	assert(AdvertiseByoipCidrRequest, "You must provide a AdvertiseByoipCidrRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AdvertiseByoipCidr",
	}
	for header,value in pairs(AdvertiseByoipCidrRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AdvertiseByoipCidrRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AdvertiseByoipCidr synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AdvertiseByoipCidrRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AdvertiseByoipCidrSync(AdvertiseByoipCidrRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AdvertiseByoipCidrAsync(AdvertiseByoipCidrRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelConversionTask asynchronously, invoking a callback when done
-- @param CancelConversionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelConversionTaskAsync(CancelConversionRequest, cb)
	assert(CancelConversionRequest, "You must provide a CancelConversionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelConversionTask",
	}
	for header,value in pairs(CancelConversionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelConversionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelConversionTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelConversionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelConversionTaskSync(CancelConversionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelConversionTaskAsync(CancelConversionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelImportTask asynchronously, invoking a callback when done
-- @param CancelImportTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelImportTaskAsync(CancelImportTaskRequest, cb)
	assert(CancelImportTaskRequest, "You must provide a CancelImportTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelImportTask",
	}
	for header,value in pairs(CancelImportTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelImportTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelImportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelImportTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelImportTaskSync(CancelImportTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelImportTaskAsync(CancelImportTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnConnectionRoute asynchronously, invoking a callback when done
-- @param CreateVpnConnectionRouteRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpnConnectionRouteAsync(CreateVpnConnectionRouteRequest, cb)
	assert(CreateVpnConnectionRouteRequest, "You must provide a CreateVpnConnectionRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpnConnectionRoute",
	}
	for header,value in pairs(CreateVpnConnectionRouteRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpnConnectionRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnConnectionRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnConnectionRouteRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpnConnectionRouteSync(CreateVpnConnectionRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnConnectionRouteAsync(CreateVpnConnectionRouteRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcEndpointConnectionNotification asynchronously, invoking a callback when done
-- @param CreateVpcEndpointConnectionNotificationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpcEndpointConnectionNotificationAsync(CreateVpcEndpointConnectionNotificationRequest, cb)
	assert(CreateVpcEndpointConnectionNotificationRequest, "You must provide a CreateVpcEndpointConnectionNotificationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpcEndpointConnectionNotification",
	}
	for header,value in pairs(CreateVpcEndpointConnectionNotificationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcEndpointConnectionNotificationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcEndpointConnectionNotification synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcEndpointConnectionNotificationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpcEndpointConnectionNotificationSync(CreateVpcEndpointConnectionNotificationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcEndpointConnectionNotificationAsync(CreateVpcEndpointConnectionNotificationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeRouteTables asynchronously, invoking a callback when done
-- @param DescribeRouteTablesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeRouteTablesAsync(DescribeRouteTablesRequest, cb)
	assert(DescribeRouteTablesRequest, "You must provide a DescribeRouteTablesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeRouteTables",
	}
	for header,value in pairs(DescribeRouteTablesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeRouteTablesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeRouteTables synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeRouteTablesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeRouteTablesSync(DescribeRouteTablesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeRouteTablesAsync(DescribeRouteTablesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetImageAttribute asynchronously, invoking a callback when done
-- @param ResetImageAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ResetImageAttributeAsync(ResetImageAttributeRequest, cb)
	assert(ResetImageAttributeRequest, "You must provide a ResetImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetImageAttribute",
	}
	for header,value in pairs(ResetImageAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetImageAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ResetImageAttributeSync(ResetImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetImageAttributeAsync(ResetImageAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateRouteTable asynchronously, invoking a callback when done
-- @param CreateRouteTableRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateRouteTableAsync(CreateRouteTableRequest, cb)
	assert(CreateRouteTableRequest, "You must provide a CreateRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateRouteTable",
	}
	for header,value in pairs(CreateRouteTableRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateRouteTableRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateRouteTableSync(CreateRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateRouteTableAsync(CreateRouteTableRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceRouteTableAssociation asynchronously, invoking a callback when done
-- @param ReplaceRouteTableAssociationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReplaceRouteTableAssociationAsync(ReplaceRouteTableAssociationRequest, cb)
	assert(ReplaceRouteTableAssociationRequest, "You must provide a ReplaceRouteTableAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceRouteTableAssociation",
	}
	for header,value in pairs(ReplaceRouteTableAssociationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceRouteTableAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceRouteTableAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceRouteTableAssociationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReplaceRouteTableAssociationSync(ReplaceRouteTableAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceRouteTableAssociationAsync(ReplaceRouteTableAssociationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcEndpoint asynchronously, invoking a callback when done
-- @param CreateVpcEndpointRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpcEndpointAsync(CreateVpcEndpointRequest, cb)
	assert(CreateVpcEndpointRequest, "You must provide a CreateVpcEndpointRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpcEndpoint",
	}
	for header,value in pairs(CreateVpcEndpointRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcEndpointRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcEndpoint synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcEndpointRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpcEndpointSync(CreateVpcEndpointRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcEndpointAsync(CreateVpcEndpointRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeScheduledInstanceAvailability asynchronously, invoking a callback when done
-- @param DescribeScheduledInstanceAvailabilityRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeScheduledInstanceAvailabilityAsync(DescribeScheduledInstanceAvailabilityRequest, cb)
	assert(DescribeScheduledInstanceAvailabilityRequest, "You must provide a DescribeScheduledInstanceAvailabilityRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstanceAvailability",
	}
	for header,value in pairs(DescribeScheduledInstanceAvailabilityRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeScheduledInstanceAvailabilityRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeScheduledInstanceAvailability synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeScheduledInstanceAvailabilityRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeScheduledInstanceAvailabilitySync(DescribeScheduledInstanceAvailabilityRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeScheduledInstanceAvailabilityAsync(DescribeScheduledInstanceAvailabilityRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeCapacityReservations asynchronously, invoking a callback when done
-- @param DescribeCapacityReservationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeCapacityReservationsAsync(DescribeCapacityReservationsRequest, cb)
	assert(DescribeCapacityReservationsRequest, "You must provide a DescribeCapacityReservationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeCapacityReservations",
	}
	for header,value in pairs(DescribeCapacityReservationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeCapacityReservationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeCapacityReservations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeCapacityReservationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeCapacityReservationsSync(DescribeCapacityReservationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeCapacityReservationsAsync(DescribeCapacityReservationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RegisterImage asynchronously, invoking a callback when done
-- @param RegisterImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RegisterImageAsync(RegisterImageRequest, cb)
	assert(RegisterImageRequest, "You must provide a RegisterImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RegisterImage",
	}
	for header,value in pairs(RegisterImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RegisterImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RegisterImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RegisterImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RegisterImageSync(RegisterImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RegisterImageAsync(RegisterImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateDhcpOptions asynchronously, invoking a callback when done
-- @param AssociateDhcpOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssociateDhcpOptionsAsync(AssociateDhcpOptionsRequest, cb)
	assert(AssociateDhcpOptionsRequest, "You must provide a AssociateDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateDhcpOptions",
	}
	for header,value in pairs(AssociateDhcpOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateDhcpOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssociateDhcpOptionsSync(AssociateDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateDhcpOptionsAsync(AssociateDhcpOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcEndpointServicePermissions asynchronously, invoking a callback when done
-- @param ModifyVpcEndpointServicePermissionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVpcEndpointServicePermissionsAsync(ModifyVpcEndpointServicePermissionsRequest, cb)
	assert(ModifyVpcEndpointServicePermissionsRequest, "You must provide a ModifyVpcEndpointServicePermissionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcEndpointServicePermissions",
	}
	for header,value in pairs(ModifyVpcEndpointServicePermissionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcEndpointServicePermissionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcEndpointServicePermissions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcEndpointServicePermissionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVpcEndpointServicePermissionsSync(ModifyVpcEndpointServicePermissionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcEndpointServicePermissionsAsync(ModifyVpcEndpointServicePermissionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportKeyPair asynchronously, invoking a callback when done
-- @param ImportKeyPairRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ImportKeyPairAsync(ImportKeyPairRequest, cb)
	assert(ImportKeyPairRequest, "You must provide a ImportKeyPairRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportKeyPair",
	}
	for header,value in pairs(ImportKeyPairRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportKeyPairRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportKeyPairRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ImportKeyPairSync(ImportKeyPairRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportKeyPairAsync(ImportKeyPairRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAvailabilityZones asynchronously, invoking a callback when done
-- @param DescribeAvailabilityZonesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAvailabilityZonesAsync(DescribeAvailabilityZonesRequest, cb)
	assert(DescribeAvailabilityZonesRequest, "You must provide a DescribeAvailabilityZonesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAvailabilityZones",
	}
	for header,value in pairs(DescribeAvailabilityZonesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAvailabilityZonesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAvailabilityZones synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAvailabilityZonesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAvailabilityZonesSync(DescribeAvailabilityZonesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAvailabilityZonesAsync(DescribeAvailabilityZonesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RequestSpotInstances asynchronously, invoking a callback when done
-- @param RequestSpotInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RequestSpotInstancesAsync(RequestSpotInstancesRequest, cb)
	assert(RequestSpotInstancesRequest, "You must provide a RequestSpotInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RequestSpotInstances",
	}
	for header,value in pairs(RequestSpotInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RequestSpotInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RequestSpotInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RequestSpotInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RequestSpotInstancesSync(RequestSpotInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RequestSpotInstancesAsync(RequestSpotInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSnapshots asynchronously, invoking a callback when done
-- @param DescribeSnapshotsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSnapshotsAsync(DescribeSnapshotsRequest, cb)
	assert(DescribeSnapshotsRequest, "You must provide a DescribeSnapshotsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSnapshots",
	}
	for header,value in pairs(DescribeSnapshotsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSnapshotsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSnapshots synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSnapshotsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSnapshotsSync(DescribeSnapshotsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSnapshotsAsync(DescribeSnapshotsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptVpcPeeringConnection asynchronously, invoking a callback when done
-- @param AcceptVpcPeeringConnectionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AcceptVpcPeeringConnectionAsync(AcceptVpcPeeringConnectionRequest, cb)
	assert(AcceptVpcPeeringConnectionRequest, "You must provide a AcceptVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AcceptVpcPeeringConnection",
	}
	for header,value in pairs(AcceptVpcPeeringConnectionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AcceptVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptVpcPeeringConnectionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AcceptVpcPeeringConnectionSync(AcceptVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptVpcPeeringConnectionAsync(AcceptVpcPeeringConnectionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesModifications asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesModificationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeReservedInstancesModificationsAsync(DescribeReservedInstancesModificationsRequest, cb)
	assert(DescribeReservedInstancesModificationsRequest, "You must provide a DescribeReservedInstancesModificationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesModifications",
	}
	for header,value in pairs(DescribeReservedInstancesModificationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesModificationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesModifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesModificationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeReservedInstancesModificationsSync(DescribeReservedInstancesModificationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesModificationsAsync(DescribeReservedInstancesModificationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetPasswordData asynchronously, invoking a callback when done
-- @param GetPasswordDataRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetPasswordDataAsync(GetPasswordDataRequest, cb)
	assert(GetPasswordDataRequest, "You must provide a GetPasswordDataRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetPasswordData",
	}
	for header,value in pairs(GetPasswordDataRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetPasswordDataRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetPasswordData synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetPasswordDataRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetPasswordDataSync(GetPasswordDataRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetPasswordDataAsync(GetPasswordDataRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImportSnapshotTasks asynchronously, invoking a callback when done
-- @param DescribeImportSnapshotTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeImportSnapshotTasksAsync(DescribeImportSnapshotTasksRequest, cb)
	assert(DescribeImportSnapshotTasksRequest, "You must provide a DescribeImportSnapshotTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImportSnapshotTasks",
	}
	for header,value in pairs(DescribeImportSnapshotTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImportSnapshotTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImportSnapshotTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImportSnapshotTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeImportSnapshotTasksSync(DescribeImportSnapshotTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImportSnapshotTasksAsync(DescribeImportSnapshotTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkInterfacePermission asynchronously, invoking a callback when done
-- @param CreateNetworkInterfacePermissionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateNetworkInterfacePermissionAsync(CreateNetworkInterfacePermissionRequest, cb)
	assert(CreateNetworkInterfacePermissionRequest, "You must provide a CreateNetworkInterfacePermissionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNetworkInterfacePermission",
	}
	for header,value in pairs(CreateNetworkInterfacePermissionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNetworkInterfacePermissionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkInterfacePermission synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkInterfacePermissionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateNetworkInterfacePermissionSync(CreateNetworkInterfacePermissionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkInterfacePermissionAsync(CreateNetworkInterfacePermissionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnConnection asynchronously, invoking a callback when done
-- @param DeleteVpnConnectionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpnConnectionAsync(DeleteVpnConnectionRequest, cb)
	assert(DeleteVpnConnectionRequest, "You must provide a DeleteVpnConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnection",
	}
	for header,value in pairs(DeleteVpnConnectionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpnConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnConnectionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpnConnectionSync(DeleteVpnConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnConnectionAsync(DeleteVpnConnectionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachVpnGateway asynchronously, invoking a callback when done
-- @param AttachVpnGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachVpnGatewayAsync(AttachVpnGatewayRequest, cb)
	assert(AttachVpnGatewayRequest, "You must provide a AttachVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachVpnGateway",
	}
	for header,value in pairs(AttachVpnGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachVpnGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachVpnGatewaySync(AttachVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachVpnGatewayAsync(AttachVpnGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteLaunchTemplate asynchronously, invoking a callback when done
-- @param DeleteLaunchTemplateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteLaunchTemplateAsync(DeleteLaunchTemplateRequest, cb)
	assert(DeleteLaunchTemplateRequest, "You must provide a DeleteLaunchTemplateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteLaunchTemplate",
	}
	for header,value in pairs(DeleteLaunchTemplateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteLaunchTemplateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteLaunchTemplate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteLaunchTemplateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteLaunchTemplateSync(DeleteLaunchTemplateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteLaunchTemplateAsync(DeleteLaunchTemplateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportImage asynchronously, invoking a callback when done
-- @param ImportImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ImportImageAsync(ImportImageRequest, cb)
	assert(ImportImageRequest, "You must provide a ImportImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportImage",
	}
	for header,value in pairs(ImportImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ImportImageSync(ImportImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportImageAsync(ImportImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImageAttribute asynchronously, invoking a callback when done
-- @param DescribeImageAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeImageAttributeAsync(DescribeImageAttributeRequest, cb)
	assert(DescribeImageAttributeRequest, "You must provide a DescribeImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImageAttribute",
	}
	for header,value in pairs(DescribeImageAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImageAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeImageAttributeSync(DescribeImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImageAttributeAsync(DescribeImageAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAddresses asynchronously, invoking a callback when done
-- @param DescribeAddressesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAddressesAsync(DescribeAddressesRequest, cb)
	assert(DescribeAddressesRequest, "You must provide a DescribeAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAddresses",
	}
	for header,value in pairs(DescribeAddressesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAddressesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAddressesSync(DescribeAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAddressesAsync(DescribeAddressesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateIamInstanceProfile asynchronously, invoking a callback when done
-- @param DisassociateIamInstanceProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisassociateIamInstanceProfileAsync(DisassociateIamInstanceProfileRequest, cb)
	assert(DisassociateIamInstanceProfileRequest, "You must provide a DisassociateIamInstanceProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateIamInstanceProfile",
	}
	for header,value in pairs(DisassociateIamInstanceProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateIamInstanceProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateIamInstanceProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateIamInstanceProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisassociateIamInstanceProfileSync(DisassociateIamInstanceProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateIamInstanceProfileAsync(DisassociateIamInstanceProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateIamInstanceProfile asynchronously, invoking a callback when done
-- @param AssociateIamInstanceProfileRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssociateIamInstanceProfileAsync(AssociateIamInstanceProfileRequest, cb)
	assert(AssociateIamInstanceProfileRequest, "You must provide a AssociateIamInstanceProfileRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateIamInstanceProfile",
	}
	for header,value in pairs(AssociateIamInstanceProfileRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateIamInstanceProfileRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateIamInstanceProfile synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateIamInstanceProfileRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssociateIamInstanceProfileSync(AssociateIamInstanceProfileRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateIamInstanceProfileAsync(AssociateIamInstanceProfileRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseHostReservation asynchronously, invoking a callback when done
-- @param PurchaseHostReservationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.PurchaseHostReservationAsync(PurchaseHostReservationRequest, cb)
	assert(PurchaseHostReservationRequest, "You must provide a PurchaseHostReservationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".PurchaseHostReservation",
	}
	for header,value in pairs(PurchaseHostReservationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", PurchaseHostReservationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseHostReservation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseHostReservationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.PurchaseHostReservationSync(PurchaseHostReservationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseHostReservationAsync(PurchaseHostReservationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call BundleInstance asynchronously, invoking a callback when done
-- @param BundleInstanceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.BundleInstanceAsync(BundleInstanceRequest, cb)
	assert(BundleInstanceRequest, "You must provide a BundleInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".BundleInstance",
	}
	for header,value in pairs(BundleInstanceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", BundleInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call BundleInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param BundleInstanceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.BundleInstanceSync(BundleInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.BundleInstanceAsync(BundleInstanceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstances asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeReservedInstancesAsync(DescribeReservedInstancesRequest, cb)
	assert(DescribeReservedInstancesRequest, "You must provide a DescribeReservedInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstances",
	}
	for header,value in pairs(DescribeReservedInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeReservedInstancesSync(DescribeReservedInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesAsync(DescribeReservedInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkAcl asynchronously, invoking a callback when done
-- @param CreateNetworkAclRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateNetworkAclAsync(CreateNetworkAclRequest, cb)
	assert(CreateNetworkAclRequest, "You must provide a CreateNetworkAclRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNetworkAcl",
	}
	for header,value in pairs(CreateNetworkAclRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNetworkAclRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkAcl synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkAclRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateNetworkAclSync(CreateNetworkAclRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkAclAsync(CreateNetworkAclRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateImage asynchronously, invoking a callback when done
-- @param CreateImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateImageAsync(CreateImageRequest, cb)
	assert(CreateImageRequest, "You must provide a CreateImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateImage",
	}
	for header,value in pairs(CreateImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateImageSync(CreateImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateImageAsync(CreateImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyHosts asynchronously, invoking a callback when done
-- @param ModifyHostsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyHostsAsync(ModifyHostsRequest, cb)
	assert(ModifyHostsRequest, "You must provide a ModifyHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyHosts",
	}
	for header,value in pairs(ModifyHostsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyHostsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyHostsSync(ModifyHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyHostsAsync(ModifyHostsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateFleet asynchronously, invoking a callback when done
-- @param CreateFleetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateFleetAsync(CreateFleetRequest, cb)
	assert(CreateFleetRequest, "You must provide a CreateFleetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateFleet",
	}
	for header,value in pairs(CreateFleetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateFleetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateFleet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateFleetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateFleetSync(CreateFleetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateFleetAsync(CreateFleetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RebootInstances asynchronously, invoking a callback when done
-- @param RebootInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RebootInstancesAsync(RebootInstancesRequest, cb)
	assert(RebootInstancesRequest, "You must provide a RebootInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RebootInstances",
	}
	for header,value in pairs(RebootInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RebootInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RebootInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RebootInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RebootInstancesSync(RebootInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RebootInstancesAsync(RebootInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIdentityIdFormat asynchronously, invoking a callback when done
-- @param DescribeIdentityIdFormatRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeIdentityIdFormatAsync(DescribeIdentityIdFormatRequest, cb)
	assert(DescribeIdentityIdFormatRequest, "You must provide a DescribeIdentityIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeIdentityIdFormat",
	}
	for header,value in pairs(DescribeIdentityIdFormatRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeIdentityIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIdentityIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIdentityIdFormatRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeIdentityIdFormatSync(DescribeIdentityIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIdentityIdFormatAsync(DescribeIdentityIdFormatRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyIdentityIdFormat asynchronously, invoking a callback when done
-- @param ModifyIdentityIdFormatRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyIdentityIdFormatAsync(ModifyIdentityIdFormatRequest, cb)
	assert(ModifyIdentityIdFormatRequest, "You must provide a ModifyIdentityIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyIdentityIdFormat",
	}
	for header,value in pairs(ModifyIdentityIdFormatRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyIdentityIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyIdentityIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyIdentityIdFormatRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyIdentityIdFormatSync(ModifyIdentityIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyIdentityIdFormatAsync(ModifyIdentityIdFormatRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetRequestHistory asynchronously, invoking a callback when done
-- @param DescribeSpotFleetRequestHistoryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSpotFleetRequestHistoryAsync(DescribeSpotFleetRequestHistoryRequest, cb)
	assert(DescribeSpotFleetRequestHistoryRequest, "You must provide a DescribeSpotFleetRequestHistoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequestHistory",
	}
	for header,value in pairs(DescribeSpotFleetRequestHistoryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotFleetRequestHistoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetRequestHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetRequestHistoryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSpotFleetRequestHistorySync(DescribeSpotFleetRequestHistoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetRequestHistoryAsync(DescribeSpotFleetRequestHistoryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseScheduledInstances asynchronously, invoking a callback when done
-- @param PurchaseScheduledInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.PurchaseScheduledInstancesAsync(PurchaseScheduledInstancesRequest, cb)
	assert(PurchaseScheduledInstancesRequest, "You must provide a PurchaseScheduledInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".PurchaseScheduledInstances",
	}
	for header,value in pairs(PurchaseScheduledInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", PurchaseScheduledInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseScheduledInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.PurchaseScheduledInstancesSync(PurchaseScheduledInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseScheduledInstancesAsync(PurchaseScheduledInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstanceCreditSpecification asynchronously, invoking a callback when done
-- @param ModifyInstanceCreditSpecificationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyInstanceCreditSpecificationAsync(ModifyInstanceCreditSpecificationRequest, cb)
	assert(ModifyInstanceCreditSpecificationRequest, "You must provide a ModifyInstanceCreditSpecificationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyInstanceCreditSpecification",
	}
	for header,value in pairs(ModifyInstanceCreditSpecificationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyInstanceCreditSpecificationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstanceCreditSpecification synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstanceCreditSpecificationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyInstanceCreditSpecificationSync(ModifyInstanceCreditSpecificationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstanceCreditSpecificationAsync(ModifyInstanceCreditSpecificationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachVolume asynchronously, invoking a callback when done
-- @param DetachVolumeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachVolumeAsync(DetachVolumeRequest, cb)
	assert(DetachVolumeRequest, "You must provide a DetachVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachVolume",
	}
	for header,value in pairs(DetachVolumeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachVolumeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachVolumeSync(DetachVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachVolumeAsync(DetachVolumeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIamInstanceProfileAssociations asynchronously, invoking a callback when done
-- @param DescribeIamInstanceProfileAssociationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeIamInstanceProfileAssociationsAsync(DescribeIamInstanceProfileAssociationsRequest, cb)
	assert(DescribeIamInstanceProfileAssociationsRequest, "You must provide a DescribeIamInstanceProfileAssociationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeIamInstanceProfileAssociations",
	}
	for header,value in pairs(DescribeIamInstanceProfileAssociationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeIamInstanceProfileAssociationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIamInstanceProfileAssociations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIamInstanceProfileAssociationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeIamInstanceProfileAssociationsSync(DescribeIamInstanceProfileAssociationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIamInstanceProfileAssociationsAsync(DescribeIamInstanceProfileAssociationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssignPrivateIpAddresses asynchronously, invoking a callback when done
-- @param AssignPrivateIpAddressesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssignPrivateIpAddressesAsync(AssignPrivateIpAddressesRequest, cb)
	assert(AssignPrivateIpAddressesRequest, "You must provide a AssignPrivateIpAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssignPrivateIpAddresses",
	}
	for header,value in pairs(AssignPrivateIpAddressesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssignPrivateIpAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssignPrivateIpAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssignPrivateIpAddressesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssignPrivateIpAddressesSync(AssignPrivateIpAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssignPrivateIpAddressesAsync(AssignPrivateIpAddressesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelExportTask asynchronously, invoking a callback when done
-- @param CancelExportTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelExportTaskAsync(CancelExportTaskRequest, cb)
	assert(CancelExportTaskRequest, "You must provide a CancelExportTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelExportTask",
	}
	for header,value in pairs(CancelExportTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelExportTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelExportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelExportTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelExportTaskSync(CancelExportTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelExportTaskAsync(CancelExportTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptVpcEndpointConnections asynchronously, invoking a callback when done
-- @param AcceptVpcEndpointConnectionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AcceptVpcEndpointConnectionsAsync(AcceptVpcEndpointConnectionsRequest, cb)
	assert(AcceptVpcEndpointConnectionsRequest, "You must provide a AcceptVpcEndpointConnectionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AcceptVpcEndpointConnections",
	}
	for header,value in pairs(AcceptVpcEndpointConnectionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AcceptVpcEndpointConnectionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptVpcEndpointConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptVpcEndpointConnectionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AcceptVpcEndpointConnectionsSync(AcceptVpcEndpointConnectionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptVpcEndpointConnectionsAsync(AcceptVpcEndpointConnectionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachVpnGateway asynchronously, invoking a callback when done
-- @param DetachVpnGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachVpnGatewayAsync(DetachVpnGatewayRequest, cb)
	assert(DetachVpnGatewayRequest, "You must provide a DetachVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachVpnGateway",
	}
	for header,value in pairs(DetachVpnGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachVpnGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachVpnGatewaySync(DetachVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachVpnGatewayAsync(DetachVpnGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcAttribute asynchronously, invoking a callback when done
-- @param DescribeVpcAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcAttributeAsync(DescribeVpcAttributeRequest, cb)
	assert(DescribeVpcAttributeRequest, "You must provide a DescribeVpcAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcAttribute",
	}
	for header,value in pairs(DescribeVpcAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcAttributeSync(DescribeVpcAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcAttributeAsync(DescribeVpcAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelBundleTask asynchronously, invoking a callback when done
-- @param CancelBundleTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelBundleTaskAsync(CancelBundleTaskRequest, cb)
	assert(CancelBundleTaskRequest, "You must provide a CancelBundleTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelBundleTask",
	}
	for header,value in pairs(CancelBundleTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelBundleTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelBundleTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelBundleTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelBundleTaskSync(CancelBundleTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelBundleTaskAsync(CancelBundleTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNatGateways asynchronously, invoking a callback when done
-- @param DescribeNatGatewaysRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeNatGatewaysAsync(DescribeNatGatewaysRequest, cb)
	assert(DescribeNatGatewaysRequest, "You must provide a DescribeNatGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNatGateways",
	}
	for header,value in pairs(DescribeNatGatewaysRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNatGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNatGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNatGatewaysRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeNatGatewaysSync(DescribeNatGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNatGatewaysAsync(DescribeNatGatewaysRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateSubnetCidrBlock asynchronously, invoking a callback when done
-- @param DisassociateSubnetCidrBlockRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisassociateSubnetCidrBlockAsync(DisassociateSubnetCidrBlockRequest, cb)
	assert(DisassociateSubnetCidrBlockRequest, "You must provide a DisassociateSubnetCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateSubnetCidrBlock",
	}
	for header,value in pairs(DisassociateSubnetCidrBlockRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateSubnetCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateSubnetCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateSubnetCidrBlockRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisassociateSubnetCidrBlockSync(DisassociateSubnetCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateSubnetCidrBlockAsync(DisassociateSubnetCidrBlockRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcPeeringConnection asynchronously, invoking a callback when done
-- @param CreateVpcPeeringConnectionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpcPeeringConnectionAsync(CreateVpcPeeringConnectionRequest, cb)
	assert(CreateVpcPeeringConnectionRequest, "You must provide a CreateVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpcPeeringConnection",
	}
	for header,value in pairs(CreateVpcPeeringConnectionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcPeeringConnectionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpcPeeringConnectionSync(CreateVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcPeeringConnectionAsync(CreateVpcPeeringConnectionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyIdFormat asynchronously, invoking a callback when done
-- @param ModifyIdFormatRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyIdFormatAsync(ModifyIdFormatRequest, cb)
	assert(ModifyIdFormatRequest, "You must provide a ModifyIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyIdFormat",
	}
	for header,value in pairs(ModifyIdFormatRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyIdFormatRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyIdFormatSync(ModifyIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyIdFormatAsync(ModifyIdFormatRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetRequests asynchronously, invoking a callback when done
-- @param DescribeSpotFleetRequestsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSpotFleetRequestsAsync(DescribeSpotFleetRequestsRequest, cb)
	assert(DescribeSpotFleetRequestsRequest, "You must provide a DescribeSpotFleetRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetRequests",
	}
	for header,value in pairs(DescribeSpotFleetRequestsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotFleetRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetRequestsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSpotFleetRequestsSync(DescribeSpotFleetRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetRequestsAsync(DescribeSpotFleetRequestsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AllocateHosts asynchronously, invoking a callback when done
-- @param AllocateHostsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AllocateHostsAsync(AllocateHostsRequest, cb)
	assert(AllocateHostsRequest, "You must provide a AllocateHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AllocateHosts",
	}
	for header,value in pairs(AllocateHostsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AllocateHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AllocateHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AllocateHostsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AllocateHostsSync(AllocateHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AllocateHostsAsync(AllocateHostsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkAcl asynchronously, invoking a callback when done
-- @param DeleteNetworkAclRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteNetworkAclAsync(DeleteNetworkAclRequest, cb)
	assert(DeleteNetworkAclRequest, "You must provide a DeleteNetworkAclRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAcl",
	}
	for header,value in pairs(DeleteNetworkAclRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNetworkAclRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkAcl synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkAclRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteNetworkAclSync(DeleteNetworkAclRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkAclAsync(DeleteNetworkAclRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call WithdrawByoipCidr asynchronously, invoking a callback when done
-- @param WithdrawByoipCidrRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.WithdrawByoipCidrAsync(WithdrawByoipCidrRequest, cb)
	assert(WithdrawByoipCidrRequest, "You must provide a WithdrawByoipCidrRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".WithdrawByoipCidr",
	}
	for header,value in pairs(WithdrawByoipCidrRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", WithdrawByoipCidrRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call WithdrawByoipCidr synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param WithdrawByoipCidrRequest
-- @return response
-- @return error_type
-- @return error_message
function M.WithdrawByoipCidrSync(WithdrawByoipCidrRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.WithdrawByoipCidrAsync(WithdrawByoipCidrRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetHostReservationPurchasePreview asynchronously, invoking a callback when done
-- @param GetHostReservationPurchasePreviewRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetHostReservationPurchasePreviewAsync(GetHostReservationPurchasePreviewRequest, cb)
	assert(GetHostReservationPurchasePreviewRequest, "You must provide a GetHostReservationPurchasePreviewRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetHostReservationPurchasePreview",
	}
	for header,value in pairs(GetHostReservationPurchasePreviewRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetHostReservationPurchasePreviewRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetHostReservationPurchasePreview synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetHostReservationPurchasePreviewRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetHostReservationPurchasePreviewSync(GetHostReservationPurchasePreviewRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetHostReservationPurchasePreviewAsync(GetHostReservationPurchasePreviewRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSecurityGroup asynchronously, invoking a callback when done
-- @param DeleteSecurityGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteSecurityGroupAsync(DeleteSecurityGroupRequest, cb)
	assert(DeleteSecurityGroupRequest, "You must provide a DeleteSecurityGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSecurityGroup",
	}
	for header,value in pairs(DeleteSecurityGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSecurityGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSecurityGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSecurityGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteSecurityGroupSync(DeleteSecurityGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSecurityGroupAsync(DeleteSecurityGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateSecurityGroupRuleDescriptionsEgress asynchronously, invoking a callback when done
-- @param UpdateSecurityGroupRuleDescriptionsEgressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateSecurityGroupRuleDescriptionsEgressAsync(UpdateSecurityGroupRuleDescriptionsEgressRequest, cb)
	assert(UpdateSecurityGroupRuleDescriptionsEgressRequest, "You must provide a UpdateSecurityGroupRuleDescriptionsEgressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateSecurityGroupRuleDescriptionsEgress",
	}
	for header,value in pairs(UpdateSecurityGroupRuleDescriptionsEgressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateSecurityGroupRuleDescriptionsEgressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateSecurityGroupRuleDescriptionsEgress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateSecurityGroupRuleDescriptionsEgressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateSecurityGroupRuleDescriptionsEgressSync(UpdateSecurityGroupRuleDescriptionsEgressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateSecurityGroupRuleDescriptionsEgressAsync(UpdateSecurityGroupRuleDescriptionsEgressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSnapshot asynchronously, invoking a callback when done
-- @param CreateSnapshotRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateSnapshotAsync(CreateSnapshotRequest, cb)
	assert(CreateSnapshotRequest, "You must provide a CreateSnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSnapshot",
	}
	for header,value in pairs(CreateSnapshotRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSnapshotRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateSnapshotSync(CreateSnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSnapshotAsync(CreateSnapshotRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSubnet asynchronously, invoking a callback when done
-- @param CreateSubnetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateSubnetAsync(CreateSubnetRequest, cb)
	assert(CreateSubnetRequest, "You must provide a CreateSubnetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSubnet",
	}
	for header,value in pairs(CreateSubnetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSubnetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSubnet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSubnetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateSubnetSync(CreateSubnetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSubnetAsync(CreateSubnetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RequestSpotFleet asynchronously, invoking a callback when done
-- @param RequestSpotFleetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RequestSpotFleetAsync(RequestSpotFleetRequest, cb)
	assert(RequestSpotFleetRequest, "You must provide a RequestSpotFleetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RequestSpotFleet",
	}
	for header,value in pairs(RequestSpotFleetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RequestSpotFleetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RequestSpotFleet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RequestSpotFleetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RequestSpotFleetSync(RequestSpotFleetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RequestSpotFleetAsync(RequestSpotFleetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyImageAttribute asynchronously, invoking a callback when done
-- @param ModifyImageAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyImageAttributeAsync(ModifyImageAttributeRequest, cb)
	assert(ModifyImageAttributeRequest, "You must provide a ModifyImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyImageAttribute",
	}
	for header,value in pairs(ModifyImageAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyImageAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyImageAttributeSync(ModifyImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyImageAttributeAsync(ModifyImageAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstanceCapacityReservationAttributes asynchronously, invoking a callback when done
-- @param ModifyInstanceCapacityReservationAttributesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyInstanceCapacityReservationAttributesAsync(ModifyInstanceCapacityReservationAttributesRequest, cb)
	assert(ModifyInstanceCapacityReservationAttributesRequest, "You must provide a ModifyInstanceCapacityReservationAttributesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyInstanceCapacityReservationAttributes",
	}
	for header,value in pairs(ModifyInstanceCapacityReservationAttributesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyInstanceCapacityReservationAttributesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstanceCapacityReservationAttributes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstanceCapacityReservationAttributesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyInstanceCapacityReservationAttributesSync(ModifyInstanceCapacityReservationAttributesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstanceCapacityReservationAttributesAsync(ModifyInstanceCapacityReservationAttributesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateSubnetCidrBlock asynchronously, invoking a callback when done
-- @param AssociateSubnetCidrBlockRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssociateSubnetCidrBlockAsync(AssociateSubnetCidrBlockRequest, cb)
	assert(AssociateSubnetCidrBlockRequest, "You must provide a AssociateSubnetCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateSubnetCidrBlock",
	}
	for header,value in pairs(AssociateSubnetCidrBlockRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateSubnetCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateSubnetCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateSubnetCidrBlockRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssociateSubnetCidrBlockSync(AssociateSubnetCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateSubnetCidrBlockAsync(AssociateSubnetCidrBlockRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyFpgaImageAttribute asynchronously, invoking a callback when done
-- @param ModifyFpgaImageAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyFpgaImageAttributeAsync(ModifyFpgaImageAttributeRequest, cb)
	assert(ModifyFpgaImageAttributeRequest, "You must provide a ModifyFpgaImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyFpgaImageAttribute",
	}
	for header,value in pairs(ModifyFpgaImageAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyFpgaImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyFpgaImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyFpgaImageAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyFpgaImageAttributeSync(ModifyFpgaImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyFpgaImageAttributeAsync(ModifyFpgaImageAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StartInstances asynchronously, invoking a callback when done
-- @param StartInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StartInstancesAsync(StartInstancesRequest, cb)
	assert(StartInstancesRequest, "You must provide a StartInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".StartInstances",
	}
	for header,value in pairs(StartInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", StartInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StartInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StartInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StartInstancesSync(StartInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StartInstancesAsync(StartInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotInstanceRequests asynchronously, invoking a callback when done
-- @param DescribeSpotInstanceRequestsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSpotInstanceRequestsAsync(DescribeSpotInstanceRequestsRequest, cb)
	assert(DescribeSpotInstanceRequestsRequest, "You must provide a DescribeSpotInstanceRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotInstanceRequests",
	}
	for header,value in pairs(DescribeSpotInstanceRequestsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotInstanceRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotInstanceRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotInstanceRequestsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSpotInstanceRequestsSync(DescribeSpotInstanceRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotInstanceRequestsAsync(DescribeSpotInstanceRequestsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVgwRoutePropagation asynchronously, invoking a callback when done
-- @param DisableVgwRoutePropagationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisableVgwRoutePropagationAsync(DisableVgwRoutePropagationRequest, cb)
	assert(DisableVgwRoutePropagationRequest, "You must provide a DisableVgwRoutePropagationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisableVgwRoutePropagation",
	}
	for header,value in pairs(DisableVgwRoutePropagationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisableVgwRoutePropagationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVgwRoutePropagation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVgwRoutePropagationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisableVgwRoutePropagationSync(DisableVgwRoutePropagationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVgwRoutePropagationAsync(DisableVgwRoutePropagationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetFpgaImageAttribute asynchronously, invoking a callback when done
-- @param ResetFpgaImageAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ResetFpgaImageAttributeAsync(ResetFpgaImageAttributeRequest, cb)
	assert(ResetFpgaImageAttributeRequest, "You must provide a ResetFpgaImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetFpgaImageAttribute",
	}
	for header,value in pairs(ResetFpgaImageAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetFpgaImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetFpgaImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetFpgaImageAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ResetFpgaImageAttributeSync(ResetFpgaImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetFpgaImageAttributeAsync(ResetFpgaImageAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcs asynchronously, invoking a callback when done
-- @param DescribeVpcsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcsAsync(DescribeVpcsRequest, cb)
	assert(DescribeVpcsRequest, "You must provide a DescribeVpcsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcs",
	}
	for header,value in pairs(DescribeVpcsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcsSync(DescribeVpcsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcsAsync(DescribeVpcsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateAddress asynchronously, invoking a callback when done
-- @param DisassociateAddressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisassociateAddressAsync(DisassociateAddressRequest, cb)
	assert(DisassociateAddressRequest, "You must provide a DisassociateAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateAddress",
	}
	for header,value in pairs(DisassociateAddressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateAddressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisassociateAddressSync(DisassociateAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateAddressAsync(DisassociateAddressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySnapshotAttribute asynchronously, invoking a callback when done
-- @param ModifySnapshotAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifySnapshotAttributeAsync(ModifySnapshotAttributeRequest, cb)
	assert(ModifySnapshotAttributeRequest, "You must provide a ModifySnapshotAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifySnapshotAttribute",
	}
	for header,value in pairs(ModifySnapshotAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifySnapshotAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySnapshotAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifySnapshotAttributeSync(ModifySnapshotAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySnapshotAttributeAsync(ModifySnapshotAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call MoveAddressToVpc asynchronously, invoking a callback when done
-- @param MoveAddressToVpcRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.MoveAddressToVpcAsync(MoveAddressToVpcRequest, cb)
	assert(MoveAddressToVpcRequest, "You must provide a MoveAddressToVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".MoveAddressToVpc",
	}
	for header,value in pairs(MoveAddressToVpcRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", MoveAddressToVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call MoveAddressToVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param MoveAddressToVpcRequest
-- @return response
-- @return error_type
-- @return error_message
function M.MoveAddressToVpcSync(MoveAddressToVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.MoveAddressToVpcAsync(MoveAddressToVpcRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcEndpointConnectionNotification asynchronously, invoking a callback when done
-- @param ModifyVpcEndpointConnectionNotificationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVpcEndpointConnectionNotificationAsync(ModifyVpcEndpointConnectionNotificationRequest, cb)
	assert(ModifyVpcEndpointConnectionNotificationRequest, "You must provide a ModifyVpcEndpointConnectionNotificationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcEndpointConnectionNotification",
	}
	for header,value in pairs(ModifyVpcEndpointConnectionNotificationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcEndpointConnectionNotificationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcEndpointConnectionNotification synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcEndpointConnectionNotificationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVpcEndpointConnectionNotificationSync(ModifyVpcEndpointConnectionNotificationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcEndpointConnectionNotificationAsync(ModifyVpcEndpointConnectionNotificationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstanceAttribute asynchronously, invoking a callback when done
-- @param ModifyInstanceAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyInstanceAttributeAsync(ModifyInstanceAttributeRequest, cb)
	assert(ModifyInstanceAttributeRequest, "You must provide a ModifyInstanceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyInstanceAttribute",
	}
	for header,value in pairs(ModifyInstanceAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyInstanceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstanceAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyInstanceAttributeSync(ModifyInstanceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstanceAttributeAsync(ModifyInstanceAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpc asynchronously, invoking a callback when done
-- @param CreateVpcRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpcAsync(CreateVpcRequest, cb)
	assert(CreateVpcRequest, "You must provide a CreateVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpc",
	}
	for header,value in pairs(CreateVpcRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpcSync(CreateVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcAsync(CreateVpcRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpointServices asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointServicesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcEndpointServicesAsync(DescribeVpcEndpointServicesRequest, cb)
	assert(DescribeVpcEndpointServicesRequest, "You must provide a DescribeVpcEndpointServicesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointServices",
	}
	for header,value in pairs(DescribeVpcEndpointServicesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointServicesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpointServices synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointServicesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcEndpointServicesSync(DescribeVpcEndpointServicesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointServicesAsync(DescribeVpcEndpointServicesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelSpotFleetRequests asynchronously, invoking a callback when done
-- @param CancelSpotFleetRequestsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelSpotFleetRequestsAsync(CancelSpotFleetRequestsRequest, cb)
	assert(CancelSpotFleetRequestsRequest, "You must provide a CancelSpotFleetRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelSpotFleetRequests",
	}
	for header,value in pairs(CancelSpotFleetRequestsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelSpotFleetRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelSpotFleetRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelSpotFleetRequestsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelSpotFleetRequestsSync(CancelSpotFleetRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelSpotFleetRequestsAsync(CancelSpotFleetRequestsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UnmonitorInstances asynchronously, invoking a callback when done
-- @param UnmonitorInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UnmonitorInstancesAsync(UnmonitorInstancesRequest, cb)
	assert(UnmonitorInstancesRequest, "You must provide a UnmonitorInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UnmonitorInstances",
	}
	for header,value in pairs(UnmonitorInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UnmonitorInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UnmonitorInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnmonitorInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UnmonitorInstancesSync(UnmonitorInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnmonitorInstancesAsync(UnmonitorInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSubnet asynchronously, invoking a callback when done
-- @param DeleteSubnetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteSubnetAsync(DeleteSubnetRequest, cb)
	assert(DeleteSubnetRequest, "You must provide a DeleteSubnetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSubnet",
	}
	for header,value in pairs(DeleteSubnetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSubnetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSubnet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSubnetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteSubnetSync(DeleteSubnetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSubnetAsync(DeleteSubnetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreatePlacementGroup asynchronously, invoking a callback when done
-- @param CreatePlacementGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreatePlacementGroupAsync(CreatePlacementGroupRequest, cb)
	assert(CreatePlacementGroupRequest, "You must provide a CreatePlacementGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreatePlacementGroup",
	}
	for header,value in pairs(CreatePlacementGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreatePlacementGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreatePlacementGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreatePlacementGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreatePlacementGroupSync(CreatePlacementGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreatePlacementGroupAsync(CreatePlacementGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CopySnapshot asynchronously, invoking a callback when done
-- @param CopySnapshotRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CopySnapshotAsync(CopySnapshotRequest, cb)
	assert(CopySnapshotRequest, "You must provide a CopySnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CopySnapshot",
	}
	for header,value in pairs(CopySnapshotRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CopySnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CopySnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CopySnapshotRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CopySnapshotSync(CopySnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CopySnapshotAsync(CopySnapshotRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param DisableVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisableVpcClassicLinkDnsSupportAsync(DisableVpcClassicLinkDnsSupportRequest, cb)
	assert(DisableVpcClassicLinkDnsSupportRequest, "You must provide a DisableVpcClassicLinkDnsSupportRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLinkDnsSupport",
	}
	for header,value in pairs(DisableVpcClassicLinkDnsSupportRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisableVpcClassicLinkDnsSupportRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisableVpcClassicLinkDnsSupportSync(DisableVpcClassicLinkDnsSupportRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVpcClassicLinkDnsSupportAsync(DisableVpcClassicLinkDnsSupportRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHostReservationOfferings asynchronously, invoking a callback when done
-- @param DescribeHostReservationOfferingsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeHostReservationOfferingsAsync(DescribeHostReservationOfferingsRequest, cb)
	assert(DescribeHostReservationOfferingsRequest, "You must provide a DescribeHostReservationOfferingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeHostReservationOfferings",
	}
	for header,value in pairs(DescribeHostReservationOfferingsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeHostReservationOfferingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHostReservationOfferings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostReservationOfferingsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeHostReservationOfferingsSync(DescribeHostReservationOfferingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostReservationOfferingsAsync(DescribeHostReservationOfferingsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumesModifications asynchronously, invoking a callback when done
-- @param DescribeVolumesModificationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVolumesModificationsAsync(DescribeVolumesModificationsRequest, cb)
	assert(DescribeVolumesModificationsRequest, "You must provide a DescribeVolumesModificationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumesModifications",
	}
	for header,value in pairs(DescribeVolumesModificationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumesModificationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumesModifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumesModificationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVolumesModificationsSync(DescribeVolumesModificationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumesModificationsAsync(DescribeVolumesModificationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpnGateways asynchronously, invoking a callback when done
-- @param DescribeVpnGatewaysRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpnGatewaysAsync(DescribeVpnGatewaysRequest, cb)
	assert(DescribeVpnGatewaysRequest, "You must provide a DescribeVpnGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpnGateways",
	}
	for header,value in pairs(DescribeVpnGatewaysRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpnGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpnGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpnGatewaysRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpnGatewaysSync(DescribeVpnGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpnGatewaysAsync(DescribeVpnGatewaysRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateVpcCidrBlock asynchronously, invoking a callback when done
-- @param AssociateVpcCidrBlockRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssociateVpcCidrBlockAsync(AssociateVpcCidrBlockRequest, cb)
	assert(AssociateVpcCidrBlockRequest, "You must provide a AssociateVpcCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateVpcCidrBlock",
	}
	for header,value in pairs(AssociateVpcCidrBlockRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateVpcCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateVpcCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateVpcCidrBlockRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssociateVpcCidrBlockSync(AssociateVpcCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateVpcCidrBlockAsync(AssociateVpcCidrBlockRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateAddress asynchronously, invoking a callback when done
-- @param AssociateAddressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssociateAddressAsync(AssociateAddressRequest, cb)
	assert(AssociateAddressRequest, "You must provide a AssociateAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateAddress",
	}
	for header,value in pairs(AssociateAddressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateAddressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssociateAddressSync(AssociateAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateAddressAsync(AssociateAddressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteCustomerGateway asynchronously, invoking a callback when done
-- @param DeleteCustomerGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteCustomerGatewayAsync(DeleteCustomerGatewayRequest, cb)
	assert(DeleteCustomerGatewayRequest, "You must provide a DeleteCustomerGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteCustomerGateway",
	}
	for header,value in pairs(DeleteCustomerGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteCustomerGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteCustomerGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteCustomerGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteCustomerGatewaySync(DeleteCustomerGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteCustomerGatewayAsync(DeleteCustomerGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CopyFpgaImage asynchronously, invoking a callback when done
-- @param CopyFpgaImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CopyFpgaImageAsync(CopyFpgaImageRequest, cb)
	assert(CopyFpgaImageRequest, "You must provide a CopyFpgaImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CopyFpgaImage",
	}
	for header,value in pairs(CopyFpgaImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CopyFpgaImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CopyFpgaImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CopyFpgaImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CopyFpgaImageSync(CopyFpgaImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CopyFpgaImageAsync(CopyFpgaImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateInternetGateway asynchronously, invoking a callback when done
-- @param CreateInternetGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateInternetGatewayAsync(CreateInternetGatewayRequest, cb)
	assert(CreateInternetGatewayRequest, "You must provide a CreateInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateInternetGateway",
	}
	for header,value in pairs(CreateInternetGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateInternetGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateInternetGatewaySync(CreateInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateInternetGatewayAsync(CreateInternetGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateLaunchTemplate asynchronously, invoking a callback when done
-- @param CreateLaunchTemplateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateLaunchTemplateAsync(CreateLaunchTemplateRequest, cb)
	assert(CreateLaunchTemplateRequest, "You must provide a CreateLaunchTemplateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateLaunchTemplate",
	}
	for header,value in pairs(CreateLaunchTemplateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateLaunchTemplateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateLaunchTemplate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateLaunchTemplateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateLaunchTemplateSync(CreateLaunchTemplateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateLaunchTemplateAsync(CreateLaunchTemplateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachClassicLinkVpc asynchronously, invoking a callback when done
-- @param AttachClassicLinkVpcRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachClassicLinkVpcAsync(AttachClassicLinkVpcRequest, cb)
	assert(AttachClassicLinkVpcRequest, "You must provide a AttachClassicLinkVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachClassicLinkVpc",
	}
	for header,value in pairs(AttachClassicLinkVpcRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachClassicLinkVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachClassicLinkVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachClassicLinkVpcRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachClassicLinkVpcSync(AttachClassicLinkVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachClassicLinkVpcAsync(AttachClassicLinkVpcRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotPriceHistory asynchronously, invoking a callback when done
-- @param DescribeSpotPriceHistoryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSpotPriceHistoryAsync(DescribeSpotPriceHistoryRequest, cb)
	assert(DescribeSpotPriceHistoryRequest, "You must provide a DescribeSpotPriceHistoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotPriceHistory",
	}
	for header,value in pairs(DescribeSpotPriceHistoryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotPriceHistoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotPriceHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotPriceHistoryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSpotPriceHistorySync(DescribeSpotPriceHistoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotPriceHistoryAsync(DescribeSpotPriceHistoryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeDhcpOptions asynchronously, invoking a callback when done
-- @param DescribeDhcpOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeDhcpOptionsAsync(DescribeDhcpOptionsRequest, cb)
	assert(DescribeDhcpOptionsRequest, "You must provide a DescribeDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeDhcpOptions",
	}
	for header,value in pairs(DescribeDhcpOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeDhcpOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeDhcpOptionsSync(DescribeDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeDhcpOptionsAsync(DescribeDhcpOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcPeeringConnection asynchronously, invoking a callback when done
-- @param DeleteVpcPeeringConnectionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpcPeeringConnectionAsync(DeleteVpcPeeringConnectionRequest, cb)
	assert(DeleteVpcPeeringConnectionRequest, "You must provide a DeleteVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpcPeeringConnection",
	}
	for header,value in pairs(DeleteVpcPeeringConnectionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcPeeringConnectionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpcPeeringConnectionSync(DeleteVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcPeeringConnectionAsync(DeleteVpcPeeringConnectionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFlowLogs asynchronously, invoking a callback when done
-- @param DescribeFlowLogsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeFlowLogsAsync(DescribeFlowLogsRequest, cb)
	assert(DescribeFlowLogsRequest, "You must provide a DescribeFlowLogsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFlowLogs",
	}
	for header,value in pairs(DescribeFlowLogsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFlowLogsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFlowLogsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeFlowLogsSync(DescribeFlowLogsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFlowLogsAsync(DescribeFlowLogsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkAclEntry asynchronously, invoking a callback when done
-- @param CreateNetworkAclEntryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateNetworkAclEntryAsync(CreateNetworkAclEntryRequest, cb)
	assert(CreateNetworkAclEntryRequest, "You must provide a CreateNetworkAclEntryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNetworkAclEntry",
	}
	for header,value in pairs(CreateNetworkAclEntryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNetworkAclEntryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkAclEntryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateNetworkAclEntrySync(CreateNetworkAclEntryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkAclEntryAsync(CreateNetworkAclEntryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReleaseHosts asynchronously, invoking a callback when done
-- @param ReleaseHostsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReleaseHostsAsync(ReleaseHostsRequest, cb)
	assert(ReleaseHostsRequest, "You must provide a ReleaseHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReleaseHosts",
	}
	for header,value in pairs(ReleaseHostsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReleaseHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReleaseHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReleaseHostsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReleaseHostsSync(ReleaseHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReleaseHostsAsync(ReleaseHostsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RestoreAddressToClassic asynchronously, invoking a callback when done
-- @param RestoreAddressToClassicRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RestoreAddressToClassicAsync(RestoreAddressToClassicRequest, cb)
	assert(RestoreAddressToClassicRequest, "You must provide a RestoreAddressToClassicRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RestoreAddressToClassic",
	}
	for header,value in pairs(RestoreAddressToClassicRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RestoreAddressToClassicRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RestoreAddressToClassic synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RestoreAddressToClassicRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RestoreAddressToClassicSync(RestoreAddressToClassicRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RestoreAddressToClassicAsync(RestoreAddressToClassicRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNetworkInterface asynchronously, invoking a callback when done
-- @param CreateNetworkInterfaceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateNetworkInterfaceAsync(CreateNetworkInterfaceRequest, cb)
	assert(CreateNetworkInterfaceRequest, "You must provide a CreateNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNetworkInterface",
	}
	for header,value in pairs(CreateNetworkInterfaceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNetworkInterfaceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateNetworkInterfaceSync(CreateNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNetworkInterfaceAsync(CreateNetworkInterfaceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteLaunchTemplateVersions asynchronously, invoking a callback when done
-- @param DeleteLaunchTemplateVersionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteLaunchTemplateVersionsAsync(DeleteLaunchTemplateVersionsRequest, cb)
	assert(DeleteLaunchTemplateVersionsRequest, "You must provide a DeleteLaunchTemplateVersionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteLaunchTemplateVersions",
	}
	for header,value in pairs(DeleteLaunchTemplateVersionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteLaunchTemplateVersionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteLaunchTemplateVersions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteLaunchTemplateVersionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteLaunchTemplateVersionsSync(DeleteLaunchTemplateVersionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteLaunchTemplateVersionsAsync(DeleteLaunchTemplateVersionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RevokeSecurityGroupIngress asynchronously, invoking a callback when done
-- @param RevokeSecurityGroupIngressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RevokeSecurityGroupIngressAsync(RevokeSecurityGroupIngressRequest, cb)
	assert(RevokeSecurityGroupIngressRequest, "You must provide a RevokeSecurityGroupIngressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupIngress",
	}
	for header,value in pairs(RevokeSecurityGroupIngressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RevokeSecurityGroupIngressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RevokeSecurityGroupIngress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RevokeSecurityGroupIngressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RevokeSecurityGroupIngressSync(RevokeSecurityGroupIngressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RevokeSecurityGroupIngressAsync(RevokeSecurityGroupIngressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UnassignPrivateIpAddresses asynchronously, invoking a callback when done
-- @param UnassignPrivateIpAddressesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UnassignPrivateIpAddressesAsync(UnassignPrivateIpAddressesRequest, cb)
	assert(UnassignPrivateIpAddressesRequest, "You must provide a UnassignPrivateIpAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UnassignPrivateIpAddresses",
	}
	for header,value in pairs(UnassignPrivateIpAddressesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UnassignPrivateIpAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UnassignPrivateIpAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnassignPrivateIpAddressesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UnassignPrivateIpAddressesSync(UnassignPrivateIpAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnassignPrivateIpAddressesAsync(UnassignPrivateIpAddressesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachInternetGateway asynchronously, invoking a callback when done
-- @param AttachInternetGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachInternetGatewayAsync(AttachInternetGatewayRequest, cb)
	assert(AttachInternetGatewayRequest, "You must provide a AttachInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachInternetGateway",
	}
	for header,value in pairs(AttachInternetGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachInternetGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachInternetGatewaySync(AttachInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachInternetGatewayAsync(AttachInternetGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateInstanceExportTask asynchronously, invoking a callback when done
-- @param CreateInstanceExportTaskRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateInstanceExportTaskAsync(CreateInstanceExportTaskRequest, cb)
	assert(CreateInstanceExportTaskRequest, "You must provide a CreateInstanceExportTaskRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateInstanceExportTask",
	}
	for header,value in pairs(CreateInstanceExportTaskRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateInstanceExportTaskRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateInstanceExportTask synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateInstanceExportTaskRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateInstanceExportTaskSync(CreateInstanceExportTaskRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateInstanceExportTaskAsync(CreateInstanceExportTaskRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteDhcpOptions asynchronously, invoking a callback when done
-- @param DeleteDhcpOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteDhcpOptionsAsync(DeleteDhcpOptionsRequest, cb)
	assert(DeleteDhcpOptionsRequest, "You must provide a DeleteDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteDhcpOptions",
	}
	for header,value in pairs(DeleteDhcpOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteDhcpOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteDhcpOptionsSync(DeleteDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteDhcpOptionsAsync(DeleteDhcpOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param ResetNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ResetNetworkInterfaceAttributeAsync(ResetNetworkInterfaceAttributeRequest, cb)
	assert(ResetNetworkInterfaceAttributeRequest, "You must provide a ResetNetworkInterfaceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetNetworkInterfaceAttribute",
	}
	for header,value in pairs(ResetNetworkInterfaceAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetNetworkInterfaceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetNetworkInterfaceAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ResetNetworkInterfaceAttributeSync(ResetNetworkInterfaceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetNetworkInterfaceAttributeAsync(ResetNetworkInterfaceAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyReservedInstances asynchronously, invoking a callback when done
-- @param ModifyReservedInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyReservedInstancesAsync(ModifyReservedInstancesRequest, cb)
	assert(ModifyReservedInstancesRequest, "You must provide a ModifyReservedInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyReservedInstances",
	}
	for header,value in pairs(ModifyReservedInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyReservedInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyReservedInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyReservedInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyReservedInstancesSync(ModifyReservedInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyReservedInstancesAsync(ModifyReservedInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachNetworkInterface asynchronously, invoking a callback when done
-- @param DetachNetworkInterfaceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachNetworkInterfaceAsync(DetachNetworkInterfaceRequest, cb)
	assert(DetachNetworkInterfaceRequest, "You must provide a DetachNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachNetworkInterface",
	}
	for header,value in pairs(DetachNetworkInterfaceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachNetworkInterfaceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachNetworkInterfaceSync(DetachNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachNetworkInterfaceAsync(DetachNetworkInterfaceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImportImageTasks asynchronously, invoking a callback when done
-- @param DescribeImportImageTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeImportImageTasksAsync(DescribeImportImageTasksRequest, cb)
	assert(DescribeImportImageTasksRequest, "You must provide a DescribeImportImageTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImportImageTasks",
	}
	for header,value in pairs(DescribeImportImageTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImportImageTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImportImageTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImportImageTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeImportImageTasksSync(DescribeImportImageTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImportImageTasksAsync(DescribeImportImageTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpointServicePermissions asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointServicePermissionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcEndpointServicePermissionsAsync(DescribeVpcEndpointServicePermissionsRequest, cb)
	assert(DescribeVpcEndpointServicePermissionsRequest, "You must provide a DescribeVpcEndpointServicePermissionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointServicePermissions",
	}
	for header,value in pairs(DescribeVpcEndpointServicePermissionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointServicePermissionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpointServicePermissions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointServicePermissionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcEndpointServicePermissionsSync(DescribeVpcEndpointServicePermissionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointServicePermissionsAsync(DescribeVpcEndpointServicePermissionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotFleetInstances asynchronously, invoking a callback when done
-- @param DescribeSpotFleetInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSpotFleetInstancesAsync(DescribeSpotFleetInstancesRequest, cb)
	assert(DescribeSpotFleetInstancesRequest, "You must provide a DescribeSpotFleetInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotFleetInstances",
	}
	for header,value in pairs(DescribeSpotFleetInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotFleetInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotFleetInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotFleetInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSpotFleetInstancesSync(DescribeSpotFleetInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotFleetInstancesAsync(DescribeSpotFleetInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVpcClassicLink asynchronously, invoking a callback when done
-- @param EnableVpcClassicLinkRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.EnableVpcClassicLinkAsync(EnableVpcClassicLinkRequest, cb)
	assert(EnableVpcClassicLinkRequest, "You must provide a EnableVpcClassicLinkRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVpcClassicLink",
	}
	for header,value in pairs(EnableVpcClassicLinkRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVpcClassicLinkRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVpcClassicLinkRequest
-- @return response
-- @return error_type
-- @return error_message
function M.EnableVpcClassicLinkSync(EnableVpcClassicLinkRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVpcClassicLinkAsync(EnableVpcClassicLinkRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateFlowLogs asynchronously, invoking a callback when done
-- @param CreateFlowLogsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateFlowLogsAsync(CreateFlowLogsRequest, cb)
	assert(CreateFlowLogsRequest, "You must provide a CreateFlowLogsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateFlowLogs",
	}
	for header,value in pairs(CreateFlowLogsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateFlowLogsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateFlowLogsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateFlowLogsSync(CreateFlowLogsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateFlowLogsAsync(CreateFlowLogsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateVpcCidrBlock asynchronously, invoking a callback when done
-- @param DisassociateVpcCidrBlockRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisassociateVpcCidrBlockAsync(DisassociateVpcCidrBlockRequest, cb)
	assert(DisassociateVpcCidrBlockRequest, "You must provide a DisassociateVpcCidrBlockRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateVpcCidrBlock",
	}
	for header,value in pairs(DisassociateVpcCidrBlockRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateVpcCidrBlockRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateVpcCidrBlock synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateVpcCidrBlockRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisassociateVpcCidrBlockSync(DisassociateVpcCidrBlockRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateVpcCidrBlockAsync(DisassociateVpcCidrBlockRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateDefaultSubnet asynchronously, invoking a callback when done
-- @param CreateDefaultSubnetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateDefaultSubnetAsync(CreateDefaultSubnetRequest, cb)
	assert(CreateDefaultSubnetRequest, "You must provide a CreateDefaultSubnetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateDefaultSubnet",
	}
	for header,value in pairs(CreateDefaultSubnetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateDefaultSubnetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateDefaultSubnet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateDefaultSubnetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateDefaultSubnetSync(CreateDefaultSubnetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateDefaultSubnetAsync(CreateDefaultSubnetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcEndpointConnectionNotifications asynchronously, invoking a callback when done
-- @param DeleteVpcEndpointConnectionNotificationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpcEndpointConnectionNotificationsAsync(DeleteVpcEndpointConnectionNotificationsRequest, cb)
	assert(DeleteVpcEndpointConnectionNotificationsRequest, "You must provide a DeleteVpcEndpointConnectionNotificationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpcEndpointConnectionNotifications",
	}
	for header,value in pairs(DeleteVpcEndpointConnectionNotificationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcEndpointConnectionNotificationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcEndpointConnectionNotifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcEndpointConnectionNotificationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpcEndpointConnectionNotificationsSync(DeleteVpcEndpointConnectionNotificationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcEndpointConnectionNotificationsAsync(DeleteVpcEndpointConnectionNotificationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumeStatus asynchronously, invoking a callback when done
-- @param DescribeVolumeStatusRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVolumeStatusAsync(DescribeVolumeStatusRequest, cb)
	assert(DescribeVolumeStatusRequest, "You must provide a DescribeVolumeStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumeStatus",
	}
	for header,value in pairs(DescribeVolumeStatusRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumeStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumeStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumeStatusRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVolumeStatusSync(DescribeVolumeStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumeStatusAsync(DescribeVolumeStatusRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHosts asynchronously, invoking a callback when done
-- @param DescribeHostsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeHostsAsync(DescribeHostsRequest, cb)
	assert(DescribeHostsRequest, "You must provide a DescribeHostsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeHosts",
	}
	for header,value in pairs(DescribeHostsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeHostsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHosts synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeHostsSync(DescribeHostsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostsAsync(DescribeHostsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcPeeringConnections asynchronously, invoking a callback when done
-- @param DescribeVpcPeeringConnectionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcPeeringConnectionsAsync(DescribeVpcPeeringConnectionsRequest, cb)
	assert(DescribeVpcPeeringConnectionsRequest, "You must provide a DescribeVpcPeeringConnectionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcPeeringConnections",
	}
	for header,value in pairs(DescribeVpcPeeringConnectionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcPeeringConnectionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcPeeringConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcPeeringConnectionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcPeeringConnectionsSync(DescribeVpcPeeringConnectionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcPeeringConnectionsAsync(DescribeVpcPeeringConnectionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumes asynchronously, invoking a callback when done
-- @param DescribeVolumesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVolumesAsync(DescribeVolumesRequest, cb)
	assert(DescribeVolumesRequest, "You must provide a DescribeVolumesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumes",
	}
	for header,value in pairs(DescribeVolumesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVolumesSync(DescribeVolumesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumesAsync(DescribeVolumesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkInterface asynchronously, invoking a callback when done
-- @param DeleteNetworkInterfaceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteNetworkInterfaceAsync(DeleteNetworkInterfaceRequest, cb)
	assert(DeleteNetworkInterfaceRequest, "You must provide a DeleteNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNetworkInterface",
	}
	for header,value in pairs(DeleteNetworkInterfaceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkInterfaceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteNetworkInterfaceSync(DeleteNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkInterfaceAsync(DeleteNetworkInterfaceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpnConnections asynchronously, invoking a callback when done
-- @param DescribeVpnConnectionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpnConnectionsAsync(DescribeVpnConnectionsRequest, cb)
	assert(DescribeVpnConnectionsRequest, "You must provide a DescribeVpnConnectionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpnConnections",
	}
	for header,value in pairs(DescribeVpnConnectionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpnConnectionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpnConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpnConnectionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpnConnectionsSync(DescribeVpnConnectionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpnConnectionsAsync(DescribeVpnConnectionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcEndpoints asynchronously, invoking a callback when done
-- @param DeleteVpcEndpointsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpcEndpointsAsync(DeleteVpcEndpointsRequest, cb)
	assert(DeleteVpcEndpointsRequest, "You must provide a DeleteVpcEndpointsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpcEndpoints",
	}
	for header,value in pairs(DeleteVpcEndpointsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcEndpointsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcEndpoints synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcEndpointsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpcEndpointsSync(DeleteVpcEndpointsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcEndpointsAsync(DeleteVpcEndpointsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVolumeAttribute asynchronously, invoking a callback when done
-- @param DescribeVolumeAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVolumeAttributeAsync(DescribeVolumeAttributeRequest, cb)
	assert(DescribeVolumeAttributeRequest, "You must provide a DescribeVolumeAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVolumeAttribute",
	}
	for header,value in pairs(DescribeVolumeAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVolumeAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVolumeAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVolumeAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVolumeAttributeSync(DescribeVolumeAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVolumeAttributeAsync(DescribeVolumeAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteKeyPair asynchronously, invoking a callback when done
-- @param DeleteKeyPairRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteKeyPairAsync(DeleteKeyPairRequest, cb)
	assert(DeleteKeyPairRequest, "You must provide a DeleteKeyPairRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteKeyPair",
	}
	for header,value in pairs(DeleteKeyPairRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteKeyPairRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteKeyPairRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteKeyPairSync(DeleteKeyPairRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteKeyPairAsync(DeleteKeyPairRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNatGateway asynchronously, invoking a callback when done
-- @param DeleteNatGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteNatGatewayAsync(DeleteNatGatewayRequest, cb)
	assert(DeleteNatGatewayRequest, "You must provide a DeleteNatGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNatGateway",
	}
	for header,value in pairs(DeleteNatGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNatGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNatGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNatGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteNatGatewaySync(DeleteNatGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNatGatewayAsync(DeleteNatGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UnassignIpv6Addresses asynchronously, invoking a callback when done
-- @param UnassignIpv6AddressesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UnassignIpv6AddressesAsync(UnassignIpv6AddressesRequest, cb)
	assert(UnassignIpv6AddressesRequest, "You must provide a UnassignIpv6AddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UnassignIpv6Addresses",
	}
	for header,value in pairs(UnassignIpv6AddressesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UnassignIpv6AddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UnassignIpv6Addresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UnassignIpv6AddressesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UnassignIpv6AddressesSync(UnassignIpv6AddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UnassignIpv6AddressesAsync(UnassignIpv6AddressesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyInstancePlacement asynchronously, invoking a callback when done
-- @param ModifyInstancePlacementRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyInstancePlacementAsync(ModifyInstancePlacementRequest, cb)
	assert(ModifyInstancePlacementRequest, "You must provide a ModifyInstancePlacementRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyInstancePlacement",
	}
	for header,value in pairs(ModifyInstancePlacementRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyInstancePlacementRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyInstancePlacement synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyInstancePlacementRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyInstancePlacementSync(ModifyInstancePlacementRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyInstancePlacementAsync(ModifyInstancePlacementRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call UpdateSecurityGroupRuleDescriptionsIngress asynchronously, invoking a callback when done
-- @param UpdateSecurityGroupRuleDescriptionsIngressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.UpdateSecurityGroupRuleDescriptionsIngressAsync(UpdateSecurityGroupRuleDescriptionsIngressRequest, cb)
	assert(UpdateSecurityGroupRuleDescriptionsIngressRequest, "You must provide a UpdateSecurityGroupRuleDescriptionsIngressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".UpdateSecurityGroupRuleDescriptionsIngress",
	}
	for header,value in pairs(UpdateSecurityGroupRuleDescriptionsIngressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", UpdateSecurityGroupRuleDescriptionsIngressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call UpdateSecurityGroupRuleDescriptionsIngress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param UpdateSecurityGroupRuleDescriptionsIngressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.UpdateSecurityGroupRuleDescriptionsIngressSync(UpdateSecurityGroupRuleDescriptionsIngressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.UpdateSecurityGroupRuleDescriptionsIngressAsync(UpdateSecurityGroupRuleDescriptionsIngressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceNetworkAclEntry asynchronously, invoking a callback when done
-- @param ReplaceNetworkAclEntryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReplaceNetworkAclEntryAsync(ReplaceNetworkAclEntryRequest, cb)
	assert(ReplaceNetworkAclEntryRequest, "You must provide a ReplaceNetworkAclEntryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclEntry",
	}
	for header,value in pairs(ReplaceNetworkAclEntryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceNetworkAclEntryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceNetworkAclEntryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReplaceNetworkAclEntrySync(ReplaceNetworkAclEntryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceNetworkAclEntryAsync(ReplaceNetworkAclEntryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateEgressOnlyInternetGateway asynchronously, invoking a callback when done
-- @param CreateEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateEgressOnlyInternetGatewayAsync(CreateEgressOnlyInternetGatewayRequest, cb)
	assert(CreateEgressOnlyInternetGatewayRequest, "You must provide a CreateEgressOnlyInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateEgressOnlyInternetGateway",
	}
	for header,value in pairs(CreateEgressOnlyInternetGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateEgressOnlyInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateEgressOnlyInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateEgressOnlyInternetGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateEgressOnlyInternetGatewaySync(CreateEgressOnlyInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateEgressOnlyInternetGatewayAsync(CreateEgressOnlyInternetGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteInternetGateway asynchronously, invoking a callback when done
-- @param DeleteInternetGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteInternetGatewayAsync(DeleteInternetGatewayRequest, cb)
	assert(DeleteInternetGatewayRequest, "You must provide a DeleteInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteInternetGateway",
	}
	for header,value in pairs(DeleteInternetGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteInternetGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteInternetGatewaySync(DeleteInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteInternetGatewayAsync(DeleteInternetGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVolume asynchronously, invoking a callback when done
-- @param CreateVolumeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVolumeAsync(CreateVolumeRequest, cb)
	assert(CreateVolumeRequest, "You must provide a CreateVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVolume",
	}
	for header,value in pairs(CreateVolumeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVolumeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVolumeSync(CreateVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVolumeAsync(CreateVolumeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RunInstances asynchronously, invoking a callback when done
-- @param RunInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RunInstancesAsync(RunInstancesRequest, cb)
	assert(RunInstancesRequest, "You must provide a RunInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RunInstances",
	}
	for header,value in pairs(RunInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RunInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RunInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RunInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RunInstancesSync(RunInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RunInstancesAsync(RunInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeScheduledInstances asynchronously, invoking a callback when done
-- @param DescribeScheduledInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeScheduledInstancesAsync(DescribeScheduledInstancesRequest, cb)
	assert(DescribeScheduledInstancesRequest, "You must provide a DescribeScheduledInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeScheduledInstances",
	}
	for header,value in pairs(DescribeScheduledInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeScheduledInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeScheduledInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeScheduledInstancesSync(DescribeScheduledInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeScheduledInstancesAsync(DescribeScheduledInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRoute asynchronously, invoking a callback when done
-- @param DeleteRouteRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteRouteAsync(DeleteRouteRequest, cb)
	assert(DeleteRouteRequest, "You must provide a DeleteRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteRoute",
	}
	for header,value in pairs(DeleteRouteRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRouteRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteRouteSync(DeleteRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRouteAsync(DeleteRouteRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateDefaultVpc asynchronously, invoking a callback when done
-- @param CreateDefaultVpcRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateDefaultVpcAsync(CreateDefaultVpcRequest, cb)
	assert(CreateDefaultVpcRequest, "You must provide a CreateDefaultVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateDefaultVpc",
	}
	for header,value in pairs(CreateDefaultVpcRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateDefaultVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateDefaultVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateDefaultVpcRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateDefaultVpcSync(CreateDefaultVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateDefaultVpcAsync(CreateDefaultVpcRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisableVpcClassicLink asynchronously, invoking a callback when done
-- @param DisableVpcClassicLinkRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisableVpcClassicLinkAsync(DisableVpcClassicLinkRequest, cb)
	assert(DisableVpcClassicLinkRequest, "You must provide a DisableVpcClassicLinkRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisableVpcClassicLink",
	}
	for header,value in pairs(DisableVpcClassicLinkRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisableVpcClassicLinkRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisableVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisableVpcClassicLinkRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisableVpcClassicLinkSync(DisableVpcClassicLinkRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisableVpcClassicLinkAsync(DisableVpcClassicLinkRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachNetworkInterface asynchronously, invoking a callback when done
-- @param AttachNetworkInterfaceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachNetworkInterfaceAsync(AttachNetworkInterfaceRequest, cb)
	assert(AttachNetworkInterfaceRequest, "You must provide a AttachNetworkInterfaceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachNetworkInterface",
	}
	for header,value in pairs(AttachNetworkInterfaceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachNetworkInterfaceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachNetworkInterface synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachNetworkInterfaceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachNetworkInterfaceSync(AttachNetworkInterfaceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachNetworkInterfaceAsync(AttachNetworkInterfaceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateNatGateway asynchronously, invoking a callback when done
-- @param CreateNatGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateNatGatewayAsync(CreateNatGatewayRequest, cb)
	assert(CreateNatGatewayRequest, "You must provide a CreateNatGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateNatGateway",
	}
	for header,value in pairs(CreateNatGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateNatGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateNatGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateNatGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateNatGatewaySync(CreateNatGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateNatGatewayAsync(CreateNatGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnConnectionRoute asynchronously, invoking a callback when done
-- @param DeleteVpnConnectionRouteRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpnConnectionRouteAsync(DeleteVpnConnectionRouteRequest, cb)
	assert(DeleteVpnConnectionRouteRequest, "You must provide a DeleteVpnConnectionRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpnConnectionRoute",
	}
	for header,value in pairs(DeleteVpnConnectionRouteRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpnConnectionRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnConnectionRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnConnectionRouteRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpnConnectionRouteSync(DeleteVpnConnectionRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnConnectionRouteAsync(DeleteVpnConnectionRouteRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelSpotInstanceRequests asynchronously, invoking a callback when done
-- @param CancelSpotInstanceRequestsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelSpotInstanceRequestsAsync(CancelSpotInstanceRequestsRequest, cb)
	assert(CancelSpotInstanceRequestsRequest, "You must provide a CancelSpotInstanceRequestsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelSpotInstanceRequests",
	}
	for header,value in pairs(CancelSpotInstanceRequestsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelSpotInstanceRequestsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelSpotInstanceRequests synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelSpotInstanceRequestsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelSpotInstanceRequestsSync(CancelSpotInstanceRequestsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelSpotInstanceRequestsAsync(CancelSpotInstanceRequestsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateKeyPair asynchronously, invoking a callback when done
-- @param CreateKeyPairRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateKeyPairAsync(CreateKeyPairRequest, cb)
	assert(CreateKeyPairRequest, "You must provide a CreateKeyPairRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateKeyPair",
	}
	for header,value in pairs(CreateKeyPairRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateKeyPairRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateKeyPair synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateKeyPairRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateKeyPairSync(CreateKeyPairRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateKeyPairAsync(CreateKeyPairRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param DescribeNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeNetworkInterfaceAttributeAsync(DescribeNetworkInterfaceAttributeRequest, cb)
	assert(DescribeNetworkInterfaceAttributeRequest, "You must provide a DescribeNetworkInterfaceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaceAttribute",
	}
	for header,value in pairs(DescribeNetworkInterfaceAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNetworkInterfaceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkInterfaceAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeNetworkInterfaceAttributeSync(DescribeNetworkInterfaceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkInterfaceAttributeAsync(DescribeNetworkInterfaceAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeIdFormat asynchronously, invoking a callback when done
-- @param DescribeIdFormatRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeIdFormatAsync(DescribeIdFormatRequest, cb)
	assert(DescribeIdFormatRequest, "You must provide a DescribeIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeIdFormat",
	}
	for header,value in pairs(DescribeIdFormatRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeIdFormatRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeIdFormatSync(DescribeIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeIdFormatAsync(DescribeIdFormatRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyLaunchTemplate asynchronously, invoking a callback when done
-- @param ModifyLaunchTemplateRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyLaunchTemplateAsync(ModifyLaunchTemplateRequest, cb)
	assert(ModifyLaunchTemplateRequest, "You must provide a ModifyLaunchTemplateRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyLaunchTemplate",
	}
	for header,value in pairs(ModifyLaunchTemplateRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyLaunchTemplateRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyLaunchTemplate synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyLaunchTemplateRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyLaunchTemplateSync(ModifyLaunchTemplateRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyLaunchTemplateAsync(ModifyLaunchTemplateRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSnapshot asynchronously, invoking a callback when done
-- @param DeleteSnapshotRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteSnapshotAsync(DeleteSnapshotRequest, cb)
	assert(DeleteSnapshotRequest, "You must provide a DeleteSnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSnapshot",
	}
	for header,value in pairs(DeleteSnapshotRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSnapshotRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteSnapshotSync(DeleteSnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSnapshotAsync(DeleteSnapshotRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeMovingAddresses asynchronously, invoking a callback when done
-- @param DescribeMovingAddressesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeMovingAddressesAsync(DescribeMovingAddressesRequest, cb)
	assert(DescribeMovingAddressesRequest, "You must provide a DescribeMovingAddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeMovingAddresses",
	}
	for header,value in pairs(DescribeMovingAddressesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeMovingAddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeMovingAddresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeMovingAddressesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeMovingAddressesSync(DescribeMovingAddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeMovingAddressesAsync(DescribeMovingAddressesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RevokeSecurityGroupEgress asynchronously, invoking a callback when done
-- @param RevokeSecurityGroupEgressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RevokeSecurityGroupEgressAsync(RevokeSecurityGroupEgressRequest, cb)
	assert(RevokeSecurityGroupEgressRequest, "You must provide a RevokeSecurityGroupEgressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RevokeSecurityGroupEgress",
	}
	for header,value in pairs(RevokeSecurityGroupEgressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RevokeSecurityGroupEgressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RevokeSecurityGroupEgress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RevokeSecurityGroupEgressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RevokeSecurityGroupEgressSync(RevokeSecurityGroupEgressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RevokeSecurityGroupEgressAsync(RevokeSecurityGroupEgressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceAttribute asynchronously, invoking a callback when done
-- @param DescribeInstanceAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstanceAttributeAsync(DescribeInstanceAttributeRequest, cb)
	assert(DescribeInstanceAttributeRequest, "You must provide a DescribeInstanceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInstanceAttribute",
	}
	for header,value in pairs(DescribeInstanceAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstanceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstanceAttributeSync(DescribeInstanceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceAttributeAsync(DescribeInstanceAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeregisterImage asynchronously, invoking a callback when done
-- @param DeregisterImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeregisterImageAsync(DeregisterImageRequest, cb)
	assert(DeregisterImageRequest, "You must provide a DeregisterImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeregisterImage",
	}
	for header,value in pairs(DeregisterImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeregisterImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeregisterImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeregisterImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeregisterImageSync(DeregisterImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeregisterImageAsync(DeregisterImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpnGateway asynchronously, invoking a callback when done
-- @param DeleteVpnGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpnGatewayAsync(DeleteVpnGatewayRequest, cb)
	assert(DeleteVpnGatewayRequest, "You must provide a DeleteVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpnGateway",
	}
	for header,value in pairs(DeleteVpnGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpnGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpnGatewaySync(DeleteVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpnGatewayAsync(DeleteVpnGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReportInstanceStatus asynchronously, invoking a callback when done
-- @param ReportInstanceStatusRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReportInstanceStatusAsync(ReportInstanceStatusRequest, cb)
	assert(ReportInstanceStatusRequest, "You must provide a ReportInstanceStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReportInstanceStatus",
	}
	for header,value in pairs(ReportInstanceStatusRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReportInstanceStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReportInstanceStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReportInstanceStatusRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReportInstanceStatusSync(ReportInstanceStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReportInstanceStatusAsync(ReportInstanceStatusRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVgwRoutePropagation asynchronously, invoking a callback when done
-- @param EnableVgwRoutePropagationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.EnableVgwRoutePropagationAsync(EnableVgwRoutePropagationRequest, cb)
	assert(EnableVgwRoutePropagationRequest, "You must provide a EnableVgwRoutePropagationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVgwRoutePropagation",
	}
	for header,value in pairs(EnableVgwRoutePropagationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVgwRoutePropagationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVgwRoutePropagation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVgwRoutePropagationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.EnableVgwRoutePropagationSync(EnableVgwRoutePropagationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVgwRoutePropagationAsync(EnableVgwRoutePropagationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelReservedInstancesListing asynchronously, invoking a callback when done
-- @param CancelReservedInstancesListingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelReservedInstancesListingAsync(CancelReservedInstancesListingRequest, cb)
	assert(CancelReservedInstancesListingRequest, "You must provide a CancelReservedInstancesListingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelReservedInstancesListing",
	}
	for header,value in pairs(CancelReservedInstancesListingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelReservedInstancesListingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelReservedInstancesListing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelReservedInstancesListingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelReservedInstancesListingSync(CancelReservedInstancesListingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelReservedInstancesListingAsync(CancelReservedInstancesListingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceStatus asynchronously, invoking a callback when done
-- @param DescribeInstanceStatusRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstanceStatusAsync(DescribeInstanceStatusRequest, cb)
	assert(DescribeInstanceStatusRequest, "You must provide a DescribeInstanceStatusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInstanceStatus",
	}
	for header,value in pairs(DescribeInstanceStatusRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstanceStatusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceStatus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceStatusRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstanceStatusSync(DescribeInstanceStatusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceStatusAsync(DescribeInstanceStatusRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePrefixLists asynchronously, invoking a callback when done
-- @param DescribePrefixListsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribePrefixListsAsync(DescribePrefixListsRequest, cb)
	assert(DescribePrefixListsRequest, "You must provide a DescribePrefixListsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribePrefixLists",
	}
	for header,value in pairs(DescribePrefixListsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePrefixListsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePrefixLists synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePrefixListsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribePrefixListsSync(DescribePrefixListsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePrefixListsAsync(DescribePrefixListsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSnapshotAttribute asynchronously, invoking a callback when done
-- @param DescribeSnapshotAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSnapshotAttributeAsync(DescribeSnapshotAttributeRequest, cb)
	assert(DescribeSnapshotAttributeRequest, "You must provide a DescribeSnapshotAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSnapshotAttribute",
	}
	for header,value in pairs(DescribeSnapshotAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSnapshotAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSnapshotAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSnapshotAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSnapshotAttributeSync(DescribeSnapshotAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSnapshotAttributeAsync(DescribeSnapshotAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call PurchaseReservedInstancesOffering asynchronously, invoking a callback when done
-- @param PurchaseReservedInstancesOfferingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.PurchaseReservedInstancesOfferingAsync(PurchaseReservedInstancesOfferingRequest, cb)
	assert(PurchaseReservedInstancesOfferingRequest, "You must provide a PurchaseReservedInstancesOfferingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".PurchaseReservedInstancesOffering",
	}
	for header,value in pairs(PurchaseReservedInstancesOfferingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", PurchaseReservedInstancesOfferingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call PurchaseReservedInstancesOffering synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param PurchaseReservedInstancesOfferingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.PurchaseReservedInstancesOfferingSync(PurchaseReservedInstancesOfferingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.PurchaseReservedInstancesOfferingAsync(PurchaseReservedInstancesOfferingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySubnetAttribute asynchronously, invoking a callback when done
-- @param ModifySubnetAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifySubnetAttributeAsync(ModifySubnetAttributeRequest, cb)
	assert(ModifySubnetAttributeRequest, "You must provide a ModifySubnetAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifySubnetAttribute",
	}
	for header,value in pairs(ModifySubnetAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifySubnetAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySubnetAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySubnetAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifySubnetAttributeSync(ModifySubnetAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySubnetAttributeAsync(ModifySubnetAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkInterfaces asynchronously, invoking a callback when done
-- @param DescribeNetworkInterfacesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeNetworkInterfacesAsync(DescribeNetworkInterfacesRequest, cb)
	assert(DescribeNetworkInterfacesRequest, "You must provide a DescribeNetworkInterfacesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfaces",
	}
	for header,value in pairs(DescribeNetworkInterfacesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNetworkInterfacesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkInterfaces synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkInterfacesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeNetworkInterfacesSync(DescribeNetworkInterfacesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkInterfacesAsync(DescribeNetworkInterfacesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyCapacityReservation asynchronously, invoking a callback when done
-- @param ModifyCapacityReservationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyCapacityReservationAsync(ModifyCapacityReservationRequest, cb)
	assert(ModifyCapacityReservationRequest, "You must provide a ModifyCapacityReservationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyCapacityReservation",
	}
	for header,value in pairs(ModifyCapacityReservationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyCapacityReservationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyCapacityReservation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyCapacityReservationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyCapacityReservationSync(ModifyCapacityReservationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyCapacityReservationAsync(ModifyCapacityReservationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeLaunchTemplates asynchronously, invoking a callback when done
-- @param DescribeLaunchTemplatesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeLaunchTemplatesAsync(DescribeLaunchTemplatesRequest, cb)
	assert(DescribeLaunchTemplatesRequest, "You must provide a DescribeLaunchTemplatesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeLaunchTemplates",
	}
	for header,value in pairs(DescribeLaunchTemplatesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeLaunchTemplatesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeLaunchTemplates synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeLaunchTemplatesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeLaunchTemplatesSync(DescribeLaunchTemplatesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeLaunchTemplatesAsync(DescribeLaunchTemplatesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ConfirmProductInstance asynchronously, invoking a callback when done
-- @param ConfirmProductInstanceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ConfirmProductInstanceAsync(ConfirmProductInstanceRequest, cb)
	assert(ConfirmProductInstanceRequest, "You must provide a ConfirmProductInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ConfirmProductInstance",
	}
	for header,value in pairs(ConfirmProductInstanceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ConfirmProductInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ConfirmProductInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ConfirmProductInstanceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ConfirmProductInstanceSync(ConfirmProductInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ConfirmProductInstanceAsync(ConfirmProductInstanceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeExportTasks asynchronously, invoking a callback when done
-- @param DescribeExportTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeExportTasksAsync(DescribeExportTasksRequest, cb)
	assert(DescribeExportTasksRequest, "You must provide a DescribeExportTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeExportTasks",
	}
	for header,value in pairs(DescribeExportTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeExportTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeExportTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeExportTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeExportTasksSync(DescribeExportTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeExportTasksAsync(DescribeExportTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachInternetGateway asynchronously, invoking a callback when done
-- @param DetachInternetGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachInternetGatewayAsync(DetachInternetGatewayRequest, cb)
	assert(DetachInternetGatewayRequest, "You must provide a DetachInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachInternetGateway",
	}
	for header,value in pairs(DetachInternetGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachInternetGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachInternetGatewaySync(DetachInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachInternetGatewayAsync(DetachInternetGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkAclEntry asynchronously, invoking a callback when done
-- @param DeleteNetworkAclEntryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteNetworkAclEntryAsync(DeleteNetworkAclEntryRequest, cb)
	assert(DeleteNetworkAclEntryRequest, "You must provide a DeleteNetworkAclEntryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNetworkAclEntry",
	}
	for header,value in pairs(DeleteNetworkAclEntryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNetworkAclEntryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkAclEntry synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkAclEntryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteNetworkAclEntrySync(DeleteNetworkAclEntryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkAclEntryAsync(DeleteNetworkAclEntryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CancelCapacityReservation asynchronously, invoking a callback when done
-- @param CancelCapacityReservationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CancelCapacityReservationAsync(CancelCapacityReservationRequest, cb)
	assert(CancelCapacityReservationRequest, "You must provide a CancelCapacityReservationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CancelCapacityReservation",
	}
	for header,value in pairs(CancelCapacityReservationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CancelCapacityReservationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CancelCapacityReservation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CancelCapacityReservationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CancelCapacityReservationSync(CancelCapacityReservationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CancelCapacityReservationAsync(CancelCapacityReservationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateFpgaImage asynchronously, invoking a callback when done
-- @param CreateFpgaImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateFpgaImageAsync(CreateFpgaImageRequest, cb)
	assert(CreateFpgaImageRequest, "You must provide a CreateFpgaImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateFpgaImage",
	}
	for header,value in pairs(CreateFpgaImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateFpgaImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateFpgaImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateFpgaImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateFpgaImageSync(CreateFpgaImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateFpgaImageAsync(CreateFpgaImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateCustomerGateway asynchronously, invoking a callback when done
-- @param CreateCustomerGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateCustomerGatewayAsync(CreateCustomerGatewayRequest, cb)
	assert(CreateCustomerGatewayRequest, "You must provide a CreateCustomerGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateCustomerGateway",
	}
	for header,value in pairs(CreateCustomerGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateCustomerGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateCustomerGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateCustomerGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateCustomerGatewaySync(CreateCustomerGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateCustomerGatewayAsync(CreateCustomerGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call StopInstances asynchronously, invoking a callback when done
-- @param StopInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.StopInstancesAsync(StopInstancesRequest, cb)
	assert(StopInstancesRequest, "You must provide a StopInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".StopInstances",
	}
	for header,value in pairs(StopInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", StopInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call StopInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param StopInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.StopInstancesSync(StopInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.StopInstancesAsync(StopInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ResetInstanceAttribute asynchronously, invoking a callback when done
-- @param ResetInstanceAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ResetInstanceAttributeAsync(ResetInstanceAttributeRequest, cb)
	assert(ResetInstanceAttributeRequest, "You must provide a ResetInstanceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ResetInstanceAttribute",
	}
	for header,value in pairs(ResetInstanceAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ResetInstanceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ResetInstanceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ResetInstanceAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ResetInstanceAttributeSync(ResetInstanceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ResetInstanceAttributeAsync(ResetInstanceAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSecurityGroup asynchronously, invoking a callback when done
-- @param CreateSecurityGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateSecurityGroupAsync(CreateSecurityGroupRequest, cb)
	assert(CreateSecurityGroupRequest, "You must provide a CreateSecurityGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSecurityGroup",
	}
	for header,value in pairs(CreateSecurityGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSecurityGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSecurityGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSecurityGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateSecurityGroupSync(CreateSecurityGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSecurityGroupAsync(CreateSecurityGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInternetGateways asynchronously, invoking a callback when done
-- @param DescribeInternetGatewaysRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInternetGatewaysAsync(DescribeInternetGatewaysRequest, cb)
	assert(DescribeInternetGatewaysRequest, "You must provide a DescribeInternetGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInternetGateways",
	}
	for header,value in pairs(DescribeInternetGatewaysRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInternetGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInternetGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInternetGatewaysRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInternetGatewaysSync(DescribeInternetGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInternetGatewaysAsync(DescribeInternetGatewaysRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyNetworkInterfaceAttribute asynchronously, invoking a callback when done
-- @param ModifyNetworkInterfaceAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyNetworkInterfaceAttributeAsync(ModifyNetworkInterfaceAttributeRequest, cb)
	assert(ModifyNetworkInterfaceAttributeRequest, "You must provide a ModifyNetworkInterfaceAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyNetworkInterfaceAttribute",
	}
	for header,value in pairs(ModifyNetworkInterfaceAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyNetworkInterfaceAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyNetworkInterfaceAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyNetworkInterfaceAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyNetworkInterfaceAttributeSync(ModifyNetworkInterfaceAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyNetworkInterfaceAttributeAsync(ModifyNetworkInterfaceAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AttachVolume asynchronously, invoking a callback when done
-- @param AttachVolumeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AttachVolumeAsync(AttachVolumeRequest, cb)
	assert(AttachVolumeRequest, "You must provide a AttachVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AttachVolume",
	}
	for header,value in pairs(AttachVolumeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AttachVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AttachVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AttachVolumeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AttachVolumeSync(AttachVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AttachVolumeAsync(AttachVolumeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFleetHistory asynchronously, invoking a callback when done
-- @param DescribeFleetHistoryRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeFleetHistoryAsync(DescribeFleetHistoryRequest, cb)
	assert(DescribeFleetHistoryRequest, "You must provide a DescribeFleetHistoryRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFleetHistory",
	}
	for header,value in pairs(DescribeFleetHistoryRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFleetHistoryRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFleetHistory synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFleetHistoryRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeFleetHistorySync(DescribeFleetHistoryRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFleetHistoryAsync(DescribeFleetHistoryRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ProvisionByoipCidr asynchronously, invoking a callback when done
-- @param ProvisionByoipCidrRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ProvisionByoipCidrAsync(ProvisionByoipCidrRequest, cb)
	assert(ProvisionByoipCidrRequest, "You must provide a ProvisionByoipCidrRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ProvisionByoipCidr",
	}
	for header,value in pairs(ProvisionByoipCidrRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ProvisionByoipCidrRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ProvisionByoipCidr synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ProvisionByoipCidrRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ProvisionByoipCidrSync(ProvisionByoipCidrRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ProvisionByoipCidrAsync(ProvisionByoipCidrRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call TerminateInstances asynchronously, invoking a callback when done
-- @param TerminateInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.TerminateInstancesAsync(TerminateInstancesRequest, cb)
	assert(TerminateInstancesRequest, "You must provide a TerminateInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".TerminateInstances",
	}
	for header,value in pairs(TerminateInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", TerminateInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call TerminateInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param TerminateInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.TerminateInstancesSync(TerminateInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.TerminateInstancesAsync(TerminateInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateTags asynchronously, invoking a callback when done
-- @param CreateTagsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateTagsAsync(CreateTagsRequest, cb)
	assert(CreateTagsRequest, "You must provide a CreateTagsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateTags",
	}
	for header,value in pairs(CreateTagsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateTagsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateTagsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateTagsSync(CreateTagsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateTagsAsync(CreateTagsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param DeleteSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteSpotDatafeedSubscriptionAsync(DeleteSpotDatafeedSubscriptionRequest, cb)
	assert(DeleteSpotDatafeedSubscriptionRequest, "You must provide a DeleteSpotDatafeedSubscriptionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteSpotDatafeedSubscription",
	}
	for header,value in pairs(DeleteSpotDatafeedSubscriptionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteSpotDatafeedSubscriptionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteSpotDatafeedSubscriptionSync(DeleteSpotDatafeedSubscriptionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteSpotDatafeedSubscriptionAsync(DeleteSpotDatafeedSubscriptionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeletePlacementGroup asynchronously, invoking a callback when done
-- @param DeletePlacementGroupRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeletePlacementGroupAsync(DeletePlacementGroupRequest, cb)
	assert(DeletePlacementGroupRequest, "You must provide a DeletePlacementGroupRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeletePlacementGroup",
	}
	for header,value in pairs(DeletePlacementGroupRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeletePlacementGroupRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeletePlacementGroup synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeletePlacementGroupRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeletePlacementGroupSync(DeletePlacementGroupRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeletePlacementGroupAsync(DeletePlacementGroupRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteRouteTable asynchronously, invoking a callback when done
-- @param DeleteRouteTableRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteRouteTableAsync(DeleteRouteTableRequest, cb)
	assert(DeleteRouteTableRequest, "You must provide a DeleteRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteRouteTable",
	}
	for header,value in pairs(DeleteRouteTableRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteRouteTableRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteRouteTableSync(DeleteRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteRouteTableAsync(DeleteRouteTableRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFleetInstances asynchronously, invoking a callback when done
-- @param DescribeFleetInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeFleetInstancesAsync(DescribeFleetInstancesRequest, cb)
	assert(DescribeFleetInstancesRequest, "You must provide a DescribeFleetInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFleetInstances",
	}
	for header,value in pairs(DescribeFleetInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFleetInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFleetInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFleetInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeFleetInstancesSync(DescribeFleetInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFleetInstancesAsync(DescribeFleetInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstanceCreditSpecifications asynchronously, invoking a callback when done
-- @param DescribeInstanceCreditSpecificationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstanceCreditSpecificationsAsync(DescribeInstanceCreditSpecificationsRequest, cb)
	assert(DescribeInstanceCreditSpecificationsRequest, "You must provide a DescribeInstanceCreditSpecificationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInstanceCreditSpecifications",
	}
	for header,value in pairs(DescribeInstanceCreditSpecificationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstanceCreditSpecificationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstanceCreditSpecifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstanceCreditSpecificationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstanceCreditSpecificationsSync(DescribeInstanceCreditSpecificationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstanceCreditSpecificationsAsync(DescribeInstanceCreditSpecificationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeKeyPairs asynchronously, invoking a callback when done
-- @param DescribeKeyPairsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeKeyPairsAsync(DescribeKeyPairsRequest, cb)
	assert(DescribeKeyPairsRequest, "You must provide a DescribeKeyPairsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeKeyPairs",
	}
	for header,value in pairs(DescribeKeyPairsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeKeyPairsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeKeyPairs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeKeyPairsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeKeyPairsSync(DescribeKeyPairsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeKeyPairsAsync(DescribeKeyPairsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetLaunchTemplateData asynchronously, invoking a callback when done
-- @param GetLaunchTemplateDataRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetLaunchTemplateDataAsync(GetLaunchTemplateDataRequest, cb)
	assert(GetLaunchTemplateDataRequest, "You must provide a GetLaunchTemplateDataRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetLaunchTemplateData",
	}
	for header,value in pairs(GetLaunchTemplateDataRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetLaunchTemplateDataRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetLaunchTemplateData synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetLaunchTemplateDataRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetLaunchTemplateDataSync(GetLaunchTemplateDataRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetLaunchTemplateDataAsync(GetLaunchTemplateDataRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeStaleSecurityGroups asynchronously, invoking a callback when done
-- @param DescribeStaleSecurityGroupsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeStaleSecurityGroupsAsync(DescribeStaleSecurityGroupsRequest, cb)
	assert(DescribeStaleSecurityGroupsRequest, "You must provide a DescribeStaleSecurityGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeStaleSecurityGroups",
	}
	for header,value in pairs(DescribeStaleSecurityGroupsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeStaleSecurityGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeStaleSecurityGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeStaleSecurityGroupsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeStaleSecurityGroupsSync(DescribeStaleSecurityGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeStaleSecurityGroupsAsync(DescribeStaleSecurityGroupsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesOfferings asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesOfferingsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeReservedInstancesOfferingsAsync(DescribeReservedInstancesOfferingsRequest, cb)
	assert(DescribeReservedInstancesOfferingsRequest, "You must provide a DescribeReservedInstancesOfferingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesOfferings",
	}
	for header,value in pairs(DescribeReservedInstancesOfferingsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesOfferingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesOfferings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesOfferingsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeReservedInstancesOfferingsSync(DescribeReservedInstancesOfferingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesOfferingsAsync(DescribeReservedInstancesOfferingsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call MonitorInstances asynchronously, invoking a callback when done
-- @param MonitorInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.MonitorInstancesAsync(MonitorInstancesRequest, cb)
	assert(MonitorInstancesRequest, "You must provide a MonitorInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".MonitorInstances",
	}
	for header,value in pairs(MonitorInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", MonitorInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call MonitorInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param MonitorInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.MonitorInstancesSync(MonitorInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.MonitorInstancesAsync(MonitorInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetConsoleScreenshot asynchronously, invoking a callback when done
-- @param GetConsoleScreenshotRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetConsoleScreenshotAsync(GetConsoleScreenshotRequest, cb)
	assert(GetConsoleScreenshotRequest, "You must provide a GetConsoleScreenshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetConsoleScreenshot",
	}
	for header,value in pairs(GetConsoleScreenshotRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetConsoleScreenshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetConsoleScreenshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetConsoleScreenshotRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetConsoleScreenshotSync(GetConsoleScreenshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetConsoleScreenshotAsync(GetConsoleScreenshotRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAccountAttributes asynchronously, invoking a callback when done
-- @param DescribeAccountAttributesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAccountAttributesAsync(DescribeAccountAttributesRequest, cb)
	assert(DescribeAccountAttributesRequest, "You must provide a DescribeAccountAttributesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAccountAttributes",
	}
	for header,value in pairs(DescribeAccountAttributesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAccountAttributesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAccountAttributes synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAccountAttributesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAccountAttributesSync(DescribeAccountAttributesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAccountAttributesAsync(DescribeAccountAttributesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssignIpv6Addresses asynchronously, invoking a callback when done
-- @param AssignIpv6AddressesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssignIpv6AddressesAsync(AssignIpv6AddressesRequest, cb)
	assert(AssignIpv6AddressesRequest, "You must provide a AssignIpv6AddressesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssignIpv6Addresses",
	}
	for header,value in pairs(AssignIpv6AddressesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssignIpv6AddressesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssignIpv6Addresses synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssignIpv6AddressesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssignIpv6AddressesSync(AssignIpv6AddressesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssignIpv6AddressesAsync(AssignIpv6AddressesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AuthorizeSecurityGroupEgress asynchronously, invoking a callback when done
-- @param AuthorizeSecurityGroupEgressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AuthorizeSecurityGroupEgressAsync(AuthorizeSecurityGroupEgressRequest, cb)
	assert(AuthorizeSecurityGroupEgressRequest, "You must provide a AuthorizeSecurityGroupEgressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupEgress",
	}
	for header,value in pairs(AuthorizeSecurityGroupEgressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AuthorizeSecurityGroupEgressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AuthorizeSecurityGroupEgress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AuthorizeSecurityGroupEgressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AuthorizeSecurityGroupEgressSync(AuthorizeSecurityGroupEgressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AuthorizeSecurityGroupEgressAsync(AuthorizeSecurityGroupEgressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AllocateAddress asynchronously, invoking a callback when done
-- @param AllocateAddressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AllocateAddressAsync(AllocateAddressRequest, cb)
	assert(AllocateAddressRequest, "You must provide a AllocateAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AllocateAddress",
	}
	for header,value in pairs(AllocateAddressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AllocateAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AllocateAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AllocateAddressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AllocateAddressSync(AllocateAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AllocateAddressAsync(AllocateAddressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeNetworkInterfacePermissions asynchronously, invoking a callback when done
-- @param DescribeNetworkInterfacePermissionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeNetworkInterfacePermissionsAsync(DescribeNetworkInterfacePermissionsRequest, cb)
	assert(DescribeNetworkInterfacePermissionsRequest, "You must provide a DescribeNetworkInterfacePermissionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeNetworkInterfacePermissions",
	}
	for header,value in pairs(DescribeNetworkInterfacePermissionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeNetworkInterfacePermissionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeNetworkInterfacePermissions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeNetworkInterfacePermissionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeNetworkInterfacePermissionsSync(DescribeNetworkInterfacePermissionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeNetworkInterfacePermissionsAsync(DescribeNetworkInterfacePermissionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AuthorizeSecurityGroupIngress asynchronously, invoking a callback when done
-- @param AuthorizeSecurityGroupIngressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AuthorizeSecurityGroupIngressAsync(AuthorizeSecurityGroupIngressRequest, cb)
	assert(AuthorizeSecurityGroupIngressRequest, "You must provide a AuthorizeSecurityGroupIngressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AuthorizeSecurityGroupIngress",
	}
	for header,value in pairs(AuthorizeSecurityGroupIngressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AuthorizeSecurityGroupIngressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AuthorizeSecurityGroupIngress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AuthorizeSecurityGroupIngressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AuthorizeSecurityGroupIngressSync(AuthorizeSecurityGroupIngressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AuthorizeSecurityGroupIngressAsync(AuthorizeSecurityGroupIngressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param CreateSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateSpotDatafeedSubscriptionAsync(CreateSpotDatafeedSubscriptionRequest, cb)
	assert(CreateSpotDatafeedSubscriptionRequest, "You must provide a CreateSpotDatafeedSubscriptionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateSpotDatafeedSubscription",
	}
	for header,value in pairs(CreateSpotDatafeedSubscriptionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateSpotDatafeedSubscriptionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateSpotDatafeedSubscriptionSync(CreateSpotDatafeedSubscriptionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateSpotDatafeedSubscriptionAsync(CreateSpotDatafeedSubscriptionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportInstance asynchronously, invoking a callback when done
-- @param ImportInstanceRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ImportInstanceAsync(ImportInstanceRequest, cb)
	assert(ImportInstanceRequest, "You must provide a ImportInstanceRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportInstance",
	}
	for header,value in pairs(ImportInstanceRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportInstanceRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportInstance synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportInstanceRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ImportInstanceSync(ImportInstanceRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportInstanceAsync(ImportInstanceRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteFpgaImage asynchronously, invoking a callback when done
-- @param DeleteFpgaImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteFpgaImageAsync(DeleteFpgaImageRequest, cb)
	assert(DeleteFpgaImageRequest, "You must provide a DeleteFpgaImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteFpgaImage",
	}
	for header,value in pairs(DeleteFpgaImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteFpgaImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteFpgaImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteFpgaImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteFpgaImageSync(DeleteFpgaImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteFpgaImageAsync(DeleteFpgaImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFpgaImageAttribute asynchronously, invoking a callback when done
-- @param DescribeFpgaImageAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeFpgaImageAttributeAsync(DescribeFpgaImageAttributeRequest, cb)
	assert(DescribeFpgaImageAttributeRequest, "You must provide a DescribeFpgaImageAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFpgaImageAttribute",
	}
	for header,value in pairs(DescribeFpgaImageAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFpgaImageAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFpgaImageAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFpgaImageAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeFpgaImageAttributeSync(DescribeFpgaImageAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFpgaImageAttributeAsync(DescribeFpgaImageAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceNetworkAclAssociation asynchronously, invoking a callback when done
-- @param ReplaceNetworkAclAssociationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReplaceNetworkAclAssociationAsync(ReplaceNetworkAclAssociationRequest, cb)
	assert(ReplaceNetworkAclAssociationRequest, "You must provide a ReplaceNetworkAclAssociationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceNetworkAclAssociation",
	}
	for header,value in pairs(ReplaceNetworkAclAssociationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceNetworkAclAssociationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceNetworkAclAssociation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceNetworkAclAssociationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReplaceNetworkAclAssociationSync(ReplaceNetworkAclAssociationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceNetworkAclAssociationAsync(ReplaceNetworkAclAssociationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcEndpointServiceConfiguration asynchronously, invoking a callback when done
-- @param ModifyVpcEndpointServiceConfigurationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVpcEndpointServiceConfigurationAsync(ModifyVpcEndpointServiceConfigurationRequest, cb)
	assert(ModifyVpcEndpointServiceConfigurationRequest, "You must provide a ModifyVpcEndpointServiceConfigurationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcEndpointServiceConfiguration",
	}
	for header,value in pairs(ModifyVpcEndpointServiceConfigurationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcEndpointServiceConfigurationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcEndpointServiceConfiguration synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcEndpointServiceConfigurationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVpcEndpointServiceConfigurationSync(ModifyVpcEndpointServiceConfigurationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcEndpointServiceConfigurationAsync(ModifyVpcEndpointServiceConfigurationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReleaseAddress asynchronously, invoking a callback when done
-- @param ReleaseAddressRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReleaseAddressAsync(ReleaseAddressRequest, cb)
	assert(ReleaseAddressRequest, "You must provide a ReleaseAddressRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReleaseAddress",
	}
	for header,value in pairs(ReleaseAddressRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReleaseAddressRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReleaseAddress synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReleaseAddressRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReleaseAddressSync(ReleaseAddressRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReleaseAddressAsync(ReleaseAddressRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFpgaImages asynchronously, invoking a callback when done
-- @param DescribeFpgaImagesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeFpgaImagesAsync(DescribeFpgaImagesRequest, cb)
	assert(DescribeFpgaImagesRequest, "You must provide a DescribeFpgaImagesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFpgaImages",
	}
	for header,value in pairs(DescribeFpgaImagesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFpgaImagesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFpgaImages synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFpgaImagesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeFpgaImagesSync(DescribeFpgaImagesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFpgaImagesAsync(DescribeFpgaImagesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RejectVpcPeeringConnection asynchronously, invoking a callback when done
-- @param RejectVpcPeeringConnectionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RejectVpcPeeringConnectionAsync(RejectVpcPeeringConnectionRequest, cb)
	assert(RejectVpcPeeringConnectionRequest, "You must provide a RejectVpcPeeringConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RejectVpcPeeringConnection",
	}
	for header,value in pairs(RejectVpcPeeringConnectionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RejectVpcPeeringConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RejectVpcPeeringConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RejectVpcPeeringConnectionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RejectVpcPeeringConnectionSync(RejectVpcPeeringConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RejectVpcPeeringConnectionAsync(RejectVpcPeeringConnectionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeElasticGpus asynchronously, invoking a callback when done
-- @param DescribeElasticGpusRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeElasticGpusAsync(DescribeElasticGpusRequest, cb)
	assert(DescribeElasticGpusRequest, "You must provide a DescribeElasticGpusRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeElasticGpus",
	}
	for header,value in pairs(DescribeElasticGpusRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeElasticGpusRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeElasticGpus synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeElasticGpusRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeElasticGpusSync(DescribeElasticGpusRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeElasticGpusAsync(DescribeElasticGpusRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeFleets asynchronously, invoking a callback when done
-- @param DescribeFleetsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeFleetsAsync(DescribeFleetsRequest, cb)
	assert(DescribeFleetsRequest, "You must provide a DescribeFleetsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeFleets",
	}
	for header,value in pairs(DescribeFleetsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeFleetsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeFleets synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeFleetsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeFleetsSync(DescribeFleetsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeFleetsAsync(DescribeFleetsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteFleets asynchronously, invoking a callback when done
-- @param DeleteFleetsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteFleetsAsync(DeleteFleetsRequest, cb)
	assert(DeleteFleetsRequest, "You must provide a DeleteFleetsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteFleets",
	}
	for header,value in pairs(DeleteFleetsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteFleetsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteFleets synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteFleetsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteFleetsSync(DeleteFleetsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteFleetsAsync(DeleteFleetsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeImages asynchronously, invoking a callback when done
-- @param DescribeImagesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeImagesAsync(DescribeImagesRequest, cb)
	assert(DescribeImagesRequest, "You must provide a DescribeImagesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeImages",
	}
	for header,value in pairs(DescribeImagesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeImagesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeImages synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeImagesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeImagesSync(DescribeImagesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeImagesAsync(DescribeImagesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DisassociateRouteTable asynchronously, invoking a callback when done
-- @param DisassociateRouteTableRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DisassociateRouteTableAsync(DisassociateRouteTableRequest, cb)
	assert(DisassociateRouteTableRequest, "You must provide a DisassociateRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DisassociateRouteTable",
	}
	for header,value in pairs(DisassociateRouteTableRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DisassociateRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DisassociateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DisassociateRouteTableRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DisassociateRouteTableSync(DisassociateRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DisassociateRouteTableAsync(DisassociateRouteTableRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcTenancy asynchronously, invoking a callback when done
-- @param ModifyVpcTenancyRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVpcTenancyAsync(ModifyVpcTenancyRequest, cb)
	assert(ModifyVpcTenancyRequest, "You must provide a ModifyVpcTenancyRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcTenancy",
	}
	for header,value in pairs(ModifyVpcTenancyRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcTenancyRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcTenancy synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcTenancyRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVpcTenancySync(ModifyVpcTenancyRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcTenancyAsync(ModifyVpcTenancyRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePrincipalIdFormat asynchronously, invoking a callback when done
-- @param DescribePrincipalIdFormatRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribePrincipalIdFormatAsync(DescribePrincipalIdFormatRequest, cb)
	assert(DescribePrincipalIdFormatRequest, "You must provide a DescribePrincipalIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribePrincipalIdFormat",
	}
	for header,value in pairs(DescribePrincipalIdFormatRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePrincipalIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePrincipalIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePrincipalIdFormatRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribePrincipalIdFormatSync(DescribePrincipalIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePrincipalIdFormatAsync(DescribePrincipalIdFormatRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePublicIpv4Pools asynchronously, invoking a callback when done
-- @param DescribePublicIpv4PoolsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribePublicIpv4PoolsAsync(DescribePublicIpv4PoolsRequest, cb)
	assert(DescribePublicIpv4PoolsRequest, "You must provide a DescribePublicIpv4PoolsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribePublicIpv4Pools",
	}
	for header,value in pairs(DescribePublicIpv4PoolsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePublicIpv4PoolsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePublicIpv4Pools synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePublicIpv4PoolsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribePublicIpv4PoolsSync(DescribePublicIpv4PoolsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePublicIpv4PoolsAsync(DescribePublicIpv4PoolsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ReplaceRoute asynchronously, invoking a callback when done
-- @param ReplaceRouteRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ReplaceRouteAsync(ReplaceRouteRequest, cb)
	assert(ReplaceRouteRequest, "You must provide a ReplaceRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ReplaceRoute",
	}
	for header,value in pairs(ReplaceRouteRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ReplaceRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ReplaceRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ReplaceRouteRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ReplaceRouteSync(ReplaceRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ReplaceRouteAsync(ReplaceRouteRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AssociateRouteTable asynchronously, invoking a callback when done
-- @param AssociateRouteTableRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AssociateRouteTableAsync(AssociateRouteTableRequest, cb)
	assert(AssociateRouteTableRequest, "You must provide a AssociateRouteTableRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AssociateRouteTable",
	}
	for header,value in pairs(AssociateRouteTableRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AssociateRouteTableRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AssociateRouteTable synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AssociateRouteTableRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AssociateRouteTableSync(AssociateRouteTableRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AssociateRouteTableAsync(AssociateRouteTableRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpc asynchronously, invoking a callback when done
-- @param DeleteVpcRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpcAsync(DeleteVpcRequest, cb)
	assert(DeleteVpcRequest, "You must provide a DeleteVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpc",
	}
	for header,value in pairs(DeleteVpcRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpcSync(DeleteVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcAsync(DeleteVpcRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSpotDatafeedSubscription asynchronously, invoking a callback when done
-- @param DescribeSpotDatafeedSubscriptionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSpotDatafeedSubscriptionAsync(DescribeSpotDatafeedSubscriptionRequest, cb)
	assert(DescribeSpotDatafeedSubscriptionRequest, "You must provide a DescribeSpotDatafeedSubscriptionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSpotDatafeedSubscription",
	}
	for header,value in pairs(DescribeSpotDatafeedSubscriptionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSpotDatafeedSubscriptionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSpotDatafeedSubscription synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSpotDatafeedSubscriptionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSpotDatafeedSubscriptionSync(DescribeSpotDatafeedSubscriptionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSpotDatafeedSubscriptionAsync(DescribeSpotDatafeedSubscriptionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribePlacementGroups asynchronously, invoking a callback when done
-- @param DescribePlacementGroupsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribePlacementGroupsAsync(DescribePlacementGroupsRequest, cb)
	assert(DescribePlacementGroupsRequest, "You must provide a DescribePlacementGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribePlacementGroups",
	}
	for header,value in pairs(DescribePlacementGroupsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribePlacementGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribePlacementGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribePlacementGroupsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribePlacementGroupsSync(DescribePlacementGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribePlacementGroupsAsync(DescribePlacementGroupsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeRegions asynchronously, invoking a callback when done
-- @param DescribeRegionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeRegionsAsync(DescribeRegionsRequest, cb)
	assert(DescribeRegionsRequest, "You must provide a DescribeRegionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeRegions",
	}
	for header,value in pairs(DescribeRegionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeRegionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeRegions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeRegionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeRegionsSync(DescribeRegionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeRegionsAsync(DescribeRegionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeInstances asynchronously, invoking a callback when done
-- @param DescribeInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeInstancesAsync(DescribeInstancesRequest, cb)
	assert(DescribeInstancesRequest, "You must provide a DescribeInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeInstances",
	}
	for header,value in pairs(DescribeInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeInstancesSync(DescribeInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeInstancesAsync(DescribeInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeLaunchTemplateVersions asynchronously, invoking a callback when done
-- @param DescribeLaunchTemplateVersionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeLaunchTemplateVersionsAsync(DescribeLaunchTemplateVersionsRequest, cb)
	assert(DescribeLaunchTemplateVersionsRequest, "You must provide a DescribeLaunchTemplateVersionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeLaunchTemplateVersions",
	}
	for header,value in pairs(DescribeLaunchTemplateVersionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeLaunchTemplateVersionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeLaunchTemplateVersions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeLaunchTemplateVersionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeLaunchTemplateVersionsSync(DescribeLaunchTemplateVersionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeLaunchTemplateVersionsAsync(DescribeLaunchTemplateVersionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateRoute asynchronously, invoking a callback when done
-- @param CreateRouteRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateRouteAsync(CreateRouteRequest, cb)
	assert(CreateRouteRequest, "You must provide a CreateRouteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateRoute",
	}
	for header,value in pairs(CreateRouteRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateRouteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateRoute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateRouteRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateRouteSync(CreateRouteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateRouteAsync(CreateRouteRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteEgressOnlyInternetGateway asynchronously, invoking a callback when done
-- @param DeleteEgressOnlyInternetGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteEgressOnlyInternetGatewayAsync(DeleteEgressOnlyInternetGatewayRequest, cb)
	assert(DeleteEgressOnlyInternetGatewayRequest, "You must provide a DeleteEgressOnlyInternetGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteEgressOnlyInternetGateway",
	}
	for header,value in pairs(DeleteEgressOnlyInternetGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteEgressOnlyInternetGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteEgressOnlyInternetGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteEgressOnlyInternetGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteEgressOnlyInternetGatewaySync(DeleteEgressOnlyInternetGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteEgressOnlyInternetGatewayAsync(DeleteEgressOnlyInternetGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSecurityGroups asynchronously, invoking a callback when done
-- @param DescribeSecurityGroupsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSecurityGroupsAsync(DescribeSecurityGroupsRequest, cb)
	assert(DescribeSecurityGroupsRequest, "You must provide a DescribeSecurityGroupsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroups",
	}
	for header,value in pairs(DescribeSecurityGroupsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSecurityGroupsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSecurityGroups synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSecurityGroupsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSecurityGroupsSync(DescribeSecurityGroupsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSecurityGroupsAsync(DescribeSecurityGroupsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateDhcpOptions asynchronously, invoking a callback when done
-- @param CreateDhcpOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateDhcpOptionsAsync(CreateDhcpOptionsRequest, cb)
	assert(CreateDhcpOptionsRequest, "You must provide a CreateDhcpOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateDhcpOptions",
	}
	for header,value in pairs(CreateDhcpOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateDhcpOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateDhcpOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateDhcpOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateDhcpOptionsSync(CreateDhcpOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateDhcpOptionsAsync(CreateDhcpOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVpcEndpointServiceConfigurations asynchronously, invoking a callback when done
-- @param DeleteVpcEndpointServiceConfigurationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVpcEndpointServiceConfigurationsAsync(DeleteVpcEndpointServiceConfigurationsRequest, cb)
	assert(DeleteVpcEndpointServiceConfigurationsRequest, "You must provide a DeleteVpcEndpointServiceConfigurationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVpcEndpointServiceConfigurations",
	}
	for header,value in pairs(DeleteVpcEndpointServiceConfigurationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVpcEndpointServiceConfigurationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVpcEndpointServiceConfigurations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVpcEndpointServiceConfigurationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVpcEndpointServiceConfigurationsSync(DeleteVpcEndpointServiceConfigurationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVpcEndpointServiceConfigurationsAsync(DeleteVpcEndpointServiceConfigurationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnGateway asynchronously, invoking a callback when done
-- @param CreateVpnGatewayRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpnGatewayAsync(CreateVpnGatewayRequest, cb)
	assert(CreateVpnGatewayRequest, "You must provide a CreateVpnGatewayRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpnGateway",
	}
	for header,value in pairs(CreateVpnGatewayRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpnGatewayRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnGateway synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnGatewayRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpnGatewaySync(CreateVpnGatewayRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnGatewayAsync(CreateVpnGatewayRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeBundleTasks asynchronously, invoking a callback when done
-- @param DescribeBundleTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeBundleTasksAsync(DescribeBundleTasksRequest, cb)
	assert(DescribeBundleTasksRequest, "You must provide a DescribeBundleTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeBundleTasks",
	}
	for header,value in pairs(DescribeBundleTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeBundleTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeBundleTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeBundleTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeBundleTasksSync(DescribeBundleTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeBundleTasksAsync(DescribeBundleTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeReservedInstancesListings asynchronously, invoking a callback when done
-- @param DescribeReservedInstancesListingsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeReservedInstancesListingsAsync(DescribeReservedInstancesListingsRequest, cb)
	assert(DescribeReservedInstancesListingsRequest, "You must provide a DescribeReservedInstancesListingsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeReservedInstancesListings",
	}
	for header,value in pairs(DescribeReservedInstancesListingsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeReservedInstancesListingsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeReservedInstancesListings synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeReservedInstancesListingsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeReservedInstancesListingsSync(DescribeReservedInstancesListingsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeReservedInstancesListingsAsync(DescribeReservedInstancesListingsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetReservedInstancesExchangeQuote asynchronously, invoking a callback when done
-- @param GetReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetReservedInstancesExchangeQuoteAsync(GetReservedInstancesExchangeQuoteRequest, cb)
	assert(GetReservedInstancesExchangeQuoteRequest, "You must provide a GetReservedInstancesExchangeQuoteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetReservedInstancesExchangeQuote",
	}
	for header,value in pairs(GetReservedInstancesExchangeQuoteRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetReservedInstancesExchangeQuoteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetReservedInstancesExchangeQuote synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetReservedInstancesExchangeQuoteRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetReservedInstancesExchangeQuoteSync(GetReservedInstancesExchangeQuoteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetReservedInstancesExchangeQuoteAsync(GetReservedInstancesExchangeQuoteRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeClassicLinkInstances asynchronously, invoking a callback when done
-- @param DescribeClassicLinkInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeClassicLinkInstancesAsync(DescribeClassicLinkInstancesRequest, cb)
	assert(DescribeClassicLinkInstancesRequest, "You must provide a DescribeClassicLinkInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeClassicLinkInstances",
	}
	for header,value in pairs(DescribeClassicLinkInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeClassicLinkInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeClassicLinkInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeClassicLinkInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeClassicLinkInstancesSync(DescribeClassicLinkInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeClassicLinkInstancesAsync(DescribeClassicLinkInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifySpotFleetRequest asynchronously, invoking a callback when done
-- @param ModifySpotFleetRequestRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifySpotFleetRequestAsync(ModifySpotFleetRequestRequest, cb)
	assert(ModifySpotFleetRequestRequest, "You must provide a ModifySpotFleetRequestRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifySpotFleetRequest",
	}
	for header,value in pairs(ModifySpotFleetRequestRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifySpotFleetRequestRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifySpotFleetRequest synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifySpotFleetRequestRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifySpotFleetRequestSync(ModifySpotFleetRequestRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifySpotFleetRequestAsync(ModifySpotFleetRequestRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteVolume asynchronously, invoking a callback when done
-- @param DeleteVolumeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteVolumeAsync(DeleteVolumeRequest, cb)
	assert(DeleteVolumeRequest, "You must provide a DeleteVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteVolume",
	}
	for header,value in pairs(DeleteVolumeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteVolumeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteVolumeSync(DeleteVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteVolumeAsync(DeleteVolumeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeConversionTasks asynchronously, invoking a callback when done
-- @param DescribeConversionTasksRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeConversionTasksAsync(DescribeConversionTasksRequest, cb)
	assert(DescribeConversionTasksRequest, "You must provide a DescribeConversionTasksRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeConversionTasks",
	}
	for header,value in pairs(DescribeConversionTasksRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeConversionTasksRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeConversionTasks synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeConversionTasksRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeConversionTasksSync(DescribeConversionTasksRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeConversionTasksAsync(DescribeConversionTasksRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcClassicLinkDnsSupport asynchronously, invoking a callback when done
-- @param DescribeVpcClassicLinkDnsSupportRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcClassicLinkDnsSupportAsync(DescribeVpcClassicLinkDnsSupportRequest, cb)
	assert(DescribeVpcClassicLinkDnsSupportRequest, "You must provide a DescribeVpcClassicLinkDnsSupportRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLinkDnsSupport",
	}
	for header,value in pairs(DescribeVpcClassicLinkDnsSupportRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcClassicLinkDnsSupportRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcClassicLinkDnsSupport synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcClassicLinkDnsSupportRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcClassicLinkDnsSupportSync(DescribeVpcClassicLinkDnsSupportRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcClassicLinkDnsSupportAsync(DescribeVpcClassicLinkDnsSupportRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CopyImage asynchronously, invoking a callback when done
-- @param CopyImageRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CopyImageAsync(CopyImageRequest, cb)
	assert(CopyImageRequest, "You must provide a CopyImageRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CopyImage",
	}
	for header,value in pairs(CopyImageRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CopyImageRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CopyImage synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CopyImageRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CopyImageSync(CopyImageRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CopyImageAsync(CopyImageRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSubnets asynchronously, invoking a callback when done
-- @param DescribeSubnetsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSubnetsAsync(DescribeSubnetsRequest, cb)
	assert(DescribeSubnetsRequest, "You must provide a DescribeSubnetsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSubnets",
	}
	for header,value in pairs(DescribeSubnetsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSubnetsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSubnets synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSubnetsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSubnetsSync(DescribeSubnetsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSubnetsAsync(DescribeSubnetsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcClassicLink asynchronously, invoking a callback when done
-- @param DescribeVpcClassicLinkRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcClassicLinkAsync(DescribeVpcClassicLinkRequest, cb)
	assert(DescribeVpcClassicLinkRequest, "You must provide a DescribeVpcClassicLinkRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcClassicLink",
	}
	for header,value in pairs(DescribeVpcClassicLinkRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcClassicLinkRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcClassicLink synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcClassicLinkRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcClassicLinkSync(DescribeVpcClassicLinkRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcClassicLinkAsync(DescribeVpcClassicLinkRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateCapacityReservation asynchronously, invoking a callback when done
-- @param CreateCapacityReservationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateCapacityReservationAsync(CreateCapacityReservationRequest, cb)
	assert(CreateCapacityReservationRequest, "You must provide a CreateCapacityReservationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateCapacityReservation",
	}
	for header,value in pairs(CreateCapacityReservationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateCapacityReservationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateCapacityReservation synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateCapacityReservationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateCapacityReservationSync(CreateCapacityReservationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateCapacityReservationAsync(CreateCapacityReservationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcPeeringConnectionOptions asynchronously, invoking a callback when done
-- @param ModifyVpcPeeringConnectionOptionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVpcPeeringConnectionOptionsAsync(ModifyVpcPeeringConnectionOptionsRequest, cb)
	assert(ModifyVpcPeeringConnectionOptionsRequest, "You must provide a ModifyVpcPeeringConnectionOptionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcPeeringConnectionOptions",
	}
	for header,value in pairs(ModifyVpcPeeringConnectionOptionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcPeeringConnectionOptionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcPeeringConnectionOptions synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcPeeringConnectionOptionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVpcPeeringConnectionOptionsSync(ModifyVpcPeeringConnectionOptionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcPeeringConnectionOptionsAsync(ModifyVpcPeeringConnectionOptionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVolumeAttribute asynchronously, invoking a callback when done
-- @param ModifyVolumeAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVolumeAttributeAsync(ModifyVolumeAttributeRequest, cb)
	assert(ModifyVolumeAttributeRequest, "You must provide a ModifyVolumeAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVolumeAttribute",
	}
	for header,value in pairs(ModifyVolumeAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVolumeAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVolumeAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVolumeAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVolumeAttributeSync(ModifyVolumeAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVolumeAttributeAsync(ModifyVolumeAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportVolume asynchronously, invoking a callback when done
-- @param ImportVolumeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ImportVolumeAsync(ImportVolumeRequest, cb)
	assert(ImportVolumeRequest, "You must provide a ImportVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportVolume",
	}
	for header,value in pairs(ImportVolumeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportVolumeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ImportVolumeSync(ImportVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportVolumeAsync(ImportVolumeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ImportSnapshot asynchronously, invoking a callback when done
-- @param ImportSnapshotRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ImportSnapshotAsync(ImportSnapshotRequest, cb)
	assert(ImportSnapshotRequest, "You must provide a ImportSnapshotRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ImportSnapshot",
	}
	for header,value in pairs(ImportSnapshotRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ImportSnapshotRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ImportSnapshot synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ImportSnapshotRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ImportSnapshotSync(ImportSnapshotRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ImportSnapshotAsync(ImportSnapshotRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call GetConsoleOutput asynchronously, invoking a callback when done
-- @param GetConsoleOutputRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.GetConsoleOutputAsync(GetConsoleOutputRequest, cb)
	assert(GetConsoleOutputRequest, "You must provide a GetConsoleOutputRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".GetConsoleOutput",
	}
	for header,value in pairs(GetConsoleOutputRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", GetConsoleOutputRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call GetConsoleOutput synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param GetConsoleOutputRequest
-- @return response
-- @return error_type
-- @return error_message
function M.GetConsoleOutputSync(GetConsoleOutputRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.GetConsoleOutputAsync(GetConsoleOutputRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpointServiceConfigurations asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointServiceConfigurationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcEndpointServiceConfigurationsAsync(DescribeVpcEndpointServiceConfigurationsRequest, cb)
	assert(DescribeVpcEndpointServiceConfigurationsRequest, "You must provide a DescribeVpcEndpointServiceConfigurationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointServiceConfigurations",
	}
	for header,value in pairs(DescribeVpcEndpointServiceConfigurationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointServiceConfigurationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpointServiceConfigurations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointServiceConfigurationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcEndpointServiceConfigurationsSync(DescribeVpcEndpointServiceConfigurationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointServiceConfigurationsAsync(DescribeVpcEndpointServiceConfigurationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateLaunchTemplateVersion asynchronously, invoking a callback when done
-- @param CreateLaunchTemplateVersionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateLaunchTemplateVersionAsync(CreateLaunchTemplateVersionRequest, cb)
	assert(CreateLaunchTemplateVersionRequest, "You must provide a CreateLaunchTemplateVersionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateLaunchTemplateVersion",
	}
	for header,value in pairs(CreateLaunchTemplateVersionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateLaunchTemplateVersionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateLaunchTemplateVersion synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateLaunchTemplateVersionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateLaunchTemplateVersionSync(CreateLaunchTemplateVersionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateLaunchTemplateVersionAsync(CreateLaunchTemplateVersionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeTags asynchronously, invoking a callback when done
-- @param DescribeTagsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeTagsAsync(DescribeTagsRequest, cb)
	assert(DescribeTagsRequest, "You must provide a DescribeTagsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeTags",
	}
	for header,value in pairs(DescribeTagsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeTagsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeTags synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeTagsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeTagsSync(DescribeTagsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeTagsAsync(DescribeTagsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeprovisionByoipCidr asynchronously, invoking a callback when done
-- @param DeprovisionByoipCidrRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeprovisionByoipCidrAsync(DeprovisionByoipCidrRequest, cb)
	assert(DeprovisionByoipCidrRequest, "You must provide a DeprovisionByoipCidrRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeprovisionByoipCidr",
	}
	for header,value in pairs(DeprovisionByoipCidrRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeprovisionByoipCidrRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeprovisionByoipCidr synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeprovisionByoipCidrRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeprovisionByoipCidrSync(DeprovisionByoipCidrRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeprovisionByoipCidrAsync(DeprovisionByoipCidrRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpointConnectionNotifications asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointConnectionNotificationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcEndpointConnectionNotificationsAsync(DescribeVpcEndpointConnectionNotificationsRequest, cb)
	assert(DescribeVpcEndpointConnectionNotificationsRequest, "You must provide a DescribeVpcEndpointConnectionNotificationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointConnectionNotifications",
	}
	for header,value in pairs(DescribeVpcEndpointConnectionNotificationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointConnectionNotificationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpointConnectionNotifications synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointConnectionNotificationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcEndpointConnectionNotificationsSync(DescribeVpcEndpointConnectionNotificationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointConnectionNotificationsAsync(DescribeVpcEndpointConnectionNotificationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpoints asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcEndpointsAsync(DescribeVpcEndpointsRequest, cb)
	assert(DescribeVpcEndpointsRequest, "You must provide a DescribeVpcEndpointsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpoints",
	}
	for header,value in pairs(DescribeVpcEndpointsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpoints synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcEndpointsSync(DescribeVpcEndpointsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointsAsync(DescribeVpcEndpointsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RejectVpcEndpointConnections asynchronously, invoking a callback when done
-- @param RejectVpcEndpointConnectionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RejectVpcEndpointConnectionsAsync(RejectVpcEndpointConnectionsRequest, cb)
	assert(RejectVpcEndpointConnectionsRequest, "You must provide a RejectVpcEndpointConnectionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RejectVpcEndpointConnections",
	}
	for header,value in pairs(RejectVpcEndpointConnectionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RejectVpcEndpointConnectionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RejectVpcEndpointConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RejectVpcEndpointConnectionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RejectVpcEndpointConnectionsSync(RejectVpcEndpointConnectionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RejectVpcEndpointConnectionsAsync(RejectVpcEndpointConnectionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcEndpoint asynchronously, invoking a callback when done
-- @param ModifyVpcEndpointRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVpcEndpointAsync(ModifyVpcEndpointRequest, cb)
	assert(ModifyVpcEndpointRequest, "You must provide a ModifyVpcEndpointRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcEndpoint",
	}
	for header,value in pairs(ModifyVpcEndpointRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcEndpointRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcEndpoint synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcEndpointRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVpcEndpointSync(ModifyVpcEndpointRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcEndpointAsync(ModifyVpcEndpointRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpcEndpointServiceConfiguration asynchronously, invoking a callback when done
-- @param CreateVpcEndpointServiceConfigurationRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpcEndpointServiceConfigurationAsync(CreateVpcEndpointServiceConfigurationRequest, cb)
	assert(CreateVpcEndpointServiceConfigurationRequest, "You must provide a CreateVpcEndpointServiceConfigurationRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpcEndpointServiceConfiguration",
	}
	for header,value in pairs(CreateVpcEndpointServiceConfigurationRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpcEndpointServiceConfigurationRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpcEndpointServiceConfiguration synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpcEndpointServiceConfigurationRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpcEndpointServiceConfigurationSync(CreateVpcEndpointServiceConfigurationRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpcEndpointServiceConfigurationAsync(CreateVpcEndpointServiceConfigurationRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVpcAttribute asynchronously, invoking a callback when done
-- @param ModifyVpcAttributeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVpcAttributeAsync(ModifyVpcAttributeRequest, cb)
	assert(ModifyVpcAttributeRequest, "You must provide a ModifyVpcAttributeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVpcAttribute",
	}
	for header,value in pairs(ModifyVpcAttributeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVpcAttributeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVpcAttribute synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVpcAttributeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVpcAttributeSync(ModifyVpcAttributeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVpcAttributeAsync(ModifyVpcAttributeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call EnableVolumeIO asynchronously, invoking a callback when done
-- @param EnableVolumeIORequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.EnableVolumeIOAsync(EnableVolumeIORequest, cb)
	assert(EnableVolumeIORequest, "You must provide a EnableVolumeIORequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".EnableVolumeIO",
	}
	for header,value in pairs(EnableVolumeIORequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", EnableVolumeIORequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call EnableVolumeIO synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param EnableVolumeIORequest
-- @return response
-- @return error_type
-- @return error_message
function M.EnableVolumeIOSync(EnableVolumeIORequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.EnableVolumeIOAsync(EnableVolumeIORequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call AcceptReservedInstancesExchangeQuote asynchronously, invoking a callback when done
-- @param AcceptReservedInstancesExchangeQuoteRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.AcceptReservedInstancesExchangeQuoteAsync(AcceptReservedInstancesExchangeQuoteRequest, cb)
	assert(AcceptReservedInstancesExchangeQuoteRequest, "You must provide a AcceptReservedInstancesExchangeQuoteRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".AcceptReservedInstancesExchangeQuote",
	}
	for header,value in pairs(AcceptReservedInstancesExchangeQuoteRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", AcceptReservedInstancesExchangeQuoteRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call AcceptReservedInstancesExchangeQuote synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param AcceptReservedInstancesExchangeQuoteRequest
-- @return response
-- @return error_type
-- @return error_message
function M.AcceptReservedInstancesExchangeQuoteSync(AcceptReservedInstancesExchangeQuoteRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.AcceptReservedInstancesExchangeQuoteAsync(AcceptReservedInstancesExchangeQuoteRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeSecurityGroupReferences asynchronously, invoking a callback when done
-- @param DescribeSecurityGroupReferencesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeSecurityGroupReferencesAsync(DescribeSecurityGroupReferencesRequest, cb)
	assert(DescribeSecurityGroupReferencesRequest, "You must provide a DescribeSecurityGroupReferencesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeSecurityGroupReferences",
	}
	for header,value in pairs(DescribeSecurityGroupReferencesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeSecurityGroupReferencesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeSecurityGroupReferences synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeSecurityGroupReferencesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeSecurityGroupReferencesSync(DescribeSecurityGroupReferencesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeSecurityGroupReferencesAsync(DescribeSecurityGroupReferencesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeVpcEndpointConnections asynchronously, invoking a callback when done
-- @param DescribeVpcEndpointConnectionsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeVpcEndpointConnectionsAsync(DescribeVpcEndpointConnectionsRequest, cb)
	assert(DescribeVpcEndpointConnectionsRequest, "You must provide a DescribeVpcEndpointConnectionsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeVpcEndpointConnections",
	}
	for header,value in pairs(DescribeVpcEndpointConnectionsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeVpcEndpointConnectionsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeVpcEndpointConnections synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeVpcEndpointConnectionsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeVpcEndpointConnectionsSync(DescribeVpcEndpointConnectionsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeVpcEndpointConnectionsAsync(DescribeVpcEndpointConnectionsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteFlowLogs asynchronously, invoking a callback when done
-- @param DeleteFlowLogsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteFlowLogsAsync(DeleteFlowLogsRequest, cb)
	assert(DeleteFlowLogsRequest, "You must provide a DeleteFlowLogsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteFlowLogs",
	}
	for header,value in pairs(DeleteFlowLogsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteFlowLogsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteFlowLogs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteFlowLogsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteFlowLogsSync(DeleteFlowLogsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteFlowLogsAsync(DeleteFlowLogsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyFleet asynchronously, invoking a callback when done
-- @param ModifyFleetRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyFleetAsync(ModifyFleetRequest, cb)
	assert(ModifyFleetRequest, "You must provide a ModifyFleetRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyFleet",
	}
	for header,value in pairs(ModifyFleetRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyFleetRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyFleet synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyFleetRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyFleetSync(ModifyFleetRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyFleetAsync(ModifyFleetRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateVpnConnection asynchronously, invoking a callback when done
-- @param CreateVpnConnectionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateVpnConnectionAsync(CreateVpnConnectionRequest, cb)
	assert(CreateVpnConnectionRequest, "You must provide a CreateVpnConnectionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateVpnConnection",
	}
	for header,value in pairs(CreateVpnConnectionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateVpnConnectionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateVpnConnection synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateVpnConnectionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateVpnConnectionSync(CreateVpnConnectionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateVpnConnectionAsync(CreateVpnConnectionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DetachClassicLinkVpc asynchronously, invoking a callback when done
-- @param DetachClassicLinkVpcRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DetachClassicLinkVpcAsync(DetachClassicLinkVpcRequest, cb)
	assert(DetachClassicLinkVpcRequest, "You must provide a DetachClassicLinkVpcRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DetachClassicLinkVpc",
	}
	for header,value in pairs(DetachClassicLinkVpcRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DetachClassicLinkVpcRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DetachClassicLinkVpc synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DetachClassicLinkVpcRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DetachClassicLinkVpcSync(DetachClassicLinkVpcRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DetachClassicLinkVpcAsync(DetachClassicLinkVpcRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call CreateReservedInstancesListing asynchronously, invoking a callback when done
-- @param CreateReservedInstancesListingRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.CreateReservedInstancesListingAsync(CreateReservedInstancesListingRequest, cb)
	assert(CreateReservedInstancesListingRequest, "You must provide a CreateReservedInstancesListingRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".CreateReservedInstancesListing",
	}
	for header,value in pairs(CreateReservedInstancesListingRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", CreateReservedInstancesListingRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call CreateReservedInstancesListing synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param CreateReservedInstancesListingRequest
-- @return response
-- @return error_type
-- @return error_message
function M.CreateReservedInstancesListingSync(CreateReservedInstancesListingRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.CreateReservedInstancesListingAsync(CreateReservedInstancesListingRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DeleteNetworkInterfacePermission asynchronously, invoking a callback when done
-- @param DeleteNetworkInterfacePermissionRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DeleteNetworkInterfacePermissionAsync(DeleteNetworkInterfacePermissionRequest, cb)
	assert(DeleteNetworkInterfacePermissionRequest, "You must provide a DeleteNetworkInterfacePermissionRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DeleteNetworkInterfacePermission",
	}
	for header,value in pairs(DeleteNetworkInterfacePermissionRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DeleteNetworkInterfacePermissionRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DeleteNetworkInterfacePermission synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DeleteNetworkInterfacePermissionRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DeleteNetworkInterfacePermissionSync(DeleteNetworkInterfacePermissionRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DeleteNetworkInterfacePermissionAsync(DeleteNetworkInterfacePermissionRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeHostReservations asynchronously, invoking a callback when done
-- @param DescribeHostReservationsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeHostReservationsAsync(DescribeHostReservationsRequest, cb)
	assert(DescribeHostReservationsRequest, "You must provide a DescribeHostReservationsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeHostReservations",
	}
	for header,value in pairs(DescribeHostReservationsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeHostReservationsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeHostReservations synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeHostReservationsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeHostReservationsSync(DescribeHostReservationsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeHostReservationsAsync(DescribeHostReservationsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeEgressOnlyInternetGateways asynchronously, invoking a callback when done
-- @param DescribeEgressOnlyInternetGatewaysRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeEgressOnlyInternetGatewaysAsync(DescribeEgressOnlyInternetGatewaysRequest, cb)
	assert(DescribeEgressOnlyInternetGatewaysRequest, "You must provide a DescribeEgressOnlyInternetGatewaysRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeEgressOnlyInternetGateways",
	}
	for header,value in pairs(DescribeEgressOnlyInternetGatewaysRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeEgressOnlyInternetGatewaysRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeEgressOnlyInternetGateways synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeEgressOnlyInternetGatewaysRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeEgressOnlyInternetGatewaysSync(DescribeEgressOnlyInternetGatewaysRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeEgressOnlyInternetGatewaysAsync(DescribeEgressOnlyInternetGatewaysRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeAggregateIdFormat asynchronously, invoking a callback when done
-- @param DescribeAggregateIdFormatRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeAggregateIdFormatAsync(DescribeAggregateIdFormatRequest, cb)
	assert(DescribeAggregateIdFormatRequest, "You must provide a DescribeAggregateIdFormatRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeAggregateIdFormat",
	}
	for header,value in pairs(DescribeAggregateIdFormatRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeAggregateIdFormatRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeAggregateIdFormat synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeAggregateIdFormatRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeAggregateIdFormatSync(DescribeAggregateIdFormatRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeAggregateIdFormatAsync(DescribeAggregateIdFormatRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call ModifyVolume asynchronously, invoking a callback when done
-- @param ModifyVolumeRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.ModifyVolumeAsync(ModifyVolumeRequest, cb)
	assert(ModifyVolumeRequest, "You must provide a ModifyVolumeRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".ModifyVolume",
	}
	for header,value in pairs(ModifyVolumeRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", ModifyVolumeRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call ModifyVolume synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param ModifyVolumeRequest
-- @return response
-- @return error_type
-- @return error_message
function M.ModifyVolumeSync(ModifyVolumeRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.ModifyVolumeAsync(ModifyVolumeRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call RunScheduledInstances asynchronously, invoking a callback when done
-- @param RunScheduledInstancesRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.RunScheduledInstancesAsync(RunScheduledInstancesRequest, cb)
	assert(RunScheduledInstancesRequest, "You must provide a RunScheduledInstancesRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".RunScheduledInstances",
	}
	for header,value in pairs(RunScheduledInstancesRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", RunScheduledInstancesRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call RunScheduledInstances synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param RunScheduledInstancesRequest
-- @return response
-- @return error_type
-- @return error_message
function M.RunScheduledInstancesSync(RunScheduledInstancesRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.RunScheduledInstancesAsync(RunScheduledInstancesRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end

--- Call DescribeByoipCidrs asynchronously, invoking a callback when done
-- @param DescribeByoipCidrsRequest
-- @param cb Callback function accepting three args: response, error_type, error_message
function M.DescribeByoipCidrsAsync(DescribeByoipCidrsRequest, cb)
	assert(DescribeByoipCidrsRequest, "You must provide a DescribeByoipCidrsRequest")
	local headers = {
		[request_headers.CONTENT_TYPE_HEADER] = content_type.from_protocol(M.metadata.protocol, M.metadata.json_version),
		[request_headers.AMZ_TARGET_HEADER] = ".DescribeByoipCidrs",
	}
	for header,value in pairs(DescribeByoipCidrsRequest.headers) do
		headers[header] = value
	end

	local request_handler, err = request_handlers.from_protocol_and_method("ec2", "POST")
	if request_handler then
		request_handler(settings.uri, "/", DescribeByoipCidrsRequest, headers, settings, cb)
	else
		cb(false, err)
	end
end

--- Call DescribeByoipCidrs synchronously, returning when done
-- This assumes that the function is called from within a coroutine
-- @param DescribeByoipCidrsRequest
-- @return response
-- @return error_type
-- @return error_message
function M.DescribeByoipCidrsSync(DescribeByoipCidrsRequest, ...)
	local co = coroutine.running()
	assert(co, "You must call this function from within a coroutine")
	M.DescribeByoipCidrsAsync(DescribeByoipCidrsRequest, function(response, error_type, error_message)
		assert(coroutine.resume(co, response, error_type, error_message))
	end)
	return coroutine.yield()
end


return M
